
FreeRTOS_SprintsChallenges_UserStory2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005482  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000046  00800060  00005482  00005516  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064e  008000a6  008000a6  0000555c  2**0
                  ALLOC
  3 .stab         00008d54  00000000  00000000  0000555c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000048f5  00000000  00000000  0000e2b0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e8       	ldi	r30, 0x82	; 130
      68:	f4 e5       	ldi	r31, 0x54	; 84
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3a       	cpi	r26, 0xA6	; 166
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a6 ea       	ldi	r26, 0xA6	; 166
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 3f       	cpi	r26, 0xF4	; 244
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6f 0b 	call	0x16de	; 0x16de <main>
      8a:	0c 94 3f 2a 	jmp	0x547e	; 0x547e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     532:	ef 92       	push	r14
     534:	ff 92       	push	r15
     536:	0f 93       	push	r16
     538:	df 93       	push	r29
     53a:	cf 93       	push	r28
     53c:	00 d0       	rcall	.+0      	; 0x53e <init_Task+0xc>
     53e:	cd b7       	in	r28, 0x3d	; 61
     540:	de b7       	in	r29, 0x3e	; 62
     542:	9a 83       	std	Y+2, r25	; 0x02
     544:	89 83       	std	Y+1, r24	; 0x01

	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     546:	8c ed       	ldi	r24, 0xDC	; 220
     548:	92 e0       	ldi	r25, 0x02	; 2
     54a:	20 e6       	ldi	r18, 0x60	; 96
     54c:	30 e0       	ldi	r19, 0x00	; 0
     54e:	e8 ea       	ldi	r30, 0xA8	; 168
     550:	f0 e0       	ldi	r31, 0x00	; 0
     552:	b9 01       	movw	r22, r18
     554:	45 e5       	ldi	r20, 0x55	; 85
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	20 e0       	ldi	r18, 0x00	; 0
     55a:	30 e0       	ldi	r19, 0x00	; 0
     55c:	04 e0       	ldi	r16, 0x04	; 4
     55e:	7f 01       	movw	r14, r30
     560:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(KeyPad_Task  , "KeyPad_Task" , configMINIMAL_STACK_SIZE ,
     564:	83 ef       	ldi	r24, 0xF3	; 243
     566:	92 e0       	ldi	r25, 0x02	; 2
     568:	2a e6       	ldi	r18, 0x6A	; 106
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	b9 01       	movw	r22, r18
     56e:	45 e5       	ldi	r20, 0x55	; 85
     570:	50 e0       	ldi	r21, 0x00	; 0
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	02 e0       	ldi	r16, 0x02	; 2
     578:	ee 24       	eor	r14, r14
     57a:	ff 24       	eor	r15, r15
     57c:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     580:	83 e3       	ldi	r24, 0x33	; 51
     582:	93 e0       	ldi	r25, 0x03	; 3
     584:	26 e7       	ldi	r18, 0x76	; 118
     586:	30 e0       	ldi	r19, 0x00	; 0
     588:	b9 01       	movw	r22, r18
     58a:	45 e5       	ldi	r20, 0x55	; 85
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	20 e0       	ldi	r18, 0x00	; 0
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	01 e0       	ldi	r16, 0x01	; 1
     594:	ee 24       	eor	r14, r14
     596:	ff 24       	eor	r15, r15
     598:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     59c:	80 91 ac 00 	lds	r24, 0x00AC
     5a0:	90 91 ad 00 	lds	r25, 0x00AD
     5a4:	0e 94 56 1f 	call	0x3eac	; 0x3eac <vTaskSuspend>
}
     5a8:	0f 90       	pop	r0
     5aa:	0f 90       	pop	r0
     5ac:	cf 91       	pop	r28
     5ae:	df 91       	pop	r29
     5b0:	0f 91       	pop	r16
     5b2:	ff 90       	pop	r15
     5b4:	ef 90       	pop	r14
     5b6:	08 95       	ret

000005b8 <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     5b8:	df 93       	push	r29
     5ba:	cf 93       	push	r28
     5bc:	00 d0       	rcall	.+0      	; 0x5be <All_Hardware_Init_Task+0x6>
     5be:	cd b7       	in	r28, 0x3d	; 61
     5c0:	de b7       	in	r29, 0x3e	; 62
     5c2:	9a 83       	std	Y+2, r25	; 0x02
     5c4:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		KeyPad_Init();
     5c6:	0e 94 9f 07 	call	0xf3e	; 0xf3e <KeyPad_Init>
		LCD_init();
     5ca:	0e 94 b0 08 	call	0x1160	; 0x1160 <LCD_init>
		Init_Done++;
     5ce:	80 91 a7 00 	lds	r24, 0x00A7
     5d2:	8f 5f       	subi	r24, 0xFF	; 255
     5d4:	80 93 a7 00 	sts	0x00A7, r24
		vTaskSuspend( AllHardwareInit_Flag);
     5d8:	80 91 a8 00 	lds	r24, 0x00A8
     5dc:	90 91 a9 00 	lds	r25, 0x00A9
     5e0:	0e 94 56 1f 	call	0x3eac	; 0x3eac <vTaskSuspend>
     5e4:	f0 cf       	rjmp	.-32     	; 0x5c6 <All_Hardware_Init_Task+0xe>

000005e6 <KeyPad_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Task(void * a_Task_ptr)
{
     5e6:	df 93       	push	r29
     5e8:	cf 93       	push	r28
     5ea:	00 d0       	rcall	.+0      	; 0x5ec <KeyPad_Task+0x6>
     5ec:	00 d0       	rcall	.+0      	; 0x5ee <KeyPad_Task+0x8>
     5ee:	cd b7       	in	r28, 0x3d	; 61
     5f0:	de b7       	in	r29, 0x3e	; 62
     5f2:	9c 83       	std	Y+4, r25	; 0x04
     5f4:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     5f6:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     5f8:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(Init_Done == 0)
     5fa:	80 91 a7 00 	lds	r24, 0x00A7
     5fe:	88 23       	and	r24, r24
     600:	e1 f3       	breq	.-8      	; 0x5fa <KeyPad_Task+0x14>

			/*Do Nothing*/
		}
		else
		{
			if(Debouncing == 0 && KeyPad_getPressedKey()!=10)
     602:	8a 81       	ldd	r24, Y+2	; 0x02
     604:	88 23       	and	r24, r24
     606:	79 f4       	brne	.+30     	; 0x626 <KeyPad_Task+0x40>
     608:	0e 94 d6 07 	call	0xfac	; 0xfac <KeyPad_getPressedKey>
     60c:	8a 30       	cpi	r24, 0x0A	; 10
     60e:	59 f0       	breq	.+22     	; 0x626 <KeyPad_Task+0x40>
			{
				OldPressedValue =  KeyPad_getPressedKey();
     610:	0e 94 d6 07 	call	0xfac	; 0xfac <KeyPad_getPressedKey>
     614:	89 83       	std	Y+1, r24	; 0x01
				Debouncing++;
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	8f 5f       	subi	r24, 0xFF	; 255
     61a:	8a 83       	std	Y+2, r24	; 0x02
				vTaskDelay(10);
     61c:	8a e0       	ldi	r24, 0x0A	; 10
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
     624:	ea cf       	rjmp	.-44     	; 0x5fa <KeyPad_Task+0x14>
			}
			else if(Debouncing == 1)
     626:	8a 81       	ldd	r24, Y+2	; 0x02
     628:	81 30       	cpi	r24, 0x01	; 1
     62a:	b9 f4       	brne	.+46     	; 0x65a <KeyPad_Task+0x74>
			{
				if(OldPressedValue == KeyPad_getPressedKey())
     62c:	0e 94 d6 07 	call	0xfac	; 0xfac <KeyPad_getPressedKey>
     630:	98 2f       	mov	r25, r24
     632:	89 81       	ldd	r24, Y+1	; 0x01
     634:	98 17       	cp	r25, r24
     636:	49 f4       	brne	.+18     	; 0x64a <KeyPad_Task+0x64>
				{
					PressedKey = OldPressedValue;
     638:	89 81       	ldd	r24, Y+1	; 0x01
     63a:	80 93 a6 00 	sts	0x00A6, r24
					DisplayFlag = 1;
     63e:	81 e0       	ldi	r24, 0x01	; 1
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	90 93 ab 00 	sts	0x00AB, r25
     646:	80 93 aa 00 	sts	0x00AA, r24
				}
				else
				{
					/*Do Nothing*/
				}
				Debouncing++;
     64a:	8a 81       	ldd	r24, Y+2	; 0x02
     64c:	8f 5f       	subi	r24, 0xFF	; 255
     64e:	8a 83       	std	Y+2, r24	; 0x02
				vTaskDelay(100);
     650:	84 e6       	ldi	r24, 0x64	; 100
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
     658:	d0 cf       	rjmp	.-96     	; 0x5fa <KeyPad_Task+0x14>
			}
			else
			{
				Debouncing = 0;
     65a:	1a 82       	std	Y+2, r1	; 0x02
				vTaskDelay(100);
     65c:	84 e6       	ldi	r24, 0x64	; 100
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
     664:	ca cf       	rjmp	.-108    	; 0x5fa <KeyPad_Task+0x14>

00000666 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     666:	df 93       	push	r29
     668:	cf 93       	push	r28
     66a:	cd b7       	in	r28, 0x3d	; 61
     66c:	de b7       	in	r29, 0x3e	; 62
     66e:	a6 97       	sbiw	r28, 0x26	; 38
     670:	0f b6       	in	r0, 0x3f	; 63
     672:	f8 94       	cli
     674:	de bf       	out	0x3e, r29	; 62
     676:	0f be       	out	0x3f, r0	; 63
     678:	cd bf       	out	0x3d, r28	; 61
     67a:	9c 8f       	std	Y+28, r25	; 0x1c
     67c:	8b 8f       	std	Y+27, r24	; 0x1b
	/*counter to count entered numbers*/
	uint8 PasswordCounter=0;
     67e:	1a 82       	std	Y+2, r1	; 0x02

	/*Password*/
	uint8 Password[]= "153426";
     680:	ce 01       	movw	r24, r28
     682:	03 96       	adiw	r24, 0x03	; 3
     684:	9e 8f       	std	Y+30, r25	; 0x1e
     686:	8d 8f       	std	Y+29, r24	; 0x1d
     688:	ef e7       	ldi	r30, 0x7F	; 127
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	f8 a3       	std	Y+32, r31	; 0x20
     68e:	ef 8f       	std	Y+31, r30	; 0x1f
     690:	f7 e0       	ldi	r31, 0x07	; 7
     692:	f9 a3       	std	Y+33, r31	; 0x21
     694:	ef 8d       	ldd	r30, Y+31	; 0x1f
     696:	f8 a1       	ldd	r31, Y+32	; 0x20
     698:	00 80       	ld	r0, Z
     69a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     69c:	98 a1       	ldd	r25, Y+32	; 0x20
     69e:	01 96       	adiw	r24, 0x01	; 1
     6a0:	98 a3       	std	Y+32, r25	; 0x20
     6a2:	8f 8f       	std	Y+31, r24	; 0x1f
     6a4:	ed 8d       	ldd	r30, Y+29	; 0x1d
     6a6:	fe 8d       	ldd	r31, Y+30	; 0x1e
     6a8:	00 82       	st	Z, r0
     6aa:	8d 8d       	ldd	r24, Y+29	; 0x1d
     6ac:	9e 8d       	ldd	r25, Y+30	; 0x1e
     6ae:	01 96       	adiw	r24, 0x01	; 1
     6b0:	9e 8f       	std	Y+30, r25	; 0x1e
     6b2:	8d 8f       	std	Y+29, r24	; 0x1d
     6b4:	99 a1       	ldd	r25, Y+33	; 0x21
     6b6:	91 50       	subi	r25, 0x01	; 1
     6b8:	99 a3       	std	Y+33, r25	; 0x21
     6ba:	e9 a1       	ldd	r30, Y+33	; 0x21
     6bc:	ee 23       	and	r30, r30
     6be:	51 f7       	brne	.-44     	; 0x694 <LCD_Task+0x2e>

	uint8 Correct[]= "Correct Password";
     6c0:	ce 01       	movw	r24, r28
     6c2:	0a 96       	adiw	r24, 0x0a	; 10
     6c4:	9b a3       	std	Y+35, r25	; 0x23
     6c6:	8a a3       	std	Y+34, r24	; 0x22
     6c8:	e6 e8       	ldi	r30, 0x86	; 134
     6ca:	f0 e0       	ldi	r31, 0x00	; 0
     6cc:	fd a3       	std	Y+37, r31	; 0x25
     6ce:	ec a3       	std	Y+36, r30	; 0x24
     6d0:	f1 e1       	ldi	r31, 0x11	; 17
     6d2:	fe a3       	std	Y+38, r31	; 0x26
     6d4:	ec a1       	ldd	r30, Y+36	; 0x24
     6d6:	fd a1       	ldd	r31, Y+37	; 0x25
     6d8:	00 80       	ld	r0, Z
     6da:	8c a1       	ldd	r24, Y+36	; 0x24
     6dc:	9d a1       	ldd	r25, Y+37	; 0x25
     6de:	01 96       	adiw	r24, 0x01	; 1
     6e0:	9d a3       	std	Y+37, r25	; 0x25
     6e2:	8c a3       	std	Y+36, r24	; 0x24
     6e4:	ea a1       	ldd	r30, Y+34	; 0x22
     6e6:	fb a1       	ldd	r31, Y+35	; 0x23
     6e8:	00 82       	st	Z, r0
     6ea:	8a a1       	ldd	r24, Y+34	; 0x22
     6ec:	9b a1       	ldd	r25, Y+35	; 0x23
     6ee:	01 96       	adiw	r24, 0x01	; 1
     6f0:	9b a3       	std	Y+35, r25	; 0x23
     6f2:	8a a3       	std	Y+34, r24	; 0x22
     6f4:	9e a1       	ldd	r25, Y+38	; 0x26
     6f6:	91 50       	subi	r25, 0x01	; 1
     6f8:	9e a3       	std	Y+38, r25	; 0x26
     6fa:	ee a1       	ldd	r30, Y+38	; 0x26
     6fc:	ee 23       	and	r30, r30
     6fe:	51 f7       	brne	.-44     	; 0x6d4 <LCD_Task+0x6e>

	/*to check on correct answer*/
	uint8 CorrectFlag = 0;
     700:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(DisplayFlag == 1 && PressedKey < 7 && PasswordCounter < 6)
     702:	80 91 aa 00 	lds	r24, 0x00AA
     706:	90 91 ab 00 	lds	r25, 0x00AB
     70a:	81 30       	cpi	r24, 0x01	; 1
     70c:	91 05       	cpc	r25, r1
     70e:	61 f5       	brne	.+88     	; 0x768 <LCD_Task+0x102>
     710:	80 91 a6 00 	lds	r24, 0x00A6
     714:	87 30       	cpi	r24, 0x07	; 7
     716:	40 f5       	brcc	.+80     	; 0x768 <LCD_Task+0x102>
     718:	8a 81       	ldd	r24, Y+2	; 0x02
     71a:	86 30       	cpi	r24, 0x06	; 6
     71c:	28 f5       	brcc	.+74     	; 0x768 <LCD_Task+0x102>
		{
			LCD_displayCharacter(PressedKey + 48);
     71e:	80 91 a6 00 	lds	r24, 0x00A6
     722:	80 5d       	subi	r24, 0xD0	; 208
     724:	0e 94 3e 09 	call	0x127c	; 0x127c <LCD_displayCharacter>
			DisplayFlag = 0;
     728:	10 92 ab 00 	sts	0x00AB, r1
     72c:	10 92 aa 00 	sts	0x00AA, r1
			if((Password[PasswordCounter] == (PressedKey+48)) && CorrectFlag == 0)
     730:	8a 81       	ldd	r24, Y+2	; 0x02
     732:	28 2f       	mov	r18, r24
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	ce 01       	movw	r24, r28
     738:	03 96       	adiw	r24, 0x03	; 3
     73a:	fc 01       	movw	r30, r24
     73c:	e2 0f       	add	r30, r18
     73e:	f3 1f       	adc	r31, r19
     740:	80 81       	ld	r24, Z
     742:	28 2f       	mov	r18, r24
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	80 91 a6 00 	lds	r24, 0x00A6
     74a:	88 2f       	mov	r24, r24
     74c:	90 e0       	ldi	r25, 0x00	; 0
     74e:	c0 96       	adiw	r24, 0x30	; 48
     750:	28 17       	cp	r18, r24
     752:	39 07       	cpc	r19, r25
     754:	19 f4       	brne	.+6      	; 0x75c <LCD_Task+0xf6>
     756:	89 81       	ldd	r24, Y+1	; 0x01
     758:	88 23       	and	r24, r24
     75a:	11 f0       	breq	.+4      	; 0x760 <LCD_Task+0xfa>
			{
				/*Do Nothing*/
			}
			else
			{
				CorrectFlag = 1;
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	89 83       	std	Y+1, r24	; 0x01
			}
			PasswordCounter++;
     760:	8a 81       	ldd	r24, Y+2	; 0x02
     762:	8f 5f       	subi	r24, 0xFF	; 255
     764:	8a 83       	std	Y+2, r24	; 0x02
     766:	25 c0       	rjmp	.+74     	; 0x7b2 <LCD_Task+0x14c>
		}
		else if(PressedKey == 7)
     768:	80 91 a6 00 	lds	r24, 0x00A6
     76c:	87 30       	cpi	r24, 0x07	; 7
     76e:	29 f4       	brne	.+10     	; 0x77a <LCD_Task+0x114>
		{
			LCD_clearScreen();
     770:	0e 94 2f 0a 	call	0x145e	; 0x145e <LCD_clearScreen>
			PasswordCounter = 0;
     774:	1a 82       	std	Y+2, r1	; 0x02
			CorrectFlag = 0;
     776:	19 82       	std	Y+1, r1	; 0x01
     778:	1c c0       	rjmp	.+56     	; 0x7b2 <LCD_Task+0x14c>
		}
		else if(PressedKey == 9 && PasswordCounter == 6)
     77a:	80 91 a6 00 	lds	r24, 0x00A6
     77e:	89 30       	cpi	r24, 0x09	; 9
     780:	c1 f4       	brne	.+48     	; 0x7b2 <LCD_Task+0x14c>
     782:	8a 81       	ldd	r24, Y+2	; 0x02
     784:	86 30       	cpi	r24, 0x06	; 6
     786:	a9 f4       	brne	.+42     	; 0x7b2 <LCD_Task+0x14c>
		{
			if(CorrectFlag == 0)
     788:	89 81       	ldd	r24, Y+1	; 0x01
     78a:	88 23       	and	r24, r24
     78c:	71 f4       	brne	.+28     	; 0x7aa <LCD_Task+0x144>
			{
				LCD_clearScreen();
     78e:	0e 94 2f 0a 	call	0x145e	; 0x145e <LCD_clearScreen>
				LCD_displayString(Correct);
     792:	ce 01       	movw	r24, r28
     794:	0a 96       	adiw	r24, 0x0a	; 10
     796:	0e 94 ab 09 	call	0x1356	; 0x1356 <LCD_displayString>
				PasswordCounter = 0;
     79a:	1a 82       	std	Y+2, r1	; 0x02
				vTaskDelay(2000);
     79c:	80 ed       	ldi	r24, 0xD0	; 208
     79e:	97 e0       	ldi	r25, 0x07	; 7
     7a0:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
				LCD_clearScreen();
     7a4:	0e 94 2f 0a 	call	0x145e	; 0x145e <LCD_clearScreen>
     7a8:	04 c0       	rjmp	.+8      	; 0x7b2 <LCD_Task+0x14c>
			}
			else
			{
				PasswordCounter = 0;
     7aa:	1a 82       	std	Y+2, r1	; 0x02
				LCD_clearScreen();
     7ac:	0e 94 2f 0a 	call	0x145e	; 0x145e <LCD_clearScreen>
				CorrectFlag = 0;
     7b0:	19 82       	std	Y+1, r1	; 0x01
			}
		}

		vTaskDelay(150);
     7b2:	86 e9       	ldi	r24, 0x96	; 150
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
     7ba:	a3 cf       	rjmp	.-186    	; 0x702 <LCD_Task+0x9c>

000007bc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     7bc:	df 93       	push	r29
     7be:	cf 93       	push	r28
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <xEventGroupCreate+0x6>
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     7c6:	8b e0       	ldi	r24, 0x0B	; 11
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	0e 94 23 07 	call	0xe46	; 0xe46 <pvPortMalloc>
     7ce:	9a 83       	std	Y+2, r25	; 0x02
     7d0:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     7d2:	89 81       	ldd	r24, Y+1	; 0x01
     7d4:	9a 81       	ldd	r25, Y+2	; 0x02
     7d6:	00 97       	sbiw	r24, 0x00	; 0
     7d8:	49 f0       	breq	.+18     	; 0x7ec <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     7da:	e9 81       	ldd	r30, Y+1	; 0x01
     7dc:	fa 81       	ldd	r31, Y+2	; 0x02
     7de:	11 82       	std	Z+1, r1	; 0x01
     7e0:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     7e2:	89 81       	ldd	r24, Y+1	; 0x01
     7e4:	9a 81       	ldd	r25, Y+2	; 0x02
     7e6:	02 96       	adiw	r24, 0x02	; 2
     7e8:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     7ec:	89 81       	ldd	r24, Y+1	; 0x01
     7ee:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     7f0:	0f 90       	pop	r0
     7f2:	0f 90       	pop	r0
     7f4:	cf 91       	pop	r28
     7f6:	df 91       	pop	r29
     7f8:	08 95       	ret

000007fa <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     7fa:	df 93       	push	r29
     7fc:	cf 93       	push	r28
     7fe:	cd b7       	in	r28, 0x3d	; 61
     800:	de b7       	in	r29, 0x3e	; 62
     802:	60 97       	sbiw	r28, 0x10	; 16
     804:	0f b6       	in	r0, 0x3f	; 63
     806:	f8 94       	cli
     808:	de bf       	out	0x3e, r29	; 62
     80a:	0f be       	out	0x3f, r0	; 63
     80c:	cd bf       	out	0x3d, r28	; 61
     80e:	9a 87       	std	Y+10, r25	; 0x0a
     810:	89 87       	std	Y+9, r24	; 0x09
     812:	7c 87       	std	Y+12, r23	; 0x0c
     814:	6b 87       	std	Y+11, r22	; 0x0b
     816:	5e 87       	std	Y+14, r21	; 0x0e
     818:	4d 87       	std	Y+13, r20	; 0x0d
     81a:	38 8b       	std	Y+16, r19	; 0x10
     81c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     81e:	89 85       	ldd	r24, Y+9	; 0x09
     820:	9a 85       	ldd	r25, Y+10	; 0x0a
     822:	9c 83       	std	Y+4, r25	; 0x04
     824:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     826:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     828:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     82c:	eb 81       	ldd	r30, Y+3	; 0x03
     82e:	fc 81       	ldd	r31, Y+4	; 0x04
     830:	80 81       	ld	r24, Z
     832:	91 81       	ldd	r25, Z+1	; 0x01
     834:	98 87       	std	Y+8, r25	; 0x08
     836:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     838:	89 85       	ldd	r24, Y+9	; 0x09
     83a:	9a 85       	ldd	r25, Y+10	; 0x0a
     83c:	2b 85       	ldd	r18, Y+11	; 0x0b
     83e:	3c 85       	ldd	r19, Y+12	; 0x0c
     840:	b9 01       	movw	r22, r18
     842:	0e 94 d4 05 	call	0xba8	; 0xba8 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     846:	2f 81       	ldd	r18, Y+7	; 0x07
     848:	38 85       	ldd	r19, Y+8	; 0x08
     84a:	8b 85       	ldd	r24, Y+11	; 0x0b
     84c:	9c 85       	ldd	r25, Y+12	; 0x0c
     84e:	28 2b       	or	r18, r24
     850:	39 2b       	or	r19, r25
     852:	8d 85       	ldd	r24, Y+13	; 0x0d
     854:	9e 85       	ldd	r25, Y+14	; 0x0e
     856:	28 23       	and	r18, r24
     858:	39 23       	and	r19, r25
     85a:	8d 85       	ldd	r24, Y+13	; 0x0d
     85c:	9e 85       	ldd	r25, Y+14	; 0x0e
     85e:	28 17       	cp	r18, r24
     860:	39 07       	cpc	r19, r25
     862:	c9 f4       	brne	.+50     	; 0x896 <__stack+0x37>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     864:	2f 81       	ldd	r18, Y+7	; 0x07
     866:	38 85       	ldd	r19, Y+8	; 0x08
     868:	8b 85       	ldd	r24, Y+11	; 0x0b
     86a:	9c 85       	ldd	r25, Y+12	; 0x0c
     86c:	82 2b       	or	r24, r18
     86e:	93 2b       	or	r25, r19
     870:	9e 83       	std	Y+6, r25	; 0x06
     872:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     874:	eb 81       	ldd	r30, Y+3	; 0x03
     876:	fc 81       	ldd	r31, Y+4	; 0x04
     878:	20 81       	ld	r18, Z
     87a:	31 81       	ldd	r19, Z+1	; 0x01
     87c:	8d 85       	ldd	r24, Y+13	; 0x0d
     87e:	9e 85       	ldd	r25, Y+14	; 0x0e
     880:	80 95       	com	r24
     882:	90 95       	com	r25
     884:	82 23       	and	r24, r18
     886:	93 23       	and	r25, r19
     888:	eb 81       	ldd	r30, Y+3	; 0x03
     88a:	fc 81       	ldd	r31, Y+4	; 0x04
     88c:	91 83       	std	Z+1, r25	; 0x01
     88e:	80 83       	st	Z, r24

			xTicksToWait = 0;
     890:	18 8a       	std	Y+16, r1	; 0x10
     892:	1f 86       	std	Y+15, r1	; 0x0f
     894:	1e c0       	rjmp	.+60     	; 0x8d2 <__stack+0x73>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     896:	8f 85       	ldd	r24, Y+15	; 0x0f
     898:	98 89       	ldd	r25, Y+16	; 0x10
     89a:	00 97       	sbiw	r24, 0x00	; 0
     89c:	91 f0       	breq	.+36     	; 0x8c2 <__stack+0x63>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     89e:	8b 81       	ldd	r24, Y+3	; 0x03
     8a0:	9c 81       	ldd	r25, Y+4	; 0x04
     8a2:	bc 01       	movw	r22, r24
     8a4:	6e 5f       	subi	r22, 0xFE	; 254
     8a6:	7f 4f       	sbci	r23, 0xFF	; 255
     8a8:	8d 85       	ldd	r24, Y+13	; 0x0d
     8aa:	9e 85       	ldd	r25, Y+14	; 0x0e
     8ac:	9c 01       	movw	r18, r24
     8ae:	35 60       	ori	r19, 0x05	; 5
     8b0:	4f 85       	ldd	r20, Y+15	; 0x0f
     8b2:	58 89       	ldd	r21, Y+16	; 0x10
     8b4:	cb 01       	movw	r24, r22
     8b6:	b9 01       	movw	r22, r18
     8b8:	0e 94 71 23 	call	0x46e2	; 0x46e2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     8bc:	1e 82       	std	Y+6, r1	; 0x06
     8be:	1d 82       	std	Y+5, r1	; 0x05
     8c0:	08 c0       	rjmp	.+16     	; 0x8d2 <__stack+0x73>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     8c2:	eb 81       	ldd	r30, Y+3	; 0x03
     8c4:	fc 81       	ldd	r31, Y+4	; 0x04
     8c6:	80 81       	ld	r24, Z
     8c8:	91 81       	ldd	r25, Z+1	; 0x01
     8ca:	9e 83       	std	Y+6, r25	; 0x06
     8cc:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     8d2:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
     8d6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     8d8:	8f 85       	ldd	r24, Y+15	; 0x0f
     8da:	98 89       	ldd	r25, Y+16	; 0x10
     8dc:	00 97       	sbiw	r24, 0x00	; 0
     8de:	09 f4       	brne	.+2      	; 0x8e2 <__stack+0x83>
     8e0:	3a c0       	rjmp	.+116    	; 0x956 <__stack+0xf7>
	{
		if( xAlreadyYielded == pdFALSE )
     8e2:	8a 81       	ldd	r24, Y+2	; 0x02
     8e4:	88 23       	and	r24, r24
     8e6:	11 f4       	brne	.+4      	; 0x8ec <__stack+0x8d>
		{
			portYIELD_WITHIN_API();
     8e8:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     8ec:	0e 94 e4 25 	call	0x4bc8	; 0x4bc8 <uxTaskResetEventItemValue>
     8f0:	9e 83       	std	Y+6, r25	; 0x06
     8f2:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     8f4:	8d 81       	ldd	r24, Y+5	; 0x05
     8f6:	9e 81       	ldd	r25, Y+6	; 0x06
     8f8:	80 70       	andi	r24, 0x00	; 0
     8fa:	92 70       	andi	r25, 0x02	; 2
     8fc:	00 97       	sbiw	r24, 0x00	; 0
     8fe:	31 f5       	brne	.+76     	; 0x94c <__stack+0xed>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     906:	eb 81       	ldd	r30, Y+3	; 0x03
     908:	fc 81       	ldd	r31, Y+4	; 0x04
     90a:	80 81       	ld	r24, Z
     90c:	91 81       	ldd	r25, Z+1	; 0x01
     90e:	9e 83       	std	Y+6, r25	; 0x06
     910:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     912:	2d 81       	ldd	r18, Y+5	; 0x05
     914:	3e 81       	ldd	r19, Y+6	; 0x06
     916:	8d 85       	ldd	r24, Y+13	; 0x0d
     918:	9e 85       	ldd	r25, Y+14	; 0x0e
     91a:	28 23       	and	r18, r24
     91c:	39 23       	and	r19, r25
     91e:	8d 85       	ldd	r24, Y+13	; 0x0d
     920:	9e 85       	ldd	r25, Y+14	; 0x0e
     922:	28 17       	cp	r18, r24
     924:	39 07       	cpc	r19, r25
     926:	71 f4       	brne	.+28     	; 0x944 <__stack+0xe5>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     928:	eb 81       	ldd	r30, Y+3	; 0x03
     92a:	fc 81       	ldd	r31, Y+4	; 0x04
     92c:	20 81       	ld	r18, Z
     92e:	31 81       	ldd	r19, Z+1	; 0x01
     930:	8d 85       	ldd	r24, Y+13	; 0x0d
     932:	9e 85       	ldd	r25, Y+14	; 0x0e
     934:	80 95       	com	r24
     936:	90 95       	com	r25
     938:	82 23       	and	r24, r18
     93a:	93 23       	and	r25, r19
     93c:	eb 81       	ldd	r30, Y+3	; 0x03
     93e:	fc 81       	ldd	r31, Y+4	; 0x04
     940:	91 83       	std	Z+1, r25	; 0x01
     942:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     948:	81 e0       	ldi	r24, 0x01	; 1
     94a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     94c:	8d 81       	ldd	r24, Y+5	; 0x05
     94e:	9e 81       	ldd	r25, Y+6	; 0x06
     950:	90 70       	andi	r25, 0x00	; 0
     952:	9e 83       	std	Y+6, r25	; 0x06
     954:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     956:	8d 81       	ldd	r24, Y+5	; 0x05
     958:	9e 81       	ldd	r25, Y+6	; 0x06
}
     95a:	60 96       	adiw	r28, 0x10	; 16
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	de bf       	out	0x3e, r29	; 62
     962:	0f be       	out	0x3f, r0	; 63
     964:	cd bf       	out	0x3d, r28	; 61
     966:	cf 91       	pop	r28
     968:	df 91       	pop	r29
     96a:	08 95       	ret

0000096c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     96c:	0f 93       	push	r16
     96e:	1f 93       	push	r17
     970:	df 93       	push	r29
     972:	cf 93       	push	r28
     974:	cd b7       	in	r28, 0x3d	; 61
     976:	de b7       	in	r29, 0x3e	; 62
     978:	63 97       	sbiw	r28, 0x13	; 19
     97a:	0f b6       	in	r0, 0x3f	; 63
     97c:	f8 94       	cli
     97e:	de bf       	out	0x3e, r29	; 62
     980:	0f be       	out	0x3f, r0	; 63
     982:	cd bf       	out	0x3d, r28	; 61
     984:	9d 87       	std	Y+13, r25	; 0x0d
     986:	8c 87       	std	Y+12, r24	; 0x0c
     988:	7f 87       	std	Y+15, r23	; 0x0f
     98a:	6e 87       	std	Y+14, r22	; 0x0e
     98c:	48 8b       	std	Y+16, r20	; 0x10
     98e:	29 8b       	std	Y+17, r18	; 0x11
     990:	1b 8b       	std	Y+19, r17	; 0x13
     992:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     994:	8c 85       	ldd	r24, Y+12	; 0x0c
     996:	9d 85       	ldd	r25, Y+13	; 0x0d
     998:	9b 87       	std	Y+11, r25	; 0x0b
     99a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     99c:	1f 82       	std	Y+7, r1	; 0x07
     99e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     9a0:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     9a2:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     9a6:	ea 85       	ldd	r30, Y+10	; 0x0a
     9a8:	fb 85       	ldd	r31, Y+11	; 0x0b
     9aa:	80 81       	ld	r24, Z
     9ac:	91 81       	ldd	r25, Z+1	; 0x01
     9ae:	9a 83       	std	Y+2, r25	; 0x02
     9b0:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     9b2:	89 81       	ldd	r24, Y+1	; 0x01
     9b4:	9a 81       	ldd	r25, Y+2	; 0x02
     9b6:	2e 85       	ldd	r18, Y+14	; 0x0e
     9b8:	3f 85       	ldd	r19, Y+15	; 0x0f
     9ba:	b9 01       	movw	r22, r18
     9bc:	49 89       	ldd	r20, Y+17	; 0x11
     9be:	0e 94 f1 06 	call	0xde2	; 0xde2 <prvTestWaitCondition>
     9c2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     9c4:	8d 81       	ldd	r24, Y+5	; 0x05
     9c6:	88 23       	and	r24, r24
     9c8:	c1 f0       	breq	.+48     	; 0x9fa <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     9ca:	89 81       	ldd	r24, Y+1	; 0x01
     9cc:	9a 81       	ldd	r25, Y+2	; 0x02
     9ce:	99 87       	std	Y+9, r25	; 0x09
     9d0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     9d2:	1b 8a       	std	Y+19, r1	; 0x13
     9d4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     9d6:	88 89       	ldd	r24, Y+16	; 0x10
     9d8:	88 23       	and	r24, r24
     9da:	e9 f1       	breq	.+122    	; 0xa56 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9dc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9de:	fb 85       	ldd	r31, Y+11	; 0x0b
     9e0:	20 81       	ld	r18, Z
     9e2:	31 81       	ldd	r19, Z+1	; 0x01
     9e4:	8e 85       	ldd	r24, Y+14	; 0x0e
     9e6:	9f 85       	ldd	r25, Y+15	; 0x0f
     9e8:	80 95       	com	r24
     9ea:	90 95       	com	r25
     9ec:	82 23       	and	r24, r18
     9ee:	93 23       	and	r25, r19
     9f0:	ea 85       	ldd	r30, Y+10	; 0x0a
     9f2:	fb 85       	ldd	r31, Y+11	; 0x0b
     9f4:	91 83       	std	Z+1, r25	; 0x01
     9f6:	80 83       	st	Z, r24
     9f8:	2e c0       	rjmp	.+92     	; 0xa56 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     9fa:	8a 89       	ldd	r24, Y+18	; 0x12
     9fc:	9b 89       	ldd	r25, Y+19	; 0x13
     9fe:	00 97       	sbiw	r24, 0x00	; 0
     a00:	39 f4       	brne	.+14     	; 0xa10 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     a02:	89 81       	ldd	r24, Y+1	; 0x01
     a04:	9a 81       	ldd	r25, Y+2	; 0x02
     a06:	99 87       	std	Y+9, r25	; 0x09
     a08:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	8b 83       	std	Y+3, r24	; 0x03
     a0e:	23 c0       	rjmp	.+70     	; 0xa56 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     a10:	88 89       	ldd	r24, Y+16	; 0x10
     a12:	88 23       	and	r24, r24
     a14:	29 f0       	breq	.+10     	; 0xa20 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     a16:	8e 81       	ldd	r24, Y+6	; 0x06
     a18:	9f 81       	ldd	r25, Y+7	; 0x07
     a1a:	91 60       	ori	r25, 0x01	; 1
     a1c:	9f 83       	std	Y+7, r25	; 0x07
     a1e:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     a20:	89 89       	ldd	r24, Y+17	; 0x11
     a22:	88 23       	and	r24, r24
     a24:	29 f0       	breq	.+10     	; 0xa30 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     a26:	8e 81       	ldd	r24, Y+6	; 0x06
     a28:	9f 81       	ldd	r25, Y+7	; 0x07
     a2a:	94 60       	ori	r25, 0x04	; 4
     a2c:	9f 83       	std	Y+7, r25	; 0x07
     a2e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     a30:	8a 85       	ldd	r24, Y+10	; 0x0a
     a32:	9b 85       	ldd	r25, Y+11	; 0x0b
     a34:	bc 01       	movw	r22, r24
     a36:	6e 5f       	subi	r22, 0xFE	; 254
     a38:	7f 4f       	sbci	r23, 0xFF	; 255
     a3a:	2e 85       	ldd	r18, Y+14	; 0x0e
     a3c:	3f 85       	ldd	r19, Y+15	; 0x0f
     a3e:	8e 81       	ldd	r24, Y+6	; 0x06
     a40:	9f 81       	ldd	r25, Y+7	; 0x07
     a42:	28 2b       	or	r18, r24
     a44:	39 2b       	or	r19, r25
     a46:	4a 89       	ldd	r20, Y+18	; 0x12
     a48:	5b 89       	ldd	r21, Y+19	; 0x13
     a4a:	cb 01       	movw	r24, r22
     a4c:	b9 01       	movw	r22, r18
     a4e:	0e 94 71 23 	call	0x46e2	; 0x46e2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     a52:	19 86       	std	Y+9, r1	; 0x09
     a54:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a56:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
     a5a:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     a5c:	8a 89       	ldd	r24, Y+18	; 0x12
     a5e:	9b 89       	ldd	r25, Y+19	; 0x13
     a60:	00 97       	sbiw	r24, 0x00	; 0
     a62:	09 f4       	brne	.+2      	; 0xa66 <xEventGroupWaitBits+0xfa>
     a64:	3c c0       	rjmp	.+120    	; 0xade <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     a66:	8c 81       	ldd	r24, Y+4	; 0x04
     a68:	88 23       	and	r24, r24
     a6a:	11 f4       	brne	.+4      	; 0xa70 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     a6c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     a70:	0e 94 e4 25 	call	0x4bc8	; 0x4bc8 <uxTaskResetEventItemValue>
     a74:	99 87       	std	Y+9, r25	; 0x09
     a76:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     a78:	88 85       	ldd	r24, Y+8	; 0x08
     a7a:	99 85       	ldd	r25, Y+9	; 0x09
     a7c:	80 70       	andi	r24, 0x00	; 0
     a7e:	92 70       	andi	r25, 0x02	; 2
     a80:	00 97       	sbiw	r24, 0x00	; 0
     a82:	41 f5       	brne	.+80     	; 0xad4 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     a8a:	ea 85       	ldd	r30, Y+10	; 0x0a
     a8c:	fb 85       	ldd	r31, Y+11	; 0x0b
     a8e:	80 81       	ld	r24, Z
     a90:	91 81       	ldd	r25, Z+1	; 0x01
     a92:	99 87       	std	Y+9, r25	; 0x09
     a94:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     a96:	88 85       	ldd	r24, Y+8	; 0x08
     a98:	99 85       	ldd	r25, Y+9	; 0x09
     a9a:	2e 85       	ldd	r18, Y+14	; 0x0e
     a9c:	3f 85       	ldd	r19, Y+15	; 0x0f
     a9e:	b9 01       	movw	r22, r18
     aa0:	49 89       	ldd	r20, Y+17	; 0x11
     aa2:	0e 94 f1 06 	call	0xde2	; 0xde2 <prvTestWaitCondition>
     aa6:	88 23       	and	r24, r24
     aa8:	89 f0       	breq	.+34     	; 0xacc <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     aaa:	88 89       	ldd	r24, Y+16	; 0x10
     aac:	88 23       	and	r24, r24
     aae:	71 f0       	breq	.+28     	; 0xacc <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ab0:	ea 85       	ldd	r30, Y+10	; 0x0a
     ab2:	fb 85       	ldd	r31, Y+11	; 0x0b
     ab4:	20 81       	ld	r18, Z
     ab6:	31 81       	ldd	r19, Z+1	; 0x01
     ab8:	8e 85       	ldd	r24, Y+14	; 0x0e
     aba:	9f 85       	ldd	r25, Y+15	; 0x0f
     abc:	80 95       	com	r24
     abe:	90 95       	com	r25
     ac0:	82 23       	and	r24, r18
     ac2:	93 23       	and	r25, r19
     ac4:	ea 85       	ldd	r30, Y+10	; 0x0a
     ac6:	fb 85       	ldd	r31, Y+11	; 0x0b
     ac8:	91 83       	std	Z+1, r25	; 0x01
     aca:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     ad0:	0f 90       	pop	r0
     ad2:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     ad4:	88 85       	ldd	r24, Y+8	; 0x08
     ad6:	99 85       	ldd	r25, Y+9	; 0x09
     ad8:	90 70       	andi	r25, 0x00	; 0
     ada:	99 87       	std	Y+9, r25	; 0x09
     adc:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     ade:	88 85       	ldd	r24, Y+8	; 0x08
     ae0:	99 85       	ldd	r25, Y+9	; 0x09
}
     ae2:	63 96       	adiw	r28, 0x13	; 19
     ae4:	0f b6       	in	r0, 0x3f	; 63
     ae6:	f8 94       	cli
     ae8:	de bf       	out	0x3e, r29	; 62
     aea:	0f be       	out	0x3f, r0	; 63
     aec:	cd bf       	out	0x3d, r28	; 61
     aee:	cf 91       	pop	r28
     af0:	df 91       	pop	r29
     af2:	1f 91       	pop	r17
     af4:	0f 91       	pop	r16
     af6:	08 95       	ret

00000af8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     af8:	df 93       	push	r29
     afa:	cf 93       	push	r28
     afc:	cd b7       	in	r28, 0x3d	; 61
     afe:	de b7       	in	r29, 0x3e	; 62
     b00:	28 97       	sbiw	r28, 0x08	; 8
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	9e 83       	std	Y+6, r25	; 0x06
     b0e:	8d 83       	std	Y+5, r24	; 0x05
     b10:	78 87       	std	Y+8, r23	; 0x08
     b12:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     b14:	8d 81       	ldd	r24, Y+5	; 0x05
     b16:	9e 81       	ldd	r25, Y+6	; 0x06
     b18:	9c 83       	std	Y+4, r25	; 0x04
     b1a:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     b1c:	0f b6       	in	r0, 0x3f	; 63
     b1e:	f8 94       	cli
     b20:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     b22:	eb 81       	ldd	r30, Y+3	; 0x03
     b24:	fc 81       	ldd	r31, Y+4	; 0x04
     b26:	80 81       	ld	r24, Z
     b28:	91 81       	ldd	r25, Z+1	; 0x01
     b2a:	9a 83       	std	Y+2, r25	; 0x02
     b2c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b2e:	eb 81       	ldd	r30, Y+3	; 0x03
     b30:	fc 81       	ldd	r31, Y+4	; 0x04
     b32:	20 81       	ld	r18, Z
     b34:	31 81       	ldd	r19, Z+1	; 0x01
     b36:	8f 81       	ldd	r24, Y+7	; 0x07
     b38:	98 85       	ldd	r25, Y+8	; 0x08
     b3a:	80 95       	com	r24
     b3c:	90 95       	com	r25
     b3e:	82 23       	and	r24, r18
     b40:	93 23       	and	r25, r19
     b42:	eb 81       	ldd	r30, Y+3	; 0x03
     b44:	fc 81       	ldd	r31, Y+4	; 0x04
     b46:	91 83       	std	Z+1, r25	; 0x01
     b48:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     b4a:	0f 90       	pop	r0
     b4c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     b4e:	89 81       	ldd	r24, Y+1	; 0x01
     b50:	9a 81       	ldd	r25, Y+2	; 0x02
}
     b52:	28 96       	adiw	r28, 0x08	; 8
     b54:	0f b6       	in	r0, 0x3f	; 63
     b56:	f8 94       	cli
     b58:	de bf       	out	0x3e, r29	; 62
     b5a:	0f be       	out	0x3f, r0	; 63
     b5c:	cd bf       	out	0x3d, r28	; 61
     b5e:	cf 91       	pop	r28
     b60:	df 91       	pop	r29
     b62:	08 95       	ret

00000b64 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     b64:	df 93       	push	r29
     b66:	cf 93       	push	r28
     b68:	cd b7       	in	r28, 0x3d	; 61
     b6a:	de b7       	in	r29, 0x3e	; 62
     b6c:	27 97       	sbiw	r28, 0x07	; 7
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	de bf       	out	0x3e, r29	; 62
     b74:	0f be       	out	0x3f, r0	; 63
     b76:	cd bf       	out	0x3d, r28	; 61
     b78:	9f 83       	std	Y+7, r25	; 0x07
     b7a:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     b7c:	8e 81       	ldd	r24, Y+6	; 0x06
     b7e:	9f 81       	ldd	r25, Y+7	; 0x07
     b80:	9c 83       	std	Y+4, r25	; 0x04
     b82:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b84:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     b86:	eb 81       	ldd	r30, Y+3	; 0x03
     b88:	fc 81       	ldd	r31, Y+4	; 0x04
     b8a:	80 81       	ld	r24, Z
     b8c:	91 81       	ldd	r25, Z+1	; 0x01
     b8e:	9a 83       	std	Y+2, r25	; 0x02
     b90:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     b92:	89 81       	ldd	r24, Y+1	; 0x01
     b94:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     b96:	27 96       	adiw	r28, 0x07	; 7
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	de bf       	out	0x3e, r29	; 62
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	cd bf       	out	0x3d, r28	; 61
     ba2:	cf 91       	pop	r28
     ba4:	df 91       	pop	r29
     ba6:	08 95       	ret

00000ba8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     ba8:	df 93       	push	r29
     baa:	cf 93       	push	r28
     bac:	cd b7       	in	r28, 0x3d	; 61
     bae:	de b7       	in	r29, 0x3e	; 62
     bb0:	65 97       	sbiw	r28, 0x15	; 21
     bb2:	0f b6       	in	r0, 0x3f	; 63
     bb4:	f8 94       	cli
     bb6:	de bf       	out	0x3e, r29	; 62
     bb8:	0f be       	out	0x3f, r0	; 63
     bba:	cd bf       	out	0x3d, r28	; 61
     bbc:	9b 8b       	std	Y+19, r25	; 0x13
     bbe:	8a 8b       	std	Y+18, r24	; 0x12
     bc0:	7d 8b       	std	Y+21, r23	; 0x15
     bc2:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     bc4:	19 86       	std	Y+9, r1	; 0x09
     bc6:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     bc8:	8a 89       	ldd	r24, Y+18	; 0x12
     bca:	9b 89       	ldd	r25, Y+19	; 0x13
     bcc:	9b 83       	std	Y+3, r25	; 0x03
     bce:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     bd0:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     bd2:	8a 81       	ldd	r24, Y+2	; 0x02
     bd4:	9b 81       	ldd	r25, Y+3	; 0x03
     bd6:	02 96       	adiw	r24, 0x02	; 2
     bd8:	9b 87       	std	Y+11, r25	; 0x0b
     bda:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bdc:	8a 85       	ldd	r24, Y+10	; 0x0a
     bde:	9b 85       	ldd	r25, Y+11	; 0x0b
     be0:	03 96       	adiw	r24, 0x03	; 3
     be2:	9d 87       	std	Y+13, r25	; 0x0d
     be4:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     be6:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     bea:	ea 85       	ldd	r30, Y+10	; 0x0a
     bec:	fb 85       	ldd	r31, Y+11	; 0x0b
     bee:	85 81       	ldd	r24, Z+5	; 0x05
     bf0:	96 81       	ldd	r25, Z+6	; 0x06
     bf2:	99 8b       	std	Y+17, r25	; 0x11
     bf4:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     bf6:	ea 81       	ldd	r30, Y+2	; 0x02
     bf8:	fb 81       	ldd	r31, Y+3	; 0x03
     bfa:	20 81       	ld	r18, Z
     bfc:	31 81       	ldd	r19, Z+1	; 0x01
     bfe:	8c 89       	ldd	r24, Y+20	; 0x14
     c00:	9d 89       	ldd	r25, Y+21	; 0x15
     c02:	82 2b       	or	r24, r18
     c04:	93 2b       	or	r25, r19
     c06:	ea 81       	ldd	r30, Y+2	; 0x02
     c08:	fb 81       	ldd	r31, Y+3	; 0x03
     c0a:	91 83       	std	Z+1, r25	; 0x01
     c0c:	80 83       	st	Z, r24
     c0e:	59 c0       	rjmp	.+178    	; 0xcc2 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     c10:	e8 89       	ldd	r30, Y+16	; 0x10
     c12:	f9 89       	ldd	r31, Y+17	; 0x11
     c14:	82 81       	ldd	r24, Z+2	; 0x02
     c16:	93 81       	ldd	r25, Z+3	; 0x03
     c18:	9f 87       	std	Y+15, r25	; 0x0f
     c1a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     c1c:	e8 89       	ldd	r30, Y+16	; 0x10
     c1e:	f9 89       	ldd	r31, Y+17	; 0x11
     c20:	80 81       	ld	r24, Z
     c22:	91 81       	ldd	r25, Z+1	; 0x01
     c24:	9f 83       	std	Y+7, r25	; 0x07
     c26:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     c28:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     c2a:	8e 81       	ldd	r24, Y+6	; 0x06
     c2c:	9f 81       	ldd	r25, Y+7	; 0x07
     c2e:	80 70       	andi	r24, 0x00	; 0
     c30:	9d 83       	std	Y+5, r25	; 0x05
     c32:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     c34:	8e 81       	ldd	r24, Y+6	; 0x06
     c36:	9f 81       	ldd	r25, Y+7	; 0x07
     c38:	90 70       	andi	r25, 0x00	; 0
     c3a:	9f 83       	std	Y+7, r25	; 0x07
     c3c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     c3e:	8c 81       	ldd	r24, Y+4	; 0x04
     c40:	9d 81       	ldd	r25, Y+5	; 0x05
     c42:	80 70       	andi	r24, 0x00	; 0
     c44:	94 70       	andi	r25, 0x04	; 4
     c46:	00 97       	sbiw	r24, 0x00	; 0
     c48:	69 f4       	brne	.+26     	; 0xc64 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     c4a:	ea 81       	ldd	r30, Y+2	; 0x02
     c4c:	fb 81       	ldd	r31, Y+3	; 0x03
     c4e:	20 81       	ld	r18, Z
     c50:	31 81       	ldd	r19, Z+1	; 0x01
     c52:	8e 81       	ldd	r24, Y+6	; 0x06
     c54:	9f 81       	ldd	r25, Y+7	; 0x07
     c56:	82 23       	and	r24, r18
     c58:	93 23       	and	r25, r19
     c5a:	00 97       	sbiw	r24, 0x00	; 0
     c5c:	91 f0       	breq	.+36     	; 0xc82 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	89 83       	std	Y+1, r24	; 0x01
     c62:	0f c0       	rjmp	.+30     	; 0xc82 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     c64:	ea 81       	ldd	r30, Y+2	; 0x02
     c66:	fb 81       	ldd	r31, Y+3	; 0x03
     c68:	20 81       	ld	r18, Z
     c6a:	31 81       	ldd	r19, Z+1	; 0x01
     c6c:	8e 81       	ldd	r24, Y+6	; 0x06
     c6e:	9f 81       	ldd	r25, Y+7	; 0x07
     c70:	28 23       	and	r18, r24
     c72:	39 23       	and	r19, r25
     c74:	8e 81       	ldd	r24, Y+6	; 0x06
     c76:	9f 81       	ldd	r25, Y+7	; 0x07
     c78:	28 17       	cp	r18, r24
     c7a:	39 07       	cpc	r19, r25
     c7c:	11 f4       	brne	.+4      	; 0xc82 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	88 23       	and	r24, r24
     c86:	c9 f0       	breq	.+50     	; 0xcba <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     c88:	8c 81       	ldd	r24, Y+4	; 0x04
     c8a:	9d 81       	ldd	r25, Y+5	; 0x05
     c8c:	80 70       	andi	r24, 0x00	; 0
     c8e:	91 70       	andi	r25, 0x01	; 1
     c90:	00 97       	sbiw	r24, 0x00	; 0
     c92:	41 f0       	breq	.+16     	; 0xca4 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     c94:	88 85       	ldd	r24, Y+8	; 0x08
     c96:	99 85       	ldd	r25, Y+9	; 0x09
     c98:	2e 81       	ldd	r18, Y+6	; 0x06
     c9a:	3f 81       	ldd	r19, Y+7	; 0x07
     c9c:	82 2b       	or	r24, r18
     c9e:	93 2b       	or	r25, r19
     ca0:	99 87       	std	Y+9, r25	; 0x09
     ca2:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     ca4:	ea 81       	ldd	r30, Y+2	; 0x02
     ca6:	fb 81       	ldd	r31, Y+3	; 0x03
     ca8:	80 81       	ld	r24, Z
     caa:	91 81       	ldd	r25, Z+1	; 0x01
     cac:	9c 01       	movw	r18, r24
     cae:	32 60       	ori	r19, 0x02	; 2
     cb0:	88 89       	ldd	r24, Y+16	; 0x10
     cb2:	99 89       	ldd	r25, Y+17	; 0x11
     cb4:	b9 01       	movw	r22, r18
     cb6:	0e 94 0c 24 	call	0x4818	; 0x4818 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     cba:	8e 85       	ldd	r24, Y+14	; 0x0e
     cbc:	9f 85       	ldd	r25, Y+15	; 0x0f
     cbe:	99 8b       	std	Y+17, r25	; 0x11
     cc0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     cc2:	28 89       	ldd	r18, Y+16	; 0x10
     cc4:	39 89       	ldd	r19, Y+17	; 0x11
     cc6:	8c 85       	ldd	r24, Y+12	; 0x0c
     cc8:	9d 85       	ldd	r25, Y+13	; 0x0d
     cca:	28 17       	cp	r18, r24
     ccc:	39 07       	cpc	r19, r25
     cce:	09 f0       	breq	.+2      	; 0xcd2 <xEventGroupSetBits+0x12a>
     cd0:	9f cf       	rjmp	.-194    	; 0xc10 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     cd2:	ea 81       	ldd	r30, Y+2	; 0x02
     cd4:	fb 81       	ldd	r31, Y+3	; 0x03
     cd6:	20 81       	ld	r18, Z
     cd8:	31 81       	ldd	r19, Z+1	; 0x01
     cda:	88 85       	ldd	r24, Y+8	; 0x08
     cdc:	99 85       	ldd	r25, Y+9	; 0x09
     cde:	80 95       	com	r24
     ce0:	90 95       	com	r25
     ce2:	82 23       	and	r24, r18
     ce4:	93 23       	and	r25, r19
     ce6:	ea 81       	ldd	r30, Y+2	; 0x02
     ce8:	fb 81       	ldd	r31, Y+3	; 0x03
     cea:	91 83       	std	Z+1, r25	; 0x01
     cec:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     cee:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     cf2:	ea 81       	ldd	r30, Y+2	; 0x02
     cf4:	fb 81       	ldd	r31, Y+3	; 0x03
     cf6:	80 81       	ld	r24, Z
     cf8:	91 81       	ldd	r25, Z+1	; 0x01
}
     cfa:	65 96       	adiw	r28, 0x15	; 21
     cfc:	0f b6       	in	r0, 0x3f	; 63
     cfe:	f8 94       	cli
     d00:	de bf       	out	0x3e, r29	; 62
     d02:	0f be       	out	0x3f, r0	; 63
     d04:	cd bf       	out	0x3d, r28	; 61
     d06:	cf 91       	pop	r28
     d08:	df 91       	pop	r29
     d0a:	08 95       	ret

00000d0c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     d0c:	df 93       	push	r29
     d0e:	cf 93       	push	r28
     d10:	00 d0       	rcall	.+0      	; 0xd12 <vEventGroupDelete+0x6>
     d12:	00 d0       	rcall	.+0      	; 0xd14 <vEventGroupDelete+0x8>
     d14:	00 d0       	rcall	.+0      	; 0xd16 <vEventGroupDelete+0xa>
     d16:	cd b7       	in	r28, 0x3d	; 61
     d18:	de b7       	in	r29, 0x3e	; 62
     d1a:	9e 83       	std	Y+6, r25	; 0x06
     d1c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     d1e:	8d 81       	ldd	r24, Y+5	; 0x05
     d20:	9e 81       	ldd	r25, Y+6	; 0x06
     d22:	9c 83       	std	Y+4, r25	; 0x04
     d24:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     d26:	8b 81       	ldd	r24, Y+3	; 0x03
     d28:	9c 81       	ldd	r25, Y+4	; 0x04
     d2a:	02 96       	adiw	r24, 0x02	; 2
     d2c:	9a 83       	std	Y+2, r25	; 0x02
     d2e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     d30:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
     d34:	08 c0       	rjmp	.+16     	; 0xd46 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     d36:	e9 81       	ldd	r30, Y+1	; 0x01
     d38:	fa 81       	ldd	r31, Y+2	; 0x02
     d3a:	85 81       	ldd	r24, Z+5	; 0x05
     d3c:	96 81       	ldd	r25, Z+6	; 0x06
     d3e:	60 e0       	ldi	r22, 0x00	; 0
     d40:	72 e0       	ldi	r23, 0x02	; 2
     d42:	0e 94 0c 24 	call	0x4818	; 0x4818 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     d46:	e9 81       	ldd	r30, Y+1	; 0x01
     d48:	fa 81       	ldd	r31, Y+2	; 0x02
     d4a:	80 81       	ld	r24, Z
     d4c:	88 23       	and	r24, r24
     d4e:	99 f7       	brne	.-26     	; 0xd36 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     d50:	8b 81       	ldd	r24, Y+3	; 0x03
     d52:	9c 81       	ldd	r25, Y+4	; 0x04
     d54:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     d58:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
}
     d5c:	26 96       	adiw	r28, 0x06	; 6
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	de bf       	out	0x3e, r29	; 62
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	cd bf       	out	0x3d, r28	; 61
     d68:	cf 91       	pop	r28
     d6a:	df 91       	pop	r29
     d6c:	08 95       	ret

00000d6e <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     d6e:	df 93       	push	r29
     d70:	cf 93       	push	r28
     d72:	00 d0       	rcall	.+0      	; 0xd74 <vEventGroupSetBitsCallback+0x6>
     d74:	00 d0       	rcall	.+0      	; 0xd76 <vEventGroupSetBitsCallback+0x8>
     d76:	00 d0       	rcall	.+0      	; 0xd78 <vEventGroupSetBitsCallback+0xa>
     d78:	cd b7       	in	r28, 0x3d	; 61
     d7a:	de b7       	in	r29, 0x3e	; 62
     d7c:	9a 83       	std	Y+2, r25	; 0x02
     d7e:	89 83       	std	Y+1, r24	; 0x01
     d80:	4b 83       	std	Y+3, r20	; 0x03
     d82:	5c 83       	std	Y+4, r21	; 0x04
     d84:	6d 83       	std	Y+5, r22	; 0x05
     d86:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d88:	89 81       	ldd	r24, Y+1	; 0x01
     d8a:	9a 81       	ldd	r25, Y+2	; 0x02
     d8c:	2b 81       	ldd	r18, Y+3	; 0x03
     d8e:	3c 81       	ldd	r19, Y+4	; 0x04
     d90:	b9 01       	movw	r22, r18
     d92:	0e 94 d4 05 	call	0xba8	; 0xba8 <xEventGroupSetBits>
}
     d96:	26 96       	adiw	r28, 0x06	; 6
     d98:	0f b6       	in	r0, 0x3f	; 63
     d9a:	f8 94       	cli
     d9c:	de bf       	out	0x3e, r29	; 62
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	cd bf       	out	0x3d, r28	; 61
     da2:	cf 91       	pop	r28
     da4:	df 91       	pop	r29
     da6:	08 95       	ret

00000da8 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     da8:	df 93       	push	r29
     daa:	cf 93       	push	r28
     dac:	00 d0       	rcall	.+0      	; 0xdae <vEventGroupClearBitsCallback+0x6>
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <vEventGroupClearBitsCallback+0x8>
     db0:	00 d0       	rcall	.+0      	; 0xdb2 <vEventGroupClearBitsCallback+0xa>
     db2:	cd b7       	in	r28, 0x3d	; 61
     db4:	de b7       	in	r29, 0x3e	; 62
     db6:	9a 83       	std	Y+2, r25	; 0x02
     db8:	89 83       	std	Y+1, r24	; 0x01
     dba:	4b 83       	std	Y+3, r20	; 0x03
     dbc:	5c 83       	std	Y+4, r21	; 0x04
     dbe:	6d 83       	std	Y+5, r22	; 0x05
     dc0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     dc2:	89 81       	ldd	r24, Y+1	; 0x01
     dc4:	9a 81       	ldd	r25, Y+2	; 0x02
     dc6:	2b 81       	ldd	r18, Y+3	; 0x03
     dc8:	3c 81       	ldd	r19, Y+4	; 0x04
     dca:	b9 01       	movw	r22, r18
     dcc:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <xEventGroupClearBits>
}
     dd0:	26 96       	adiw	r28, 0x06	; 6
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cd bf       	out	0x3d, r28	; 61
     ddc:	cf 91       	pop	r28
     dde:	df 91       	pop	r29
     de0:	08 95       	ret

00000de2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     de2:	df 93       	push	r29
     de4:	cf 93       	push	r28
     de6:	00 d0       	rcall	.+0      	; 0xde8 <prvTestWaitCondition+0x6>
     de8:	00 d0       	rcall	.+0      	; 0xdea <prvTestWaitCondition+0x8>
     dea:	00 d0       	rcall	.+0      	; 0xdec <prvTestWaitCondition+0xa>
     dec:	cd b7       	in	r28, 0x3d	; 61
     dee:	de b7       	in	r29, 0x3e	; 62
     df0:	9b 83       	std	Y+3, r25	; 0x03
     df2:	8a 83       	std	Y+2, r24	; 0x02
     df4:	7d 83       	std	Y+5, r23	; 0x05
     df6:	6c 83       	std	Y+4, r22	; 0x04
     df8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     dfa:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     dfc:	8e 81       	ldd	r24, Y+6	; 0x06
     dfe:	88 23       	and	r24, r24
     e00:	59 f4       	brne	.+22     	; 0xe18 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     e02:	8a 81       	ldd	r24, Y+2	; 0x02
     e04:	9b 81       	ldd	r25, Y+3	; 0x03
     e06:	2c 81       	ldd	r18, Y+4	; 0x04
     e08:	3d 81       	ldd	r19, Y+5	; 0x05
     e0a:	82 23       	and	r24, r18
     e0c:	93 23       	and	r25, r19
     e0e:	00 97       	sbiw	r24, 0x00	; 0
     e10:	81 f0       	breq	.+32     	; 0xe32 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e12:	81 e0       	ldi	r24, 0x01	; 1
     e14:	89 83       	std	Y+1, r24	; 0x01
     e16:	0d c0       	rjmp	.+26     	; 0xe32 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e18:	2a 81       	ldd	r18, Y+2	; 0x02
     e1a:	3b 81       	ldd	r19, Y+3	; 0x03
     e1c:	8c 81       	ldd	r24, Y+4	; 0x04
     e1e:	9d 81       	ldd	r25, Y+5	; 0x05
     e20:	28 23       	and	r18, r24
     e22:	39 23       	and	r19, r25
     e24:	8c 81       	ldd	r24, Y+4	; 0x04
     e26:	9d 81       	ldd	r25, Y+5	; 0x05
     e28:	28 17       	cp	r18, r24
     e2a:	39 07       	cpc	r19, r25
     e2c:	11 f4       	brne	.+4      	; 0xe32 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     e32:	89 81       	ldd	r24, Y+1	; 0x01
}
     e34:	26 96       	adiw	r28, 0x06	; 6
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	cd bf       	out	0x3d, r28	; 61
     e40:	cf 91       	pop	r28
     e42:	df 91       	pop	r29
     e44:	08 95       	ret

00000e46 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e46:	df 93       	push	r29
     e48:	cf 93       	push	r28
     e4a:	00 d0       	rcall	.+0      	; 0xe4c <pvPortMalloc+0x6>
     e4c:	00 d0       	rcall	.+0      	; 0xe4e <pvPortMalloc+0x8>
     e4e:	cd b7       	in	r28, 0x3d	; 61
     e50:	de b7       	in	r29, 0x3e	; 62
     e52:	9c 83       	std	Y+4, r25	; 0x04
     e54:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     e56:	1a 82       	std	Y+2, r1	; 0x02
     e58:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     e5a:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     e5e:	80 91 b0 00 	lds	r24, 0x00B0
     e62:	90 91 b1 00 	lds	r25, 0x00B1
     e66:	00 97       	sbiw	r24, 0x00	; 0
     e68:	31 f4       	brne	.+12     	; 0xe76 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e6a:	83 eb       	ldi	r24, 0xB3	; 179
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	90 93 b1 00 	sts	0x00B1, r25
     e72:	80 93 b0 00 	sts	0x00B0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e76:	80 91 ae 00 	lds	r24, 0x00AE
     e7a:	90 91 af 00 	lds	r25, 0x00AF
     e7e:	2b 81       	ldd	r18, Y+3	; 0x03
     e80:	3c 81       	ldd	r19, Y+4	; 0x04
     e82:	82 0f       	add	r24, r18
     e84:	93 1f       	adc	r25, r19
     e86:	25 e0       	ldi	r18, 0x05	; 5
     e88:	8b 3d       	cpi	r24, 0xDB	; 219
     e8a:	92 07       	cpc	r25, r18
     e8c:	38 f5       	brcc	.+78     	; 0xedc <pvPortMalloc+0x96>
     e8e:	20 91 ae 00 	lds	r18, 0x00AE
     e92:	30 91 af 00 	lds	r19, 0x00AF
     e96:	8b 81       	ldd	r24, Y+3	; 0x03
     e98:	9c 81       	ldd	r25, Y+4	; 0x04
     e9a:	28 0f       	add	r18, r24
     e9c:	39 1f       	adc	r19, r25
     e9e:	80 91 ae 00 	lds	r24, 0x00AE
     ea2:	90 91 af 00 	lds	r25, 0x00AF
     ea6:	82 17       	cp	r24, r18
     ea8:	93 07       	cpc	r25, r19
     eaa:	c0 f4       	brcc	.+48     	; 0xedc <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     eac:	20 91 b0 00 	lds	r18, 0x00B0
     eb0:	30 91 b1 00 	lds	r19, 0x00B1
     eb4:	80 91 ae 00 	lds	r24, 0x00AE
     eb8:	90 91 af 00 	lds	r25, 0x00AF
     ebc:	82 0f       	add	r24, r18
     ebe:	93 1f       	adc	r25, r19
     ec0:	9a 83       	std	Y+2, r25	; 0x02
     ec2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     ec4:	20 91 ae 00 	lds	r18, 0x00AE
     ec8:	30 91 af 00 	lds	r19, 0x00AF
     ecc:	8b 81       	ldd	r24, Y+3	; 0x03
     ece:	9c 81       	ldd	r25, Y+4	; 0x04
     ed0:	82 0f       	add	r24, r18
     ed2:	93 1f       	adc	r25, r19
     ed4:	90 93 af 00 	sts	0x00AF, r25
     ed8:	80 93 ae 00 	sts	0x00AE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     edc:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     ee0:	89 81       	ldd	r24, Y+1	; 0x01
     ee2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ee4:	0f 90       	pop	r0
     ee6:	0f 90       	pop	r0
     ee8:	0f 90       	pop	r0
     eea:	0f 90       	pop	r0
     eec:	cf 91       	pop	r28
     eee:	df 91       	pop	r29
     ef0:	08 95       	ret

00000ef2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ef2:	df 93       	push	r29
     ef4:	cf 93       	push	r28
     ef6:	00 d0       	rcall	.+0      	; 0xef8 <vPortFree+0x6>
     ef8:	cd b7       	in	r28, 0x3d	; 61
     efa:	de b7       	in	r29, 0x3e	; 62
     efc:	9a 83       	std	Y+2, r25	; 0x02
     efe:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     f00:	0f 90       	pop	r0
     f02:	0f 90       	pop	r0
     f04:	cf 91       	pop	r28
     f06:	df 91       	pop	r29
     f08:	08 95       	ret

00000f0a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f0a:	df 93       	push	r29
     f0c:	cf 93       	push	r28
     f0e:	cd b7       	in	r28, 0x3d	; 61
     f10:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f12:	10 92 af 00 	sts	0x00AF, r1
     f16:	10 92 ae 00 	sts	0x00AE, r1
}
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f28:	20 91 ae 00 	lds	r18, 0x00AE
     f2c:	30 91 af 00 	lds	r19, 0x00AF
     f30:	8b ed       	ldi	r24, 0xDB	; 219
     f32:	95 e0       	ldi	r25, 0x05	; 5
     f34:	82 1b       	sub	r24, r18
     f36:	93 0b       	sbc	r25, r19
}
     f38:	cf 91       	pop	r28
     f3a:	df 91       	pop	r29
     f3c:	08 95       	ret

00000f3e <KeyPad_Init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Init(void)
{
     f3e:	df 93       	push	r29
     f40:	cf 93       	push	r28
     f42:	cd b7       	in	r28, 0x3d	; 61
     f44:	de b7       	in	r29, 0x3e	; 62
	/*set Pins Of KeyPad*/
	DIO_SetPinDirection(DIO_PIN18,INPUT);
     f46:	82 e1       	ldi	r24, 0x12	; 18
     f48:	60 e0       	ldi	r22, 0x00	; 0
     f4a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN19,INPUT);
     f4e:	83 e1       	ldi	r24, 0x13	; 19
     f50:	60 e0       	ldi	r22, 0x00	; 0
     f52:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN20,INPUT);
     f56:	84 e1       	ldi	r24, 0x14	; 20
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN21,OUTPUT);
     f5e:	85 e1       	ldi	r24, 0x15	; 21
     f60:	61 e0       	ldi	r22, 0x01	; 1
     f62:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN22,OUTPUT);
     f66:	86 e1       	ldi	r24, 0x16	; 22
     f68:	61 e0       	ldi	r22, 0x01	; 1
     f6a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN23,OUTPUT);
     f6e:	87 e1       	ldi	r24, 0x17	; 23
     f70:	61 e0       	ldi	r22, 0x01	; 1
     f72:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_WritePin(DIO_PIN18,HIGH);
     f76:	82 e1       	ldi	r24, 0x12	; 18
     f78:	61 e0       	ldi	r22, 0x01	; 1
     f7a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN19,HIGH);
     f7e:	83 e1       	ldi	r24, 0x13	; 19
     f80:	61 e0       	ldi	r22, 0x01	; 1
     f82:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN20,HIGH);
     f86:	84 e1       	ldi	r24, 0x14	; 20
     f88:	61 e0       	ldi	r22, 0x01	; 1
     f8a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN21,LOW);
     f8e:	85 e1       	ldi	r24, 0x15	; 21
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN22,LOW);
     f96:	86 e1       	ldi	r24, 0x16	; 22
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN23,LOW);
     f9e:	87 e1       	ldi	r24, 0x17	; 23
     fa0:	60 e0       	ldi	r22, 0x00	; 0
     fa2:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
}
     fa6:	cf 91       	pop	r28
     fa8:	df 91       	pop	r29
     faa:	08 95       	ret

00000fac <KeyPad_getPressedKey>:
 * Outputs:			NULL
 *
 * Return:			pressed key (uint8)
 *******************************************************************************/
uint8 KeyPad_getPressedKey(void)
{
     fac:	df 93       	push	r29
     fae:	cf 93       	push	r28
     fb0:	00 d0       	rcall	.+0      	; 0xfb2 <KeyPad_getPressedKey+0x6>
     fb2:	00 d0       	rcall	.+0      	; 0xfb4 <KeyPad_getPressedKey+0x8>
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
	/*return value*/
	uint8 ReturnVal=10;
     fb8:	8a e0       	ldi	r24, 0x0A	; 10
     fba:	8b 83       	std	Y+3, r24	; 0x03

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
     fbc:	19 82       	std	Y+1, r1	; 0x01
     fbe:	42 c0       	rjmp	.+132    	; 0x1044 <KeyPad_getPressedKey+0x98>
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
     fc0:	e4 e3       	ldi	r30, 0x34	; 52
     fc2:	f0 e0       	ldi	r31, 0x00	; 0
     fc4:	89 81       	ldd	r24, Y+1	; 0x01
     fc6:	28 2f       	mov	r18, r24
     fc8:	30 e0       	ldi	r19, 0x00	; 0
     fca:	80 e2       	ldi	r24, 0x20	; 32
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	02 c0       	rjmp	.+4      	; 0xfd4 <KeyPad_getPressedKey+0x28>
     fd0:	88 0f       	add	r24, r24
     fd2:	99 1f       	adc	r25, r25
     fd4:	2a 95       	dec	r18
     fd6:	e2 f7       	brpl	.-8      	; 0xfd0 <KeyPad_getPressedKey+0x24>
     fd8:	80 83       	st	Z, r24
		KEYPAD_PORT_OUT = (~(0b00100000<<col));
     fda:	e5 e3       	ldi	r30, 0x35	; 53
     fdc:	f0 e0       	ldi	r31, 0x00	; 0
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	28 2f       	mov	r18, r24
     fe2:	30 e0       	ldi	r19, 0x00	; 0
     fe4:	80 e2       	ldi	r24, 0x20	; 32
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	02 2e       	mov	r0, r18
     fea:	02 c0       	rjmp	.+4      	; 0xff0 <KeyPad_getPressedKey+0x44>
     fec:	88 0f       	add	r24, r24
     fee:	99 1f       	adc	r25, r25
     ff0:	0a 94       	dec	r0
     ff2:	e2 f7       	brpl	.-8      	; 0xfec <KeyPad_getPressedKey+0x40>
     ff4:	80 95       	com	r24
     ff6:	80 83       	st	Z, r24

		for(row=START_ROW;row<END_ROW;row++)
     ff8:	82 e0       	ldi	r24, 0x02	; 2
     ffa:	8a 83       	std	Y+2, r24	; 0x02
     ffc:	1d c0       	rjmp	.+58     	; 0x1038 <KeyPad_getPressedKey+0x8c>
		{
			if(GET_BIT(KEYPAD_PORT_IN,row) == 0)
     ffe:	e3 e3       	ldi	r30, 0x33	; 51
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	80 81       	ld	r24, Z
    1004:	28 2f       	mov	r18, r24
    1006:	30 e0       	ldi	r19, 0x00	; 0
    1008:	8a 81       	ldd	r24, Y+2	; 0x02
    100a:	88 2f       	mov	r24, r24
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	a9 01       	movw	r20, r18
    1010:	02 c0       	rjmp	.+4      	; 0x1016 <KeyPad_getPressedKey+0x6a>
    1012:	55 95       	asr	r21
    1014:	47 95       	ror	r20
    1016:	8a 95       	dec	r24
    1018:	e2 f7       	brpl	.-8      	; 0x1012 <KeyPad_getPressedKey+0x66>
    101a:	ca 01       	movw	r24, r20
    101c:	81 70       	andi	r24, 0x01	; 1
    101e:	90 70       	andi	r25, 0x00	; 0
    1020:	00 97       	sbiw	r24, 0x00	; 0
    1022:	39 f4       	brne	.+14     	; 0x1032 <KeyPad_getPressedKey+0x86>
				/*check on Configurations Mode*/
#if(N_COL ==3)
#if(N_ROW == 3)

				/*return value of pressed Key*/
				return  KeyPad_3x3_switch(row-START_ROW,col);
    1024:	8a 81       	ldd	r24, Y+2	; 0x02
    1026:	82 50       	subi	r24, 0x02	; 2
    1028:	69 81       	ldd	r22, Y+1	; 0x01
    102a:	0e 94 30 08 	call	0x1060	; 0x1060 <KeyPad_3x3_switch>
    102e:	8c 83       	std	Y+4, r24	; 0x04
    1030:	0f c0       	rjmp	.+30     	; 0x1050 <KeyPad_getPressedKey+0xa4>
	for(col=0;col<N_COL;col++)
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
		KEYPAD_PORT_OUT = (~(0b00100000<<col));

		for(row=START_ROW;row<END_ROW;row++)
    1032:	8a 81       	ldd	r24, Y+2	; 0x02
    1034:	8f 5f       	subi	r24, 0xFF	; 255
    1036:	8a 83       	std	Y+2, r24	; 0x02
    1038:	8a 81       	ldd	r24, Y+2	; 0x02
    103a:	85 30       	cpi	r24, 0x05	; 5
    103c:	00 f3       	brcs	.-64     	; 0xffe <KeyPad_getPressedKey+0x52>

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
    103e:	89 81       	ldd	r24, Y+1	; 0x01
    1040:	8f 5f       	subi	r24, 0xFF	; 255
    1042:	89 83       	std	Y+1, r24	; 0x01
    1044:	89 81       	ldd	r24, Y+1	; 0x01
    1046:	83 30       	cpi	r24, 0x03	; 3
    1048:	08 f4       	brcc	.+2      	; 0x104c <KeyPad_getPressedKey+0xa0>
    104a:	ba cf       	rjmp	.-140    	; 0xfc0 <KeyPad_getPressedKey+0x14>
				return KeyPad_4x4_switch(row-START_ROW,col);
#endif
			}
		}
	}
	return ReturnVal;
    104c:	5b 81       	ldd	r21, Y+3	; 0x03
    104e:	5c 83       	std	Y+4, r21	; 0x04
    1050:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1052:	0f 90       	pop	r0
    1054:	0f 90       	pop	r0
    1056:	0f 90       	pop	r0
    1058:	0f 90       	pop	r0
    105a:	cf 91       	pop	r28
    105c:	df 91       	pop	r29
    105e:	08 95       	ret

00001060 <KeyPad_3x3_switch>:
 * Outputs:			NULL
 *
 * Return:			value of Pressed Key (uint8)
 *******************************************************************************/
static uint8 KeyPad_3x3_switch(uint8 row, uint8 col)
{
    1060:	df 93       	push	r29
    1062:	cf 93       	push	r28
    1064:	cd b7       	in	r28, 0x3d	; 61
    1066:	de b7       	in	r29, 0x3e	; 62
    1068:	2b 97       	sbiw	r28, 0x0b	; 11
    106a:	0f b6       	in	r0, 0x3f	; 63
    106c:	f8 94       	cli
    106e:	de bf       	out	0x3e, r29	; 62
    1070:	0f be       	out	0x3f, r0	; 63
    1072:	cd bf       	out	0x3d, r28	; 61
    1074:	8a 83       	std	Y+2, r24	; 0x02
    1076:	6b 83       	std	Y+3, r22	; 0x03
	/*variable of return value*/
	uint8 ReturnVal = 0;
    1078:	19 82       	std	Y+1, r1	; 0x01

	/*determine row of pressed key*/
	switch(row)
    107a:	8a 81       	ldd	r24, Y+2	; 0x02
    107c:	28 2f       	mov	r18, r24
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	3b 87       	std	Y+11, r19	; 0x0b
    1082:	2a 87       	std	Y+10, r18	; 0x0a
    1084:	8a 85       	ldd	r24, Y+10	; 0x0a
    1086:	9b 85       	ldd	r25, Y+11	; 0x0b
    1088:	81 30       	cpi	r24, 0x01	; 1
    108a:	91 05       	cpc	r25, r1
    108c:	41 f1       	breq	.+80     	; 0x10de <KeyPad_3x3_switch+0x7e>
    108e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1090:	3b 85       	ldd	r19, Y+11	; 0x0b
    1092:	22 30       	cpi	r18, 0x02	; 2
    1094:	31 05       	cpc	r19, r1
    1096:	09 f4       	brne	.+2      	; 0x109a <KeyPad_3x3_switch+0x3a>
    1098:	3e c0       	rjmp	.+124    	; 0x1116 <KeyPad_3x3_switch+0xb6>
    109a:	8a 85       	ldd	r24, Y+10	; 0x0a
    109c:	9b 85       	ldd	r25, Y+11	; 0x0b
    109e:	00 97       	sbiw	r24, 0x00	; 0
    10a0:	09 f0       	breq	.+2      	; 0x10a4 <KeyPad_3x3_switch+0x44>
    10a2:	54 c0       	rjmp	.+168    	; 0x114c <KeyPad_3x3_switch+0xec>
	{
	case 0:
		/*determine column of pressed key*/
		switch(col)
    10a4:	8b 81       	ldd	r24, Y+3	; 0x03
    10a6:	28 2f       	mov	r18, r24
    10a8:	30 e0       	ldi	r19, 0x00	; 0
    10aa:	39 87       	std	Y+9, r19	; 0x09
    10ac:	28 87       	std	Y+8, r18	; 0x08
    10ae:	88 85       	ldd	r24, Y+8	; 0x08
    10b0:	99 85       	ldd	r25, Y+9	; 0x09
    10b2:	81 30       	cpi	r24, 0x01	; 1
    10b4:	91 05       	cpc	r25, r1
    10b6:	69 f0       	breq	.+26     	; 0x10d2 <KeyPad_3x3_switch+0x72>
    10b8:	28 85       	ldd	r18, Y+8	; 0x08
    10ba:	39 85       	ldd	r19, Y+9	; 0x09
    10bc:	22 30       	cpi	r18, 0x02	; 2
    10be:	31 05       	cpc	r19, r1
    10c0:	59 f0       	breq	.+22     	; 0x10d8 <KeyPad_3x3_switch+0x78>
    10c2:	88 85       	ldd	r24, Y+8	; 0x08
    10c4:	99 85       	ldd	r25, Y+9	; 0x09
    10c6:	00 97       	sbiw	r24, 0x00	; 0
    10c8:	09 f0       	breq	.+2      	; 0x10cc <KeyPad_3x3_switch+0x6c>
    10ca:	40 c0       	rjmp	.+128    	; 0x114c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R1C1;
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	89 83       	std	Y+1, r24	; 0x01
    10d0:	3d c0       	rjmp	.+122    	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R1C2;
    10d2:	82 e0       	ldi	r24, 0x02	; 2
    10d4:	89 83       	std	Y+1, r24	; 0x01
    10d6:	3a c0       	rjmp	.+116    	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R1C3;
    10d8:	83 e0       	ldi	r24, 0x03	; 3
    10da:	89 83       	std	Y+1, r24	; 0x01
    10dc:	37 c0       	rjmp	.+110    	; 0x114c <KeyPad_3x3_switch+0xec>
		}
		break;

	case 1:
		/*determine column of pressed key*/
		switch(col)
    10de:	8b 81       	ldd	r24, Y+3	; 0x03
    10e0:	28 2f       	mov	r18, r24
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	3f 83       	std	Y+7, r19	; 0x07
    10e6:	2e 83       	std	Y+6, r18	; 0x06
    10e8:	8e 81       	ldd	r24, Y+6	; 0x06
    10ea:	9f 81       	ldd	r25, Y+7	; 0x07
    10ec:	81 30       	cpi	r24, 0x01	; 1
    10ee:	91 05       	cpc	r25, r1
    10f0:	61 f0       	breq	.+24     	; 0x110a <KeyPad_3x3_switch+0xaa>
    10f2:	2e 81       	ldd	r18, Y+6	; 0x06
    10f4:	3f 81       	ldd	r19, Y+7	; 0x07
    10f6:	22 30       	cpi	r18, 0x02	; 2
    10f8:	31 05       	cpc	r19, r1
    10fa:	51 f0       	breq	.+20     	; 0x1110 <KeyPad_3x3_switch+0xb0>
    10fc:	8e 81       	ldd	r24, Y+6	; 0x06
    10fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1100:	00 97       	sbiw	r24, 0x00	; 0
    1102:	21 f5       	brne	.+72     	; 0x114c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R2C1;
    1104:	84 e0       	ldi	r24, 0x04	; 4
    1106:	89 83       	std	Y+1, r24	; 0x01
    1108:	21 c0       	rjmp	.+66     	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R2C2;
    110a:	85 e0       	ldi	r24, 0x05	; 5
    110c:	89 83       	std	Y+1, r24	; 0x01
    110e:	1e c0       	rjmp	.+60     	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R2C3;
    1110:	86 e0       	ldi	r24, 0x06	; 6
    1112:	89 83       	std	Y+1, r24	; 0x01
    1114:	1b c0       	rjmp	.+54     	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		}
			break;
	case 2:
		/*determine column of pressed key*/
		switch(col)
    1116:	8b 81       	ldd	r24, Y+3	; 0x03
    1118:	28 2f       	mov	r18, r24
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	3d 83       	std	Y+5, r19	; 0x05
    111e:	2c 83       	std	Y+4, r18	; 0x04
    1120:	8c 81       	ldd	r24, Y+4	; 0x04
    1122:	9d 81       	ldd	r25, Y+5	; 0x05
    1124:	81 30       	cpi	r24, 0x01	; 1
    1126:	91 05       	cpc	r25, r1
    1128:	61 f0       	breq	.+24     	; 0x1142 <KeyPad_3x3_switch+0xe2>
    112a:	2c 81       	ldd	r18, Y+4	; 0x04
    112c:	3d 81       	ldd	r19, Y+5	; 0x05
    112e:	22 30       	cpi	r18, 0x02	; 2
    1130:	31 05       	cpc	r19, r1
    1132:	51 f0       	breq	.+20     	; 0x1148 <KeyPad_3x3_switch+0xe8>
    1134:	8c 81       	ldd	r24, Y+4	; 0x04
    1136:	9d 81       	ldd	r25, Y+5	; 0x05
    1138:	00 97       	sbiw	r24, 0x00	; 0
    113a:	41 f4       	brne	.+16     	; 0x114c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R3C1;
    113c:	87 e0       	ldi	r24, 0x07	; 7
    113e:	89 83       	std	Y+1, r24	; 0x01
    1140:	05 c0       	rjmp	.+10     	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R3C2;
    1142:	88 e0       	ldi	r24, 0x08	; 8
    1144:	89 83       	std	Y+1, r24	; 0x01
    1146:	02 c0       	rjmp	.+4      	; 0x114c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R3C3;
    1148:	89 e0       	ldi	r24, 0x09	; 9
    114a:	89 83       	std	Y+1, r24	; 0x01
		}
		break;
	}

	/*return value of pressed key*/
	return ReturnVal;
    114c:	89 81       	ldd	r24, Y+1	; 0x01
}
    114e:	2b 96       	adiw	r28, 0x0b	; 11
    1150:	0f b6       	in	r0, 0x3f	; 63
    1152:	f8 94       	cli
    1154:	de bf       	out	0x3e, r29	; 62
    1156:	0f be       	out	0x3f, r0	; 63
    1158:	cd bf       	out	0x3d, r28	; 61
    115a:	cf 91       	pop	r28
    115c:	df 91       	pop	r29
    115e:	08 95       	ret

00001160 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1160:	df 93       	push	r29
    1162:	cf 93       	push	r28
    1164:	cd b7       	in	r28, 0x3d	; 61
    1166:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1168:	aa e3       	ldi	r26, 0x3A	; 58
    116a:	b0 e0       	ldi	r27, 0x00	; 0
    116c:	ea e3       	ldi	r30, 0x3A	; 58
    116e:	f0 e0       	ldi	r31, 0x00	; 0
    1170:	80 81       	ld	r24, Z
    1172:	8e 60       	ori	r24, 0x0E	; 14
    1174:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1176:	aa e3       	ldi	r26, 0x3A	; 58
    1178:	b0 e0       	ldi	r27, 0x00	; 0
    117a:	ea e3       	ldi	r30, 0x3A	; 58
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	80 81       	ld	r24, Z
    1180:	80 6f       	ori	r24, 0xF0	; 240
    1182:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    1184:	82 e0       	ldi	r24, 0x02	; 2
    1186:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    118a:	88 e2       	ldi	r24, 0x28	; 40
    118c:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    1190:	8c e0       	ldi	r24, 0x0C	; 12
    1192:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>

}
    119c:	cf 91       	pop	r28
    119e:	df 91       	pop	r29
    11a0:	08 95       	ret

000011a2 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    11a2:	df 93       	push	r29
    11a4:	cf 93       	push	r28
    11a6:	0f 92       	push	r0
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    11ae:	ab e3       	ldi	r26, 0x3B	; 59
    11b0:	b0 e0       	ldi	r27, 0x00	; 0
    11b2:	eb e3       	ldi	r30, 0x3B	; 59
    11b4:	f0 e0       	ldi	r31, 0x00	; 0
    11b6:	80 81       	ld	r24, Z
    11b8:	8d 7f       	andi	r24, 0xFD	; 253
    11ba:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    11bc:	ab e3       	ldi	r26, 0x3B	; 59
    11be:	b0 e0       	ldi	r27, 0x00	; 0
    11c0:	eb e3       	ldi	r30, 0x3B	; 59
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	80 81       	ld	r24, Z
    11c6:	8b 7f       	andi	r24, 0xFB	; 251
    11c8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11d2:	ab e3       	ldi	r26, 0x3B	; 59
    11d4:	b0 e0       	ldi	r27, 0x00	; 0
    11d6:	eb e3       	ldi	r30, 0x3B	; 59
    11d8:	f0 e0       	ldi	r31, 0x00	; 0
    11da:	80 81       	ld	r24, Z
    11dc:	88 60       	ori	r24, 0x08	; 8
    11de:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    11e8:	ab e3       	ldi	r26, 0x3B	; 59
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	eb e3       	ldi	r30, 0x3B	; 59
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	98 2f       	mov	r25, r24
    11f4:	9f 70       	andi	r25, 0x0F	; 15
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	80 7f       	andi	r24, 0xF0	; 240
    11fa:	89 2b       	or	r24, r25
    11fc:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1206:	ab e3       	ldi	r26, 0x3B	; 59
    1208:	b0 e0       	ldi	r27, 0x00	; 0
    120a:	eb e3       	ldi	r30, 0x3B	; 59
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	87 7f       	andi	r24, 0xF7	; 247
    1212:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    121c:	ab e3       	ldi	r26, 0x3B	; 59
    121e:	b0 e0       	ldi	r27, 0x00	; 0
    1220:	eb e3       	ldi	r30, 0x3B	; 59
    1222:	f0 e0       	ldi	r31, 0x00	; 0
    1224:	80 81       	ld	r24, Z
    1226:	88 60       	ori	r24, 0x08	; 8
    1228:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    122a:	81 e0       	ldi	r24, 0x01	; 1
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1232:	ab e3       	ldi	r26, 0x3B	; 59
    1234:	b0 e0       	ldi	r27, 0x00	; 0
    1236:	eb e3       	ldi	r30, 0x3B	; 59
    1238:	f0 e0       	ldi	r31, 0x00	; 0
    123a:	80 81       	ld	r24, Z
    123c:	28 2f       	mov	r18, r24
    123e:	2f 70       	andi	r18, 0x0F	; 15
    1240:	89 81       	ldd	r24, Y+1	; 0x01
    1242:	88 2f       	mov	r24, r24
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	82 95       	swap	r24
    1248:	92 95       	swap	r25
    124a:	90 7f       	andi	r25, 0xF0	; 240
    124c:	98 27       	eor	r25, r24
    124e:	80 7f       	andi	r24, 0xF0	; 240
    1250:	98 27       	eor	r25, r24
    1252:	82 2b       	or	r24, r18
    1254:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    125e:	ab e3       	ldi	r26, 0x3B	; 59
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	eb e3       	ldi	r30, 0x3B	; 59
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	87 7f       	andi	r24, 0xF7	; 247
    126a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    126c:	81 e0       	ldi	r24, 0x01	; 1
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1274:	0f 90       	pop	r0
    1276:	cf 91       	pop	r28
    1278:	df 91       	pop	r29
    127a:	08 95       	ret

0000127c <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    127c:	df 93       	push	r29
    127e:	cf 93       	push	r28
    1280:	0f 92       	push	r0
    1282:	cd b7       	in	r28, 0x3d	; 61
    1284:	de b7       	in	r29, 0x3e	; 62
    1286:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1288:	ab e3       	ldi	r26, 0x3B	; 59
    128a:	b0 e0       	ldi	r27, 0x00	; 0
    128c:	eb e3       	ldi	r30, 0x3B	; 59
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	82 60       	ori	r24, 0x02	; 2
    1294:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1296:	ab e3       	ldi	r26, 0x3B	; 59
    1298:	b0 e0       	ldi	r27, 0x00	; 0
    129a:	eb e3       	ldi	r30, 0x3B	; 59
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	80 81       	ld	r24, Z
    12a0:	8b 7f       	andi	r24, 0xFB	; 251
    12a2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12ac:	ab e3       	ldi	r26, 0x3B	; 59
    12ae:	b0 e0       	ldi	r27, 0x00	; 0
    12b0:	eb e3       	ldi	r30, 0x3B	; 59
    12b2:	f0 e0       	ldi	r31, 0x00	; 0
    12b4:	80 81       	ld	r24, Z
    12b6:	88 60       	ori	r24, 0x08	; 8
    12b8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    12c2:	ab e3       	ldi	r26, 0x3B	; 59
    12c4:	b0 e0       	ldi	r27, 0x00	; 0
    12c6:	eb e3       	ldi	r30, 0x3B	; 59
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	98 2f       	mov	r25, r24
    12ce:	9f 70       	andi	r25, 0x0F	; 15
    12d0:	89 81       	ldd	r24, Y+1	; 0x01
    12d2:	80 7f       	andi	r24, 0xF0	; 240
    12d4:	89 2b       	or	r24, r25
    12d6:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    12d8:	81 e0       	ldi	r24, 0x01	; 1
    12da:	90 e0       	ldi	r25, 0x00	; 0
    12dc:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    12e0:	ab e3       	ldi	r26, 0x3B	; 59
    12e2:	b0 e0       	ldi	r27, 0x00	; 0
    12e4:	eb e3       	ldi	r30, 0x3B	; 59
    12e6:	f0 e0       	ldi	r31, 0x00	; 0
    12e8:	80 81       	ld	r24, Z
    12ea:	87 7f       	andi	r24, 0xF7	; 247
    12ec:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12f6:	ab e3       	ldi	r26, 0x3B	; 59
    12f8:	b0 e0       	ldi	r27, 0x00	; 0
    12fa:	eb e3       	ldi	r30, 0x3B	; 59
    12fc:	f0 e0       	ldi	r31, 0x00	; 0
    12fe:	80 81       	ld	r24, Z
    1300:	88 60       	ori	r24, 0x08	; 8
    1302:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    130c:	ab e3       	ldi	r26, 0x3B	; 59
    130e:	b0 e0       	ldi	r27, 0x00	; 0
    1310:	eb e3       	ldi	r30, 0x3B	; 59
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	80 81       	ld	r24, Z
    1316:	28 2f       	mov	r18, r24
    1318:	2f 70       	andi	r18, 0x0F	; 15
    131a:	89 81       	ldd	r24, Y+1	; 0x01
    131c:	88 2f       	mov	r24, r24
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	82 95       	swap	r24
    1322:	92 95       	swap	r25
    1324:	90 7f       	andi	r25, 0xF0	; 240
    1326:	98 27       	eor	r25, r24
    1328:	80 7f       	andi	r24, 0xF0	; 240
    132a:	98 27       	eor	r25, r24
    132c:	82 2b       	or	r24, r18
    132e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1338:	ab e3       	ldi	r26, 0x3B	; 59
    133a:	b0 e0       	ldi	r27, 0x00	; 0
    133c:	eb e3       	ldi	r30, 0x3B	; 59
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	80 81       	ld	r24, Z
    1342:	87 7f       	andi	r24, 0xF7	; 247
    1344:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1346:	81 e0       	ldi	r24, 0x01	; 1
    1348:	90 e0       	ldi	r25, 0x00	; 0
    134a:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    134e:	0f 90       	pop	r0
    1350:	cf 91       	pop	r28
    1352:	df 91       	pop	r29
    1354:	08 95       	ret

00001356 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1356:	df 93       	push	r29
    1358:	cf 93       	push	r28
    135a:	00 d0       	rcall	.+0      	; 0x135c <LCD_displayString+0x6>
    135c:	0f 92       	push	r0
    135e:	cd b7       	in	r28, 0x3d	; 61
    1360:	de b7       	in	r29, 0x3e	; 62
    1362:	9b 83       	std	Y+3, r25	; 0x03
    1364:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1366:	19 82       	std	Y+1, r1	; 0x01
    1368:	0e c0       	rjmp	.+28     	; 0x1386 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    136a:	89 81       	ldd	r24, Y+1	; 0x01
    136c:	28 2f       	mov	r18, r24
    136e:	30 e0       	ldi	r19, 0x00	; 0
    1370:	8a 81       	ldd	r24, Y+2	; 0x02
    1372:	9b 81       	ldd	r25, Y+3	; 0x03
    1374:	fc 01       	movw	r30, r24
    1376:	e2 0f       	add	r30, r18
    1378:	f3 1f       	adc	r31, r19
    137a:	80 81       	ld	r24, Z
    137c:	0e 94 3e 09 	call	0x127c	; 0x127c <LCD_displayCharacter>
		i++;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	8f 5f       	subi	r24, 0xFF	; 255
    1384:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    1386:	89 81       	ldd	r24, Y+1	; 0x01
    1388:	28 2f       	mov	r18, r24
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	8a 81       	ldd	r24, Y+2	; 0x02
    138e:	9b 81       	ldd	r25, Y+3	; 0x03
    1390:	fc 01       	movw	r30, r24
    1392:	e2 0f       	add	r30, r18
    1394:	f3 1f       	adc	r31, r19
    1396:	80 81       	ld	r24, Z
    1398:	88 23       	and	r24, r24
    139a:	39 f7       	brne	.-50     	; 0x136a <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    139c:	0f 90       	pop	r0
    139e:	0f 90       	pop	r0
    13a0:	0f 90       	pop	r0
    13a2:	cf 91       	pop	r28
    13a4:	df 91       	pop	r29
    13a6:	08 95       	ret

000013a8 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    13a8:	df 93       	push	r29
    13aa:	cf 93       	push	r28
    13ac:	00 d0       	rcall	.+0      	; 0x13ae <LCD_goToRowColumn+0x6>
    13ae:	00 d0       	rcall	.+0      	; 0x13b0 <LCD_goToRowColumn+0x8>
    13b0:	0f 92       	push	r0
    13b2:	cd b7       	in	r28, 0x3d	; 61
    13b4:	de b7       	in	r29, 0x3e	; 62
    13b6:	8a 83       	std	Y+2, r24	; 0x02
    13b8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    13ba:	8a 81       	ldd	r24, Y+2	; 0x02
    13bc:	28 2f       	mov	r18, r24
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	3d 83       	std	Y+5, r19	; 0x05
    13c2:	2c 83       	std	Y+4, r18	; 0x04
    13c4:	8c 81       	ldd	r24, Y+4	; 0x04
    13c6:	9d 81       	ldd	r25, Y+5	; 0x05
    13c8:	81 30       	cpi	r24, 0x01	; 1
    13ca:	91 05       	cpc	r25, r1
    13cc:	c1 f0       	breq	.+48     	; 0x13fe <LCD_goToRowColumn+0x56>
    13ce:	2c 81       	ldd	r18, Y+4	; 0x04
    13d0:	3d 81       	ldd	r19, Y+5	; 0x05
    13d2:	22 30       	cpi	r18, 0x02	; 2
    13d4:	31 05       	cpc	r19, r1
    13d6:	2c f4       	brge	.+10     	; 0x13e2 <LCD_goToRowColumn+0x3a>
    13d8:	8c 81       	ldd	r24, Y+4	; 0x04
    13da:	9d 81       	ldd	r25, Y+5	; 0x05
    13dc:	00 97       	sbiw	r24, 0x00	; 0
    13de:	61 f0       	breq	.+24     	; 0x13f8 <LCD_goToRowColumn+0x50>
    13e0:	19 c0       	rjmp	.+50     	; 0x1414 <LCD_goToRowColumn+0x6c>
    13e2:	2c 81       	ldd	r18, Y+4	; 0x04
    13e4:	3d 81       	ldd	r19, Y+5	; 0x05
    13e6:	22 30       	cpi	r18, 0x02	; 2
    13e8:	31 05       	cpc	r19, r1
    13ea:	69 f0       	breq	.+26     	; 0x1406 <LCD_goToRowColumn+0x5e>
    13ec:	8c 81       	ldd	r24, Y+4	; 0x04
    13ee:	9d 81       	ldd	r25, Y+5	; 0x05
    13f0:	83 30       	cpi	r24, 0x03	; 3
    13f2:	91 05       	cpc	r25, r1
    13f4:	61 f0       	breq	.+24     	; 0x140e <LCD_goToRowColumn+0x66>
    13f6:	0e c0       	rjmp	.+28     	; 0x1414 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    13f8:	8b 81       	ldd	r24, Y+3	; 0x03
    13fa:	89 83       	std	Y+1, r24	; 0x01
    13fc:	0b c0       	rjmp	.+22     	; 0x1414 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    13fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1400:	80 5c       	subi	r24, 0xC0	; 192
    1402:	89 83       	std	Y+1, r24	; 0x01
    1404:	07 c0       	rjmp	.+14     	; 0x1414 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	80 5f       	subi	r24, 0xF0	; 240
    140a:	89 83       	std	Y+1, r24	; 0x01
    140c:	03 c0       	rjmp	.+6      	; 0x1414 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    140e:	8b 81       	ldd	r24, Y+3	; 0x03
    1410:	80 5b       	subi	r24, 0xB0	; 176
    1412:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	80 68       	ori	r24, 0x80	; 128
    1418:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>
}
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	0f 90       	pop	r0
    1422:	0f 90       	pop	r0
    1424:	0f 90       	pop	r0
    1426:	cf 91       	pop	r28
    1428:	df 91       	pop	r29
    142a:	08 95       	ret

0000142c <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	00 d0       	rcall	.+0      	; 0x1432 <LCD_displayStringRowColumn+0x6>
    1432:	00 d0       	rcall	.+0      	; 0x1434 <LCD_displayStringRowColumn+0x8>
    1434:	cd b7       	in	r28, 0x3d	; 61
    1436:	de b7       	in	r29, 0x3e	; 62
    1438:	89 83       	std	Y+1, r24	; 0x01
    143a:	6a 83       	std	Y+2, r22	; 0x02
    143c:	5c 83       	std	Y+4, r21	; 0x04
    143e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1440:	89 81       	ldd	r24, Y+1	; 0x01
    1442:	6a 81       	ldd	r22, Y+2	; 0x02
    1444:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1448:	8b 81       	ldd	r24, Y+3	; 0x03
    144a:	9c 81       	ldd	r25, Y+4	; 0x04
    144c:	0e 94 ab 09 	call	0x1356	; 0x1356 <LCD_displayString>
}
    1450:	0f 90       	pop	r0
    1452:	0f 90       	pop	r0
    1454:	0f 90       	pop	r0
    1456:	0f 90       	pop	r0
    1458:	cf 91       	pop	r28
    145a:	df 91       	pop	r29
    145c:	08 95       	ret

0000145e <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    145e:	df 93       	push	r29
    1460:	cf 93       	push	r28
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <LCD_sendCommand>
}
    146c:	cf 91       	pop	r28
    146e:	df 91       	pop	r29
    1470:	08 95       	ret

00001472 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1472:	df 93       	push	r29
    1474:	cf 93       	push	r28
    1476:	00 d0       	rcall	.+0      	; 0x1478 <vListInitialise+0x6>
    1478:	cd b7       	in	r28, 0x3d	; 61
    147a:	de b7       	in	r29, 0x3e	; 62
    147c:	9a 83       	std	Y+2, r25	; 0x02
    147e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	9a 81       	ldd	r25, Y+2	; 0x02
    1484:	03 96       	adiw	r24, 0x03	; 3
    1486:	e9 81       	ldd	r30, Y+1	; 0x01
    1488:	fa 81       	ldd	r31, Y+2	; 0x02
    148a:	92 83       	std	Z+2, r25	; 0x02
    148c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    148e:	e9 81       	ldd	r30, Y+1	; 0x01
    1490:	fa 81       	ldd	r31, Y+2	; 0x02
    1492:	8f ef       	ldi	r24, 0xFF	; 255
    1494:	9f ef       	ldi	r25, 0xFF	; 255
    1496:	94 83       	std	Z+4, r25	; 0x04
    1498:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    149a:	89 81       	ldd	r24, Y+1	; 0x01
    149c:	9a 81       	ldd	r25, Y+2	; 0x02
    149e:	03 96       	adiw	r24, 0x03	; 3
    14a0:	e9 81       	ldd	r30, Y+1	; 0x01
    14a2:	fa 81       	ldd	r31, Y+2	; 0x02
    14a4:	96 83       	std	Z+6, r25	; 0x06
    14a6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14a8:	89 81       	ldd	r24, Y+1	; 0x01
    14aa:	9a 81       	ldd	r25, Y+2	; 0x02
    14ac:	03 96       	adiw	r24, 0x03	; 3
    14ae:	e9 81       	ldd	r30, Y+1	; 0x01
    14b0:	fa 81       	ldd	r31, Y+2	; 0x02
    14b2:	90 87       	std	Z+8, r25	; 0x08
    14b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    14b6:	e9 81       	ldd	r30, Y+1	; 0x01
    14b8:	fa 81       	ldd	r31, Y+2	; 0x02
    14ba:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    14bc:	0f 90       	pop	r0
    14be:	0f 90       	pop	r0
    14c0:	cf 91       	pop	r28
    14c2:	df 91       	pop	r29
    14c4:	08 95       	ret

000014c6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    14c6:	df 93       	push	r29
    14c8:	cf 93       	push	r28
    14ca:	00 d0       	rcall	.+0      	; 0x14cc <vListInitialiseItem+0x6>
    14cc:	cd b7       	in	r28, 0x3d	; 61
    14ce:	de b7       	in	r29, 0x3e	; 62
    14d0:	9a 83       	std	Y+2, r25	; 0x02
    14d2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    14d4:	e9 81       	ldd	r30, Y+1	; 0x01
    14d6:	fa 81       	ldd	r31, Y+2	; 0x02
    14d8:	11 86       	std	Z+9, r1	; 0x09
    14da:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    14dc:	0f 90       	pop	r0
    14de:	0f 90       	pop	r0
    14e0:	cf 91       	pop	r28
    14e2:	df 91       	pop	r29
    14e4:	08 95       	ret

000014e6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    14e6:	df 93       	push	r29
    14e8:	cf 93       	push	r28
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <vListInsertEnd+0x6>
    14ec:	00 d0       	rcall	.+0      	; 0x14ee <vListInsertEnd+0x8>
    14ee:	00 d0       	rcall	.+0      	; 0x14f0 <vListInsertEnd+0xa>
    14f0:	cd b7       	in	r28, 0x3d	; 61
    14f2:	de b7       	in	r29, 0x3e	; 62
    14f4:	9c 83       	std	Y+4, r25	; 0x04
    14f6:	8b 83       	std	Y+3, r24	; 0x03
    14f8:	7e 83       	std	Y+6, r23	; 0x06
    14fa:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    14fc:	eb 81       	ldd	r30, Y+3	; 0x03
    14fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1500:	81 81       	ldd	r24, Z+1	; 0x01
    1502:	92 81       	ldd	r25, Z+2	; 0x02
    1504:	9a 83       	std	Y+2, r25	; 0x02
    1506:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1508:	ed 81       	ldd	r30, Y+5	; 0x05
    150a:	fe 81       	ldd	r31, Y+6	; 0x06
    150c:	89 81       	ldd	r24, Y+1	; 0x01
    150e:	9a 81       	ldd	r25, Y+2	; 0x02
    1510:	93 83       	std	Z+3, r25	; 0x03
    1512:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1514:	e9 81       	ldd	r30, Y+1	; 0x01
    1516:	fa 81       	ldd	r31, Y+2	; 0x02
    1518:	84 81       	ldd	r24, Z+4	; 0x04
    151a:	95 81       	ldd	r25, Z+5	; 0x05
    151c:	ed 81       	ldd	r30, Y+5	; 0x05
    151e:	fe 81       	ldd	r31, Y+6	; 0x06
    1520:	95 83       	std	Z+5, r25	; 0x05
    1522:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1524:	e9 81       	ldd	r30, Y+1	; 0x01
    1526:	fa 81       	ldd	r31, Y+2	; 0x02
    1528:	04 80       	ldd	r0, Z+4	; 0x04
    152a:	f5 81       	ldd	r31, Z+5	; 0x05
    152c:	e0 2d       	mov	r30, r0
    152e:	8d 81       	ldd	r24, Y+5	; 0x05
    1530:	9e 81       	ldd	r25, Y+6	; 0x06
    1532:	93 83       	std	Z+3, r25	; 0x03
    1534:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1536:	e9 81       	ldd	r30, Y+1	; 0x01
    1538:	fa 81       	ldd	r31, Y+2	; 0x02
    153a:	8d 81       	ldd	r24, Y+5	; 0x05
    153c:	9e 81       	ldd	r25, Y+6	; 0x06
    153e:	95 83       	std	Z+5, r25	; 0x05
    1540:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1542:	ed 81       	ldd	r30, Y+5	; 0x05
    1544:	fe 81       	ldd	r31, Y+6	; 0x06
    1546:	8b 81       	ldd	r24, Y+3	; 0x03
    1548:	9c 81       	ldd	r25, Y+4	; 0x04
    154a:	91 87       	std	Z+9, r25	; 0x09
    154c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    154e:	eb 81       	ldd	r30, Y+3	; 0x03
    1550:	fc 81       	ldd	r31, Y+4	; 0x04
    1552:	80 81       	ld	r24, Z
    1554:	8f 5f       	subi	r24, 0xFF	; 255
    1556:	eb 81       	ldd	r30, Y+3	; 0x03
    1558:	fc 81       	ldd	r31, Y+4	; 0x04
    155a:	80 83       	st	Z, r24
}
    155c:	26 96       	adiw	r28, 0x06	; 6
    155e:	0f b6       	in	r0, 0x3f	; 63
    1560:	f8 94       	cli
    1562:	de bf       	out	0x3e, r29	; 62
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	cd bf       	out	0x3d, r28	; 61
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	08 95       	ret

0000156e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    156e:	df 93       	push	r29
    1570:	cf 93       	push	r28
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
    1576:	28 97       	sbiw	r28, 0x08	; 8
    1578:	0f b6       	in	r0, 0x3f	; 63
    157a:	f8 94       	cli
    157c:	de bf       	out	0x3e, r29	; 62
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	cd bf       	out	0x3d, r28	; 61
    1582:	9e 83       	std	Y+6, r25	; 0x06
    1584:	8d 83       	std	Y+5, r24	; 0x05
    1586:	78 87       	std	Y+8, r23	; 0x08
    1588:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    158a:	ef 81       	ldd	r30, Y+7	; 0x07
    158c:	f8 85       	ldd	r31, Y+8	; 0x08
    158e:	80 81       	ld	r24, Z
    1590:	91 81       	ldd	r25, Z+1	; 0x01
    1592:	9a 83       	std	Y+2, r25	; 0x02
    1594:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1596:	89 81       	ldd	r24, Y+1	; 0x01
    1598:	9a 81       	ldd	r25, Y+2	; 0x02
    159a:	2f ef       	ldi	r18, 0xFF	; 255
    159c:	8f 3f       	cpi	r24, 0xFF	; 255
    159e:	92 07       	cpc	r25, r18
    15a0:	39 f4       	brne	.+14     	; 0x15b0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15a2:	ed 81       	ldd	r30, Y+5	; 0x05
    15a4:	fe 81       	ldd	r31, Y+6	; 0x06
    15a6:	87 81       	ldd	r24, Z+7	; 0x07
    15a8:	90 85       	ldd	r25, Z+8	; 0x08
    15aa:	9c 83       	std	Y+4, r25	; 0x04
    15ac:	8b 83       	std	Y+3, r24	; 0x03
    15ae:	18 c0       	rjmp	.+48     	; 0x15e0 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    15b0:	8d 81       	ldd	r24, Y+5	; 0x05
    15b2:	9e 81       	ldd	r25, Y+6	; 0x06
    15b4:	03 96       	adiw	r24, 0x03	; 3
    15b6:	9c 83       	std	Y+4, r25	; 0x04
    15b8:	8b 83       	std	Y+3, r24	; 0x03
    15ba:	06 c0       	rjmp	.+12     	; 0x15c8 <vListInsert+0x5a>
    15bc:	eb 81       	ldd	r30, Y+3	; 0x03
    15be:	fc 81       	ldd	r31, Y+4	; 0x04
    15c0:	82 81       	ldd	r24, Z+2	; 0x02
    15c2:	93 81       	ldd	r25, Z+3	; 0x03
    15c4:	9c 83       	std	Y+4, r25	; 0x04
    15c6:	8b 83       	std	Y+3, r24	; 0x03
    15c8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ca:	fc 81       	ldd	r31, Y+4	; 0x04
    15cc:	02 80       	ldd	r0, Z+2	; 0x02
    15ce:	f3 81       	ldd	r31, Z+3	; 0x03
    15d0:	e0 2d       	mov	r30, r0
    15d2:	20 81       	ld	r18, Z
    15d4:	31 81       	ldd	r19, Z+1	; 0x01
    15d6:	89 81       	ldd	r24, Y+1	; 0x01
    15d8:	9a 81       	ldd	r25, Y+2	; 0x02
    15da:	82 17       	cp	r24, r18
    15dc:	93 07       	cpc	r25, r19
    15de:	70 f7       	brcc	.-36     	; 0x15bc <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15e0:	eb 81       	ldd	r30, Y+3	; 0x03
    15e2:	fc 81       	ldd	r31, Y+4	; 0x04
    15e4:	82 81       	ldd	r24, Z+2	; 0x02
    15e6:	93 81       	ldd	r25, Z+3	; 0x03
    15e8:	ef 81       	ldd	r30, Y+7	; 0x07
    15ea:	f8 85       	ldd	r31, Y+8	; 0x08
    15ec:	93 83       	std	Z+3, r25	; 0x03
    15ee:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    15f0:	ef 81       	ldd	r30, Y+7	; 0x07
    15f2:	f8 85       	ldd	r31, Y+8	; 0x08
    15f4:	02 80       	ldd	r0, Z+2	; 0x02
    15f6:	f3 81       	ldd	r31, Z+3	; 0x03
    15f8:	e0 2d       	mov	r30, r0
    15fa:	8f 81       	ldd	r24, Y+7	; 0x07
    15fc:	98 85       	ldd	r25, Y+8	; 0x08
    15fe:	95 83       	std	Z+5, r25	; 0x05
    1600:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1602:	ef 81       	ldd	r30, Y+7	; 0x07
    1604:	f8 85       	ldd	r31, Y+8	; 0x08
    1606:	8b 81       	ldd	r24, Y+3	; 0x03
    1608:	9c 81       	ldd	r25, Y+4	; 0x04
    160a:	95 83       	std	Z+5, r25	; 0x05
    160c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    160e:	eb 81       	ldd	r30, Y+3	; 0x03
    1610:	fc 81       	ldd	r31, Y+4	; 0x04
    1612:	8f 81       	ldd	r24, Y+7	; 0x07
    1614:	98 85       	ldd	r25, Y+8	; 0x08
    1616:	93 83       	std	Z+3, r25	; 0x03
    1618:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    161a:	ef 81       	ldd	r30, Y+7	; 0x07
    161c:	f8 85       	ldd	r31, Y+8	; 0x08
    161e:	8d 81       	ldd	r24, Y+5	; 0x05
    1620:	9e 81       	ldd	r25, Y+6	; 0x06
    1622:	91 87       	std	Z+9, r25	; 0x09
    1624:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1626:	ed 81       	ldd	r30, Y+5	; 0x05
    1628:	fe 81       	ldd	r31, Y+6	; 0x06
    162a:	80 81       	ld	r24, Z
    162c:	8f 5f       	subi	r24, 0xFF	; 255
    162e:	ed 81       	ldd	r30, Y+5	; 0x05
    1630:	fe 81       	ldd	r31, Y+6	; 0x06
    1632:	80 83       	st	Z, r24
}
    1634:	28 96       	adiw	r28, 0x08	; 8
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	de bf       	out	0x3e, r29	; 62
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	cd bf       	out	0x3d, r28	; 61
    1640:	cf 91       	pop	r28
    1642:	df 91       	pop	r29
    1644:	08 95       	ret

00001646 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1646:	df 93       	push	r29
    1648:	cf 93       	push	r28
    164a:	00 d0       	rcall	.+0      	; 0x164c <uxListRemove+0x6>
    164c:	00 d0       	rcall	.+0      	; 0x164e <uxListRemove+0x8>
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
    1652:	9c 83       	std	Y+4, r25	; 0x04
    1654:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1656:	eb 81       	ldd	r30, Y+3	; 0x03
    1658:	fc 81       	ldd	r31, Y+4	; 0x04
    165a:	80 85       	ldd	r24, Z+8	; 0x08
    165c:	91 85       	ldd	r25, Z+9	; 0x09
    165e:	9a 83       	std	Y+2, r25	; 0x02
    1660:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1662:	eb 81       	ldd	r30, Y+3	; 0x03
    1664:	fc 81       	ldd	r31, Y+4	; 0x04
    1666:	a2 81       	ldd	r26, Z+2	; 0x02
    1668:	b3 81       	ldd	r27, Z+3	; 0x03
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	84 81       	ldd	r24, Z+4	; 0x04
    1670:	95 81       	ldd	r25, Z+5	; 0x05
    1672:	15 96       	adiw	r26, 0x05	; 5
    1674:	9c 93       	st	X, r25
    1676:	8e 93       	st	-X, r24
    1678:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    167a:	eb 81       	ldd	r30, Y+3	; 0x03
    167c:	fc 81       	ldd	r31, Y+4	; 0x04
    167e:	a4 81       	ldd	r26, Z+4	; 0x04
    1680:	b5 81       	ldd	r27, Z+5	; 0x05
    1682:	eb 81       	ldd	r30, Y+3	; 0x03
    1684:	fc 81       	ldd	r31, Y+4	; 0x04
    1686:	82 81       	ldd	r24, Z+2	; 0x02
    1688:	93 81       	ldd	r25, Z+3	; 0x03
    168a:	13 96       	adiw	r26, 0x03	; 3
    168c:	9c 93       	st	X, r25
    168e:	8e 93       	st	-X, r24
    1690:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	21 81       	ldd	r18, Z+1	; 0x01
    1698:	32 81       	ldd	r19, Z+2	; 0x02
    169a:	8b 81       	ldd	r24, Y+3	; 0x03
    169c:	9c 81       	ldd	r25, Y+4	; 0x04
    169e:	28 17       	cp	r18, r24
    16a0:	39 07       	cpc	r19, r25
    16a2:	41 f4       	brne	.+16     	; 0x16b4 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    16a4:	eb 81       	ldd	r30, Y+3	; 0x03
    16a6:	fc 81       	ldd	r31, Y+4	; 0x04
    16a8:	84 81       	ldd	r24, Z+4	; 0x04
    16aa:	95 81       	ldd	r25, Z+5	; 0x05
    16ac:	e9 81       	ldd	r30, Y+1	; 0x01
    16ae:	fa 81       	ldd	r31, Y+2	; 0x02
    16b0:	92 83       	std	Z+2, r25	; 0x02
    16b2:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    16b4:	eb 81       	ldd	r30, Y+3	; 0x03
    16b6:	fc 81       	ldd	r31, Y+4	; 0x04
    16b8:	11 86       	std	Z+9, r1	; 0x09
    16ba:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    16bc:	e9 81       	ldd	r30, Y+1	; 0x01
    16be:	fa 81       	ldd	r31, Y+2	; 0x02
    16c0:	80 81       	ld	r24, Z
    16c2:	81 50       	subi	r24, 0x01	; 1
    16c4:	e9 81       	ldd	r30, Y+1	; 0x01
    16c6:	fa 81       	ldd	r31, Y+2	; 0x02
    16c8:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    16ca:	e9 81       	ldd	r30, Y+1	; 0x01
    16cc:	fa 81       	ldd	r31, Y+2	; 0x02
    16ce:	80 81       	ld	r24, Z
}
    16d0:	0f 90       	pop	r0
    16d2:	0f 90       	pop	r0
    16d4:	0f 90       	pop	r0
    16d6:	0f 90       	pop	r0
    16d8:	cf 91       	pop	r28
    16da:	df 91       	pop	r29
    16dc:	08 95       	ret

000016de <main>:

#include "UserTasks.h"


void main(void)
{
    16de:	ef 92       	push	r14
    16e0:	ff 92       	push	r15
    16e2:	0f 93       	push	r16
    16e4:	df 93       	push	r29
    16e6:	cf 93       	push	r28
    16e8:	cd b7       	in	r28, 0x3d	; 61
    16ea:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    16ec:	89 e9       	ldi	r24, 0x99	; 153
    16ee:	92 e0       	ldi	r25, 0x02	; 2
    16f0:	27 e9       	ldi	r18, 0x97	; 151
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	ec ea       	ldi	r30, 0xAC	; 172
    16f6:	f0 e0       	ldi	r31, 0x00	; 0
    16f8:	b9 01       	movw	r22, r18
    16fa:	45 e5       	ldi	r20, 0x55	; 85
    16fc:	50 e0       	ldi	r21, 0x00	; 0
    16fe:	20 e0       	ldi	r18, 0x00	; 0
    1700:	30 e0       	ldi	r19, 0x00	; 0
    1702:	03 e0       	ldi	r16, 0x03	; 3
    1704:	7f 01       	movw	r14, r30
    1706:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , &InitTask_Flag);


	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    170a:	8c e0       	ldi	r24, 0x0C	; 12
    170c:	61 e0       	ldi	r22, 0x01	; 1
    170e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

	vTaskStartScheduler();
    1712:	0e 94 c3 20 	call	0x4186	; 0x4186 <vTaskStartScheduler>
    1716:	ff cf       	rjmp	.-2      	; 0x1716 <main+0x38>

00001718 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	28 97       	sbiw	r28, 0x08	; 8
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	9c 83       	std	Y+4, r25	; 0x04
    172e:	8b 83       	std	Y+3, r24	; 0x03
    1730:	7e 83       	std	Y+6, r23	; 0x06
    1732:	6d 83       	std	Y+5, r22	; 0x05
    1734:	58 87       	std	Y+8, r21	; 0x08
    1736:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1738:	eb 81       	ldd	r30, Y+3	; 0x03
    173a:	fc 81       	ldd	r31, Y+4	; 0x04
    173c:	81 e1       	ldi	r24, 0x11	; 17
    173e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1740:	8b 81       	ldd	r24, Y+3	; 0x03
    1742:	9c 81       	ldd	r25, Y+4	; 0x04
    1744:	01 97       	sbiw	r24, 0x01	; 1
    1746:	9c 83       	std	Y+4, r25	; 0x04
    1748:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    174a:	eb 81       	ldd	r30, Y+3	; 0x03
    174c:	fc 81       	ldd	r31, Y+4	; 0x04
    174e:	82 e2       	ldi	r24, 0x22	; 34
    1750:	80 83       	st	Z, r24
	pxTopOfStack--;
    1752:	8b 81       	ldd	r24, Y+3	; 0x03
    1754:	9c 81       	ldd	r25, Y+4	; 0x04
    1756:	01 97       	sbiw	r24, 0x01	; 1
    1758:	9c 83       	std	Y+4, r25	; 0x04
    175a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    175c:	eb 81       	ldd	r30, Y+3	; 0x03
    175e:	fc 81       	ldd	r31, Y+4	; 0x04
    1760:	83 e3       	ldi	r24, 0x33	; 51
    1762:	80 83       	st	Z, r24
	pxTopOfStack--;
    1764:	8b 81       	ldd	r24, Y+3	; 0x03
    1766:	9c 81       	ldd	r25, Y+4	; 0x04
    1768:	01 97       	sbiw	r24, 0x01	; 1
    176a:	9c 83       	std	Y+4, r25	; 0x04
    176c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    176e:	8d 81       	ldd	r24, Y+5	; 0x05
    1770:	9e 81       	ldd	r25, Y+6	; 0x06
    1772:	9a 83       	std	Y+2, r25	; 0x02
    1774:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1776:	89 81       	ldd	r24, Y+1	; 0x01
    1778:	eb 81       	ldd	r30, Y+3	; 0x03
    177a:	fc 81       	ldd	r31, Y+4	; 0x04
    177c:	80 83       	st	Z, r24
	pxTopOfStack--;
    177e:	8b 81       	ldd	r24, Y+3	; 0x03
    1780:	9c 81       	ldd	r25, Y+4	; 0x04
    1782:	01 97       	sbiw	r24, 0x01	; 1
    1784:	9c 83       	std	Y+4, r25	; 0x04
    1786:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1788:	89 81       	ldd	r24, Y+1	; 0x01
    178a:	9a 81       	ldd	r25, Y+2	; 0x02
    178c:	89 2f       	mov	r24, r25
    178e:	99 27       	eor	r25, r25
    1790:	9a 83       	std	Y+2, r25	; 0x02
    1792:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1794:	89 81       	ldd	r24, Y+1	; 0x01
    1796:	eb 81       	ldd	r30, Y+3	; 0x03
    1798:	fc 81       	ldd	r31, Y+4	; 0x04
    179a:	80 83       	st	Z, r24
	pxTopOfStack--;
    179c:	8b 81       	ldd	r24, Y+3	; 0x03
    179e:	9c 81       	ldd	r25, Y+4	; 0x04
    17a0:	01 97       	sbiw	r24, 0x01	; 1
    17a2:	9c 83       	std	Y+4, r25	; 0x04
    17a4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    17a6:	eb 81       	ldd	r30, Y+3	; 0x03
    17a8:	fc 81       	ldd	r31, Y+4	; 0x04
    17aa:	10 82       	st	Z, r1
	pxTopOfStack--;
    17ac:	8b 81       	ldd	r24, Y+3	; 0x03
    17ae:	9c 81       	ldd	r25, Y+4	; 0x04
    17b0:	01 97       	sbiw	r24, 0x01	; 1
    17b2:	9c 83       	std	Y+4, r25	; 0x04
    17b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17b6:	eb 81       	ldd	r30, Y+3	; 0x03
    17b8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ba:	80 e8       	ldi	r24, 0x80	; 128
    17bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    17be:	8b 81       	ldd	r24, Y+3	; 0x03
    17c0:	9c 81       	ldd	r25, Y+4	; 0x04
    17c2:	01 97       	sbiw	r24, 0x01	; 1
    17c4:	9c 83       	std	Y+4, r25	; 0x04
    17c6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    17c8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ca:	fc 81       	ldd	r31, Y+4	; 0x04
    17cc:	10 82       	st	Z, r1
	pxTopOfStack--;
    17ce:	8b 81       	ldd	r24, Y+3	; 0x03
    17d0:	9c 81       	ldd	r25, Y+4	; 0x04
    17d2:	01 97       	sbiw	r24, 0x01	; 1
    17d4:	9c 83       	std	Y+4, r25	; 0x04
    17d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    17d8:	eb 81       	ldd	r30, Y+3	; 0x03
    17da:	fc 81       	ldd	r31, Y+4	; 0x04
    17dc:	82 e0       	ldi	r24, 0x02	; 2
    17de:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e0:	8b 81       	ldd	r24, Y+3	; 0x03
    17e2:	9c 81       	ldd	r25, Y+4	; 0x04
    17e4:	01 97       	sbiw	r24, 0x01	; 1
    17e6:	9c 83       	std	Y+4, r25	; 0x04
    17e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    17ea:	eb 81       	ldd	r30, Y+3	; 0x03
    17ec:	fc 81       	ldd	r31, Y+4	; 0x04
    17ee:	83 e0       	ldi	r24, 0x03	; 3
    17f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f2:	8b 81       	ldd	r24, Y+3	; 0x03
    17f4:	9c 81       	ldd	r25, Y+4	; 0x04
    17f6:	01 97       	sbiw	r24, 0x01	; 1
    17f8:	9c 83       	std	Y+4, r25	; 0x04
    17fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    17fc:	eb 81       	ldd	r30, Y+3	; 0x03
    17fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1800:	84 e0       	ldi	r24, 0x04	; 4
    1802:	80 83       	st	Z, r24
	pxTopOfStack--;
    1804:	8b 81       	ldd	r24, Y+3	; 0x03
    1806:	9c 81       	ldd	r25, Y+4	; 0x04
    1808:	01 97       	sbiw	r24, 0x01	; 1
    180a:	9c 83       	std	Y+4, r25	; 0x04
    180c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    180e:	eb 81       	ldd	r30, Y+3	; 0x03
    1810:	fc 81       	ldd	r31, Y+4	; 0x04
    1812:	85 e0       	ldi	r24, 0x05	; 5
    1814:	80 83       	st	Z, r24
	pxTopOfStack--;
    1816:	8b 81       	ldd	r24, Y+3	; 0x03
    1818:	9c 81       	ldd	r25, Y+4	; 0x04
    181a:	01 97       	sbiw	r24, 0x01	; 1
    181c:	9c 83       	std	Y+4, r25	; 0x04
    181e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1820:	eb 81       	ldd	r30, Y+3	; 0x03
    1822:	fc 81       	ldd	r31, Y+4	; 0x04
    1824:	86 e0       	ldi	r24, 0x06	; 6
    1826:	80 83       	st	Z, r24
	pxTopOfStack--;
    1828:	8b 81       	ldd	r24, Y+3	; 0x03
    182a:	9c 81       	ldd	r25, Y+4	; 0x04
    182c:	01 97       	sbiw	r24, 0x01	; 1
    182e:	9c 83       	std	Y+4, r25	; 0x04
    1830:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1832:	eb 81       	ldd	r30, Y+3	; 0x03
    1834:	fc 81       	ldd	r31, Y+4	; 0x04
    1836:	87 e0       	ldi	r24, 0x07	; 7
    1838:	80 83       	st	Z, r24
	pxTopOfStack--;
    183a:	8b 81       	ldd	r24, Y+3	; 0x03
    183c:	9c 81       	ldd	r25, Y+4	; 0x04
    183e:	01 97       	sbiw	r24, 0x01	; 1
    1840:	9c 83       	std	Y+4, r25	; 0x04
    1842:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1844:	eb 81       	ldd	r30, Y+3	; 0x03
    1846:	fc 81       	ldd	r31, Y+4	; 0x04
    1848:	88 e0       	ldi	r24, 0x08	; 8
    184a:	80 83       	st	Z, r24
	pxTopOfStack--;
    184c:	8b 81       	ldd	r24, Y+3	; 0x03
    184e:	9c 81       	ldd	r25, Y+4	; 0x04
    1850:	01 97       	sbiw	r24, 0x01	; 1
    1852:	9c 83       	std	Y+4, r25	; 0x04
    1854:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1856:	eb 81       	ldd	r30, Y+3	; 0x03
    1858:	fc 81       	ldd	r31, Y+4	; 0x04
    185a:	89 e0       	ldi	r24, 0x09	; 9
    185c:	80 83       	st	Z, r24
	pxTopOfStack--;
    185e:	8b 81       	ldd	r24, Y+3	; 0x03
    1860:	9c 81       	ldd	r25, Y+4	; 0x04
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	9c 83       	std	Y+4, r25	; 0x04
    1866:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1868:	eb 81       	ldd	r30, Y+3	; 0x03
    186a:	fc 81       	ldd	r31, Y+4	; 0x04
    186c:	80 e1       	ldi	r24, 0x10	; 16
    186e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1870:	8b 81       	ldd	r24, Y+3	; 0x03
    1872:	9c 81       	ldd	r25, Y+4	; 0x04
    1874:	01 97       	sbiw	r24, 0x01	; 1
    1876:	9c 83       	std	Y+4, r25	; 0x04
    1878:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    187a:	eb 81       	ldd	r30, Y+3	; 0x03
    187c:	fc 81       	ldd	r31, Y+4	; 0x04
    187e:	81 e1       	ldi	r24, 0x11	; 17
    1880:	80 83       	st	Z, r24
	pxTopOfStack--;
    1882:	8b 81       	ldd	r24, Y+3	; 0x03
    1884:	9c 81       	ldd	r25, Y+4	; 0x04
    1886:	01 97       	sbiw	r24, 0x01	; 1
    1888:	9c 83       	std	Y+4, r25	; 0x04
    188a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    188c:	eb 81       	ldd	r30, Y+3	; 0x03
    188e:	fc 81       	ldd	r31, Y+4	; 0x04
    1890:	82 e1       	ldi	r24, 0x12	; 18
    1892:	80 83       	st	Z, r24
	pxTopOfStack--;
    1894:	8b 81       	ldd	r24, Y+3	; 0x03
    1896:	9c 81       	ldd	r25, Y+4	; 0x04
    1898:	01 97       	sbiw	r24, 0x01	; 1
    189a:	9c 83       	std	Y+4, r25	; 0x04
    189c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    189e:	eb 81       	ldd	r30, Y+3	; 0x03
    18a0:	fc 81       	ldd	r31, Y+4	; 0x04
    18a2:	83 e1       	ldi	r24, 0x13	; 19
    18a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	01 97       	sbiw	r24, 0x01	; 1
    18ac:	9c 83       	std	Y+4, r25	; 0x04
    18ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    18b0:	eb 81       	ldd	r30, Y+3	; 0x03
    18b2:	fc 81       	ldd	r31, Y+4	; 0x04
    18b4:	84 e1       	ldi	r24, 0x14	; 20
    18b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18b8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ba:	9c 81       	ldd	r25, Y+4	; 0x04
    18bc:	01 97       	sbiw	r24, 0x01	; 1
    18be:	9c 83       	std	Y+4, r25	; 0x04
    18c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    18c2:	eb 81       	ldd	r30, Y+3	; 0x03
    18c4:	fc 81       	ldd	r31, Y+4	; 0x04
    18c6:	85 e1       	ldi	r24, 0x15	; 21
    18c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ca:	8b 81       	ldd	r24, Y+3	; 0x03
    18cc:	9c 81       	ldd	r25, Y+4	; 0x04
    18ce:	01 97       	sbiw	r24, 0x01	; 1
    18d0:	9c 83       	std	Y+4, r25	; 0x04
    18d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    18d4:	eb 81       	ldd	r30, Y+3	; 0x03
    18d6:	fc 81       	ldd	r31, Y+4	; 0x04
    18d8:	86 e1       	ldi	r24, 0x16	; 22
    18da:	80 83       	st	Z, r24
	pxTopOfStack--;
    18dc:	8b 81       	ldd	r24, Y+3	; 0x03
    18de:	9c 81       	ldd	r25, Y+4	; 0x04
    18e0:	01 97       	sbiw	r24, 0x01	; 1
    18e2:	9c 83       	std	Y+4, r25	; 0x04
    18e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    18e6:	eb 81       	ldd	r30, Y+3	; 0x03
    18e8:	fc 81       	ldd	r31, Y+4	; 0x04
    18ea:	87 e1       	ldi	r24, 0x17	; 23
    18ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ee:	8b 81       	ldd	r24, Y+3	; 0x03
    18f0:	9c 81       	ldd	r25, Y+4	; 0x04
    18f2:	01 97       	sbiw	r24, 0x01	; 1
    18f4:	9c 83       	std	Y+4, r25	; 0x04
    18f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    18f8:	eb 81       	ldd	r30, Y+3	; 0x03
    18fa:	fc 81       	ldd	r31, Y+4	; 0x04
    18fc:	88 e1       	ldi	r24, 0x18	; 24
    18fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1900:	8b 81       	ldd	r24, Y+3	; 0x03
    1902:	9c 81       	ldd	r25, Y+4	; 0x04
    1904:	01 97       	sbiw	r24, 0x01	; 1
    1906:	9c 83       	std	Y+4, r25	; 0x04
    1908:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    190a:	eb 81       	ldd	r30, Y+3	; 0x03
    190c:	fc 81       	ldd	r31, Y+4	; 0x04
    190e:	89 e1       	ldi	r24, 0x19	; 25
    1910:	80 83       	st	Z, r24
	pxTopOfStack--;
    1912:	8b 81       	ldd	r24, Y+3	; 0x03
    1914:	9c 81       	ldd	r25, Y+4	; 0x04
    1916:	01 97       	sbiw	r24, 0x01	; 1
    1918:	9c 83       	std	Y+4, r25	; 0x04
    191a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    191c:	eb 81       	ldd	r30, Y+3	; 0x03
    191e:	fc 81       	ldd	r31, Y+4	; 0x04
    1920:	80 e2       	ldi	r24, 0x20	; 32
    1922:	80 83       	st	Z, r24
	pxTopOfStack--;
    1924:	8b 81       	ldd	r24, Y+3	; 0x03
    1926:	9c 81       	ldd	r25, Y+4	; 0x04
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	9c 83       	std	Y+4, r25	; 0x04
    192c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    192e:	eb 81       	ldd	r30, Y+3	; 0x03
    1930:	fc 81       	ldd	r31, Y+4	; 0x04
    1932:	81 e2       	ldi	r24, 0x21	; 33
    1934:	80 83       	st	Z, r24
	pxTopOfStack--;
    1936:	8b 81       	ldd	r24, Y+3	; 0x03
    1938:	9c 81       	ldd	r25, Y+4	; 0x04
    193a:	01 97       	sbiw	r24, 0x01	; 1
    193c:	9c 83       	std	Y+4, r25	; 0x04
    193e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1940:	eb 81       	ldd	r30, Y+3	; 0x03
    1942:	fc 81       	ldd	r31, Y+4	; 0x04
    1944:	82 e2       	ldi	r24, 0x22	; 34
    1946:	80 83       	st	Z, r24
	pxTopOfStack--;
    1948:	8b 81       	ldd	r24, Y+3	; 0x03
    194a:	9c 81       	ldd	r25, Y+4	; 0x04
    194c:	01 97       	sbiw	r24, 0x01	; 1
    194e:	9c 83       	std	Y+4, r25	; 0x04
    1950:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1952:	eb 81       	ldd	r30, Y+3	; 0x03
    1954:	fc 81       	ldd	r31, Y+4	; 0x04
    1956:	83 e2       	ldi	r24, 0x23	; 35
    1958:	80 83       	st	Z, r24
	pxTopOfStack--;
    195a:	8b 81       	ldd	r24, Y+3	; 0x03
    195c:	9c 81       	ldd	r25, Y+4	; 0x04
    195e:	01 97       	sbiw	r24, 0x01	; 1
    1960:	9c 83       	std	Y+4, r25	; 0x04
    1962:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1964:	8f 81       	ldd	r24, Y+7	; 0x07
    1966:	98 85       	ldd	r25, Y+8	; 0x08
    1968:	9a 83       	std	Y+2, r25	; 0x02
    196a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    196c:	89 81       	ldd	r24, Y+1	; 0x01
    196e:	eb 81       	ldd	r30, Y+3	; 0x03
    1970:	fc 81       	ldd	r31, Y+4	; 0x04
    1972:	80 83       	st	Z, r24
	pxTopOfStack--;
    1974:	8b 81       	ldd	r24, Y+3	; 0x03
    1976:	9c 81       	ldd	r25, Y+4	; 0x04
    1978:	01 97       	sbiw	r24, 0x01	; 1
    197a:	9c 83       	std	Y+4, r25	; 0x04
    197c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    197e:	89 81       	ldd	r24, Y+1	; 0x01
    1980:	9a 81       	ldd	r25, Y+2	; 0x02
    1982:	89 2f       	mov	r24, r25
    1984:	99 27       	eor	r25, r25
    1986:	9a 83       	std	Y+2, r25	; 0x02
    1988:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    198a:	89 81       	ldd	r24, Y+1	; 0x01
    198c:	eb 81       	ldd	r30, Y+3	; 0x03
    198e:	fc 81       	ldd	r31, Y+4	; 0x04
    1990:	80 83       	st	Z, r24
	pxTopOfStack--;
    1992:	8b 81       	ldd	r24, Y+3	; 0x03
    1994:	9c 81       	ldd	r25, Y+4	; 0x04
    1996:	01 97       	sbiw	r24, 0x01	; 1
    1998:	9c 83       	std	Y+4, r25	; 0x04
    199a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    199c:	eb 81       	ldd	r30, Y+3	; 0x03
    199e:	fc 81       	ldd	r31, Y+4	; 0x04
    19a0:	86 e2       	ldi	r24, 0x26	; 38
    19a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a4:	8b 81       	ldd	r24, Y+3	; 0x03
    19a6:	9c 81       	ldd	r25, Y+4	; 0x04
    19a8:	01 97       	sbiw	r24, 0x01	; 1
    19aa:	9c 83       	std	Y+4, r25	; 0x04
    19ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    19ae:	eb 81       	ldd	r30, Y+3	; 0x03
    19b0:	fc 81       	ldd	r31, Y+4	; 0x04
    19b2:	87 e2       	ldi	r24, 0x27	; 39
    19b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b6:	8b 81       	ldd	r24, Y+3	; 0x03
    19b8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ba:	01 97       	sbiw	r24, 0x01	; 1
    19bc:	9c 83       	std	Y+4, r25	; 0x04
    19be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    19c0:	eb 81       	ldd	r30, Y+3	; 0x03
    19c2:	fc 81       	ldd	r31, Y+4	; 0x04
    19c4:	88 e2       	ldi	r24, 0x28	; 40
    19c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19c8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ca:	9c 81       	ldd	r25, Y+4	; 0x04
    19cc:	01 97       	sbiw	r24, 0x01	; 1
    19ce:	9c 83       	std	Y+4, r25	; 0x04
    19d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    19d2:	eb 81       	ldd	r30, Y+3	; 0x03
    19d4:	fc 81       	ldd	r31, Y+4	; 0x04
    19d6:	89 e2       	ldi	r24, 0x29	; 41
    19d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19da:	8b 81       	ldd	r24, Y+3	; 0x03
    19dc:	9c 81       	ldd	r25, Y+4	; 0x04
    19de:	01 97       	sbiw	r24, 0x01	; 1
    19e0:	9c 83       	std	Y+4, r25	; 0x04
    19e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    19e4:	eb 81       	ldd	r30, Y+3	; 0x03
    19e6:	fc 81       	ldd	r31, Y+4	; 0x04
    19e8:	80 e3       	ldi	r24, 0x30	; 48
    19ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ec:	8b 81       	ldd	r24, Y+3	; 0x03
    19ee:	9c 81       	ldd	r25, Y+4	; 0x04
    19f0:	01 97       	sbiw	r24, 0x01	; 1
    19f2:	9c 83       	std	Y+4, r25	; 0x04
    19f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    19f6:	eb 81       	ldd	r30, Y+3	; 0x03
    19f8:	fc 81       	ldd	r31, Y+4	; 0x04
    19fa:	81 e3       	ldi	r24, 0x31	; 49
    19fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	9c 81       	ldd	r25, Y+4	; 0x04
    1a02:	01 97       	sbiw	r24, 0x01	; 1
    1a04:	9c 83       	std	Y+4, r25	; 0x04
    1a06:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1a08:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1a0c:	28 96       	adiw	r28, 0x08	; 8
    1a0e:	0f b6       	in	r0, 0x3f	; 63
    1a10:	f8 94       	cli
    1a12:	de bf       	out	0x3e, r29	; 62
    1a14:	0f be       	out	0x3f, r0	; 63
    1a16:	cd bf       	out	0x3d, r28	; 61
    1a18:	cf 91       	pop	r28
    1a1a:	df 91       	pop	r29
    1a1c:	08 95       	ret

00001a1e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1a1e:	df 93       	push	r29
    1a20:	cf 93       	push	r28
    1a22:	cd b7       	in	r28, 0x3d	; 61
    1a24:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1a26:	0e 94 01 0e 	call	0x1c02	; 0x1c02 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a2a:	a0 91 8e 06 	lds	r26, 0x068E
    1a2e:	b0 91 8f 06 	lds	r27, 0x068F
    1a32:	cd 91       	ld	r28, X+
    1a34:	cd bf       	out	0x3d, r28	; 61
    1a36:	dd 91       	ld	r29, X+
    1a38:	de bf       	out	0x3e, r29	; 62
    1a3a:	ff 91       	pop	r31
    1a3c:	ef 91       	pop	r30
    1a3e:	df 91       	pop	r29
    1a40:	cf 91       	pop	r28
    1a42:	bf 91       	pop	r27
    1a44:	af 91       	pop	r26
    1a46:	9f 91       	pop	r25
    1a48:	8f 91       	pop	r24
    1a4a:	7f 91       	pop	r23
    1a4c:	6f 91       	pop	r22
    1a4e:	5f 91       	pop	r21
    1a50:	4f 91       	pop	r20
    1a52:	3f 91       	pop	r19
    1a54:	2f 91       	pop	r18
    1a56:	1f 91       	pop	r17
    1a58:	0f 91       	pop	r16
    1a5a:	ff 90       	pop	r15
    1a5c:	ef 90       	pop	r14
    1a5e:	df 90       	pop	r13
    1a60:	cf 90       	pop	r12
    1a62:	bf 90       	pop	r11
    1a64:	af 90       	pop	r10
    1a66:	9f 90       	pop	r9
    1a68:	8f 90       	pop	r8
    1a6a:	7f 90       	pop	r7
    1a6c:	6f 90       	pop	r6
    1a6e:	5f 90       	pop	r5
    1a70:	4f 90       	pop	r4
    1a72:	3f 90       	pop	r3
    1a74:	2f 90       	pop	r2
    1a76:	1f 90       	pop	r1
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a7e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1a80:	81 e0       	ldi	r24, 0x01	; 1
}
    1a82:	cf 91       	pop	r28
    1a84:	df 91       	pop	r29
    1a86:	08 95       	ret

00001a88 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a88:	df 93       	push	r29
    1a8a:	cf 93       	push	r28
    1a8c:	cd b7       	in	r28, 0x3d	; 61
    1a8e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1a90:	cf 91       	pop	r28
    1a92:	df 91       	pop	r29
    1a94:	08 95       	ret

00001a96 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1a96:	0f 92       	push	r0
    1a98:	0f b6       	in	r0, 0x3f	; 63
    1a9a:	f8 94       	cli
    1a9c:	0f 92       	push	r0
    1a9e:	1f 92       	push	r1
    1aa0:	11 24       	eor	r1, r1
    1aa2:	2f 92       	push	r2
    1aa4:	3f 92       	push	r3
    1aa6:	4f 92       	push	r4
    1aa8:	5f 92       	push	r5
    1aaa:	6f 92       	push	r6
    1aac:	7f 92       	push	r7
    1aae:	8f 92       	push	r8
    1ab0:	9f 92       	push	r9
    1ab2:	af 92       	push	r10
    1ab4:	bf 92       	push	r11
    1ab6:	cf 92       	push	r12
    1ab8:	df 92       	push	r13
    1aba:	ef 92       	push	r14
    1abc:	ff 92       	push	r15
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	2f 93       	push	r18
    1ac4:	3f 93       	push	r19
    1ac6:	4f 93       	push	r20
    1ac8:	5f 93       	push	r21
    1aca:	6f 93       	push	r22
    1acc:	7f 93       	push	r23
    1ace:	8f 93       	push	r24
    1ad0:	9f 93       	push	r25
    1ad2:	af 93       	push	r26
    1ad4:	bf 93       	push	r27
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
    1ada:	ef 93       	push	r30
    1adc:	ff 93       	push	r31
    1ade:	a0 91 8e 06 	lds	r26, 0x068E
    1ae2:	b0 91 8f 06 	lds	r27, 0x068F
    1ae6:	0d b6       	in	r0, 0x3d	; 61
    1ae8:	0d 92       	st	X+, r0
    1aea:	0e b6       	in	r0, 0x3e	; 62
    1aec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1aee:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1af2:	a0 91 8e 06 	lds	r26, 0x068E
    1af6:	b0 91 8f 06 	lds	r27, 0x068F
    1afa:	cd 91       	ld	r28, X+
    1afc:	cd bf       	out	0x3d, r28	; 61
    1afe:	dd 91       	ld	r29, X+
    1b00:	de bf       	out	0x3e, r29	; 62
    1b02:	ff 91       	pop	r31
    1b04:	ef 91       	pop	r30
    1b06:	df 91       	pop	r29
    1b08:	cf 91       	pop	r28
    1b0a:	bf 91       	pop	r27
    1b0c:	af 91       	pop	r26
    1b0e:	9f 91       	pop	r25
    1b10:	8f 91       	pop	r24
    1b12:	7f 91       	pop	r23
    1b14:	6f 91       	pop	r22
    1b16:	5f 91       	pop	r21
    1b18:	4f 91       	pop	r20
    1b1a:	3f 91       	pop	r19
    1b1c:	2f 91       	pop	r18
    1b1e:	1f 91       	pop	r17
    1b20:	0f 91       	pop	r16
    1b22:	ff 90       	pop	r15
    1b24:	ef 90       	pop	r14
    1b26:	df 90       	pop	r13
    1b28:	cf 90       	pop	r12
    1b2a:	bf 90       	pop	r11
    1b2c:	af 90       	pop	r10
    1b2e:	9f 90       	pop	r9
    1b30:	8f 90       	pop	r8
    1b32:	7f 90       	pop	r7
    1b34:	6f 90       	pop	r6
    1b36:	5f 90       	pop	r5
    1b38:	4f 90       	pop	r4
    1b3a:	3f 90       	pop	r3
    1b3c:	2f 90       	pop	r2
    1b3e:	1f 90       	pop	r1
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b46:	08 95       	ret

00001b48 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b48:	0f 92       	push	r0
    1b4a:	0f b6       	in	r0, 0x3f	; 63
    1b4c:	f8 94       	cli
    1b4e:	0f 92       	push	r0
    1b50:	1f 92       	push	r1
    1b52:	11 24       	eor	r1, r1
    1b54:	2f 92       	push	r2
    1b56:	3f 92       	push	r3
    1b58:	4f 92       	push	r4
    1b5a:	5f 92       	push	r5
    1b5c:	6f 92       	push	r6
    1b5e:	7f 92       	push	r7
    1b60:	8f 92       	push	r8
    1b62:	9f 92       	push	r9
    1b64:	af 92       	push	r10
    1b66:	bf 92       	push	r11
    1b68:	cf 92       	push	r12
    1b6a:	df 92       	push	r13
    1b6c:	ef 92       	push	r14
    1b6e:	ff 92       	push	r15
    1b70:	0f 93       	push	r16
    1b72:	1f 93       	push	r17
    1b74:	2f 93       	push	r18
    1b76:	3f 93       	push	r19
    1b78:	4f 93       	push	r20
    1b7a:	5f 93       	push	r21
    1b7c:	6f 93       	push	r22
    1b7e:	7f 93       	push	r23
    1b80:	8f 93       	push	r24
    1b82:	9f 93       	push	r25
    1b84:	af 93       	push	r26
    1b86:	bf 93       	push	r27
    1b88:	cf 93       	push	r28
    1b8a:	df 93       	push	r29
    1b8c:	ef 93       	push	r30
    1b8e:	ff 93       	push	r31
    1b90:	a0 91 8e 06 	lds	r26, 0x068E
    1b94:	b0 91 8f 06 	lds	r27, 0x068F
    1b98:	0d b6       	in	r0, 0x3d	; 61
    1b9a:	0d 92       	st	X+, r0
    1b9c:	0e b6       	in	r0, 0x3e	; 62
    1b9e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1ba0:	0e 94 fd 21 	call	0x43fa	; 0x43fa <xTaskIncrementTick>
    1ba4:	88 23       	and	r24, r24
    1ba6:	11 f0       	breq	.+4      	; 0x1bac <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1ba8:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1bac:	a0 91 8e 06 	lds	r26, 0x068E
    1bb0:	b0 91 8f 06 	lds	r27, 0x068F
    1bb4:	cd 91       	ld	r28, X+
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	dd 91       	ld	r29, X+
    1bba:	de bf       	out	0x3e, r29	; 62
    1bbc:	ff 91       	pop	r31
    1bbe:	ef 91       	pop	r30
    1bc0:	df 91       	pop	r29
    1bc2:	cf 91       	pop	r28
    1bc4:	bf 91       	pop	r27
    1bc6:	af 91       	pop	r26
    1bc8:	9f 91       	pop	r25
    1bca:	8f 91       	pop	r24
    1bcc:	7f 91       	pop	r23
    1bce:	6f 91       	pop	r22
    1bd0:	5f 91       	pop	r21
    1bd2:	4f 91       	pop	r20
    1bd4:	3f 91       	pop	r19
    1bd6:	2f 91       	pop	r18
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	bf 90       	pop	r11
    1be6:	af 90       	pop	r10
    1be8:	9f 90       	pop	r9
    1bea:	8f 90       	pop	r8
    1bec:	7f 90       	pop	r7
    1bee:	6f 90       	pop	r6
    1bf0:	5f 90       	pop	r5
    1bf2:	4f 90       	pop	r4
    1bf4:	3f 90       	pop	r3
    1bf6:	2f 90       	pop	r2
    1bf8:	1f 90       	pop	r1
    1bfa:	0f 90       	pop	r0
    1bfc:	0f be       	out	0x3f, r0	; 63
    1bfe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c00:	08 95       	ret

00001c02 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1c02:	df 93       	push	r29
    1c04:	cf 93       	push	r28
    1c06:	00 d0       	rcall	.+0      	; 0x1c08 <prvSetupTimerInterrupt+0x6>
    1c08:	00 d0       	rcall	.+0      	; 0x1c0a <prvSetupTimerInterrupt+0x8>
    1c0a:	00 d0       	rcall	.+0      	; 0x1c0c <prvSetupTimerInterrupt+0xa>
    1c0c:	cd b7       	in	r28, 0x3d	; 61
    1c0e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1c10:	80 e4       	ldi	r24, 0x40	; 64
    1c12:	9f e1       	ldi	r25, 0x1F	; 31
    1c14:	a0 e0       	ldi	r26, 0x00	; 0
    1c16:	b0 e0       	ldi	r27, 0x00	; 0
    1c18:	8b 83       	std	Y+3, r24	; 0x03
    1c1a:	9c 83       	std	Y+4, r25	; 0x04
    1c1c:	ad 83       	std	Y+5, r26	; 0x05
    1c1e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	ad 81       	ldd	r26, Y+5	; 0x05
    1c26:	be 81       	ldd	r27, Y+6	; 0x06
    1c28:	68 94       	set
    1c2a:	15 f8       	bld	r1, 5
    1c2c:	b6 95       	lsr	r27
    1c2e:	a7 95       	ror	r26
    1c30:	97 95       	ror	r25
    1c32:	87 95       	ror	r24
    1c34:	16 94       	lsr	r1
    1c36:	d1 f7       	brne	.-12     	; 0x1c2c <prvSetupTimerInterrupt+0x2a>
    1c38:	8b 83       	std	Y+3, r24	; 0x03
    1c3a:	9c 83       	std	Y+4, r25	; 0x04
    1c3c:	ad 83       	std	Y+5, r26	; 0x05
    1c3e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1c40:	8b 81       	ldd	r24, Y+3	; 0x03
    1c42:	9c 81       	ldd	r25, Y+4	; 0x04
    1c44:	ad 81       	ldd	r26, Y+5	; 0x05
    1c46:	be 81       	ldd	r27, Y+6	; 0x06
    1c48:	01 97       	sbiw	r24, 0x01	; 1
    1c4a:	a1 09       	sbc	r26, r1
    1c4c:	b1 09       	sbc	r27, r1
    1c4e:	8b 83       	std	Y+3, r24	; 0x03
    1c50:	9c 83       	std	Y+4, r25	; 0x04
    1c52:	ad 83       	std	Y+5, r26	; 0x05
    1c54:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c56:	8b 81       	ldd	r24, Y+3	; 0x03
    1c58:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5e:	ad 81       	ldd	r26, Y+5	; 0x05
    1c60:	be 81       	ldd	r27, Y+6	; 0x06
    1c62:	89 2f       	mov	r24, r25
    1c64:	9a 2f       	mov	r25, r26
    1c66:	ab 2f       	mov	r26, r27
    1c68:	bb 27       	eor	r27, r27
    1c6a:	8b 83       	std	Y+3, r24	; 0x03
    1c6c:	9c 83       	std	Y+4, r25	; 0x04
    1c6e:	ad 83       	std	Y+5, r26	; 0x05
    1c70:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c72:	8b 81       	ldd	r24, Y+3	; 0x03
    1c74:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c76:	eb e4       	ldi	r30, 0x4B	; 75
    1c78:	f0 e0       	ldi	r31, 0x00	; 0
    1c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1c7e:	ea e4       	ldi	r30, 0x4A	; 74
    1c80:	f0 e0       	ldi	r31, 0x00	; 0
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1c86:	8b e0       	ldi	r24, 0x0B	; 11
    1c88:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1c8a:	ee e4       	ldi	r30, 0x4E	; 78
    1c8c:	f0 e0       	ldi	r31, 0x00	; 0
    1c8e:	89 81       	ldd	r24, Y+1	; 0x01
    1c90:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1c92:	e9 e5       	ldi	r30, 0x59	; 89
    1c94:	f0 e0       	ldi	r31, 0x00	; 0
    1c96:	80 81       	ld	r24, Z
    1c98:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1c9a:	89 81       	ldd	r24, Y+1	; 0x01
    1c9c:	80 61       	ori	r24, 0x10	; 16
    1c9e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1ca0:	e9 e5       	ldi	r30, 0x59	; 89
    1ca2:	f0 e0       	ldi	r31, 0x00	; 0
    1ca4:	89 81       	ldd	r24, Y+1	; 0x01
    1ca6:	80 83       	st	Z, r24
}
    1ca8:	26 96       	adiw	r28, 0x06	; 6
    1caa:	0f b6       	in	r0, 0x3f	; 63
    1cac:	f8 94       	cli
    1cae:	de bf       	out	0x3e, r29	; 62
    1cb0:	0f be       	out	0x3f, r0	; 63
    1cb2:	cd bf       	out	0x3d, r28	; 61
    1cb4:	cf 91       	pop	r28
    1cb6:	df 91       	pop	r29
    1cb8:	08 95       	ret

00001cba <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1cba:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1cbe:	18 95       	reti

00001cc0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1cc0:	df 93       	push	r29
    1cc2:	cf 93       	push	r28
    1cc4:	00 d0       	rcall	.+0      	; 0x1cc6 <xQueueGenericReset+0x6>
    1cc6:	00 d0       	rcall	.+0      	; 0x1cc8 <xQueueGenericReset+0x8>
    1cc8:	0f 92       	push	r0
    1cca:	cd b7       	in	r28, 0x3d	; 61
    1ccc:	de b7       	in	r29, 0x3e	; 62
    1cce:	9c 83       	std	Y+4, r25	; 0x04
    1cd0:	8b 83       	std	Y+3, r24	; 0x03
    1cd2:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1cd4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd8:	9a 83       	std	Y+2, r25	; 0x02
    1cda:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	f8 94       	cli
    1ce0:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ce2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce6:	40 81       	ld	r20, Z
    1ce8:	51 81       	ldd	r21, Z+1	; 0x01
    1cea:	e9 81       	ldd	r30, Y+1	; 0x01
    1cec:	fa 81       	ldd	r31, Y+2	; 0x02
    1cee:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cf0:	28 2f       	mov	r18, r24
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cfa:	88 2f       	mov	r24, r24
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	bc 01       	movw	r22, r24
    1d00:	26 9f       	mul	r18, r22
    1d02:	c0 01       	movw	r24, r0
    1d04:	27 9f       	mul	r18, r23
    1d06:	90 0d       	add	r25, r0
    1d08:	36 9f       	mul	r19, r22
    1d0a:	90 0d       	add	r25, r0
    1d0c:	11 24       	eor	r1, r1
    1d0e:	84 0f       	add	r24, r20
    1d10:	95 1f       	adc	r25, r21
    1d12:	e9 81       	ldd	r30, Y+1	; 0x01
    1d14:	fa 81       	ldd	r31, Y+2	; 0x02
    1d16:	95 83       	std	Z+5, r25	; 0x05
    1d18:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1d20:	e9 81       	ldd	r30, Y+1	; 0x01
    1d22:	fa 81       	ldd	r31, Y+2	; 0x02
    1d24:	80 81       	ld	r24, Z
    1d26:	91 81       	ldd	r25, Z+1	; 0x01
    1d28:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2c:	93 83       	std	Z+3, r25	; 0x03
    1d2e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d30:	e9 81       	ldd	r30, Y+1	; 0x01
    1d32:	fa 81       	ldd	r31, Y+2	; 0x02
    1d34:	40 81       	ld	r20, Z
    1d36:	51 81       	ldd	r21, Z+1	; 0x01
    1d38:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d3e:	88 2f       	mov	r24, r24
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	9c 01       	movw	r18, r24
    1d44:	21 50       	subi	r18, 0x01	; 1
    1d46:	30 40       	sbci	r19, 0x00	; 0
    1d48:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d4e:	88 2f       	mov	r24, r24
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	bc 01       	movw	r22, r24
    1d54:	26 9f       	mul	r18, r22
    1d56:	c0 01       	movw	r24, r0
    1d58:	27 9f       	mul	r18, r23
    1d5a:	90 0d       	add	r25, r0
    1d5c:	36 9f       	mul	r19, r22
    1d5e:	90 0d       	add	r25, r0
    1d60:	11 24       	eor	r1, r1
    1d62:	84 0f       	add	r24, r20
    1d64:	95 1f       	adc	r25, r21
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	97 83       	std	Z+7, r25	; 0x07
    1d6c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d70:	fa 81       	ldd	r31, Y+2	; 0x02
    1d72:	8f ef       	ldi	r24, 0xFF	; 255
    1d74:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1d76:	e9 81       	ldd	r30, Y+1	; 0x01
    1d78:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7a:	8f ef       	ldi	r24, 0xFF	; 255
    1d7c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1d7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d80:	88 23       	and	r24, r24
    1d82:	79 f4       	brne	.+30     	; 0x1da2 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d84:	e9 81       	ldd	r30, Y+1	; 0x01
    1d86:	fa 81       	ldd	r31, Y+2	; 0x02
    1d88:	80 85       	ldd	r24, Z+8	; 0x08
    1d8a:	88 23       	and	r24, r24
    1d8c:	a1 f0       	breq	.+40     	; 0x1db6 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d8e:	89 81       	ldd	r24, Y+1	; 0x01
    1d90:	9a 81       	ldd	r25, Y+2	; 0x02
    1d92:	08 96       	adiw	r24, 0x08	; 8
    1d94:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    1d98:	88 23       	and	r24, r24
    1d9a:	69 f0       	breq	.+26     	; 0x1db6 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1d9c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    1da0:	0a c0       	rjmp	.+20     	; 0x1db6 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1da2:	89 81       	ldd	r24, Y+1	; 0x01
    1da4:	9a 81       	ldd	r25, Y+2	; 0x02
    1da6:	08 96       	adiw	r24, 0x08	; 8
    1da8:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1dac:	89 81       	ldd	r24, Y+1	; 0x01
    1dae:	9a 81       	ldd	r25, Y+2	; 0x02
    1db0:	41 96       	adiw	r24, 0x11	; 17
    1db2:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1db6:	0f 90       	pop	r0
    1db8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1dba:	81 e0       	ldi	r24, 0x01	; 1
}
    1dbc:	0f 90       	pop	r0
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	0f 90       	pop	r0
    1dc4:	0f 90       	pop	r0
    1dc6:	cf 91       	pop	r28
    1dc8:	df 91       	pop	r29
    1dca:	08 95       	ret

00001dcc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1dcc:	0f 93       	push	r16
    1dce:	1f 93       	push	r17
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	cd b7       	in	r28, 0x3d	; 61
    1dd6:	de b7       	in	r29, 0x3e	; 62
    1dd8:	29 97       	sbiw	r28, 0x09	; 9
    1dda:	0f b6       	in	r0, 0x3f	; 63
    1ddc:	f8 94       	cli
    1dde:	de bf       	out	0x3e, r29	; 62
    1de0:	0f be       	out	0x3f, r0	; 63
    1de2:	cd bf       	out	0x3d, r28	; 61
    1de4:	8f 83       	std	Y+7, r24	; 0x07
    1de6:	68 87       	std	Y+8, r22	; 0x08
    1de8:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1dea:	88 85       	ldd	r24, Y+8	; 0x08
    1dec:	88 23       	and	r24, r24
    1dee:	19 f4       	brne	.+6      	; 0x1df6 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1df0:	1c 82       	std	Y+4, r1	; 0x04
    1df2:	1b 82       	std	Y+3, r1	; 0x03
    1df4:	10 c0       	rjmp	.+32     	; 0x1e16 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1df6:	8f 81       	ldd	r24, Y+7	; 0x07
    1df8:	28 2f       	mov	r18, r24
    1dfa:	30 e0       	ldi	r19, 0x00	; 0
    1dfc:	88 85       	ldd	r24, Y+8	; 0x08
    1dfe:	88 2f       	mov	r24, r24
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	ac 01       	movw	r20, r24
    1e04:	24 9f       	mul	r18, r20
    1e06:	c0 01       	movw	r24, r0
    1e08:	25 9f       	mul	r18, r21
    1e0a:	90 0d       	add	r25, r0
    1e0c:	34 9f       	mul	r19, r20
    1e0e:	90 0d       	add	r25, r0
    1e10:	11 24       	eor	r1, r1
    1e12:	9c 83       	std	Y+4, r25	; 0x04
    1e14:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1e16:	8b 81       	ldd	r24, Y+3	; 0x03
    1e18:	9c 81       	ldd	r25, Y+4	; 0x04
    1e1a:	4f 96       	adiw	r24, 0x1f	; 31
    1e1c:	0e 94 23 07 	call	0xe46	; 0xe46 <pvPortMalloc>
    1e20:	9e 83       	std	Y+6, r25	; 0x06
    1e22:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1e24:	8d 81       	ldd	r24, Y+5	; 0x05
    1e26:	9e 81       	ldd	r25, Y+6	; 0x06
    1e28:	00 97       	sbiw	r24, 0x00	; 0
    1e2a:	a1 f0       	breq	.+40     	; 0x1e54 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1e2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e30:	9a 83       	std	Y+2, r25	; 0x02
    1e32:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e34:	89 81       	ldd	r24, Y+1	; 0x01
    1e36:	9a 81       	ldd	r25, Y+2	; 0x02
    1e38:	4f 96       	adiw	r24, 0x1f	; 31
    1e3a:	9a 83       	std	Y+2, r25	; 0x02
    1e3c:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1e3e:	29 81       	ldd	r18, Y+1	; 0x01
    1e40:	3a 81       	ldd	r19, Y+2	; 0x02
    1e42:	ed 81       	ldd	r30, Y+5	; 0x05
    1e44:	fe 81       	ldd	r31, Y+6	; 0x06
    1e46:	8f 81       	ldd	r24, Y+7	; 0x07
    1e48:	68 85       	ldd	r22, Y+8	; 0x08
    1e4a:	a9 01       	movw	r20, r18
    1e4c:	29 85       	ldd	r18, Y+9	; 0x09
    1e4e:	8f 01       	movw	r16, r30
    1e50:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1e54:	8d 81       	ldd	r24, Y+5	; 0x05
    1e56:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1e58:	29 96       	adiw	r28, 0x09	; 9
    1e5a:	0f b6       	in	r0, 0x3f	; 63
    1e5c:	f8 94       	cli
    1e5e:	de bf       	out	0x3e, r29	; 62
    1e60:	0f be       	out	0x3f, r0	; 63
    1e62:	cd bf       	out	0x3d, r28	; 61
    1e64:	cf 91       	pop	r28
    1e66:	df 91       	pop	r29
    1e68:	1f 91       	pop	r17
    1e6a:	0f 91       	pop	r16
    1e6c:	08 95       	ret

00001e6e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1e6e:	0f 93       	push	r16
    1e70:	1f 93       	push	r17
    1e72:	df 93       	push	r29
    1e74:	cf 93       	push	r28
    1e76:	cd b7       	in	r28, 0x3d	; 61
    1e78:	de b7       	in	r29, 0x3e	; 62
    1e7a:	27 97       	sbiw	r28, 0x07	; 7
    1e7c:	0f b6       	in	r0, 0x3f	; 63
    1e7e:	f8 94       	cli
    1e80:	de bf       	out	0x3e, r29	; 62
    1e82:	0f be       	out	0x3f, r0	; 63
    1e84:	cd bf       	out	0x3d, r28	; 61
    1e86:	89 83       	std	Y+1, r24	; 0x01
    1e88:	6a 83       	std	Y+2, r22	; 0x02
    1e8a:	5c 83       	std	Y+4, r21	; 0x04
    1e8c:	4b 83       	std	Y+3, r20	; 0x03
    1e8e:	2d 83       	std	Y+5, r18	; 0x05
    1e90:	1f 83       	std	Y+7, r17	; 0x07
    1e92:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1e94:	8a 81       	ldd	r24, Y+2	; 0x02
    1e96:	88 23       	and	r24, r24
    1e98:	39 f4       	brne	.+14     	; 0x1ea8 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1e9a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e9c:	9f 81       	ldd	r25, Y+7	; 0x07
    1e9e:	ee 81       	ldd	r30, Y+6	; 0x06
    1ea0:	ff 81       	ldd	r31, Y+7	; 0x07
    1ea2:	91 83       	std	Z+1, r25	; 0x01
    1ea4:	80 83       	st	Z, r24
    1ea6:	06 c0       	rjmp	.+12     	; 0x1eb4 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    1eac:	ee 81       	ldd	r30, Y+6	; 0x06
    1eae:	ff 81       	ldd	r31, Y+7	; 0x07
    1eb0:	91 83       	std	Z+1, r25	; 0x01
    1eb2:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1eb4:	ee 81       	ldd	r30, Y+6	; 0x06
    1eb6:	ff 81       	ldd	r31, Y+7	; 0x07
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
    1eba:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1ebc:	ee 81       	ldd	r30, Y+6	; 0x06
    1ebe:	ff 81       	ldd	r31, Y+7	; 0x07
    1ec0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec2:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ec4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ec8:	61 e0       	ldi	r22, 0x01	; 1
    1eca:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1ece:	27 96       	adiw	r28, 0x07	; 7
    1ed0:	0f b6       	in	r0, 0x3f	; 63
    1ed2:	f8 94       	cli
    1ed4:	de bf       	out	0x3e, r29	; 62
    1ed6:	0f be       	out	0x3f, r0	; 63
    1ed8:	cd bf       	out	0x3d, r28	; 61
    1eda:	cf 91       	pop	r28
    1edc:	df 91       	pop	r29
    1ede:	1f 91       	pop	r17
    1ee0:	0f 91       	pop	r16
    1ee2:	08 95       	ret

00001ee4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1ee4:	df 93       	push	r29
    1ee6:	cf 93       	push	r28
    1ee8:	cd b7       	in	r28, 0x3d	; 61
    1eea:	de b7       	in	r29, 0x3e	; 62
    1eec:	2f 97       	sbiw	r28, 0x0f	; 15
    1eee:	0f b6       	in	r0, 0x3f	; 63
    1ef0:	f8 94       	cli
    1ef2:	de bf       	out	0x3e, r29	; 62
    1ef4:	0f be       	out	0x3f, r0	; 63
    1ef6:	cd bf       	out	0x3d, r28	; 61
    1ef8:	99 87       	std	Y+9, r25	; 0x09
    1efa:	88 87       	std	Y+8, r24	; 0x08
    1efc:	7b 87       	std	Y+11, r23	; 0x0b
    1efe:	6a 87       	std	Y+10, r22	; 0x0a
    1f00:	5d 87       	std	Y+13, r21	; 0x0d
    1f02:	4c 87       	std	Y+12, r20	; 0x0c
    1f04:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1f06:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1f08:	88 85       	ldd	r24, Y+8	; 0x08
    1f0a:	99 85       	ldd	r25, Y+9	; 0x09
    1f0c:	9a 83       	std	Y+2, r25	; 0x02
    1f0e:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f16:	e9 81       	ldd	r30, Y+1	; 0x01
    1f18:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f20:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f22:	98 17       	cp	r25, r24
    1f24:	18 f0       	brcs	.+6      	; 0x1f2c <xQueueGenericSend+0x48>
    1f26:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f28:	82 30       	cpi	r24, 0x02	; 2
    1f2a:	11 f5       	brne	.+68     	; 0x1f70 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
    1f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f30:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f32:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f34:	b9 01       	movw	r22, r18
    1f36:	4e 85       	ldd	r20, Y+14	; 0x0e
    1f38:	0e 94 c4 13 	call	0x2788	; 0x2788 <prvCopyDataToQueue>
    1f3c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f40:	fa 81       	ldd	r31, Y+2	; 0x02
    1f42:	81 89       	ldd	r24, Z+17	; 0x11
    1f44:	88 23       	and	r24, r24
    1f46:	51 f0       	breq	.+20     	; 0x1f5c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f48:	89 81       	ldd	r24, Y+1	; 0x01
    1f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f4c:	41 96       	adiw	r24, 0x11	; 17
    1f4e:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    1f52:	88 23       	and	r24, r24
    1f54:	41 f0       	breq	.+16     	; 0x1f66 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1f56:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    1f5a:	05 c0       	rjmp	.+10     	; 0x1f66 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5e:	88 23       	and	r24, r24
    1f60:	11 f0       	breq	.+4      	; 0x1f66 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1f62:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1f66:	0f 90       	pop	r0
    1f68:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f6a:	81 e0       	ldi	r24, 0x01	; 1
    1f6c:	8f 87       	std	Y+15, r24	; 0x0f
    1f6e:	5c c0       	rjmp	.+184    	; 0x2028 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f70:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f72:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f74:	00 97       	sbiw	r24, 0x00	; 0
    1f76:	21 f4       	brne	.+8      	; 0x1f80 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1f7c:	1f 86       	std	Y+15, r1	; 0x0f
    1f7e:	54 c0       	rjmp	.+168    	; 0x2028 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f80:	8c 81       	ldd	r24, Y+4	; 0x04
    1f82:	88 23       	and	r24, r24
    1f84:	31 f4       	brne	.+12     	; 0x1f92 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f86:	ce 01       	movw	r24, r28
    1f88:	05 96       	adiw	r24, 0x05	; 5
    1f8a:	0e 94 87 24 	call	0x490e	; 0x490e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f8e:	81 e0       	ldi	r24, 0x01	; 1
    1f90:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f96:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f9a:	0f b6       	in	r0, 0x3f	; 63
    1f9c:	f8 94       	cli
    1f9e:	0f 92       	push	r0
    1fa0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fa6:	8f 3f       	cpi	r24, 0xFF	; 255
    1fa8:	19 f4       	brne	.+6      	; 0x1fb0 <xQueueGenericSend+0xcc>
    1faa:	e9 81       	ldd	r30, Y+1	; 0x01
    1fac:	fa 81       	ldd	r31, Y+2	; 0x02
    1fae:	15 8e       	std	Z+29, r1	; 0x1d
    1fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fb6:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb8:	19 f4       	brne	.+6      	; 0x1fc0 <xQueueGenericSend+0xdc>
    1fba:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1fbe:	16 8e       	std	Z+30, r1	; 0x1e
    1fc0:	0f 90       	pop	r0
    1fc2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fc4:	ce 01       	movw	r24, r28
    1fc6:	05 96       	adiw	r24, 0x05	; 5
    1fc8:	9e 01       	movw	r18, r28
    1fca:	24 5f       	subi	r18, 0xF4	; 244
    1fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fce:	b9 01       	movw	r22, r18
    1fd0:	0e 94 a0 24 	call	0x4940	; 0x4940 <xTaskCheckForTimeOut>
    1fd4:	88 23       	and	r24, r24
    1fd6:	09 f5       	brne	.+66     	; 0x201a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	9a 81       	ldd	r25, Y+2	; 0x02
    1fdc:	0e 94 40 15 	call	0x2a80	; 0x2a80 <prvIsQueueFull>
    1fe0:	88 23       	and	r24, r24
    1fe2:	a1 f0       	breq	.+40     	; 0x200c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	08 96       	adiw	r24, 0x08	; 8
    1fea:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fec:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fee:	b9 01       	movw	r22, r18
    1ff0:	0e 94 4f 23 	call	0x469e	; 0x469e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
    1ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff8:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ffc:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    2000:	88 23       	and	r24, r24
    2002:	09 f0       	breq	.+2      	; 0x2006 <xQueueGenericSend+0x122>
    2004:	85 cf       	rjmp	.-246    	; 0x1f10 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2006:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    200a:	82 cf       	rjmp	.-252    	; 0x1f10 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    200c:	89 81       	ldd	r24, Y+1	; 0x01
    200e:	9a 81       	ldd	r25, Y+2	; 0x02
    2010:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2014:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    2018:	7b cf       	rjmp	.-266    	; 0x1f10 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	9a 81       	ldd	r25, Y+2	; 0x02
    201e:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2022:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2026:	1f 86       	std	Y+15, r1	; 0x0f
    2028:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    202a:	2f 96       	adiw	r28, 0x0f	; 15
    202c:	0f b6       	in	r0, 0x3f	; 63
    202e:	f8 94       	cli
    2030:	de bf       	out	0x3e, r29	; 62
    2032:	0f be       	out	0x3f, r0	; 63
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	cf 91       	pop	r28
    2038:	df 91       	pop	r29
    203a:	08 95       	ret

0000203c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    203c:	df 93       	push	r29
    203e:	cf 93       	push	r28
    2040:	cd b7       	in	r28, 0x3d	; 61
    2042:	de b7       	in	r29, 0x3e	; 62
    2044:	2c 97       	sbiw	r28, 0x0c	; 12
    2046:	0f b6       	in	r0, 0x3f	; 63
    2048:	f8 94       	cli
    204a:	de bf       	out	0x3e, r29	; 62
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	cd bf       	out	0x3d, r28	; 61
    2050:	9f 83       	std	Y+7, r25	; 0x07
    2052:	8e 83       	std	Y+6, r24	; 0x06
    2054:	79 87       	std	Y+9, r23	; 0x09
    2056:	68 87       	std	Y+8, r22	; 0x08
    2058:	5b 87       	std	Y+11, r21	; 0x0b
    205a:	4a 87       	std	Y+10, r20	; 0x0a
    205c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    205e:	8e 81       	ldd	r24, Y+6	; 0x06
    2060:	9f 81       	ldd	r25, Y+7	; 0x07
    2062:	9b 83       	std	Y+3, r25	; 0x03
    2064:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2066:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2068:	ea 81       	ldd	r30, Y+2	; 0x02
    206a:	fb 81       	ldd	r31, Y+3	; 0x03
    206c:	92 8d       	ldd	r25, Z+26	; 0x1a
    206e:	ea 81       	ldd	r30, Y+2	; 0x02
    2070:	fb 81       	ldd	r31, Y+3	; 0x03
    2072:	83 8d       	ldd	r24, Z+27	; 0x1b
    2074:	98 17       	cp	r25, r24
    2076:	18 f0       	brcs	.+6      	; 0x207e <xQueueGenericSendFromISR+0x42>
    2078:	8c 85       	ldd	r24, Y+12	; 0x0c
    207a:	82 30       	cpi	r24, 0x02	; 2
    207c:	61 f5       	brne	.+88     	; 0x20d6 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    207e:	ea 81       	ldd	r30, Y+2	; 0x02
    2080:	fb 81       	ldd	r31, Y+3	; 0x03
    2082:	86 8d       	ldd	r24, Z+30	; 0x1e
    2084:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2086:	8a 81       	ldd	r24, Y+2	; 0x02
    2088:	9b 81       	ldd	r25, Y+3	; 0x03
    208a:	28 85       	ldd	r18, Y+8	; 0x08
    208c:	39 85       	ldd	r19, Y+9	; 0x09
    208e:	b9 01       	movw	r22, r18
    2090:	4c 85       	ldd	r20, Y+12	; 0x0c
    2092:	0e 94 c4 13 	call	0x2788	; 0x2788 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2096:	89 81       	ldd	r24, Y+1	; 0x01
    2098:	8f 3f       	cpi	r24, 0xFF	; 255
    209a:	a9 f4       	brne	.+42     	; 0x20c6 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    209c:	ea 81       	ldd	r30, Y+2	; 0x02
    209e:	fb 81       	ldd	r31, Y+3	; 0x03
    20a0:	81 89       	ldd	r24, Z+17	; 0x11
    20a2:	88 23       	and	r24, r24
    20a4:	a9 f0       	breq	.+42     	; 0x20d0 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20a6:	8a 81       	ldd	r24, Y+2	; 0x02
    20a8:	9b 81       	ldd	r25, Y+3	; 0x03
    20aa:	41 96       	adiw	r24, 0x11	; 17
    20ac:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    20b0:	88 23       	and	r24, r24
    20b2:	71 f0       	breq	.+28     	; 0x20d0 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    20b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    20b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    20b8:	00 97       	sbiw	r24, 0x00	; 0
    20ba:	51 f0       	breq	.+20     	; 0x20d0 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    20bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    20be:	fb 85       	ldd	r31, Y+11	; 0x0b
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	80 83       	st	Z, r24
    20c4:	05 c0       	rjmp	.+10     	; 0x20d0 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    20c6:	89 81       	ldd	r24, Y+1	; 0x01
    20c8:	8f 5f       	subi	r24, 0xFF	; 255
    20ca:	ea 81       	ldd	r30, Y+2	; 0x02
    20cc:	fb 81       	ldd	r31, Y+3	; 0x03
    20ce:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	8d 83       	std	Y+5, r24	; 0x05
    20d4:	01 c0       	rjmp	.+2      	; 0x20d8 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20d6:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20d8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    20da:	2c 96       	adiw	r28, 0x0c	; 12
    20dc:	0f b6       	in	r0, 0x3f	; 63
    20de:	f8 94       	cli
    20e0:	de bf       	out	0x3e, r29	; 62
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	cd bf       	out	0x3d, r28	; 61
    20e6:	cf 91       	pop	r28
    20e8:	df 91       	pop	r29
    20ea:	08 95       	ret

000020ec <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    20ec:	df 93       	push	r29
    20ee:	cf 93       	push	r28
    20f0:	cd b7       	in	r28, 0x3d	; 61
    20f2:	de b7       	in	r29, 0x3e	; 62
    20f4:	2a 97       	sbiw	r28, 0x0a	; 10
    20f6:	0f b6       	in	r0, 0x3f	; 63
    20f8:	f8 94       	cli
    20fa:	de bf       	out	0x3e, r29	; 62
    20fc:	0f be       	out	0x3f, r0	; 63
    20fe:	cd bf       	out	0x3d, r28	; 61
    2100:	98 87       	std	Y+8, r25	; 0x08
    2102:	8f 83       	std	Y+7, r24	; 0x07
    2104:	7a 87       	std	Y+10, r23	; 0x0a
    2106:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2108:	8f 81       	ldd	r24, Y+7	; 0x07
    210a:	98 85       	ldd	r25, Y+8	; 0x08
    210c:	9c 83       	std	Y+4, r25	; 0x04
    210e:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2110:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2112:	eb 81       	ldd	r30, Y+3	; 0x03
    2114:	fc 81       	ldd	r31, Y+4	; 0x04
    2116:	82 8d       	ldd	r24, Z+26	; 0x1a
    2118:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    211a:	eb 81       	ldd	r30, Y+3	; 0x03
    211c:	fc 81       	ldd	r31, Y+4	; 0x04
    211e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2120:	8a 81       	ldd	r24, Y+2	; 0x02
    2122:	89 17       	cp	r24, r25
    2124:	48 f5       	brcc	.+82     	; 0x2178 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2126:	eb 81       	ldd	r30, Y+3	; 0x03
    2128:	fc 81       	ldd	r31, Y+4	; 0x04
    212a:	86 8d       	ldd	r24, Z+30	; 0x1e
    212c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    212e:	8a 81       	ldd	r24, Y+2	; 0x02
    2130:	8f 5f       	subi	r24, 0xFF	; 255
    2132:	eb 81       	ldd	r30, Y+3	; 0x03
    2134:	fc 81       	ldd	r31, Y+4	; 0x04
    2136:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2138:	89 81       	ldd	r24, Y+1	; 0x01
    213a:	8f 3f       	cpi	r24, 0xFF	; 255
    213c:	a9 f4       	brne	.+42     	; 0x2168 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    213e:	eb 81       	ldd	r30, Y+3	; 0x03
    2140:	fc 81       	ldd	r31, Y+4	; 0x04
    2142:	81 89       	ldd	r24, Z+17	; 0x11
    2144:	88 23       	and	r24, r24
    2146:	a9 f0       	breq	.+42     	; 0x2172 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2148:	8b 81       	ldd	r24, Y+3	; 0x03
    214a:	9c 81       	ldd	r25, Y+4	; 0x04
    214c:	41 96       	adiw	r24, 0x11	; 17
    214e:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    2152:	88 23       	and	r24, r24
    2154:	71 f0       	breq	.+28     	; 0x2172 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2156:	89 85       	ldd	r24, Y+9	; 0x09
    2158:	9a 85       	ldd	r25, Y+10	; 0x0a
    215a:	00 97       	sbiw	r24, 0x00	; 0
    215c:	51 f0       	breq	.+20     	; 0x2172 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    215e:	e9 85       	ldd	r30, Y+9	; 0x09
    2160:	fa 85       	ldd	r31, Y+10	; 0x0a
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	80 83       	st	Z, r24
    2166:	05 c0       	rjmp	.+10     	; 0x2172 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2168:	89 81       	ldd	r24, Y+1	; 0x01
    216a:	8f 5f       	subi	r24, 0xFF	; 255
    216c:	eb 81       	ldd	r30, Y+3	; 0x03
    216e:	fc 81       	ldd	r31, Y+4	; 0x04
    2170:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	8e 83       	std	Y+6, r24	; 0x06
    2176:	01 c0       	rjmp	.+2      	; 0x217a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2178:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    217a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    217c:	2a 96       	adiw	r28, 0x0a	; 10
    217e:	0f b6       	in	r0, 0x3f	; 63
    2180:	f8 94       	cli
    2182:	de bf       	out	0x3e, r29	; 62
    2184:	0f be       	out	0x3f, r0	; 63
    2186:	cd bf       	out	0x3d, r28	; 61
    2188:	cf 91       	pop	r28
    218a:	df 91       	pop	r29
    218c:	08 95       	ret

0000218e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    218e:	df 93       	push	r29
    2190:	cf 93       	push	r28
    2192:	cd b7       	in	r28, 0x3d	; 61
    2194:	de b7       	in	r29, 0x3e	; 62
    2196:	2e 97       	sbiw	r28, 0x0e	; 14
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	de bf       	out	0x3e, r29	; 62
    219e:	0f be       	out	0x3f, r0	; 63
    21a0:	cd bf       	out	0x3d, r28	; 61
    21a2:	99 87       	std	Y+9, r25	; 0x09
    21a4:	88 87       	std	Y+8, r24	; 0x08
    21a6:	7b 87       	std	Y+11, r23	; 0x0b
    21a8:	6a 87       	std	Y+10, r22	; 0x0a
    21aa:	5d 87       	std	Y+13, r21	; 0x0d
    21ac:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    21ae:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    21b0:	88 85       	ldd	r24, Y+8	; 0x08
    21b2:	99 85       	ldd	r25, Y+9	; 0x09
    21b4:	9b 83       	std	Y+3, r25	; 0x03
    21b6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    21b8:	0f b6       	in	r0, 0x3f	; 63
    21ba:	f8 94       	cli
    21bc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21be:	ea 81       	ldd	r30, Y+2	; 0x02
    21c0:	fb 81       	ldd	r31, Y+3	; 0x03
    21c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21c4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21c6:	89 81       	ldd	r24, Y+1	; 0x01
    21c8:	88 23       	and	r24, r24
    21ca:	f9 f0       	breq	.+62     	; 0x220a <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    21cc:	8a 81       	ldd	r24, Y+2	; 0x02
    21ce:	9b 81       	ldd	r25, Y+3	; 0x03
    21d0:	2a 85       	ldd	r18, Y+10	; 0x0a
    21d2:	3b 85       	ldd	r19, Y+11	; 0x0b
    21d4:	b9 01       	movw	r22, r18
    21d6:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    21da:	89 81       	ldd	r24, Y+1	; 0x01
    21dc:	81 50       	subi	r24, 0x01	; 1
    21de:	ea 81       	ldd	r30, Y+2	; 0x02
    21e0:	fb 81       	ldd	r31, Y+3	; 0x03
    21e2:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21e4:	ea 81       	ldd	r30, Y+2	; 0x02
    21e6:	fb 81       	ldd	r31, Y+3	; 0x03
    21e8:	80 85       	ldd	r24, Z+8	; 0x08
    21ea:	88 23       	and	r24, r24
    21ec:	49 f0       	breq	.+18     	; 0x2200 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21ee:	8a 81       	ldd	r24, Y+2	; 0x02
    21f0:	9b 81       	ldd	r25, Y+3	; 0x03
    21f2:	08 96       	adiw	r24, 0x08	; 8
    21f4:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    21f8:	88 23       	and	r24, r24
    21fa:	11 f0       	breq	.+4      	; 0x2200 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    21fc:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2200:	0f 90       	pop	r0
    2202:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2204:	81 e0       	ldi	r24, 0x01	; 1
    2206:	8e 87       	std	Y+14, r24	; 0x0e
    2208:	63 c0       	rjmp	.+198    	; 0x22d0 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    220a:	8c 85       	ldd	r24, Y+12	; 0x0c
    220c:	9d 85       	ldd	r25, Y+13	; 0x0d
    220e:	00 97       	sbiw	r24, 0x00	; 0
    2210:	21 f4       	brne	.+8      	; 0x221a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2212:	0f 90       	pop	r0
    2214:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2216:	1e 86       	std	Y+14, r1	; 0x0e
    2218:	5b c0       	rjmp	.+182    	; 0x22d0 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    221a:	8c 81       	ldd	r24, Y+4	; 0x04
    221c:	88 23       	and	r24, r24
    221e:	31 f4       	brne	.+12     	; 0x222c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2220:	ce 01       	movw	r24, r28
    2222:	05 96       	adiw	r24, 0x05	; 5
    2224:	0e 94 87 24 	call	0x490e	; 0x490e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    222c:	0f 90       	pop	r0
    222e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2230:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	0f 92       	push	r0
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2240:	8f 3f       	cpi	r24, 0xFF	; 255
    2242:	19 f4       	brne	.+6      	; 0x224a <xQueueReceive+0xbc>
    2244:	ea 81       	ldd	r30, Y+2	; 0x02
    2246:	fb 81       	ldd	r31, Y+3	; 0x03
    2248:	15 8e       	std	Z+29, r1	; 0x1d
    224a:	ea 81       	ldd	r30, Y+2	; 0x02
    224c:	fb 81       	ldd	r31, Y+3	; 0x03
    224e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2250:	8f 3f       	cpi	r24, 0xFF	; 255
    2252:	19 f4       	brne	.+6      	; 0x225a <xQueueReceive+0xcc>
    2254:	ea 81       	ldd	r30, Y+2	; 0x02
    2256:	fb 81       	ldd	r31, Y+3	; 0x03
    2258:	16 8e       	std	Z+30, r1	; 0x1e
    225a:	0f 90       	pop	r0
    225c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    225e:	ce 01       	movw	r24, r28
    2260:	05 96       	adiw	r24, 0x05	; 5
    2262:	9e 01       	movw	r18, r28
    2264:	24 5f       	subi	r18, 0xF4	; 244
    2266:	3f 4f       	sbci	r19, 0xFF	; 255
    2268:	b9 01       	movw	r22, r18
    226a:	0e 94 a0 24 	call	0x4940	; 0x4940 <xTaskCheckForTimeOut>
    226e:	88 23       	and	r24, r24
    2270:	09 f5       	brne	.+66     	; 0x22b4 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2272:	8a 81       	ldd	r24, Y+2	; 0x02
    2274:	9b 81       	ldd	r25, Y+3	; 0x03
    2276:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    227a:	88 23       	and	r24, r24
    227c:	a1 f0       	breq	.+40     	; 0x22a6 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    227e:	8a 81       	ldd	r24, Y+2	; 0x02
    2280:	9b 81       	ldd	r25, Y+3	; 0x03
    2282:	41 96       	adiw	r24, 0x11	; 17
    2284:	2c 85       	ldd	r18, Y+12	; 0x0c
    2286:	3d 85       	ldd	r19, Y+13	; 0x0d
    2288:	b9 01       	movw	r22, r18
    228a:	0e 94 4f 23 	call	0x469e	; 0x469e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    228e:	8a 81       	ldd	r24, Y+2	; 0x02
    2290:	9b 81       	ldd	r25, Y+3	; 0x03
    2292:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2296:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    229a:	88 23       	and	r24, r24
    229c:	09 f0       	breq	.+2      	; 0x22a0 <xQueueReceive+0x112>
    229e:	8c cf       	rjmp	.-232    	; 0x21b8 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    22a0:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    22a4:	89 cf       	rjmp	.-238    	; 0x21b8 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    22a6:	8a 81       	ldd	r24, Y+2	; 0x02
    22a8:	9b 81       	ldd	r25, Y+3	; 0x03
    22aa:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    22ae:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    22b2:	82 cf       	rjmp	.-252    	; 0x21b8 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    22b4:	8a 81       	ldd	r24, Y+2	; 0x02
    22b6:	9b 81       	ldd	r25, Y+3	; 0x03
    22b8:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    22bc:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22c0:	8a 81       	ldd	r24, Y+2	; 0x02
    22c2:	9b 81       	ldd	r25, Y+3	; 0x03
    22c4:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    22c8:	88 23       	and	r24, r24
    22ca:	09 f4       	brne	.+2      	; 0x22ce <xQueueReceive+0x140>
    22cc:	75 cf       	rjmp	.-278    	; 0x21b8 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    22ce:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    22d0:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    22d2:	2e 96       	adiw	r28, 0x0e	; 14
    22d4:	0f b6       	in	r0, 0x3f	; 63
    22d6:	f8 94       	cli
    22d8:	de bf       	out	0x3e, r29	; 62
    22da:	0f be       	out	0x3f, r0	; 63
    22dc:	cd bf       	out	0x3d, r28	; 61
    22de:	cf 91       	pop	r28
    22e0:	df 91       	pop	r29
    22e2:	08 95       	ret

000022e4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    22e4:	df 93       	push	r29
    22e6:	cf 93       	push	r28
    22e8:	cd b7       	in	r28, 0x3d	; 61
    22ea:	de b7       	in	r29, 0x3e	; 62
    22ec:	2c 97       	sbiw	r28, 0x0c	; 12
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	de bf       	out	0x3e, r29	; 62
    22f4:	0f be       	out	0x3f, r0	; 63
    22f6:	cd bf       	out	0x3d, r28	; 61
    22f8:	99 87       	std	Y+9, r25	; 0x09
    22fa:	88 87       	std	Y+8, r24	; 0x08
    22fc:	7b 87       	std	Y+11, r23	; 0x0b
    22fe:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2300:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2302:	88 85       	ldd	r24, Y+8	; 0x08
    2304:	99 85       	ldd	r25, Y+9	; 0x09
    2306:	9b 83       	std	Y+3, r25	; 0x03
    2308:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    230a:	0f b6       	in	r0, 0x3f	; 63
    230c:	f8 94       	cli
    230e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2310:	ea 81       	ldd	r30, Y+2	; 0x02
    2312:	fb 81       	ldd	r31, Y+3	; 0x03
    2314:	82 8d       	ldd	r24, Z+26	; 0x1a
    2316:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	88 23       	and	r24, r24
    231c:	c1 f0       	breq	.+48     	; 0x234e <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    231e:	89 81       	ldd	r24, Y+1	; 0x01
    2320:	81 50       	subi	r24, 0x01	; 1
    2322:	ea 81       	ldd	r30, Y+2	; 0x02
    2324:	fb 81       	ldd	r31, Y+3	; 0x03
    2326:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2328:	ea 81       	ldd	r30, Y+2	; 0x02
    232a:	fb 81       	ldd	r31, Y+3	; 0x03
    232c:	80 85       	ldd	r24, Z+8	; 0x08
    232e:	88 23       	and	r24, r24
    2330:	49 f0       	breq	.+18     	; 0x2344 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2332:	8a 81       	ldd	r24, Y+2	; 0x02
    2334:	9b 81       	ldd	r25, Y+3	; 0x03
    2336:	08 96       	adiw	r24, 0x08	; 8
    2338:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    233c:	88 23       	and	r24, r24
    233e:	11 f0       	breq	.+4      	; 0x2344 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2340:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2344:	0f 90       	pop	r0
    2346:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	8c 87       	std	Y+12, r24	; 0x0c
    234c:	63 c0       	rjmp	.+198    	; 0x2414 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    234e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2350:	9b 85       	ldd	r25, Y+11	; 0x0b
    2352:	00 97       	sbiw	r24, 0x00	; 0
    2354:	21 f4       	brne	.+8      	; 0x235e <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2356:	0f 90       	pop	r0
    2358:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    235a:	1c 86       	std	Y+12, r1	; 0x0c
    235c:	5b c0       	rjmp	.+182    	; 0x2414 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    235e:	8c 81       	ldd	r24, Y+4	; 0x04
    2360:	88 23       	and	r24, r24
    2362:	31 f4       	brne	.+12     	; 0x2370 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2364:	ce 01       	movw	r24, r28
    2366:	05 96       	adiw	r24, 0x05	; 5
    2368:	0e 94 87 24 	call	0x490e	; 0x490e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2370:	0f 90       	pop	r0
    2372:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2374:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2378:	0f b6       	in	r0, 0x3f	; 63
    237a:	f8 94       	cli
    237c:	0f 92       	push	r0
    237e:	ea 81       	ldd	r30, Y+2	; 0x02
    2380:	fb 81       	ldd	r31, Y+3	; 0x03
    2382:	85 8d       	ldd	r24, Z+29	; 0x1d
    2384:	8f 3f       	cpi	r24, 0xFF	; 255
    2386:	19 f4       	brne	.+6      	; 0x238e <xQueueSemaphoreTake+0xaa>
    2388:	ea 81       	ldd	r30, Y+2	; 0x02
    238a:	fb 81       	ldd	r31, Y+3	; 0x03
    238c:	15 8e       	std	Z+29, r1	; 0x1d
    238e:	ea 81       	ldd	r30, Y+2	; 0x02
    2390:	fb 81       	ldd	r31, Y+3	; 0x03
    2392:	86 8d       	ldd	r24, Z+30	; 0x1e
    2394:	8f 3f       	cpi	r24, 0xFF	; 255
    2396:	19 f4       	brne	.+6      	; 0x239e <xQueueSemaphoreTake+0xba>
    2398:	ea 81       	ldd	r30, Y+2	; 0x02
    239a:	fb 81       	ldd	r31, Y+3	; 0x03
    239c:	16 8e       	std	Z+30, r1	; 0x1e
    239e:	0f 90       	pop	r0
    23a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23a2:	ce 01       	movw	r24, r28
    23a4:	05 96       	adiw	r24, 0x05	; 5
    23a6:	9e 01       	movw	r18, r28
    23a8:	26 5f       	subi	r18, 0xF6	; 246
    23aa:	3f 4f       	sbci	r19, 0xFF	; 255
    23ac:	b9 01       	movw	r22, r18
    23ae:	0e 94 a0 24 	call	0x4940	; 0x4940 <xTaskCheckForTimeOut>
    23b2:	88 23       	and	r24, r24
    23b4:	09 f5       	brne	.+66     	; 0x23f8 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23b6:	8a 81       	ldd	r24, Y+2	; 0x02
    23b8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ba:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    23be:	88 23       	and	r24, r24
    23c0:	a1 f0       	breq	.+40     	; 0x23ea <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23c2:	8a 81       	ldd	r24, Y+2	; 0x02
    23c4:	9b 81       	ldd	r25, Y+3	; 0x03
    23c6:	41 96       	adiw	r24, 0x11	; 17
    23c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    23ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    23cc:	b9 01       	movw	r22, r18
    23ce:	0e 94 4f 23 	call	0x469e	; 0x469e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    23d2:	8a 81       	ldd	r24, Y+2	; 0x02
    23d4:	9b 81       	ldd	r25, Y+3	; 0x03
    23d6:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    23da:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    23de:	88 23       	and	r24, r24
    23e0:	09 f0       	breq	.+2      	; 0x23e4 <xQueueSemaphoreTake+0x100>
    23e2:	93 cf       	rjmp	.-218    	; 0x230a <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    23e4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    23e8:	90 cf       	rjmp	.-224    	; 0x230a <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    23ea:	8a 81       	ldd	r24, Y+2	; 0x02
    23ec:	9b 81       	ldd	r25, Y+3	; 0x03
    23ee:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    23f2:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    23f6:	89 cf       	rjmp	.-238    	; 0x230a <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    23f8:	8a 81       	ldd	r24, Y+2	; 0x02
    23fa:	9b 81       	ldd	r25, Y+3	; 0x03
    23fc:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2400:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2404:	8a 81       	ldd	r24, Y+2	; 0x02
    2406:	9b 81       	ldd	r25, Y+3	; 0x03
    2408:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    240c:	88 23       	and	r24, r24
    240e:	09 f4       	brne	.+2      	; 0x2412 <xQueueSemaphoreTake+0x12e>
    2410:	7c cf       	rjmp	.-264    	; 0x230a <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2412:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2414:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2416:	2c 96       	adiw	r28, 0x0c	; 12
    2418:	0f b6       	in	r0, 0x3f	; 63
    241a:	f8 94       	cli
    241c:	de bf       	out	0x3e, r29	; 62
    241e:	0f be       	out	0x3f, r0	; 63
    2420:	cd bf       	out	0x3d, r28	; 61
    2422:	cf 91       	pop	r28
    2424:	df 91       	pop	r29
    2426:	08 95       	ret

00002428 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2428:	df 93       	push	r29
    242a:	cf 93       	push	r28
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	60 97       	sbiw	r28, 0x10	; 16
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
    2436:	de bf       	out	0x3e, r29	; 62
    2438:	0f be       	out	0x3f, r0	; 63
    243a:	cd bf       	out	0x3d, r28	; 61
    243c:	9b 87       	std	Y+11, r25	; 0x0b
    243e:	8a 87       	std	Y+10, r24	; 0x0a
    2440:	7d 87       	std	Y+13, r23	; 0x0d
    2442:	6c 87       	std	Y+12, r22	; 0x0c
    2444:	5f 87       	std	Y+15, r21	; 0x0f
    2446:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2448:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    244a:	8a 85       	ldd	r24, Y+10	; 0x0a
    244c:	9b 85       	ldd	r25, Y+11	; 0x0b
    244e:	9b 83       	std	Y+3, r25	; 0x03
    2450:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2458:	ea 81       	ldd	r30, Y+2	; 0x02
    245a:	fb 81       	ldd	r31, Y+3	; 0x03
    245c:	82 8d       	ldd	r24, Z+26	; 0x1a
    245e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2460:	89 81       	ldd	r24, Y+1	; 0x01
    2462:	88 23       	and	r24, r24
    2464:	31 f1       	breq	.+76     	; 0x24b2 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2466:	ea 81       	ldd	r30, Y+2	; 0x02
    2468:	fb 81       	ldd	r31, Y+3	; 0x03
    246a:	86 81       	ldd	r24, Z+6	; 0x06
    246c:	97 81       	ldd	r25, Z+7	; 0x07
    246e:	9d 83       	std	Y+5, r25	; 0x05
    2470:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2472:	8a 81       	ldd	r24, Y+2	; 0x02
    2474:	9b 81       	ldd	r25, Y+3	; 0x03
    2476:	2c 85       	ldd	r18, Y+12	; 0x0c
    2478:	3d 85       	ldd	r19, Y+13	; 0x0d
    247a:	b9 01       	movw	r22, r18
    247c:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2480:	ea 81       	ldd	r30, Y+2	; 0x02
    2482:	fb 81       	ldd	r31, Y+3	; 0x03
    2484:	8c 81       	ldd	r24, Y+4	; 0x04
    2486:	9d 81       	ldd	r25, Y+5	; 0x05
    2488:	97 83       	std	Z+7, r25	; 0x07
    248a:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    248c:	ea 81       	ldd	r30, Y+2	; 0x02
    248e:	fb 81       	ldd	r31, Y+3	; 0x03
    2490:	81 89       	ldd	r24, Z+17	; 0x11
    2492:	88 23       	and	r24, r24
    2494:	49 f0       	breq	.+18     	; 0x24a8 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2496:	8a 81       	ldd	r24, Y+2	; 0x02
    2498:	9b 81       	ldd	r25, Y+3	; 0x03
    249a:	41 96       	adiw	r24, 0x11	; 17
    249c:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    24a0:	88 23       	and	r24, r24
    24a2:	11 f0       	breq	.+4      	; 0x24a8 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    24a4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    24a8:	0f 90       	pop	r0
    24aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    24ac:	81 e0       	ldi	r24, 0x01	; 1
    24ae:	88 8b       	std	Y+16, r24	; 0x10
    24b0:	63 c0       	rjmp	.+198    	; 0x2578 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    24b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    24b4:	9f 85       	ldd	r25, Y+15	; 0x0f
    24b6:	00 97       	sbiw	r24, 0x00	; 0
    24b8:	21 f4       	brne	.+8      	; 0x24c2 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    24ba:	0f 90       	pop	r0
    24bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    24be:	18 8a       	std	Y+16, r1	; 0x10
    24c0:	5b c0       	rjmp	.+182    	; 0x2578 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    24c2:	8e 81       	ldd	r24, Y+6	; 0x06
    24c4:	88 23       	and	r24, r24
    24c6:	31 f4       	brne	.+12     	; 0x24d4 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    24c8:	ce 01       	movw	r24, r28
    24ca:	07 96       	adiw	r24, 0x07	; 7
    24cc:	0e 94 87 24 	call	0x490e	; 0x490e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    24d4:	0f 90       	pop	r0
    24d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    24d8:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	0f 92       	push	r0
    24e2:	ea 81       	ldd	r30, Y+2	; 0x02
    24e4:	fb 81       	ldd	r31, Y+3	; 0x03
    24e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    24e8:	8f 3f       	cpi	r24, 0xFF	; 255
    24ea:	19 f4       	brne	.+6      	; 0x24f2 <xQueuePeek+0xca>
    24ec:	ea 81       	ldd	r30, Y+2	; 0x02
    24ee:	fb 81       	ldd	r31, Y+3	; 0x03
    24f0:	15 8e       	std	Z+29, r1	; 0x1d
    24f2:	ea 81       	ldd	r30, Y+2	; 0x02
    24f4:	fb 81       	ldd	r31, Y+3	; 0x03
    24f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    24f8:	8f 3f       	cpi	r24, 0xFF	; 255
    24fa:	19 f4       	brne	.+6      	; 0x2502 <xQueuePeek+0xda>
    24fc:	ea 81       	ldd	r30, Y+2	; 0x02
    24fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2500:	16 8e       	std	Z+30, r1	; 0x1e
    2502:	0f 90       	pop	r0
    2504:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2506:	ce 01       	movw	r24, r28
    2508:	07 96       	adiw	r24, 0x07	; 7
    250a:	9e 01       	movw	r18, r28
    250c:	22 5f       	subi	r18, 0xF2	; 242
    250e:	3f 4f       	sbci	r19, 0xFF	; 255
    2510:	b9 01       	movw	r22, r18
    2512:	0e 94 a0 24 	call	0x4940	; 0x4940 <xTaskCheckForTimeOut>
    2516:	88 23       	and	r24, r24
    2518:	09 f5       	brne	.+66     	; 0x255c <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    251a:	8a 81       	ldd	r24, Y+2	; 0x02
    251c:	9b 81       	ldd	r25, Y+3	; 0x03
    251e:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    2522:	88 23       	and	r24, r24
    2524:	a1 f0       	breq	.+40     	; 0x254e <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2526:	8a 81       	ldd	r24, Y+2	; 0x02
    2528:	9b 81       	ldd	r25, Y+3	; 0x03
    252a:	41 96       	adiw	r24, 0x11	; 17
    252c:	2e 85       	ldd	r18, Y+14	; 0x0e
    252e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2530:	b9 01       	movw	r22, r18
    2532:	0e 94 4f 23 	call	0x469e	; 0x469e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2536:	8a 81       	ldd	r24, Y+2	; 0x02
    2538:	9b 81       	ldd	r25, Y+3	; 0x03
    253a:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    253e:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    2542:	88 23       	and	r24, r24
    2544:	09 f0       	breq	.+2      	; 0x2548 <xQueuePeek+0x120>
    2546:	85 cf       	rjmp	.-246    	; 0x2452 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2548:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    254c:	82 cf       	rjmp	.-252    	; 0x2452 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    254e:	8a 81       	ldd	r24, Y+2	; 0x02
    2550:	9b 81       	ldd	r25, Y+3	; 0x03
    2552:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2556:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    255a:	7b cf       	rjmp	.-266    	; 0x2452 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    255c:	8a 81       	ldd	r24, Y+2	; 0x02
    255e:	9b 81       	ldd	r25, Y+3	; 0x03
    2560:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2564:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2568:	8a 81       	ldd	r24, Y+2	; 0x02
    256a:	9b 81       	ldd	r25, Y+3	; 0x03
    256c:	0e 94 04 15 	call	0x2a08	; 0x2a08 <prvIsQueueEmpty>
    2570:	88 23       	and	r24, r24
    2572:	09 f4       	brne	.+2      	; 0x2576 <xQueuePeek+0x14e>
    2574:	6e cf       	rjmp	.-292    	; 0x2452 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2576:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2578:	88 89       	ldd	r24, Y+16	; 0x10
}
    257a:	60 96       	adiw	r28, 0x10	; 16
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	f8 94       	cli
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	cd bf       	out	0x3d, r28	; 61
    2586:	cf 91       	pop	r28
    2588:	df 91       	pop	r29
    258a:	08 95       	ret

0000258c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
    2594:	2c 97       	sbiw	r28, 0x0c	; 12
    2596:	0f b6       	in	r0, 0x3f	; 63
    2598:	f8 94       	cli
    259a:	de bf       	out	0x3e, r29	; 62
    259c:	0f be       	out	0x3f, r0	; 63
    259e:	cd bf       	out	0x3d, r28	; 61
    25a0:	98 87       	std	Y+8, r25	; 0x08
    25a2:	8f 83       	std	Y+7, r24	; 0x07
    25a4:	7a 87       	std	Y+10, r23	; 0x0a
    25a6:	69 87       	std	Y+9, r22	; 0x09
    25a8:	5c 87       	std	Y+12, r21	; 0x0c
    25aa:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    25ac:	8f 81       	ldd	r24, Y+7	; 0x07
    25ae:	98 85       	ldd	r25, Y+8	; 0x08
    25b0:	9c 83       	std	Y+4, r25	; 0x04
    25b2:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    25b4:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25b6:	eb 81       	ldd	r30, Y+3	; 0x03
    25b8:	fc 81       	ldd	r31, Y+4	; 0x04
    25ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    25bc:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25be:	8a 81       	ldd	r24, Y+2	; 0x02
    25c0:	88 23       	and	r24, r24
    25c2:	81 f1       	breq	.+96     	; 0x2624 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    25c4:	eb 81       	ldd	r30, Y+3	; 0x03
    25c6:	fc 81       	ldd	r31, Y+4	; 0x04
    25c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    25ca:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    25cc:	8b 81       	ldd	r24, Y+3	; 0x03
    25ce:	9c 81       	ldd	r25, Y+4	; 0x04
    25d0:	29 85       	ldd	r18, Y+9	; 0x09
    25d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    25d4:	b9 01       	movw	r22, r18
    25d6:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    25da:	8a 81       	ldd	r24, Y+2	; 0x02
    25dc:	81 50       	subi	r24, 0x01	; 1
    25de:	eb 81       	ldd	r30, Y+3	; 0x03
    25e0:	fc 81       	ldd	r31, Y+4	; 0x04
    25e2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    25e4:	89 81       	ldd	r24, Y+1	; 0x01
    25e6:	8f 3f       	cpi	r24, 0xFF	; 255
    25e8:	a9 f4       	brne	.+42     	; 0x2614 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25ea:	eb 81       	ldd	r30, Y+3	; 0x03
    25ec:	fc 81       	ldd	r31, Y+4	; 0x04
    25ee:	80 85       	ldd	r24, Z+8	; 0x08
    25f0:	88 23       	and	r24, r24
    25f2:	a9 f0       	breq	.+42     	; 0x261e <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    25f4:	8b 81       	ldd	r24, Y+3	; 0x03
    25f6:	9c 81       	ldd	r25, Y+4	; 0x04
    25f8:	08 96       	adiw	r24, 0x08	; 8
    25fa:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    25fe:	88 23       	and	r24, r24
    2600:	71 f0       	breq	.+28     	; 0x261e <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2602:	8b 85       	ldd	r24, Y+11	; 0x0b
    2604:	9c 85       	ldd	r25, Y+12	; 0x0c
    2606:	00 97       	sbiw	r24, 0x00	; 0
    2608:	51 f0       	breq	.+20     	; 0x261e <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    260a:	eb 85       	ldd	r30, Y+11	; 0x0b
    260c:	fc 85       	ldd	r31, Y+12	; 0x0c
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	80 83       	st	Z, r24
    2612:	05 c0       	rjmp	.+10     	; 0x261e <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2614:	89 81       	ldd	r24, Y+1	; 0x01
    2616:	8f 5f       	subi	r24, 0xFF	; 255
    2618:	eb 81       	ldd	r30, Y+3	; 0x03
    261a:	fc 81       	ldd	r31, Y+4	; 0x04
    261c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	8e 83       	std	Y+6, r24	; 0x06
    2622:	01 c0       	rjmp	.+2      	; 0x2626 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2624:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2626:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2628:	2c 96       	adiw	r28, 0x0c	; 12
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	f8 94       	cli
    262e:	de bf       	out	0x3e, r29	; 62
    2630:	0f be       	out	0x3f, r0	; 63
    2632:	cd bf       	out	0x3d, r28	; 61
    2634:	cf 91       	pop	r28
    2636:	df 91       	pop	r29
    2638:	08 95       	ret

0000263a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    263a:	df 93       	push	r29
    263c:	cf 93       	push	r28
    263e:	cd b7       	in	r28, 0x3d	; 61
    2640:	de b7       	in	r29, 0x3e	; 62
    2642:	2a 97       	sbiw	r28, 0x0a	; 10
    2644:	0f b6       	in	r0, 0x3f	; 63
    2646:	f8 94       	cli
    2648:	de bf       	out	0x3e, r29	; 62
    264a:	0f be       	out	0x3f, r0	; 63
    264c:	cd bf       	out	0x3d, r28	; 61
    264e:	98 87       	std	Y+8, r25	; 0x08
    2650:	8f 83       	std	Y+7, r24	; 0x07
    2652:	7a 87       	std	Y+10, r23	; 0x0a
    2654:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2656:	8f 81       	ldd	r24, Y+7	; 0x07
    2658:	98 85       	ldd	r25, Y+8	; 0x08
    265a:	9a 83       	std	Y+2, r25	; 0x02
    265c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    265e:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2660:	e9 81       	ldd	r30, Y+1	; 0x01
    2662:	fa 81       	ldd	r31, Y+2	; 0x02
    2664:	82 8d       	ldd	r24, Z+26	; 0x1a
    2666:	88 23       	and	r24, r24
    2668:	b1 f0       	breq	.+44     	; 0x2696 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    266a:	e9 81       	ldd	r30, Y+1	; 0x01
    266c:	fa 81       	ldd	r31, Y+2	; 0x02
    266e:	86 81       	ldd	r24, Z+6	; 0x06
    2670:	97 81       	ldd	r25, Z+7	; 0x07
    2672:	9c 83       	std	Y+4, r25	; 0x04
    2674:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	9a 81       	ldd	r25, Y+2	; 0x02
    267a:	29 85       	ldd	r18, Y+9	; 0x09
    267c:	3a 85       	ldd	r19, Y+10	; 0x0a
    267e:	b9 01       	movw	r22, r18
    2680:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2684:	e9 81       	ldd	r30, Y+1	; 0x01
    2686:	fa 81       	ldd	r31, Y+2	; 0x02
    2688:	8b 81       	ldd	r24, Y+3	; 0x03
    268a:	9c 81       	ldd	r25, Y+4	; 0x04
    268c:	97 83       	std	Z+7, r25	; 0x07
    268e:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2690:	81 e0       	ldi	r24, 0x01	; 1
    2692:	8e 83       	std	Y+6, r24	; 0x06
    2694:	01 c0       	rjmp	.+2      	; 0x2698 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2696:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2698:	8e 81       	ldd	r24, Y+6	; 0x06
}
    269a:	2a 96       	adiw	r28, 0x0a	; 10
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	de bf       	out	0x3e, r29	; 62
    26a2:	0f be       	out	0x3f, r0	; 63
    26a4:	cd bf       	out	0x3d, r28	; 61
    26a6:	cf 91       	pop	r28
    26a8:	df 91       	pop	r29
    26aa:	08 95       	ret

000026ac <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    26ac:	df 93       	push	r29
    26ae:	cf 93       	push	r28
    26b0:	00 d0       	rcall	.+0      	; 0x26b2 <uxQueueMessagesWaiting+0x6>
    26b2:	0f 92       	push	r0
    26b4:	cd b7       	in	r28, 0x3d	; 61
    26b6:	de b7       	in	r29, 0x3e	; 62
    26b8:	9b 83       	std	Y+3, r25	; 0x03
    26ba:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    26c2:	ea 81       	ldd	r30, Y+2	; 0x02
    26c4:	fb 81       	ldd	r31, Y+3	; 0x03
    26c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    26ca:	0f 90       	pop	r0
    26cc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    26ce:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    26d0:	0f 90       	pop	r0
    26d2:	0f 90       	pop	r0
    26d4:	0f 90       	pop	r0
    26d6:	cf 91       	pop	r28
    26d8:	df 91       	pop	r29
    26da:	08 95       	ret

000026dc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    26dc:	df 93       	push	r29
    26de:	cf 93       	push	r28
    26e0:	00 d0       	rcall	.+0      	; 0x26e2 <uxQueueSpacesAvailable+0x6>
    26e2:	00 d0       	rcall	.+0      	; 0x26e4 <uxQueueSpacesAvailable+0x8>
    26e4:	0f 92       	push	r0
    26e6:	cd b7       	in	r28, 0x3d	; 61
    26e8:	de b7       	in	r29, 0x3e	; 62
    26ea:	9d 83       	std	Y+5, r25	; 0x05
    26ec:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    26ee:	8c 81       	ldd	r24, Y+4	; 0x04
    26f0:	9d 81       	ldd	r25, Y+5	; 0x05
    26f2:	9a 83       	std	Y+2, r25	; 0x02
    26f4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    26f6:	0f b6       	in	r0, 0x3f	; 63
    26f8:	f8 94       	cli
    26fa:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    26fc:	e9 81       	ldd	r30, Y+1	; 0x01
    26fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2700:	93 8d       	ldd	r25, Z+27	; 0x1b
    2702:	e9 81       	ldd	r30, Y+1	; 0x01
    2704:	fa 81       	ldd	r31, Y+2	; 0x02
    2706:	82 8d       	ldd	r24, Z+26	; 0x1a
    2708:	29 2f       	mov	r18, r25
    270a:	28 1b       	sub	r18, r24
    270c:	82 2f       	mov	r24, r18
    270e:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2710:	0f 90       	pop	r0
    2712:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2714:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2716:	0f 90       	pop	r0
    2718:	0f 90       	pop	r0
    271a:	0f 90       	pop	r0
    271c:	0f 90       	pop	r0
    271e:	0f 90       	pop	r0
    2720:	cf 91       	pop	r28
    2722:	df 91       	pop	r29
    2724:	08 95       	ret

00002726 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2726:	df 93       	push	r29
    2728:	cf 93       	push	r28
    272a:	00 d0       	rcall	.+0      	; 0x272c <uxQueueMessagesWaitingFromISR+0x6>
    272c:	00 d0       	rcall	.+0      	; 0x272e <uxQueueMessagesWaitingFromISR+0x8>
    272e:	0f 92       	push	r0
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
    2734:	9d 83       	std	Y+5, r25	; 0x05
    2736:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2738:	8c 81       	ldd	r24, Y+4	; 0x04
    273a:	9d 81       	ldd	r25, Y+5	; 0x05
    273c:	9a 83       	std	Y+2, r25	; 0x02
    273e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2740:	e9 81       	ldd	r30, Y+1	; 0x01
    2742:	fa 81       	ldd	r31, Y+2	; 0x02
    2744:	82 8d       	ldd	r24, Z+26	; 0x1a
    2746:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    274a:	0f 90       	pop	r0
    274c:	0f 90       	pop	r0
    274e:	0f 90       	pop	r0
    2750:	0f 90       	pop	r0
    2752:	0f 90       	pop	r0
    2754:	cf 91       	pop	r28
    2756:	df 91       	pop	r29
    2758:	08 95       	ret

0000275a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    275a:	df 93       	push	r29
    275c:	cf 93       	push	r28
    275e:	00 d0       	rcall	.+0      	; 0x2760 <vQueueDelete+0x6>
    2760:	00 d0       	rcall	.+0      	; 0x2762 <vQueueDelete+0x8>
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
    2766:	9c 83       	std	Y+4, r25	; 0x04
    2768:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    276a:	8b 81       	ldd	r24, Y+3	; 0x03
    276c:	9c 81       	ldd	r25, Y+4	; 0x04
    276e:	9a 83       	std	Y+2, r25	; 0x02
    2770:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2772:	89 81       	ldd	r24, Y+1	; 0x01
    2774:	9a 81       	ldd	r25, Y+2	; 0x02
    2776:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    277a:	0f 90       	pop	r0
    277c:	0f 90       	pop	r0
    277e:	0f 90       	pop	r0
    2780:	0f 90       	pop	r0
    2782:	cf 91       	pop	r28
    2784:	df 91       	pop	r29
    2786:	08 95       	ret

00002788 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2788:	df 93       	push	r29
    278a:	cf 93       	push	r28
    278c:	cd b7       	in	r28, 0x3d	; 61
    278e:	de b7       	in	r29, 0x3e	; 62
    2790:	27 97       	sbiw	r28, 0x07	; 7
    2792:	0f b6       	in	r0, 0x3f	; 63
    2794:	f8 94       	cli
    2796:	de bf       	out	0x3e, r29	; 62
    2798:	0f be       	out	0x3f, r0	; 63
    279a:	cd bf       	out	0x3d, r28	; 61
    279c:	9c 83       	std	Y+4, r25	; 0x04
    279e:	8b 83       	std	Y+3, r24	; 0x03
    27a0:	7e 83       	std	Y+6, r23	; 0x06
    27a2:	6d 83       	std	Y+5, r22	; 0x05
    27a4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    27a6:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27a8:	eb 81       	ldd	r30, Y+3	; 0x03
    27aa:	fc 81       	ldd	r31, Y+4	; 0x04
    27ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    27ae:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    27b0:	eb 81       	ldd	r30, Y+3	; 0x03
    27b2:	fc 81       	ldd	r31, Y+4	; 0x04
    27b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    27b6:	88 23       	and	r24, r24
    27b8:	09 f4       	brne	.+2      	; 0x27bc <prvCopyDataToQueue+0x34>
    27ba:	7d c0       	rjmp	.+250    	; 0x28b6 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    27bc:	8f 81       	ldd	r24, Y+7	; 0x07
    27be:	88 23       	and	r24, r24
    27c0:	99 f5       	brne	.+102    	; 0x2828 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    27c2:	eb 81       	ldd	r30, Y+3	; 0x03
    27c4:	fc 81       	ldd	r31, Y+4	; 0x04
    27c6:	62 81       	ldd	r22, Z+2	; 0x02
    27c8:	73 81       	ldd	r23, Z+3	; 0x03
    27ca:	eb 81       	ldd	r30, Y+3	; 0x03
    27cc:	fc 81       	ldd	r31, Y+4	; 0x04
    27ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    27d0:	48 2f       	mov	r20, r24
    27d2:	50 e0       	ldi	r21, 0x00	; 0
    27d4:	2d 81       	ldd	r18, Y+5	; 0x05
    27d6:	3e 81       	ldd	r19, Y+6	; 0x06
    27d8:	cb 01       	movw	r24, r22
    27da:	b9 01       	movw	r22, r18
    27dc:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    27e0:	eb 81       	ldd	r30, Y+3	; 0x03
    27e2:	fc 81       	ldd	r31, Y+4	; 0x04
    27e4:	22 81       	ldd	r18, Z+2	; 0x02
    27e6:	33 81       	ldd	r19, Z+3	; 0x03
    27e8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ea:	fc 81       	ldd	r31, Y+4	; 0x04
    27ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    27ee:	88 2f       	mov	r24, r24
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	82 0f       	add	r24, r18
    27f4:	93 1f       	adc	r25, r19
    27f6:	eb 81       	ldd	r30, Y+3	; 0x03
    27f8:	fc 81       	ldd	r31, Y+4	; 0x04
    27fa:	93 83       	std	Z+3, r25	; 0x03
    27fc:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    27fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2800:	fc 81       	ldd	r31, Y+4	; 0x04
    2802:	22 81       	ldd	r18, Z+2	; 0x02
    2804:	33 81       	ldd	r19, Z+3	; 0x03
    2806:	eb 81       	ldd	r30, Y+3	; 0x03
    2808:	fc 81       	ldd	r31, Y+4	; 0x04
    280a:	84 81       	ldd	r24, Z+4	; 0x04
    280c:	95 81       	ldd	r25, Z+5	; 0x05
    280e:	28 17       	cp	r18, r24
    2810:	39 07       	cpc	r19, r25
    2812:	08 f4       	brcc	.+2      	; 0x2816 <prvCopyDataToQueue+0x8e>
    2814:	50 c0       	rjmp	.+160    	; 0x28b6 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2816:	eb 81       	ldd	r30, Y+3	; 0x03
    2818:	fc 81       	ldd	r31, Y+4	; 0x04
    281a:	80 81       	ld	r24, Z
    281c:	91 81       	ldd	r25, Z+1	; 0x01
    281e:	eb 81       	ldd	r30, Y+3	; 0x03
    2820:	fc 81       	ldd	r31, Y+4	; 0x04
    2822:	93 83       	std	Z+3, r25	; 0x03
    2824:	82 83       	std	Z+2, r24	; 0x02
    2826:	47 c0       	rjmp	.+142    	; 0x28b6 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2828:	eb 81       	ldd	r30, Y+3	; 0x03
    282a:	fc 81       	ldd	r31, Y+4	; 0x04
    282c:	66 81       	ldd	r22, Z+6	; 0x06
    282e:	77 81       	ldd	r23, Z+7	; 0x07
    2830:	eb 81       	ldd	r30, Y+3	; 0x03
    2832:	fc 81       	ldd	r31, Y+4	; 0x04
    2834:	84 8d       	ldd	r24, Z+28	; 0x1c
    2836:	48 2f       	mov	r20, r24
    2838:	50 e0       	ldi	r21, 0x00	; 0
    283a:	2d 81       	ldd	r18, Y+5	; 0x05
    283c:	3e 81       	ldd	r19, Y+6	; 0x06
    283e:	cb 01       	movw	r24, r22
    2840:	b9 01       	movw	r22, r18
    2842:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2846:	eb 81       	ldd	r30, Y+3	; 0x03
    2848:	fc 81       	ldd	r31, Y+4	; 0x04
    284a:	26 81       	ldd	r18, Z+6	; 0x06
    284c:	37 81       	ldd	r19, Z+7	; 0x07
    284e:	eb 81       	ldd	r30, Y+3	; 0x03
    2850:	fc 81       	ldd	r31, Y+4	; 0x04
    2852:	84 8d       	ldd	r24, Z+28	; 0x1c
    2854:	88 2f       	mov	r24, r24
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	90 95       	com	r25
    285a:	81 95       	neg	r24
    285c:	9f 4f       	sbci	r25, 0xFF	; 255
    285e:	82 0f       	add	r24, r18
    2860:	93 1f       	adc	r25, r19
    2862:	eb 81       	ldd	r30, Y+3	; 0x03
    2864:	fc 81       	ldd	r31, Y+4	; 0x04
    2866:	97 83       	std	Z+7, r25	; 0x07
    2868:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    286a:	eb 81       	ldd	r30, Y+3	; 0x03
    286c:	fc 81       	ldd	r31, Y+4	; 0x04
    286e:	26 81       	ldd	r18, Z+6	; 0x06
    2870:	37 81       	ldd	r19, Z+7	; 0x07
    2872:	eb 81       	ldd	r30, Y+3	; 0x03
    2874:	fc 81       	ldd	r31, Y+4	; 0x04
    2876:	80 81       	ld	r24, Z
    2878:	91 81       	ldd	r25, Z+1	; 0x01
    287a:	28 17       	cp	r18, r24
    287c:	39 07       	cpc	r19, r25
    287e:	90 f4       	brcc	.+36     	; 0x28a4 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2880:	eb 81       	ldd	r30, Y+3	; 0x03
    2882:	fc 81       	ldd	r31, Y+4	; 0x04
    2884:	24 81       	ldd	r18, Z+4	; 0x04
    2886:	35 81       	ldd	r19, Z+5	; 0x05
    2888:	eb 81       	ldd	r30, Y+3	; 0x03
    288a:	fc 81       	ldd	r31, Y+4	; 0x04
    288c:	84 8d       	ldd	r24, Z+28	; 0x1c
    288e:	88 2f       	mov	r24, r24
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	90 95       	com	r25
    2894:	81 95       	neg	r24
    2896:	9f 4f       	sbci	r25, 0xFF	; 255
    2898:	82 0f       	add	r24, r18
    289a:	93 1f       	adc	r25, r19
    289c:	eb 81       	ldd	r30, Y+3	; 0x03
    289e:	fc 81       	ldd	r31, Y+4	; 0x04
    28a0:	97 83       	std	Z+7, r25	; 0x07
    28a2:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    28a4:	8f 81       	ldd	r24, Y+7	; 0x07
    28a6:	82 30       	cpi	r24, 0x02	; 2
    28a8:	31 f4       	brne	.+12     	; 0x28b6 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28aa:	89 81       	ldd	r24, Y+1	; 0x01
    28ac:	88 23       	and	r24, r24
    28ae:	19 f0       	breq	.+6      	; 0x28b6 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	81 50       	subi	r24, 0x01	; 1
    28b4:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28b6:	89 81       	ldd	r24, Y+1	; 0x01
    28b8:	8f 5f       	subi	r24, 0xFF	; 255
    28ba:	eb 81       	ldd	r30, Y+3	; 0x03
    28bc:	fc 81       	ldd	r31, Y+4	; 0x04
    28be:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    28c0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    28c2:	27 96       	adiw	r28, 0x07	; 7
    28c4:	0f b6       	in	r0, 0x3f	; 63
    28c6:	f8 94       	cli
    28c8:	de bf       	out	0x3e, r29	; 62
    28ca:	0f be       	out	0x3f, r0	; 63
    28cc:	cd bf       	out	0x3d, r28	; 61
    28ce:	cf 91       	pop	r28
    28d0:	df 91       	pop	r29
    28d2:	08 95       	ret

000028d4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    28d4:	df 93       	push	r29
    28d6:	cf 93       	push	r28
    28d8:	00 d0       	rcall	.+0      	; 0x28da <prvCopyDataFromQueue+0x6>
    28da:	00 d0       	rcall	.+0      	; 0x28dc <prvCopyDataFromQueue+0x8>
    28dc:	cd b7       	in	r28, 0x3d	; 61
    28de:	de b7       	in	r29, 0x3e	; 62
    28e0:	9a 83       	std	Y+2, r25	; 0x02
    28e2:	89 83       	std	Y+1, r24	; 0x01
    28e4:	7c 83       	std	Y+4, r23	; 0x04
    28e6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    28e8:	e9 81       	ldd	r30, Y+1	; 0x01
    28ea:	fa 81       	ldd	r31, Y+2	; 0x02
    28ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    28ee:	88 23       	and	r24, r24
    28f0:	89 f1       	breq	.+98     	; 0x2954 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    28f2:	e9 81       	ldd	r30, Y+1	; 0x01
    28f4:	fa 81       	ldd	r31, Y+2	; 0x02
    28f6:	26 81       	ldd	r18, Z+6	; 0x06
    28f8:	37 81       	ldd	r19, Z+7	; 0x07
    28fa:	e9 81       	ldd	r30, Y+1	; 0x01
    28fc:	fa 81       	ldd	r31, Y+2	; 0x02
    28fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2900:	88 2f       	mov	r24, r24
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	82 0f       	add	r24, r18
    2906:	93 1f       	adc	r25, r19
    2908:	e9 81       	ldd	r30, Y+1	; 0x01
    290a:	fa 81       	ldd	r31, Y+2	; 0x02
    290c:	97 83       	std	Z+7, r25	; 0x07
    290e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2910:	e9 81       	ldd	r30, Y+1	; 0x01
    2912:	fa 81       	ldd	r31, Y+2	; 0x02
    2914:	26 81       	ldd	r18, Z+6	; 0x06
    2916:	37 81       	ldd	r19, Z+7	; 0x07
    2918:	e9 81       	ldd	r30, Y+1	; 0x01
    291a:	fa 81       	ldd	r31, Y+2	; 0x02
    291c:	84 81       	ldd	r24, Z+4	; 0x04
    291e:	95 81       	ldd	r25, Z+5	; 0x05
    2920:	28 17       	cp	r18, r24
    2922:	39 07       	cpc	r19, r25
    2924:	40 f0       	brcs	.+16     	; 0x2936 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2926:	e9 81       	ldd	r30, Y+1	; 0x01
    2928:	fa 81       	ldd	r31, Y+2	; 0x02
    292a:	80 81       	ld	r24, Z
    292c:	91 81       	ldd	r25, Z+1	; 0x01
    292e:	e9 81       	ldd	r30, Y+1	; 0x01
    2930:	fa 81       	ldd	r31, Y+2	; 0x02
    2932:	97 83       	std	Z+7, r25	; 0x07
    2934:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2936:	e9 81       	ldd	r30, Y+1	; 0x01
    2938:	fa 81       	ldd	r31, Y+2	; 0x02
    293a:	46 81       	ldd	r20, Z+6	; 0x06
    293c:	57 81       	ldd	r21, Z+7	; 0x07
    293e:	e9 81       	ldd	r30, Y+1	; 0x01
    2940:	fa 81       	ldd	r31, Y+2	; 0x02
    2942:	84 8d       	ldd	r24, Z+28	; 0x1c
    2944:	28 2f       	mov	r18, r24
    2946:	30 e0       	ldi	r19, 0x00	; 0
    2948:	8b 81       	ldd	r24, Y+3	; 0x03
    294a:	9c 81       	ldd	r25, Y+4	; 0x04
    294c:	ba 01       	movw	r22, r20
    294e:	a9 01       	movw	r20, r18
    2950:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
	}
}
    2954:	0f 90       	pop	r0
    2956:	0f 90       	pop	r0
    2958:	0f 90       	pop	r0
    295a:	0f 90       	pop	r0
    295c:	cf 91       	pop	r28
    295e:	df 91       	pop	r29
    2960:	08 95       	ret

00002962 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <prvUnlockQueue+0x6>
    2968:	00 d0       	rcall	.+0      	; 0x296a <prvUnlockQueue+0x8>
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	9c 83       	std	Y+4, r25	; 0x04
    2970:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2972:	0f b6       	in	r0, 0x3f	; 63
    2974:	f8 94       	cli
    2976:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2978:	eb 81       	ldd	r30, Y+3	; 0x03
    297a:	fc 81       	ldd	r31, Y+4	; 0x04
    297c:	86 8d       	ldd	r24, Z+30	; 0x1e
    297e:	8a 83       	std	Y+2, r24	; 0x02
    2980:	11 c0       	rjmp	.+34     	; 0x29a4 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2982:	eb 81       	ldd	r30, Y+3	; 0x03
    2984:	fc 81       	ldd	r31, Y+4	; 0x04
    2986:	81 89       	ldd	r24, Z+17	; 0x11
    2988:	88 23       	and	r24, r24
    298a:	79 f0       	breq	.+30     	; 0x29aa <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    298c:	8b 81       	ldd	r24, Y+3	; 0x03
    298e:	9c 81       	ldd	r25, Y+4	; 0x04
    2990:	41 96       	adiw	r24, 0x11	; 17
    2992:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    2996:	88 23       	and	r24, r24
    2998:	11 f0       	breq	.+4      	; 0x299e <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    299a:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    299e:	8a 81       	ldd	r24, Y+2	; 0x02
    29a0:	81 50       	subi	r24, 0x01	; 1
    29a2:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    29a4:	8a 81       	ldd	r24, Y+2	; 0x02
    29a6:	18 16       	cp	r1, r24
    29a8:	64 f3       	brlt	.-40     	; 0x2982 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    29aa:	eb 81       	ldd	r30, Y+3	; 0x03
    29ac:	fc 81       	ldd	r31, Y+4	; 0x04
    29ae:	8f ef       	ldi	r24, 0xFF	; 255
    29b0:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    29b2:	0f 90       	pop	r0
    29b4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    29b6:	0f b6       	in	r0, 0x3f	; 63
    29b8:	f8 94       	cli
    29ba:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    29bc:	eb 81       	ldd	r30, Y+3	; 0x03
    29be:	fc 81       	ldd	r31, Y+4	; 0x04
    29c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    29c2:	89 83       	std	Y+1, r24	; 0x01
    29c4:	11 c0       	rjmp	.+34     	; 0x29e8 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29c6:	eb 81       	ldd	r30, Y+3	; 0x03
    29c8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ca:	80 85       	ldd	r24, Z+8	; 0x08
    29cc:	88 23       	and	r24, r24
    29ce:	79 f0       	breq	.+30     	; 0x29ee <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    29d0:	8b 81       	ldd	r24, Y+3	; 0x03
    29d2:	9c 81       	ldd	r25, Y+4	; 0x04
    29d4:	08 96       	adiw	r24, 0x08	; 8
    29d6:	0e 94 a1 23 	call	0x4742	; 0x4742 <xTaskRemoveFromEventList>
    29da:	88 23       	and	r24, r24
    29dc:	11 f0       	breq	.+4      	; 0x29e2 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    29de:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    29e2:	89 81       	ldd	r24, Y+1	; 0x01
    29e4:	81 50       	subi	r24, 0x01	; 1
    29e6:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
    29ea:	18 16       	cp	r1, r24
    29ec:	64 f3       	brlt	.-40     	; 0x29c6 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    29ee:	eb 81       	ldd	r30, Y+3	; 0x03
    29f0:	fc 81       	ldd	r31, Y+4	; 0x04
    29f2:	8f ef       	ldi	r24, 0xFF	; 255
    29f4:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    29f6:	0f 90       	pop	r0
    29f8:	0f be       	out	0x3f, r0	; 63
}
    29fa:	0f 90       	pop	r0
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	0f 90       	pop	r0
    2a02:	cf 91       	pop	r28
    2a04:	df 91       	pop	r29
    2a06:	08 95       	ret

00002a08 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2a08:	df 93       	push	r29
    2a0a:	cf 93       	push	r28
    2a0c:	00 d0       	rcall	.+0      	; 0x2a0e <prvIsQueueEmpty+0x6>
    2a0e:	0f 92       	push	r0
    2a10:	cd b7       	in	r28, 0x3d	; 61
    2a12:	de b7       	in	r29, 0x3e	; 62
    2a14:	9b 83       	std	Y+3, r25	; 0x03
    2a16:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a18:	0f b6       	in	r0, 0x3f	; 63
    2a1a:	f8 94       	cli
    2a1c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2a1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a20:	fb 81       	ldd	r31, Y+3	; 0x03
    2a22:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a24:	88 23       	and	r24, r24
    2a26:	19 f4       	brne	.+6      	; 0x2a2e <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	89 83       	std	Y+1, r24	; 0x01
    2a2c:	01 c0       	rjmp	.+2      	; 0x2a30 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2a2e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a30:	0f 90       	pop	r0
    2a32:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a34:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a36:	0f 90       	pop	r0
    2a38:	0f 90       	pop	r0
    2a3a:	0f 90       	pop	r0
    2a3c:	cf 91       	pop	r28
    2a3e:	df 91       	pop	r29
    2a40:	08 95       	ret

00002a42 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2a42:	df 93       	push	r29
    2a44:	cf 93       	push	r28
    2a46:	00 d0       	rcall	.+0      	; 0x2a48 <xQueueIsQueueEmptyFromISR+0x6>
    2a48:	00 d0       	rcall	.+0      	; 0x2a4a <xQueueIsQueueEmptyFromISR+0x8>
    2a4a:	0f 92       	push	r0
    2a4c:	cd b7       	in	r28, 0x3d	; 61
    2a4e:	de b7       	in	r29, 0x3e	; 62
    2a50:	9d 83       	std	Y+5, r25	; 0x05
    2a52:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2a54:	8c 81       	ldd	r24, Y+4	; 0x04
    2a56:	9d 81       	ldd	r25, Y+5	; 0x05
    2a58:	9a 83       	std	Y+2, r25	; 0x02
    2a5a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a60:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a62:	88 23       	and	r24, r24
    2a64:	19 f4       	brne	.+6      	; 0x2a6c <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2a66:	81 e0       	ldi	r24, 0x01	; 1
    2a68:	8b 83       	std	Y+3, r24	; 0x03
    2a6a:	01 c0       	rjmp	.+2      	; 0x2a6e <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2a6c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a70:	0f 90       	pop	r0
    2a72:	0f 90       	pop	r0
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	0f 90       	pop	r0
    2a7a:	cf 91       	pop	r28
    2a7c:	df 91       	pop	r29
    2a7e:	08 95       	ret

00002a80 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2a80:	df 93       	push	r29
    2a82:	cf 93       	push	r28
    2a84:	00 d0       	rcall	.+0      	; 0x2a86 <prvIsQueueFull+0x6>
    2a86:	0f 92       	push	r0
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	9b 83       	std	Y+3, r25	; 0x03
    2a8e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a90:	0f b6       	in	r0, 0x3f	; 63
    2a92:	f8 94       	cli
    2a94:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2a96:	ea 81       	ldd	r30, Y+2	; 0x02
    2a98:	fb 81       	ldd	r31, Y+3	; 0x03
    2a9a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2aa0:	83 8d       	ldd	r24, Z+27	; 0x1b
    2aa2:	98 17       	cp	r25, r24
    2aa4:	19 f4       	brne	.+6      	; 0x2aac <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	89 83       	std	Y+1, r24	; 0x01
    2aaa:	01 c0       	rjmp	.+2      	; 0x2aae <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2aac:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2aae:	0f 90       	pop	r0
    2ab0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ab2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ab4:	0f 90       	pop	r0
    2ab6:	0f 90       	pop	r0
    2ab8:	0f 90       	pop	r0
    2aba:	cf 91       	pop	r28
    2abc:	df 91       	pop	r29
    2abe:	08 95       	ret

00002ac0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2ac0:	df 93       	push	r29
    2ac2:	cf 93       	push	r28
    2ac4:	00 d0       	rcall	.+0      	; 0x2ac6 <xQueueIsQueueFullFromISR+0x6>
    2ac6:	00 d0       	rcall	.+0      	; 0x2ac8 <xQueueIsQueueFullFromISR+0x8>
    2ac8:	0f 92       	push	r0
    2aca:	cd b7       	in	r28, 0x3d	; 61
    2acc:	de b7       	in	r29, 0x3e	; 62
    2ace:	9d 83       	std	Y+5, r25	; 0x05
    2ad0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2ad2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ad4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ad6:	9a 83       	std	Y+2, r25	; 0x02
    2ad8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ada:	e9 81       	ldd	r30, Y+1	; 0x01
    2adc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ade:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ae0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ae6:	98 17       	cp	r25, r24
    2ae8:	19 f4       	brne	.+6      	; 0x2af0 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	8b 83       	std	Y+3, r24	; 0x03
    2aee:	01 c0       	rjmp	.+2      	; 0x2af2 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2af0:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2af2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2af4:	0f 90       	pop	r0
    2af6:	0f 90       	pop	r0
    2af8:	0f 90       	pop	r0
    2afa:	0f 90       	pop	r0
    2afc:	0f 90       	pop	r0
    2afe:	cf 91       	pop	r28
    2b00:	df 91       	pop	r29
    2b02:	08 95       	ret

00002b04 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2b04:	0f 93       	push	r16
    2b06:	df 93       	push	r29
    2b08:	cf 93       	push	r28
    2b0a:	cd b7       	in	r28, 0x3d	; 61
    2b0c:	de b7       	in	r29, 0x3e	; 62
    2b0e:	28 97       	sbiw	r28, 0x08	; 8
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	de bf       	out	0x3e, r29	; 62
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	cd bf       	out	0x3d, r28	; 61
    2b1a:	9d 83       	std	Y+5, r25	; 0x05
    2b1c:	8c 83       	std	Y+4, r24	; 0x04
    2b1e:	7f 83       	std	Y+7, r23	; 0x07
    2b20:	6e 83       	std	Y+6, r22	; 0x06
    2b22:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2b24:	88 85       	ldd	r24, Y+8	; 0x08
    2b26:	81 30       	cpi	r24, 0x01	; 1
    2b28:	19 f4       	brne	.+6      	; 0x2b30 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	89 83       	std	Y+1, r24	; 0x01
    2b2e:	01 c0       	rjmp	.+2      	; 0x2b32 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2b30:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2b32:	8e 81       	ldd	r24, Y+6	; 0x06
    2b34:	9f 81       	ldd	r25, Y+7	; 0x07
    2b36:	00 97       	sbiw	r24, 0x00	; 0
    2b38:	21 f4       	brne	.+8      	; 0x2b42 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	9f 83       	std	Y+7, r25	; 0x07
    2b40:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2b42:	8c 81       	ldd	r24, Y+4	; 0x04
    2b44:	9d 81       	ldd	r25, Y+5	; 0x05
    2b46:	01 96       	adiw	r24, 0x01	; 1
    2b48:	9d 83       	std	Y+5, r25	; 0x05
    2b4a:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2b4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b4e:	9d 81       	ldd	r25, Y+5	; 0x05
    2b50:	0f 96       	adiw	r24, 0x0f	; 15
    2b52:	0e 94 23 07 	call	0xe46	; 0xe46 <pvPortMalloc>
    2b56:	9b 83       	std	Y+3, r25	; 0x03
    2b58:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b5e:	00 97       	sbiw	r24, 0x00	; 0
    2b60:	89 f0       	breq	.+34     	; 0x2b84 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2b62:	6a 81       	ldd	r22, Y+2	; 0x02
    2b64:	7b 81       	ldd	r23, Y+3	; 0x03
    2b66:	8a 81       	ldd	r24, Y+2	; 0x02
    2b68:	9b 81       	ldd	r25, Y+3	; 0x03
    2b6a:	9c 01       	movw	r18, r24
    2b6c:	21 5f       	subi	r18, 0xF1	; 241
    2b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b70:	4c 81       	ldd	r20, Y+4	; 0x04
    2b72:	5d 81       	ldd	r21, Y+5	; 0x05
    2b74:	ee 81       	ldd	r30, Y+6	; 0x06
    2b76:	ff 81       	ldd	r31, Y+7	; 0x07
    2b78:	cb 01       	movw	r24, r22
    2b7a:	b9 01       	movw	r22, r18
    2b7c:	9f 01       	movw	r18, r30
    2b7e:	09 81       	ldd	r16, Y+1	; 0x01
    2b80:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2b88:	28 96       	adiw	r28, 0x08	; 8
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	de bf       	out	0x3e, r29	; 62
    2b90:	0f be       	out	0x3f, r0	; 63
    2b92:	cd bf       	out	0x3d, r28	; 61
    2b94:	cf 91       	pop	r28
    2b96:	df 91       	pop	r29
    2b98:	0f 91       	pop	r16
    2b9a:	08 95       	ret

00002b9c <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2b9c:	df 93       	push	r29
    2b9e:	cf 93       	push	r28
    2ba0:	00 d0       	rcall	.+0      	; 0x2ba2 <vStreamBufferDelete+0x6>
    2ba2:	00 d0       	rcall	.+0      	; 0x2ba4 <vStreamBufferDelete+0x8>
    2ba4:	cd b7       	in	r28, 0x3d	; 61
    2ba6:	de b7       	in	r29, 0x3e	; 62
    2ba8:	9c 83       	std	Y+4, r25	; 0x04
    2baa:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2bac:	8b 81       	ldd	r24, Y+3	; 0x03
    2bae:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb0:	9a 83       	std	Y+2, r25	; 0x02
    2bb2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb8:	86 85       	ldd	r24, Z+14	; 0x0e
    2bba:	88 2f       	mov	r24, r24
    2bbc:	90 e0       	ldi	r25, 0x00	; 0
    2bbe:	82 70       	andi	r24, 0x02	; 2
    2bc0:	90 70       	andi	r25, 0x00	; 0
    2bc2:	00 97       	sbiw	r24, 0x00	; 0
    2bc4:	29 f4       	brne	.+10     	; 0x2bd0 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2bc6:	89 81       	ldd	r24, Y+1	; 0x01
    2bc8:	9a 81       	ldd	r25, Y+2	; 0x02
    2bca:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
    2bce:	08 c0       	rjmp	.+16     	; 0x2be0 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2bd0:	89 81       	ldd	r24, Y+1	; 0x01
    2bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd4:	60 e0       	ldi	r22, 0x00	; 0
    2bd6:	70 e0       	ldi	r23, 0x00	; 0
    2bd8:	4f e0       	ldi	r20, 0x0F	; 15
    2bda:	50 e0       	ldi	r21, 0x00	; 0
    2bdc:	0e 94 38 2a 	call	0x5470	; 0x5470 <memset>
	}
}
    2be0:	0f 90       	pop	r0
    2be2:	0f 90       	pop	r0
    2be4:	0f 90       	pop	r0
    2be6:	0f 90       	pop	r0
    2be8:	cf 91       	pop	r28
    2bea:	df 91       	pop	r29
    2bec:	08 95       	ret

00002bee <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2bee:	0f 93       	push	r16
    2bf0:	df 93       	push	r29
    2bf2:	cf 93       	push	r28
    2bf4:	00 d0       	rcall	.+0      	; 0x2bf6 <xStreamBufferReset+0x8>
    2bf6:	00 d0       	rcall	.+0      	; 0x2bf8 <xStreamBufferReset+0xa>
    2bf8:	0f 92       	push	r0
    2bfa:	cd b7       	in	r28, 0x3d	; 61
    2bfc:	de b7       	in	r29, 0x3e	; 62
    2bfe:	9d 83       	std	Y+5, r25	; 0x05
    2c00:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c02:	8c 81       	ldd	r24, Y+4	; 0x04
    2c04:	9d 81       	ldd	r25, Y+5	; 0x05
    2c06:	9b 83       	std	Y+3, r25	; 0x03
    2c08:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2c0a:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2c0c:	0f b6       	in	r0, 0x3f	; 63
    2c0e:	f8 94       	cli
    2c10:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2c12:	ea 81       	ldd	r30, Y+2	; 0x02
    2c14:	fb 81       	ldd	r31, Y+3	; 0x03
    2c16:	80 85       	ldd	r24, Z+8	; 0x08
    2c18:	91 85       	ldd	r25, Z+9	; 0x09
    2c1a:	00 97       	sbiw	r24, 0x00	; 0
    2c1c:	f1 f4       	brne	.+60     	; 0x2c5a <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2c1e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c20:	fb 81       	ldd	r31, Y+3	; 0x03
    2c22:	82 85       	ldd	r24, Z+10	; 0x0a
    2c24:	93 85       	ldd	r25, Z+11	; 0x0b
    2c26:	00 97       	sbiw	r24, 0x00	; 0
    2c28:	c1 f4       	brne	.+48     	; 0x2c5a <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2c2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c2e:	24 85       	ldd	r18, Z+12	; 0x0c
    2c30:	35 85       	ldd	r19, Z+13	; 0x0d
    2c32:	ea 81       	ldd	r30, Y+2	; 0x02
    2c34:	fb 81       	ldd	r31, Y+3	; 0x03
    2c36:	44 81       	ldd	r20, Z+4	; 0x04
    2c38:	55 81       	ldd	r21, Z+5	; 0x05
    2c3a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c3c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c3e:	a6 81       	ldd	r26, Z+6	; 0x06
    2c40:	b7 81       	ldd	r27, Z+7	; 0x07
    2c42:	ea 81       	ldd	r30, Y+2	; 0x02
    2c44:	fb 81       	ldd	r31, Y+3	; 0x03
    2c46:	e6 85       	ldd	r30, Z+14	; 0x0e
    2c48:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c4c:	b9 01       	movw	r22, r18
    2c4e:	9d 01       	movw	r18, r26
    2c50:	0e 2f       	mov	r16, r30
    2c52:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2c56:	81 e0       	ldi	r24, 0x01	; 1
    2c58:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2c5a:	0f 90       	pop	r0
    2c5c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c5e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c60:	0f 90       	pop	r0
    2c62:	0f 90       	pop	r0
    2c64:	0f 90       	pop	r0
    2c66:	0f 90       	pop	r0
    2c68:	0f 90       	pop	r0
    2c6a:	cf 91       	pop	r28
    2c6c:	df 91       	pop	r29
    2c6e:	0f 91       	pop	r16
    2c70:	08 95       	ret

00002c72 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2c72:	df 93       	push	r29
    2c74:	cf 93       	push	r28
    2c76:	cd b7       	in	r28, 0x3d	; 61
    2c78:	de b7       	in	r29, 0x3e	; 62
    2c7a:	27 97       	sbiw	r28, 0x07	; 7
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	de bf       	out	0x3e, r29	; 62
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	cd bf       	out	0x3d, r28	; 61
    2c86:	9d 83       	std	Y+5, r25	; 0x05
    2c88:	8c 83       	std	Y+4, r24	; 0x04
    2c8a:	7f 83       	std	Y+7, r23	; 0x07
    2c8c:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c90:	9d 81       	ldd	r25, Y+5	; 0x05
    2c92:	9b 83       	std	Y+3, r25	; 0x03
    2c94:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2c96:	8e 81       	ldd	r24, Y+6	; 0x06
    2c98:	9f 81       	ldd	r25, Y+7	; 0x07
    2c9a:	00 97       	sbiw	r24, 0x00	; 0
    2c9c:	21 f4       	brne	.+8      	; 0x2ca6 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2c9e:	81 e0       	ldi	r24, 0x01	; 1
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	9f 83       	std	Y+7, r25	; 0x07
    2ca4:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2ca6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ca8:	fb 81       	ldd	r31, Y+3	; 0x03
    2caa:	24 81       	ldd	r18, Z+4	; 0x04
    2cac:	35 81       	ldd	r19, Z+5	; 0x05
    2cae:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb2:	28 17       	cp	r18, r24
    2cb4:	39 07       	cpc	r19, r25
    2cb6:	48 f0       	brcs	.+18     	; 0x2cca <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2cb8:	ea 81       	ldd	r30, Y+2	; 0x02
    2cba:	fb 81       	ldd	r31, Y+3	; 0x03
    2cbc:	8e 81       	ldd	r24, Y+6	; 0x06
    2cbe:	9f 81       	ldd	r25, Y+7	; 0x07
    2cc0:	97 83       	std	Z+7, r25	; 0x07
    2cc2:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	89 83       	std	Y+1, r24	; 0x01
    2cc8:	01 c0       	rjmp	.+2      	; 0x2ccc <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2cca:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cce:	27 96       	adiw	r28, 0x07	; 7
    2cd0:	0f b6       	in	r0, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	de bf       	out	0x3e, r29	; 62
    2cd6:	0f be       	out	0x3f, r0	; 63
    2cd8:	cd bf       	out	0x3d, r28	; 61
    2cda:	cf 91       	pop	r28
    2cdc:	df 91       	pop	r29
    2cde:	08 95       	ret

00002ce0 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2ce0:	df 93       	push	r29
    2ce2:	cf 93       	push	r28
    2ce4:	00 d0       	rcall	.+0      	; 0x2ce6 <xStreamBufferSpacesAvailable+0x6>
    2ce6:	00 d0       	rcall	.+0      	; 0x2ce8 <xStreamBufferSpacesAvailable+0x8>
    2ce8:	00 d0       	rcall	.+0      	; 0x2cea <xStreamBufferSpacesAvailable+0xa>
    2cea:	cd b7       	in	r28, 0x3d	; 61
    2cec:	de b7       	in	r29, 0x3e	; 62
    2cee:	9e 83       	std	Y+6, r25	; 0x06
    2cf0:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    2cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    2cf6:	9c 83       	std	Y+4, r25	; 0x04
    2cf8:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    2cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    2cfe:	24 81       	ldd	r18, Z+4	; 0x04
    2d00:	35 81       	ldd	r19, Z+5	; 0x05
    2d02:	eb 81       	ldd	r30, Y+3	; 0x03
    2d04:	fc 81       	ldd	r31, Y+4	; 0x04
    2d06:	80 81       	ld	r24, Z
    2d08:	91 81       	ldd	r25, Z+1	; 0x01
    2d0a:	82 0f       	add	r24, r18
    2d0c:	93 1f       	adc	r25, r19
    2d0e:	9a 83       	std	Y+2, r25	; 0x02
    2d10:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2d12:	eb 81       	ldd	r30, Y+3	; 0x03
    2d14:	fc 81       	ldd	r31, Y+4	; 0x04
    2d16:	22 81       	ldd	r18, Z+2	; 0x02
    2d18:	33 81       	ldd	r19, Z+3	; 0x03
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
    2d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1e:	82 1b       	sub	r24, r18
    2d20:	93 0b       	sbc	r25, r19
    2d22:	9a 83       	std	Y+2, r25	; 0x02
    2d24:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2d26:	89 81       	ldd	r24, Y+1	; 0x01
    2d28:	9a 81       	ldd	r25, Y+2	; 0x02
    2d2a:	01 97       	sbiw	r24, 0x01	; 1
    2d2c:	9a 83       	std	Y+2, r25	; 0x02
    2d2e:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2d30:	eb 81       	ldd	r30, Y+3	; 0x03
    2d32:	fc 81       	ldd	r31, Y+4	; 0x04
    2d34:	24 81       	ldd	r18, Z+4	; 0x04
    2d36:	35 81       	ldd	r19, Z+5	; 0x05
    2d38:	89 81       	ldd	r24, Y+1	; 0x01
    2d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d3c:	82 17       	cp	r24, r18
    2d3e:	93 07       	cpc	r25, r19
    2d40:	50 f0       	brcs	.+20     	; 0x2d56 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2d42:	eb 81       	ldd	r30, Y+3	; 0x03
    2d44:	fc 81       	ldd	r31, Y+4	; 0x04
    2d46:	24 81       	ldd	r18, Z+4	; 0x04
    2d48:	35 81       	ldd	r19, Z+5	; 0x05
    2d4a:	89 81       	ldd	r24, Y+1	; 0x01
    2d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4e:	82 1b       	sub	r24, r18
    2d50:	93 0b       	sbc	r25, r19
    2d52:	9a 83       	std	Y+2, r25	; 0x02
    2d54:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2d56:	89 81       	ldd	r24, Y+1	; 0x01
    2d58:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d5a:	26 96       	adiw	r28, 0x06	; 6
    2d5c:	0f b6       	in	r0, 0x3f	; 63
    2d5e:	f8 94       	cli
    2d60:	de bf       	out	0x3e, r29	; 62
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	cd bf       	out	0x3d, r28	; 61
    2d66:	cf 91       	pop	r28
    2d68:	df 91       	pop	r29
    2d6a:	08 95       	ret

00002d6c <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2d6c:	df 93       	push	r29
    2d6e:	cf 93       	push	r28
    2d70:	00 d0       	rcall	.+0      	; 0x2d72 <xStreamBufferBytesAvailable+0x6>
    2d72:	00 d0       	rcall	.+0      	; 0x2d74 <xStreamBufferBytesAvailable+0x8>
    2d74:	00 d0       	rcall	.+0      	; 0x2d76 <xStreamBufferBytesAvailable+0xa>
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
    2d7a:	9e 83       	std	Y+6, r25	; 0x06
    2d7c:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d80:	9e 81       	ldd	r25, Y+6	; 0x06
    2d82:	9c 83       	std	Y+4, r25	; 0x04
    2d84:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2d86:	8b 81       	ldd	r24, Y+3	; 0x03
    2d88:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8a:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    2d8e:	9a 83       	std	Y+2, r25	; 0x02
    2d90:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2d92:	89 81       	ldd	r24, Y+1	; 0x01
    2d94:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d96:	26 96       	adiw	r28, 0x06	; 6
    2d98:	0f b6       	in	r0, 0x3f	; 63
    2d9a:	f8 94       	cli
    2d9c:	de bf       	out	0x3e, r29	; 62
    2d9e:	0f be       	out	0x3f, r0	; 63
    2da0:	cd bf       	out	0x3d, r28	; 61
    2da2:	cf 91       	pop	r28
    2da4:	df 91       	pop	r29
    2da6:	08 95       	ret

00002da8 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2da8:	ef 92       	push	r14
    2daa:	ff 92       	push	r15
    2dac:	0f 93       	push	r16
    2dae:	1f 93       	push	r17
    2db0:	df 93       	push	r29
    2db2:	cf 93       	push	r28
    2db4:	cd b7       	in	r28, 0x3d	; 61
    2db6:	de b7       	in	r29, 0x3e	; 62
    2db8:	63 97       	sbiw	r28, 0x13	; 19
    2dba:	0f b6       	in	r0, 0x3f	; 63
    2dbc:	f8 94       	cli
    2dbe:	de bf       	out	0x3e, r29	; 62
    2dc0:	0f be       	out	0x3f, r0	; 63
    2dc2:	cd bf       	out	0x3d, r28	; 61
    2dc4:	9d 87       	std	Y+13, r25	; 0x0d
    2dc6:	8c 87       	std	Y+12, r24	; 0x0c
    2dc8:	7f 87       	std	Y+15, r23	; 0x0f
    2dca:	6e 87       	std	Y+14, r22	; 0x0e
    2dcc:	59 8b       	std	Y+17, r21	; 0x11
    2dce:	48 8b       	std	Y+16, r20	; 0x10
    2dd0:	3b 8b       	std	Y+19, r19	; 0x13
    2dd2:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2dd4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2dd6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2dd8:	98 87       	std	Y+8, r25	; 0x08
    2dda:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2ddc:	1c 82       	std	Y+4, r1	; 0x04
    2dde:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2de0:	88 89       	ldd	r24, Y+16	; 0x10
    2de2:	99 89       	ldd	r25, Y+17	; 0x11
    2de4:	9a 83       	std	Y+2, r25	; 0x02
    2de6:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2de8:	ef 81       	ldd	r30, Y+7	; 0x07
    2dea:	f8 85       	ldd	r31, Y+8	; 0x08
    2dec:	86 85       	ldd	r24, Z+14	; 0x0e
    2dee:	88 2f       	mov	r24, r24
    2df0:	90 e0       	ldi	r25, 0x00	; 0
    2df2:	81 70       	andi	r24, 0x01	; 1
    2df4:	90 70       	andi	r25, 0x00	; 0
    2df6:	88 23       	and	r24, r24
    2df8:	29 f0       	breq	.+10     	; 0x2e04 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2dfa:	89 81       	ldd	r24, Y+1	; 0x01
    2dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfe:	02 96       	adiw	r24, 0x02	; 2
    2e00:	9a 83       	std	Y+2, r25	; 0x02
    2e02:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2e04:	8a 89       	ldd	r24, Y+18	; 0x12
    2e06:	9b 89       	ldd	r25, Y+19	; 0x13
    2e08:	00 97       	sbiw	r24, 0x00	; 0
    2e0a:	09 f4       	brne	.+2      	; 0x2e0e <xStreamBufferSend+0x66>
    2e0c:	40 c0       	rjmp	.+128    	; 0x2e8e <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2e0e:	ce 01       	movw	r24, r28
    2e10:	09 96       	adiw	r24, 0x09	; 9
    2e12:	0e 94 69 24 	call	0x48d2	; 0x48d2 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2e16:	0f b6       	in	r0, 0x3f	; 63
    2e18:	f8 94       	cli
    2e1a:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e1c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e1e:	98 85       	ldd	r25, Y+8	; 0x08
    2e20:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xStreamBufferSpacesAvailable>
    2e24:	9c 83       	std	Y+4, r25	; 0x04
    2e26:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2e28:	2b 81       	ldd	r18, Y+3	; 0x03
    2e2a:	3c 81       	ldd	r19, Y+4	; 0x04
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e30:	28 17       	cp	r18, r24
    2e32:	39 07       	cpc	r19, r25
    2e34:	50 f5       	brcc	.+84     	; 0x2e8a <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2e36:	80 e0       	ldi	r24, 0x00	; 0
    2e38:	90 e0       	ldi	r25, 0x00	; 0
    2e3a:	0e 94 79 29 	call	0x52f2	; 0x52f2 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2e3e:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <xTaskGetCurrentTaskHandle>
    2e42:	ef 81       	ldd	r30, Y+7	; 0x07
    2e44:	f8 85       	ldd	r31, Y+8	; 0x08
    2e46:	93 87       	std	Z+11, r25	; 0x0b
    2e48:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2e4a:	0f 90       	pop	r0
    2e4c:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2e4e:	ea 89       	ldd	r30, Y+18	; 0x12
    2e50:	fb 89       	ldd	r31, Y+19	; 0x13
    2e52:	60 e0       	ldi	r22, 0x00	; 0
    2e54:	70 e0       	ldi	r23, 0x00	; 0
    2e56:	80 e0       	ldi	r24, 0x00	; 0
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	20 e0       	ldi	r18, 0x00	; 0
    2e5c:	30 e0       	ldi	r19, 0x00	; 0
    2e5e:	40 e0       	ldi	r20, 0x00	; 0
    2e60:	50 e0       	ldi	r21, 0x00	; 0
    2e62:	00 e0       	ldi	r16, 0x00	; 0
    2e64:	10 e0       	ldi	r17, 0x00	; 0
    2e66:	7f 01       	movw	r14, r30
    2e68:	0e 94 82 26 	call	0x4d04	; 0x4d04 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2e6c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e6e:	f8 85       	ldd	r31, Y+8	; 0x08
    2e70:	13 86       	std	Z+11, r1	; 0x0b
    2e72:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2e74:	ce 01       	movw	r24, r28
    2e76:	09 96       	adiw	r24, 0x09	; 9
    2e78:	9e 01       	movw	r18, r28
    2e7a:	2e 5e       	subi	r18, 0xEE	; 238
    2e7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e7e:	b9 01       	movw	r22, r18
    2e80:	0e 94 a0 24 	call	0x4940	; 0x4940 <xTaskCheckForTimeOut>
    2e84:	88 23       	and	r24, r24
    2e86:	39 f2       	breq	.-114    	; 0x2e16 <xStreamBufferSend+0x6e>
    2e88:	02 c0       	rjmp	.+4      	; 0x2e8e <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2e8a:	0f 90       	pop	r0
    2e8c:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e90:	9c 81       	ldd	r25, Y+4	; 0x04
    2e92:	00 97       	sbiw	r24, 0x00	; 0
    2e94:	31 f4       	brne	.+12     	; 0x2ea2 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e96:	8f 81       	ldd	r24, Y+7	; 0x07
    2e98:	98 85       	ldd	r25, Y+8	; 0x08
    2e9a:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xStreamBufferSpacesAvailable>
    2e9e:	9c 83       	std	Y+4, r25	; 0x04
    2ea0:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2ea2:	8f 81       	ldd	r24, Y+7	; 0x07
    2ea4:	98 85       	ldd	r25, Y+8	; 0x08
    2ea6:	2e 85       	ldd	r18, Y+14	; 0x0e
    2ea8:	3f 85       	ldd	r19, Y+15	; 0x0f
    2eaa:	48 89       	ldd	r20, Y+16	; 0x10
    2eac:	59 89       	ldd	r21, Y+17	; 0x11
    2eae:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2eb2:	a9 81       	ldd	r26, Y+1	; 0x01
    2eb4:	ba 81       	ldd	r27, Y+2	; 0x02
    2eb6:	b9 01       	movw	r22, r18
    2eb8:	9f 01       	movw	r18, r30
    2eba:	8d 01       	movw	r16, r26
    2ebc:	0e 94 19 18 	call	0x3032	; 0x3032 <prvWriteMessageToBuffer>
    2ec0:	9e 83       	std	Y+6, r25	; 0x06
    2ec2:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2ec4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec8:	00 97       	sbiw	r24, 0x00	; 0
    2eca:	39 f1       	breq	.+78     	; 0x2f1a <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2ecc:	8f 81       	ldd	r24, Y+7	; 0x07
    2ece:	98 85       	ldd	r25, Y+8	; 0x08
    2ed0:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    2ed4:	9c 01       	movw	r18, r24
    2ed6:	ef 81       	ldd	r30, Y+7	; 0x07
    2ed8:	f8 85       	ldd	r31, Y+8	; 0x08
    2eda:	86 81       	ldd	r24, Z+6	; 0x06
    2edc:	97 81       	ldd	r25, Z+7	; 0x07
    2ede:	28 17       	cp	r18, r24
    2ee0:	39 07       	cpc	r19, r25
    2ee2:	d8 f0       	brcs	.+54     	; 0x2f1a <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2ee4:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
    2ee8:	ef 81       	ldd	r30, Y+7	; 0x07
    2eea:	f8 85       	ldd	r31, Y+8	; 0x08
    2eec:	80 85       	ldd	r24, Z+8	; 0x08
    2eee:	91 85       	ldd	r25, Z+9	; 0x09
    2ef0:	00 97       	sbiw	r24, 0x00	; 0
    2ef2:	89 f0       	breq	.+34     	; 0x2f16 <xStreamBufferSend+0x16e>
    2ef4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ef6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ef8:	80 85       	ldd	r24, Z+8	; 0x08
    2efa:	91 85       	ldd	r25, Z+9	; 0x09
    2efc:	40 e0       	ldi	r20, 0x00	; 0
    2efe:	50 e0       	ldi	r21, 0x00	; 0
    2f00:	60 e0       	ldi	r22, 0x00	; 0
    2f02:	70 e0       	ldi	r23, 0x00	; 0
    2f04:	20 e0       	ldi	r18, 0x00	; 0
    2f06:	00 e0       	ldi	r16, 0x00	; 0
    2f08:	10 e0       	ldi	r17, 0x00	; 0
    2f0a:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskGenericNotify>
    2f0e:	ef 81       	ldd	r30, Y+7	; 0x07
    2f10:	f8 85       	ldd	r31, Y+8	; 0x08
    2f12:	11 86       	std	Z+9, r1	; 0x09
    2f14:	10 86       	std	Z+8, r1	; 0x08
    2f16:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2f1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f1c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2f1e:	63 96       	adiw	r28, 0x13	; 19
    2f20:	0f b6       	in	r0, 0x3f	; 63
    2f22:	f8 94       	cli
    2f24:	de bf       	out	0x3e, r29	; 62
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	cd bf       	out	0x3d, r28	; 61
    2f2a:	cf 91       	pop	r28
    2f2c:	df 91       	pop	r29
    2f2e:	1f 91       	pop	r17
    2f30:	0f 91       	pop	r16
    2f32:	ff 90       	pop	r15
    2f34:	ef 90       	pop	r14
    2f36:	08 95       	ret

00002f38 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2f38:	ef 92       	push	r14
    2f3a:	ff 92       	push	r15
    2f3c:	0f 93       	push	r16
    2f3e:	1f 93       	push	r17
    2f40:	df 93       	push	r29
    2f42:	cf 93       	push	r28
    2f44:	cd b7       	in	r28, 0x3d	; 61
    2f46:	de b7       	in	r29, 0x3e	; 62
    2f48:	61 97       	sbiw	r28, 0x11	; 17
    2f4a:	0f b6       	in	r0, 0x3f	; 63
    2f4c:	f8 94       	cli
    2f4e:	de bf       	out	0x3e, r29	; 62
    2f50:	0f be       	out	0x3f, r0	; 63
    2f52:	cd bf       	out	0x3d, r28	; 61
    2f54:	9b 87       	std	Y+11, r25	; 0x0b
    2f56:	8a 87       	std	Y+10, r24	; 0x0a
    2f58:	7d 87       	std	Y+13, r23	; 0x0d
    2f5a:	6c 87       	std	Y+12, r22	; 0x0c
    2f5c:	5f 87       	std	Y+15, r21	; 0x0f
    2f5e:	4e 87       	std	Y+14, r20	; 0x0e
    2f60:	39 8b       	std	Y+17, r19	; 0x11
    2f62:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f64:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f66:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f68:	99 87       	std	Y+9, r25	; 0x09
    2f6a:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2f6c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f6e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f70:	9b 83       	std	Y+3, r25	; 0x03
    2f72:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2f74:	e8 85       	ldd	r30, Y+8	; 0x08
    2f76:	f9 85       	ldd	r31, Y+9	; 0x09
    2f78:	86 85       	ldd	r24, Z+14	; 0x0e
    2f7a:	88 2f       	mov	r24, r24
    2f7c:	90 e0       	ldi	r25, 0x00	; 0
    2f7e:	81 70       	andi	r24, 0x01	; 1
    2f80:	90 70       	andi	r25, 0x00	; 0
    2f82:	88 23       	and	r24, r24
    2f84:	29 f0       	breq	.+10     	; 0x2f90 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2f86:	8a 81       	ldd	r24, Y+2	; 0x02
    2f88:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8a:	02 96       	adiw	r24, 0x02	; 2
    2f8c:	9b 83       	std	Y+3, r25	; 0x03
    2f8e:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2f90:	88 85       	ldd	r24, Y+8	; 0x08
    2f92:	99 85       	ldd	r25, Y+9	; 0x09
    2f94:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xStreamBufferSpacesAvailable>
    2f98:	9d 83       	std	Y+5, r25	; 0x05
    2f9a:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2f9c:	88 85       	ldd	r24, Y+8	; 0x08
    2f9e:	99 85       	ldd	r25, Y+9	; 0x09
    2fa0:	2c 85       	ldd	r18, Y+12	; 0x0c
    2fa2:	3d 85       	ldd	r19, Y+13	; 0x0d
    2fa4:	4e 85       	ldd	r20, Y+14	; 0x0e
    2fa6:	5f 85       	ldd	r21, Y+15	; 0x0f
    2fa8:	ec 81       	ldd	r30, Y+4	; 0x04
    2faa:	fd 81       	ldd	r31, Y+5	; 0x05
    2fac:	aa 81       	ldd	r26, Y+2	; 0x02
    2fae:	bb 81       	ldd	r27, Y+3	; 0x03
    2fb0:	b9 01       	movw	r22, r18
    2fb2:	9f 01       	movw	r18, r30
    2fb4:	8d 01       	movw	r16, r26
    2fb6:	0e 94 19 18 	call	0x3032	; 0x3032 <prvWriteMessageToBuffer>
    2fba:	9f 83       	std	Y+7, r25	; 0x07
    2fbc:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2fbe:	8e 81       	ldd	r24, Y+6	; 0x06
    2fc0:	9f 81       	ldd	r25, Y+7	; 0x07
    2fc2:	00 97       	sbiw	r24, 0x00	; 0
    2fc4:	39 f1       	breq	.+78     	; 0x3014 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2fc6:	88 85       	ldd	r24, Y+8	; 0x08
    2fc8:	99 85       	ldd	r25, Y+9	; 0x09
    2fca:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    2fce:	9c 01       	movw	r18, r24
    2fd0:	e8 85       	ldd	r30, Y+8	; 0x08
    2fd2:	f9 85       	ldd	r31, Y+9	; 0x09
    2fd4:	86 81       	ldd	r24, Z+6	; 0x06
    2fd6:	97 81       	ldd	r25, Z+7	; 0x07
    2fd8:	28 17       	cp	r18, r24
    2fda:	39 07       	cpc	r19, r25
    2fdc:	d8 f0       	brcs	.+54     	; 0x3014 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2fde:	19 82       	std	Y+1, r1	; 0x01
    2fe0:	e8 85       	ldd	r30, Y+8	; 0x08
    2fe2:	f9 85       	ldd	r31, Y+9	; 0x09
    2fe4:	80 85       	ldd	r24, Z+8	; 0x08
    2fe6:	91 85       	ldd	r25, Z+9	; 0x09
    2fe8:	00 97       	sbiw	r24, 0x00	; 0
    2fea:	a1 f0       	breq	.+40     	; 0x3014 <xStreamBufferSendFromISR+0xdc>
    2fec:	e8 85       	ldd	r30, Y+8	; 0x08
    2fee:	f9 85       	ldd	r31, Y+9	; 0x09
    2ff0:	80 85       	ldd	r24, Z+8	; 0x08
    2ff2:	91 85       	ldd	r25, Z+9	; 0x09
    2ff4:	e8 89       	ldd	r30, Y+16	; 0x10
    2ff6:	f9 89       	ldd	r31, Y+17	; 0x11
    2ff8:	40 e0       	ldi	r20, 0x00	; 0
    2ffa:	50 e0       	ldi	r21, 0x00	; 0
    2ffc:	60 e0       	ldi	r22, 0x00	; 0
    2ffe:	70 e0       	ldi	r23, 0x00	; 0
    3000:	20 e0       	ldi	r18, 0x00	; 0
    3002:	00 e0       	ldi	r16, 0x00	; 0
    3004:	10 e0       	ldi	r17, 0x00	; 0
    3006:	7f 01       	movw	r14, r30
    3008:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
    300c:	e8 85       	ldd	r30, Y+8	; 0x08
    300e:	f9 85       	ldd	r31, Y+9	; 0x09
    3010:	11 86       	std	Z+9, r1	; 0x09
    3012:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3014:	8e 81       	ldd	r24, Y+6	; 0x06
    3016:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3018:	61 96       	adiw	r28, 0x11	; 17
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	de bf       	out	0x3e, r29	; 62
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	cd bf       	out	0x3d, r28	; 61
    3024:	cf 91       	pop	r28
    3026:	df 91       	pop	r29
    3028:	1f 91       	pop	r17
    302a:	0f 91       	pop	r16
    302c:	ff 90       	pop	r15
    302e:	ef 90       	pop	r14
    3030:	08 95       	ret

00003032 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3032:	0f 93       	push	r16
    3034:	1f 93       	push	r17
    3036:	df 93       	push	r29
    3038:	cf 93       	push	r28
    303a:	cd b7       	in	r28, 0x3d	; 61
    303c:	de b7       	in	r29, 0x3e	; 62
    303e:	61 97       	sbiw	r28, 0x11	; 17
    3040:	0f b6       	in	r0, 0x3f	; 63
    3042:	f8 94       	cli
    3044:	de bf       	out	0x3e, r29	; 62
    3046:	0f be       	out	0x3f, r0	; 63
    3048:	cd bf       	out	0x3d, r28	; 61
    304a:	9d 83       	std	Y+5, r25	; 0x05
    304c:	8c 83       	std	Y+4, r24	; 0x04
    304e:	7f 83       	std	Y+7, r23	; 0x07
    3050:	6e 83       	std	Y+6, r22	; 0x06
    3052:	59 87       	std	Y+9, r21	; 0x09
    3054:	48 87       	std	Y+8, r20	; 0x08
    3056:	3b 87       	std	Y+11, r19	; 0x0b
    3058:	2a 87       	std	Y+10, r18	; 0x0a
    305a:	1d 87       	std	Y+13, r17	; 0x0d
    305c:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    305e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3060:	9b 85       	ldd	r25, Y+11	; 0x0b
    3062:	00 97       	sbiw	r24, 0x00	; 0
    3064:	11 f4       	brne	.+4      	; 0x306a <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3066:	1b 82       	std	Y+3, r1	; 0x03
    3068:	38 c0       	rjmp	.+112    	; 0x30da <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    306a:	ec 81       	ldd	r30, Y+4	; 0x04
    306c:	fd 81       	ldd	r31, Y+5	; 0x05
    306e:	86 85       	ldd	r24, Z+14	; 0x0e
    3070:	88 2f       	mov	r24, r24
    3072:	90 e0       	ldi	r25, 0x00	; 0
    3074:	81 70       	andi	r24, 0x01	; 1
    3076:	90 70       	andi	r25, 0x00	; 0
    3078:	00 97       	sbiw	r24, 0x00	; 0
    307a:	d1 f4       	brne	.+52     	; 0x30b0 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    307c:	81 e0       	ldi	r24, 0x01	; 1
    307e:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3080:	28 85       	ldd	r18, Y+8	; 0x08
    3082:	39 85       	ldd	r19, Y+9	; 0x09
    3084:	39 8b       	std	Y+17, r19	; 0x11
    3086:	28 8b       	std	Y+16, r18	; 0x10
    3088:	8a 85       	ldd	r24, Y+10	; 0x0a
    308a:	9b 85       	ldd	r25, Y+11	; 0x0b
    308c:	9f 87       	std	Y+15, r25	; 0x0f
    308e:	8e 87       	std	Y+14, r24	; 0x0e
    3090:	2e 85       	ldd	r18, Y+14	; 0x0e
    3092:	3f 85       	ldd	r19, Y+15	; 0x0f
    3094:	88 89       	ldd	r24, Y+16	; 0x10
    3096:	99 89       	ldd	r25, Y+17	; 0x11
    3098:	82 17       	cp	r24, r18
    309a:	93 07       	cpc	r25, r19
    309c:	20 f4       	brcc	.+8      	; 0x30a6 <prvWriteMessageToBuffer+0x74>
    309e:	28 89       	ldd	r18, Y+16	; 0x10
    30a0:	39 89       	ldd	r19, Y+17	; 0x11
    30a2:	3f 87       	std	Y+15, r19	; 0x0f
    30a4:	2e 87       	std	Y+14, r18	; 0x0e
    30a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    30a8:	9f 85       	ldd	r25, Y+15	; 0x0f
    30aa:	99 87       	std	Y+9, r25	; 0x09
    30ac:	88 87       	std	Y+8, r24	; 0x08
    30ae:	15 c0       	rjmp	.+42     	; 0x30da <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    30b0:	2a 85       	ldd	r18, Y+10	; 0x0a
    30b2:	3b 85       	ldd	r19, Y+11	; 0x0b
    30b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    30b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    30b8:	28 17       	cp	r18, r24
    30ba:	39 07       	cpc	r19, r25
    30bc:	68 f0       	brcs	.+26     	; 0x30d8 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    30be:	81 e0       	ldi	r24, 0x01	; 1
    30c0:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    30c2:	9e 01       	movw	r18, r28
    30c4:	28 5f       	subi	r18, 0xF8	; 248
    30c6:	3f 4f       	sbci	r19, 0xFF	; 255
    30c8:	8c 81       	ldd	r24, Y+4	; 0x04
    30ca:	9d 81       	ldd	r25, Y+5	; 0x05
    30cc:	b9 01       	movw	r22, r18
    30ce:	42 e0       	ldi	r20, 0x02	; 2
    30d0:	50 e0       	ldi	r21, 0x00	; 0
    30d2:	0e 94 66 1b 	call	0x36cc	; 0x36cc <prvWriteBytesToBuffer>
    30d6:	01 c0       	rjmp	.+2      	; 0x30da <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    30d8:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	88 23       	and	r24, r24
    30de:	61 f0       	breq	.+24     	; 0x30f8 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    30e0:	2e 81       	ldd	r18, Y+6	; 0x06
    30e2:	3f 81       	ldd	r19, Y+7	; 0x07
    30e4:	48 85       	ldd	r20, Y+8	; 0x08
    30e6:	59 85       	ldd	r21, Y+9	; 0x09
    30e8:	8c 81       	ldd	r24, Y+4	; 0x04
    30ea:	9d 81       	ldd	r25, Y+5	; 0x05
    30ec:	b9 01       	movw	r22, r18
    30ee:	0e 94 66 1b 	call	0x36cc	; 0x36cc <prvWriteBytesToBuffer>
    30f2:	9a 83       	std	Y+2, r25	; 0x02
    30f4:	89 83       	std	Y+1, r24	; 0x01
    30f6:	02 c0       	rjmp	.+4      	; 0x30fc <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    30f8:	1a 82       	std	Y+2, r1	; 0x02
    30fa:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    30fc:	89 81       	ldd	r24, Y+1	; 0x01
    30fe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3100:	61 96       	adiw	r28, 0x11	; 17
    3102:	0f b6       	in	r0, 0x3f	; 63
    3104:	f8 94       	cli
    3106:	de bf       	out	0x3e, r29	; 62
    3108:	0f be       	out	0x3f, r0	; 63
    310a:	cd bf       	out	0x3d, r28	; 61
    310c:	cf 91       	pop	r28
    310e:	df 91       	pop	r29
    3110:	1f 91       	pop	r17
    3112:	0f 91       	pop	r16
    3114:	08 95       	ret

00003116 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3116:	ef 92       	push	r14
    3118:	ff 92       	push	r15
    311a:	0f 93       	push	r16
    311c:	1f 93       	push	r17
    311e:	df 93       	push	r29
    3120:	cf 93       	push	r28
    3122:	cd b7       	in	r28, 0x3d	; 61
    3124:	de b7       	in	r29, 0x3e	; 62
    3126:	60 97       	sbiw	r28, 0x10	; 16
    3128:	0f b6       	in	r0, 0x3f	; 63
    312a:	f8 94       	cli
    312c:	de bf       	out	0x3e, r29	; 62
    312e:	0f be       	out	0x3f, r0	; 63
    3130:	cd bf       	out	0x3d, r28	; 61
    3132:	9a 87       	std	Y+10, r25	; 0x0a
    3134:	89 87       	std	Y+9, r24	; 0x09
    3136:	7c 87       	std	Y+12, r23	; 0x0c
    3138:	6b 87       	std	Y+11, r22	; 0x0b
    313a:	5e 87       	std	Y+14, r21	; 0x0e
    313c:	4d 87       	std	Y+13, r20	; 0x0d
    313e:	38 8b       	std	Y+16, r19	; 0x10
    3140:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3142:	89 85       	ldd	r24, Y+9	; 0x09
    3144:	9a 85       	ldd	r25, Y+10	; 0x0a
    3146:	98 87       	std	Y+8, r25	; 0x08
    3148:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    314a:	1e 82       	std	Y+6, r1	; 0x06
    314c:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    314e:	ef 81       	ldd	r30, Y+7	; 0x07
    3150:	f8 85       	ldd	r31, Y+8	; 0x08
    3152:	86 85       	ldd	r24, Z+14	; 0x0e
    3154:	88 2f       	mov	r24, r24
    3156:	90 e0       	ldi	r25, 0x00	; 0
    3158:	81 70       	andi	r24, 0x01	; 1
    315a:	90 70       	andi	r25, 0x00	; 0
    315c:	88 23       	and	r24, r24
    315e:	29 f0       	breq	.+10     	; 0x316a <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3160:	82 e0       	ldi	r24, 0x02	; 2
    3162:	90 e0       	ldi	r25, 0x00	; 0
    3164:	9a 83       	std	Y+2, r25	; 0x02
    3166:	89 83       	std	Y+1, r24	; 0x01
    3168:	02 c0       	rjmp	.+4      	; 0x316e <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    316a:	1a 82       	std	Y+2, r1	; 0x02
    316c:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    316e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3170:	98 89       	ldd	r25, Y+16	; 0x10
    3172:	00 97       	sbiw	r24, 0x00	; 0
    3174:	09 f4       	brne	.+2      	; 0x3178 <xStreamBufferReceive+0x62>
    3176:	3d c0       	rjmp	.+122    	; 0x31f2 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    317e:	8f 81       	ldd	r24, Y+7	; 0x07
    3180:	98 85       	ldd	r25, Y+8	; 0x08
    3182:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    3186:	9c 83       	std	Y+4, r25	; 0x04
    3188:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    318a:	2b 81       	ldd	r18, Y+3	; 0x03
    318c:	3c 81       	ldd	r19, Y+4	; 0x04
    318e:	89 81       	ldd	r24, Y+1	; 0x01
    3190:	9a 81       	ldd	r25, Y+2	; 0x02
    3192:	82 17       	cp	r24, r18
    3194:	93 07       	cpc	r25, r19
    3196:	50 f0       	brcs	.+20     	; 0x31ac <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3198:	80 e0       	ldi	r24, 0x00	; 0
    319a:	90 e0       	ldi	r25, 0x00	; 0
    319c:	0e 94 79 29 	call	0x52f2	; 0x52f2 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    31a0:	0e 94 d2 25 	call	0x4ba4	; 0x4ba4 <xTaskGetCurrentTaskHandle>
    31a4:	ef 81       	ldd	r30, Y+7	; 0x07
    31a6:	f8 85       	ldd	r31, Y+8	; 0x08
    31a8:	91 87       	std	Z+9, r25	; 0x09
    31aa:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    31ac:	0f 90       	pop	r0
    31ae:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    31b0:	2b 81       	ldd	r18, Y+3	; 0x03
    31b2:	3c 81       	ldd	r19, Y+4	; 0x04
    31b4:	89 81       	ldd	r24, Y+1	; 0x01
    31b6:	9a 81       	ldd	r25, Y+2	; 0x02
    31b8:	82 17       	cp	r24, r18
    31ba:	93 07       	cpc	r25, r19
    31bc:	00 f1       	brcs	.+64     	; 0x31fe <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    31be:	ef 85       	ldd	r30, Y+15	; 0x0f
    31c0:	f8 89       	ldd	r31, Y+16	; 0x10
    31c2:	60 e0       	ldi	r22, 0x00	; 0
    31c4:	70 e0       	ldi	r23, 0x00	; 0
    31c6:	80 e0       	ldi	r24, 0x00	; 0
    31c8:	90 e0       	ldi	r25, 0x00	; 0
    31ca:	20 e0       	ldi	r18, 0x00	; 0
    31cc:	30 e0       	ldi	r19, 0x00	; 0
    31ce:	40 e0       	ldi	r20, 0x00	; 0
    31d0:	50 e0       	ldi	r21, 0x00	; 0
    31d2:	00 e0       	ldi	r16, 0x00	; 0
    31d4:	10 e0       	ldi	r17, 0x00	; 0
    31d6:	7f 01       	movw	r14, r30
    31d8:	0e 94 82 26 	call	0x4d04	; 0x4d04 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    31dc:	ef 81       	ldd	r30, Y+7	; 0x07
    31de:	f8 85       	ldd	r31, Y+8	; 0x08
    31e0:	11 86       	std	Z+9, r1	; 0x09
    31e2:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31e4:	8f 81       	ldd	r24, Y+7	; 0x07
    31e6:	98 85       	ldd	r25, Y+8	; 0x08
    31e8:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    31ec:	9c 83       	std	Y+4, r25	; 0x04
    31ee:	8b 83       	std	Y+3, r24	; 0x03
    31f0:	06 c0       	rjmp	.+12     	; 0x31fe <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31f2:	8f 81       	ldd	r24, Y+7	; 0x07
    31f4:	98 85       	ldd	r25, Y+8	; 0x08
    31f6:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    31fa:	9c 83       	std	Y+4, r25	; 0x04
    31fc:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    31fe:	2b 81       	ldd	r18, Y+3	; 0x03
    3200:	3c 81       	ldd	r19, Y+4	; 0x04
    3202:	89 81       	ldd	r24, Y+1	; 0x01
    3204:	9a 81       	ldd	r25, Y+2	; 0x02
    3206:	82 17       	cp	r24, r18
    3208:	93 07       	cpc	r25, r19
    320a:	80 f5       	brcc	.+96     	; 0x326c <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    320c:	8f 81       	ldd	r24, Y+7	; 0x07
    320e:	98 85       	ldd	r25, Y+8	; 0x08
    3210:	2b 85       	ldd	r18, Y+11	; 0x0b
    3212:	3c 85       	ldd	r19, Y+12	; 0x0c
    3214:	4d 85       	ldd	r20, Y+13	; 0x0d
    3216:	5e 85       	ldd	r21, Y+14	; 0x0e
    3218:	eb 81       	ldd	r30, Y+3	; 0x03
    321a:	fc 81       	ldd	r31, Y+4	; 0x04
    321c:	a9 81       	ldd	r26, Y+1	; 0x01
    321e:	ba 81       	ldd	r27, Y+2	; 0x02
    3220:	b9 01       	movw	r22, r18
    3222:	9f 01       	movw	r18, r30
    3224:	8d 01       	movw	r16, r26
    3226:	0e 94 0f 1a 	call	0x341e	; 0x341e <prvReadMessageFromBuffer>
    322a:	9e 83       	std	Y+6, r25	; 0x06
    322c:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    322e:	8d 81       	ldd	r24, Y+5	; 0x05
    3230:	9e 81       	ldd	r25, Y+6	; 0x06
    3232:	00 97       	sbiw	r24, 0x00	; 0
    3234:	d9 f0       	breq	.+54     	; 0x326c <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3236:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
    323a:	ef 81       	ldd	r30, Y+7	; 0x07
    323c:	f8 85       	ldd	r31, Y+8	; 0x08
    323e:	82 85       	ldd	r24, Z+10	; 0x0a
    3240:	93 85       	ldd	r25, Z+11	; 0x0b
    3242:	00 97       	sbiw	r24, 0x00	; 0
    3244:	89 f0       	breq	.+34     	; 0x3268 <xStreamBufferReceive+0x152>
    3246:	ef 81       	ldd	r30, Y+7	; 0x07
    3248:	f8 85       	ldd	r31, Y+8	; 0x08
    324a:	82 85       	ldd	r24, Z+10	; 0x0a
    324c:	93 85       	ldd	r25, Z+11	; 0x0b
    324e:	40 e0       	ldi	r20, 0x00	; 0
    3250:	50 e0       	ldi	r21, 0x00	; 0
    3252:	60 e0       	ldi	r22, 0x00	; 0
    3254:	70 e0       	ldi	r23, 0x00	; 0
    3256:	20 e0       	ldi	r18, 0x00	; 0
    3258:	00 e0       	ldi	r16, 0x00	; 0
    325a:	10 e0       	ldi	r17, 0x00	; 0
    325c:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <xTaskGenericNotify>
    3260:	ef 81       	ldd	r30, Y+7	; 0x07
    3262:	f8 85       	ldd	r31, Y+8	; 0x08
    3264:	13 86       	std	Z+11, r1	; 0x0b
    3266:	12 86       	std	Z+10, r1	; 0x0a
    3268:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    326c:	8d 81       	ldd	r24, Y+5	; 0x05
    326e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3270:	60 96       	adiw	r28, 0x10	; 16
    3272:	0f b6       	in	r0, 0x3f	; 63
    3274:	f8 94       	cli
    3276:	de bf       	out	0x3e, r29	; 62
    3278:	0f be       	out	0x3f, r0	; 63
    327a:	cd bf       	out	0x3d, r28	; 61
    327c:	cf 91       	pop	r28
    327e:	df 91       	pop	r29
    3280:	1f 91       	pop	r17
    3282:	0f 91       	pop	r16
    3284:	ff 90       	pop	r15
    3286:	ef 90       	pop	r14
    3288:	08 95       	ret

0000328a <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    328a:	df 93       	push	r29
    328c:	cf 93       	push	r28
    328e:	cd b7       	in	r28, 0x3d	; 61
    3290:	de b7       	in	r29, 0x3e	; 62
    3292:	2c 97       	sbiw	r28, 0x0c	; 12
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	de bf       	out	0x3e, r29	; 62
    329a:	0f be       	out	0x3f, r0	; 63
    329c:	cd bf       	out	0x3d, r28	; 61
    329e:	9c 87       	std	Y+12, r25	; 0x0c
    32a0:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    32a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    32a4:	9c 85       	ldd	r25, Y+12	; 0x0c
    32a6:	98 87       	std	Y+8, r25	; 0x08
    32a8:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    32aa:	ef 81       	ldd	r30, Y+7	; 0x07
    32ac:	f8 85       	ldd	r31, Y+8	; 0x08
    32ae:	86 85       	ldd	r24, Z+14	; 0x0e
    32b0:	88 2f       	mov	r24, r24
    32b2:	90 e0       	ldi	r25, 0x00	; 0
    32b4:	81 70       	andi	r24, 0x01	; 1
    32b6:	90 70       	andi	r25, 0x00	; 0
    32b8:	88 23       	and	r24, r24
    32ba:	61 f1       	breq	.+88     	; 0x3314 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    32bc:	8f 81       	ldd	r24, Y+7	; 0x07
    32be:	98 85       	ldd	r25, Y+8	; 0x08
    32c0:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    32c4:	9c 83       	std	Y+4, r25	; 0x04
    32c6:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    32c8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ca:	9c 81       	ldd	r25, Y+4	; 0x04
    32cc:	83 30       	cpi	r24, 0x03	; 3
    32ce:	91 05       	cpc	r25, r1
    32d0:	f0 f0       	brcs	.+60     	; 0x330e <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    32d2:	ef 81       	ldd	r30, Y+7	; 0x07
    32d4:	f8 85       	ldd	r31, Y+8	; 0x08
    32d6:	80 81       	ld	r24, Z
    32d8:	91 81       	ldd	r25, Z+1	; 0x01
    32da:	9a 83       	std	Y+2, r25	; 0x02
    32dc:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    32de:	9e 01       	movw	r18, r28
    32e0:	27 5f       	subi	r18, 0xF7	; 247
    32e2:	3f 4f       	sbci	r19, 0xFF	; 255
    32e4:	8f 81       	ldd	r24, Y+7	; 0x07
    32e6:	98 85       	ldd	r25, Y+8	; 0x08
    32e8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ea:	fc 81       	ldd	r31, Y+4	; 0x04
    32ec:	b9 01       	movw	r22, r18
    32ee:	42 e0       	ldi	r20, 0x02	; 2
    32f0:	50 e0       	ldi	r21, 0x00	; 0
    32f2:	9f 01       	movw	r18, r30
    32f4:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    32f8:	89 85       	ldd	r24, Y+9	; 0x09
    32fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    32fc:	9e 83       	std	Y+6, r25	; 0x06
    32fe:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3300:	ef 81       	ldd	r30, Y+7	; 0x07
    3302:	f8 85       	ldd	r31, Y+8	; 0x08
    3304:	89 81       	ldd	r24, Y+1	; 0x01
    3306:	9a 81       	ldd	r25, Y+2	; 0x02
    3308:	91 83       	std	Z+1, r25	; 0x01
    330a:	80 83       	st	Z, r24
    330c:	05 c0       	rjmp	.+10     	; 0x3318 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    330e:	1e 82       	std	Y+6, r1	; 0x06
    3310:	1d 82       	std	Y+5, r1	; 0x05
    3312:	02 c0       	rjmp	.+4      	; 0x3318 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3314:	1e 82       	std	Y+6, r1	; 0x06
    3316:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3318:	8d 81       	ldd	r24, Y+5	; 0x05
    331a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    331c:	2c 96       	adiw	r28, 0x0c	; 12
    331e:	0f b6       	in	r0, 0x3f	; 63
    3320:	f8 94       	cli
    3322:	de bf       	out	0x3e, r29	; 62
    3324:	0f be       	out	0x3f, r0	; 63
    3326:	cd bf       	out	0x3d, r28	; 61
    3328:	cf 91       	pop	r28
    332a:	df 91       	pop	r29
    332c:	08 95       	ret

0000332e <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    332e:	ef 92       	push	r14
    3330:	ff 92       	push	r15
    3332:	0f 93       	push	r16
    3334:	1f 93       	push	r17
    3336:	df 93       	push	r29
    3338:	cf 93       	push	r28
    333a:	cd b7       	in	r28, 0x3d	; 61
    333c:	de b7       	in	r29, 0x3e	; 62
    333e:	61 97       	sbiw	r28, 0x11	; 17
    3340:	0f b6       	in	r0, 0x3f	; 63
    3342:	f8 94       	cli
    3344:	de bf       	out	0x3e, r29	; 62
    3346:	0f be       	out	0x3f, r0	; 63
    3348:	cd bf       	out	0x3d, r28	; 61
    334a:	9b 87       	std	Y+11, r25	; 0x0b
    334c:	8a 87       	std	Y+10, r24	; 0x0a
    334e:	7d 87       	std	Y+13, r23	; 0x0d
    3350:	6c 87       	std	Y+12, r22	; 0x0c
    3352:	5f 87       	std	Y+15, r21	; 0x0f
    3354:	4e 87       	std	Y+14, r20	; 0x0e
    3356:	39 8b       	std	Y+17, r19	; 0x11
    3358:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    335a:	8a 85       	ldd	r24, Y+10	; 0x0a
    335c:	9b 85       	ldd	r25, Y+11	; 0x0b
    335e:	99 87       	std	Y+9, r25	; 0x09
    3360:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3362:	1f 82       	std	Y+7, r1	; 0x07
    3364:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3366:	e8 85       	ldd	r30, Y+8	; 0x08
    3368:	f9 85       	ldd	r31, Y+9	; 0x09
    336a:	86 85       	ldd	r24, Z+14	; 0x0e
    336c:	88 2f       	mov	r24, r24
    336e:	90 e0       	ldi	r25, 0x00	; 0
    3370:	81 70       	andi	r24, 0x01	; 1
    3372:	90 70       	andi	r25, 0x00	; 0
    3374:	88 23       	and	r24, r24
    3376:	29 f0       	breq	.+10     	; 0x3382 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3378:	82 e0       	ldi	r24, 0x02	; 2
    337a:	90 e0       	ldi	r25, 0x00	; 0
    337c:	9b 83       	std	Y+3, r25	; 0x03
    337e:	8a 83       	std	Y+2, r24	; 0x02
    3380:	02 c0       	rjmp	.+4      	; 0x3386 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3382:	1b 82       	std	Y+3, r1	; 0x03
    3384:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3386:	88 85       	ldd	r24, Y+8	; 0x08
    3388:	99 85       	ldd	r25, Y+9	; 0x09
    338a:	0e 94 a0 1c 	call	0x3940	; 0x3940 <prvBytesInBuffer>
    338e:	9d 83       	std	Y+5, r25	; 0x05
    3390:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3392:	2c 81       	ldd	r18, Y+4	; 0x04
    3394:	3d 81       	ldd	r19, Y+5	; 0x05
    3396:	8a 81       	ldd	r24, Y+2	; 0x02
    3398:	9b 81       	ldd	r25, Y+3	; 0x03
    339a:	82 17       	cp	r24, r18
    339c:	93 07       	cpc	r25, r19
    339e:	80 f5       	brcc	.+96     	; 0x3400 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    33a0:	88 85       	ldd	r24, Y+8	; 0x08
    33a2:	99 85       	ldd	r25, Y+9	; 0x09
    33a4:	2c 85       	ldd	r18, Y+12	; 0x0c
    33a6:	3d 85       	ldd	r19, Y+13	; 0x0d
    33a8:	4e 85       	ldd	r20, Y+14	; 0x0e
    33aa:	5f 85       	ldd	r21, Y+15	; 0x0f
    33ac:	ec 81       	ldd	r30, Y+4	; 0x04
    33ae:	fd 81       	ldd	r31, Y+5	; 0x05
    33b0:	aa 81       	ldd	r26, Y+2	; 0x02
    33b2:	bb 81       	ldd	r27, Y+3	; 0x03
    33b4:	b9 01       	movw	r22, r18
    33b6:	9f 01       	movw	r18, r30
    33b8:	8d 01       	movw	r16, r26
    33ba:	0e 94 0f 1a 	call	0x341e	; 0x341e <prvReadMessageFromBuffer>
    33be:	9f 83       	std	Y+7, r25	; 0x07
    33c0:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    33c2:	8e 81       	ldd	r24, Y+6	; 0x06
    33c4:	9f 81       	ldd	r25, Y+7	; 0x07
    33c6:	00 97       	sbiw	r24, 0x00	; 0
    33c8:	d9 f0       	breq	.+54     	; 0x3400 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    33ca:	19 82       	std	Y+1, r1	; 0x01
    33cc:	e8 85       	ldd	r30, Y+8	; 0x08
    33ce:	f9 85       	ldd	r31, Y+9	; 0x09
    33d0:	82 85       	ldd	r24, Z+10	; 0x0a
    33d2:	93 85       	ldd	r25, Z+11	; 0x0b
    33d4:	00 97       	sbiw	r24, 0x00	; 0
    33d6:	a1 f0       	breq	.+40     	; 0x3400 <xStreamBufferReceiveFromISR+0xd2>
    33d8:	e8 85       	ldd	r30, Y+8	; 0x08
    33da:	f9 85       	ldd	r31, Y+9	; 0x09
    33dc:	82 85       	ldd	r24, Z+10	; 0x0a
    33de:	93 85       	ldd	r25, Z+11	; 0x0b
    33e0:	e8 89       	ldd	r30, Y+16	; 0x10
    33e2:	f9 89       	ldd	r31, Y+17	; 0x11
    33e4:	40 e0       	ldi	r20, 0x00	; 0
    33e6:	50 e0       	ldi	r21, 0x00	; 0
    33e8:	60 e0       	ldi	r22, 0x00	; 0
    33ea:	70 e0       	ldi	r23, 0x00	; 0
    33ec:	20 e0       	ldi	r18, 0x00	; 0
    33ee:	00 e0       	ldi	r16, 0x00	; 0
    33f0:	10 e0       	ldi	r17, 0x00	; 0
    33f2:	7f 01       	movw	r14, r30
    33f4:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
    33f8:	e8 85       	ldd	r30, Y+8	; 0x08
    33fa:	f9 85       	ldd	r31, Y+9	; 0x09
    33fc:	13 86       	std	Z+11, r1	; 0x0b
    33fe:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3400:	8e 81       	ldd	r24, Y+6	; 0x06
    3402:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3404:	61 96       	adiw	r28, 0x11	; 17
    3406:	0f b6       	in	r0, 0x3f	; 63
    3408:	f8 94       	cli
    340a:	de bf       	out	0x3e, r29	; 62
    340c:	0f be       	out	0x3f, r0	; 63
    340e:	cd bf       	out	0x3d, r28	; 61
    3410:	cf 91       	pop	r28
    3412:	df 91       	pop	r29
    3414:	1f 91       	pop	r17
    3416:	0f 91       	pop	r16
    3418:	ff 90       	pop	r15
    341a:	ef 90       	pop	r14
    341c:	08 95       	ret

0000341e <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    341e:	0f 93       	push	r16
    3420:	1f 93       	push	r17
    3422:	df 93       	push	r29
    3424:	cf 93       	push	r28
    3426:	cd b7       	in	r28, 0x3d	; 61
    3428:	de b7       	in	r29, 0x3e	; 62
    342a:	62 97       	sbiw	r28, 0x12	; 18
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	f8 94       	cli
    3430:	de bf       	out	0x3e, r29	; 62
    3432:	0f be       	out	0x3f, r0	; 63
    3434:	cd bf       	out	0x3d, r28	; 61
    3436:	9a 87       	std	Y+10, r25	; 0x0a
    3438:	89 87       	std	Y+9, r24	; 0x09
    343a:	7c 87       	std	Y+12, r23	; 0x0c
    343c:	6b 87       	std	Y+11, r22	; 0x0b
    343e:	5e 87       	std	Y+14, r21	; 0x0e
    3440:	4d 87       	std	Y+13, r20	; 0x0d
    3442:	38 8b       	std	Y+16, r19	; 0x10
    3444:	2f 87       	std	Y+15, r18	; 0x0f
    3446:	1a 8b       	std	Y+18, r17	; 0x12
    3448:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    344a:	89 89       	ldd	r24, Y+17	; 0x11
    344c:	9a 89       	ldd	r25, Y+18	; 0x12
    344e:	00 97       	sbiw	r24, 0x00	; 0
    3450:	91 f1       	breq	.+100    	; 0x34b6 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3452:	e9 85       	ldd	r30, Y+9	; 0x09
    3454:	fa 85       	ldd	r31, Y+10	; 0x0a
    3456:	80 81       	ld	r24, Z
    3458:	91 81       	ldd	r25, Z+1	; 0x01
    345a:	9e 83       	std	Y+6, r25	; 0x06
    345c:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    345e:	ae 01       	movw	r20, r28
    3460:	49 5f       	subi	r20, 0xF9	; 249
    3462:	5f 4f       	sbci	r21, 0xFF	; 255
    3464:	89 85       	ldd	r24, Y+9	; 0x09
    3466:	9a 85       	ldd	r25, Y+10	; 0x0a
    3468:	29 89       	ldd	r18, Y+17	; 0x11
    346a:	3a 89       	ldd	r19, Y+18	; 0x12
    346c:	ef 85       	ldd	r30, Y+15	; 0x0f
    346e:	f8 89       	ldd	r31, Y+16	; 0x10
    3470:	ba 01       	movw	r22, r20
    3472:	a9 01       	movw	r20, r18
    3474:	9f 01       	movw	r18, r30
    3476:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    347a:	8f 81       	ldd	r24, Y+7	; 0x07
    347c:	98 85       	ldd	r25, Y+8	; 0x08
    347e:	9a 83       	std	Y+2, r25	; 0x02
    3480:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3482:	2f 85       	ldd	r18, Y+15	; 0x0f
    3484:	38 89       	ldd	r19, Y+16	; 0x10
    3486:	89 89       	ldd	r24, Y+17	; 0x11
    3488:	9a 89       	ldd	r25, Y+18	; 0x12
    348a:	a9 01       	movw	r20, r18
    348c:	48 1b       	sub	r20, r24
    348e:	59 0b       	sbc	r21, r25
    3490:	ca 01       	movw	r24, r20
    3492:	98 8b       	std	Y+16, r25	; 0x10
    3494:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3496:	29 81       	ldd	r18, Y+1	; 0x01
    3498:	3a 81       	ldd	r19, Y+2	; 0x02
    349a:	8d 85       	ldd	r24, Y+13	; 0x0d
    349c:	9e 85       	ldd	r25, Y+14	; 0x0e
    349e:	82 17       	cp	r24, r18
    34a0:	93 07       	cpc	r25, r19
    34a2:	68 f4       	brcc	.+26     	; 0x34be <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    34a4:	e9 85       	ldd	r30, Y+9	; 0x09
    34a6:	fa 85       	ldd	r31, Y+10	; 0x0a
    34a8:	8d 81       	ldd	r24, Y+5	; 0x05
    34aa:	9e 81       	ldd	r25, Y+6	; 0x06
    34ac:	91 83       	std	Z+1, r25	; 0x01
    34ae:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    34b0:	1a 82       	std	Y+2, r1	; 0x02
    34b2:	19 82       	std	Y+1, r1	; 0x01
    34b4:	04 c0       	rjmp	.+8      	; 0x34be <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    34b6:	8d 85       	ldd	r24, Y+13	; 0x0d
    34b8:	9e 85       	ldd	r25, Y+14	; 0x0e
    34ba:	9a 83       	std	Y+2, r25	; 0x02
    34bc:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    34be:	4b 85       	ldd	r20, Y+11	; 0x0b
    34c0:	5c 85       	ldd	r21, Y+12	; 0x0c
    34c2:	89 85       	ldd	r24, Y+9	; 0x09
    34c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    34c6:	29 81       	ldd	r18, Y+1	; 0x01
    34c8:	3a 81       	ldd	r19, Y+2	; 0x02
    34ca:	ef 85       	ldd	r30, Y+15	; 0x0f
    34cc:	f8 89       	ldd	r31, Y+16	; 0x10
    34ce:	ba 01       	movw	r22, r20
    34d0:	a9 01       	movw	r20, r18
    34d2:	9f 01       	movw	r18, r30
    34d4:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <prvReadBytesFromBuffer>
    34d8:	9c 83       	std	Y+4, r25	; 0x04
    34da:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    34dc:	8b 81       	ldd	r24, Y+3	; 0x03
    34de:	9c 81       	ldd	r25, Y+4	; 0x04
}
    34e0:	62 96       	adiw	r28, 0x12	; 18
    34e2:	0f b6       	in	r0, 0x3f	; 63
    34e4:	f8 94       	cli
    34e6:	de bf       	out	0x3e, r29	; 62
    34e8:	0f be       	out	0x3f, r0	; 63
    34ea:	cd bf       	out	0x3d, r28	; 61
    34ec:	cf 91       	pop	r28
    34ee:	df 91       	pop	r29
    34f0:	1f 91       	pop	r17
    34f2:	0f 91       	pop	r16
    34f4:	08 95       	ret

000034f6 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    34f6:	df 93       	push	r29
    34f8:	cf 93       	push	r28
    34fa:	cd b7       	in	r28, 0x3d	; 61
    34fc:	de b7       	in	r29, 0x3e	; 62
    34fe:	27 97       	sbiw	r28, 0x07	; 7
    3500:	0f b6       	in	r0, 0x3f	; 63
    3502:	f8 94       	cli
    3504:	de bf       	out	0x3e, r29	; 62
    3506:	0f be       	out	0x3f, r0	; 63
    3508:	cd bf       	out	0x3d, r28	; 61
    350a:	9f 83       	std	Y+7, r25	; 0x07
    350c:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    350e:	8e 81       	ldd	r24, Y+6	; 0x06
    3510:	9f 81       	ldd	r25, Y+7	; 0x07
    3512:	9d 83       	std	Y+5, r25	; 0x05
    3514:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3516:	ec 81       	ldd	r30, Y+4	; 0x04
    3518:	fd 81       	ldd	r31, Y+5	; 0x05
    351a:	80 81       	ld	r24, Z
    351c:	91 81       	ldd	r25, Z+1	; 0x01
    351e:	9a 83       	std	Y+2, r25	; 0x02
    3520:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    3522:	ec 81       	ldd	r30, Y+4	; 0x04
    3524:	fd 81       	ldd	r31, Y+5	; 0x05
    3526:	22 81       	ldd	r18, Z+2	; 0x02
    3528:	33 81       	ldd	r19, Z+3	; 0x03
    352a:	89 81       	ldd	r24, Y+1	; 0x01
    352c:	9a 81       	ldd	r25, Y+2	; 0x02
    352e:	28 17       	cp	r18, r24
    3530:	39 07       	cpc	r19, r25
    3532:	19 f4       	brne	.+6      	; 0x353a <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    3534:	81 e0       	ldi	r24, 0x01	; 1
    3536:	8b 83       	std	Y+3, r24	; 0x03
    3538:	01 c0       	rjmp	.+2      	; 0x353c <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    353a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    353c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    353e:	27 96       	adiw	r28, 0x07	; 7
    3540:	0f b6       	in	r0, 0x3f	; 63
    3542:	f8 94       	cli
    3544:	de bf       	out	0x3e, r29	; 62
    3546:	0f be       	out	0x3f, r0	; 63
    3548:	cd bf       	out	0x3d, r28	; 61
    354a:	cf 91       	pop	r28
    354c:	df 91       	pop	r29
    354e:	08 95       	ret

00003550 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3550:	df 93       	push	r29
    3552:	cf 93       	push	r28
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	27 97       	sbiw	r28, 0x07	; 7
    355a:	0f b6       	in	r0, 0x3f	; 63
    355c:	f8 94       	cli
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	0f be       	out	0x3f, r0	; 63
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	9f 83       	std	Y+7, r25	; 0x07
    3566:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3568:	8e 81       	ldd	r24, Y+6	; 0x06
    356a:	9f 81       	ldd	r25, Y+7	; 0x07
    356c:	9a 83       	std	Y+2, r25	; 0x02
    356e:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3570:	e9 81       	ldd	r30, Y+1	; 0x01
    3572:	fa 81       	ldd	r31, Y+2	; 0x02
    3574:	86 85       	ldd	r24, Z+14	; 0x0e
    3576:	88 2f       	mov	r24, r24
    3578:	90 e0       	ldi	r25, 0x00	; 0
    357a:	81 70       	andi	r24, 0x01	; 1
    357c:	90 70       	andi	r25, 0x00	; 0
    357e:	88 23       	and	r24, r24
    3580:	29 f0       	breq	.+10     	; 0x358c <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3582:	82 e0       	ldi	r24, 0x02	; 2
    3584:	90 e0       	ldi	r25, 0x00	; 0
    3586:	9c 83       	std	Y+4, r25	; 0x04
    3588:	8b 83       	std	Y+3, r24	; 0x03
    358a:	02 c0       	rjmp	.+4      	; 0x3590 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    358c:	1c 82       	std	Y+4, r1	; 0x04
    358e:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3590:	8e 81       	ldd	r24, Y+6	; 0x06
    3592:	9f 81       	ldd	r25, Y+7	; 0x07
    3594:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <xStreamBufferSpacesAvailable>
    3598:	9c 01       	movw	r18, r24
    359a:	8b 81       	ldd	r24, Y+3	; 0x03
    359c:	9c 81       	ldd	r25, Y+4	; 0x04
    359e:	82 17       	cp	r24, r18
    35a0:	93 07       	cpc	r25, r19
    35a2:	18 f0       	brcs	.+6      	; 0x35aa <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    35a4:	81 e0       	ldi	r24, 0x01	; 1
    35a6:	8d 83       	std	Y+5, r24	; 0x05
    35a8:	01 c0       	rjmp	.+2      	; 0x35ac <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    35aa:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    35ac:	8d 81       	ldd	r24, Y+5	; 0x05
}
    35ae:	27 96       	adiw	r28, 0x07	; 7
    35b0:	0f b6       	in	r0, 0x3f	; 63
    35b2:	f8 94       	cli
    35b4:	de bf       	out	0x3e, r29	; 62
    35b6:	0f be       	out	0x3f, r0	; 63
    35b8:	cd bf       	out	0x3d, r28	; 61
    35ba:	cf 91       	pop	r28
    35bc:	df 91       	pop	r29
    35be:	08 95       	ret

000035c0 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    35c0:	ef 92       	push	r14
    35c2:	ff 92       	push	r15
    35c4:	0f 93       	push	r16
    35c6:	1f 93       	push	r17
    35c8:	df 93       	push	r29
    35ca:	cf 93       	push	r28
    35cc:	cd b7       	in	r28, 0x3d	; 61
    35ce:	de b7       	in	r29, 0x3e	; 62
    35d0:	28 97       	sbiw	r28, 0x08	; 8
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	de bf       	out	0x3e, r29	; 62
    35d8:	0f be       	out	0x3f, r0	; 63
    35da:	cd bf       	out	0x3d, r28	; 61
    35dc:	9e 83       	std	Y+6, r25	; 0x06
    35de:	8d 83       	std	Y+5, r24	; 0x05
    35e0:	78 87       	std	Y+8, r23	; 0x08
    35e2:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    35e4:	8d 81       	ldd	r24, Y+5	; 0x05
    35e6:	9e 81       	ldd	r25, Y+6	; 0x06
    35e8:	9c 83       	std	Y+4, r25	; 0x04
    35ea:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    35ec:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    35ee:	eb 81       	ldd	r30, Y+3	; 0x03
    35f0:	fc 81       	ldd	r31, Y+4	; 0x04
    35f2:	80 85       	ldd	r24, Z+8	; 0x08
    35f4:	91 85       	ldd	r25, Z+9	; 0x09
    35f6:	00 97       	sbiw	r24, 0x00	; 0
    35f8:	b9 f0       	breq	.+46     	; 0x3628 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    35fa:	eb 81       	ldd	r30, Y+3	; 0x03
    35fc:	fc 81       	ldd	r31, Y+4	; 0x04
    35fe:	80 85       	ldd	r24, Z+8	; 0x08
    3600:	91 85       	ldd	r25, Z+9	; 0x09
    3602:	ef 81       	ldd	r30, Y+7	; 0x07
    3604:	f8 85       	ldd	r31, Y+8	; 0x08
    3606:	40 e0       	ldi	r20, 0x00	; 0
    3608:	50 e0       	ldi	r21, 0x00	; 0
    360a:	60 e0       	ldi	r22, 0x00	; 0
    360c:	70 e0       	ldi	r23, 0x00	; 0
    360e:	20 e0       	ldi	r18, 0x00	; 0
    3610:	00 e0       	ldi	r16, 0x00	; 0
    3612:	10 e0       	ldi	r17, 0x00	; 0
    3614:	7f 01       	movw	r14, r30
    3616:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    361a:	eb 81       	ldd	r30, Y+3	; 0x03
    361c:	fc 81       	ldd	r31, Y+4	; 0x04
    361e:	11 86       	std	Z+9, r1	; 0x09
    3620:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    3622:	81 e0       	ldi	r24, 0x01	; 1
    3624:	8a 83       	std	Y+2, r24	; 0x02
    3626:	01 c0       	rjmp	.+2      	; 0x362a <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3628:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    362a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    362c:	28 96       	adiw	r28, 0x08	; 8
    362e:	0f b6       	in	r0, 0x3f	; 63
    3630:	f8 94       	cli
    3632:	de bf       	out	0x3e, r29	; 62
    3634:	0f be       	out	0x3f, r0	; 63
    3636:	cd bf       	out	0x3d, r28	; 61
    3638:	cf 91       	pop	r28
    363a:	df 91       	pop	r29
    363c:	1f 91       	pop	r17
    363e:	0f 91       	pop	r16
    3640:	ff 90       	pop	r15
    3642:	ef 90       	pop	r14
    3644:	08 95       	ret

00003646 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3646:	ef 92       	push	r14
    3648:	ff 92       	push	r15
    364a:	0f 93       	push	r16
    364c:	1f 93       	push	r17
    364e:	df 93       	push	r29
    3650:	cf 93       	push	r28
    3652:	cd b7       	in	r28, 0x3d	; 61
    3654:	de b7       	in	r29, 0x3e	; 62
    3656:	28 97       	sbiw	r28, 0x08	; 8
    3658:	0f b6       	in	r0, 0x3f	; 63
    365a:	f8 94       	cli
    365c:	de bf       	out	0x3e, r29	; 62
    365e:	0f be       	out	0x3f, r0	; 63
    3660:	cd bf       	out	0x3d, r28	; 61
    3662:	9e 83       	std	Y+6, r25	; 0x06
    3664:	8d 83       	std	Y+5, r24	; 0x05
    3666:	78 87       	std	Y+8, r23	; 0x08
    3668:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    366a:	8d 81       	ldd	r24, Y+5	; 0x05
    366c:	9e 81       	ldd	r25, Y+6	; 0x06
    366e:	9c 83       	std	Y+4, r25	; 0x04
    3670:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3672:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3674:	eb 81       	ldd	r30, Y+3	; 0x03
    3676:	fc 81       	ldd	r31, Y+4	; 0x04
    3678:	82 85       	ldd	r24, Z+10	; 0x0a
    367a:	93 85       	ldd	r25, Z+11	; 0x0b
    367c:	00 97       	sbiw	r24, 0x00	; 0
    367e:	b9 f0       	breq	.+46     	; 0x36ae <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3680:	eb 81       	ldd	r30, Y+3	; 0x03
    3682:	fc 81       	ldd	r31, Y+4	; 0x04
    3684:	82 85       	ldd	r24, Z+10	; 0x0a
    3686:	93 85       	ldd	r25, Z+11	; 0x0b
    3688:	ef 81       	ldd	r30, Y+7	; 0x07
    368a:	f8 85       	ldd	r31, Y+8	; 0x08
    368c:	40 e0       	ldi	r20, 0x00	; 0
    368e:	50 e0       	ldi	r21, 0x00	; 0
    3690:	60 e0       	ldi	r22, 0x00	; 0
    3692:	70 e0       	ldi	r23, 0x00	; 0
    3694:	20 e0       	ldi	r18, 0x00	; 0
    3696:	00 e0       	ldi	r16, 0x00	; 0
    3698:	10 e0       	ldi	r17, 0x00	; 0
    369a:	7f 01       	movw	r14, r30
    369c:	0e 94 fb 27 	call	0x4ff6	; 0x4ff6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    36a0:	eb 81       	ldd	r30, Y+3	; 0x03
    36a2:	fc 81       	ldd	r31, Y+4	; 0x04
    36a4:	13 86       	std	Z+11, r1	; 0x0b
    36a6:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    36a8:	81 e0       	ldi	r24, 0x01	; 1
    36aa:	8a 83       	std	Y+2, r24	; 0x02
    36ac:	01 c0       	rjmp	.+2      	; 0x36b0 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    36ae:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    36b0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    36b2:	28 96       	adiw	r28, 0x08	; 8
    36b4:	0f b6       	in	r0, 0x3f	; 63
    36b6:	f8 94       	cli
    36b8:	de bf       	out	0x3e, r29	; 62
    36ba:	0f be       	out	0x3f, r0	; 63
    36bc:	cd bf       	out	0x3d, r28	; 61
    36be:	cf 91       	pop	r28
    36c0:	df 91       	pop	r29
    36c2:	1f 91       	pop	r17
    36c4:	0f 91       	pop	r16
    36c6:	ff 90       	pop	r15
    36c8:	ef 90       	pop	r14
    36ca:	08 95       	ret

000036cc <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    36cc:	df 93       	push	r29
    36ce:	cf 93       	push	r28
    36d0:	cd b7       	in	r28, 0x3d	; 61
    36d2:	de b7       	in	r29, 0x3e	; 62
    36d4:	2e 97       	sbiw	r28, 0x0e	; 14
    36d6:	0f b6       	in	r0, 0x3f	; 63
    36d8:	f8 94       	cli
    36da:	de bf       	out	0x3e, r29	; 62
    36dc:	0f be       	out	0x3f, r0	; 63
    36de:	cd bf       	out	0x3d, r28	; 61
    36e0:	9e 83       	std	Y+6, r25	; 0x06
    36e2:	8d 83       	std	Y+5, r24	; 0x05
    36e4:	78 87       	std	Y+8, r23	; 0x08
    36e6:	6f 83       	std	Y+7, r22	; 0x07
    36e8:	5a 87       	std	Y+10, r21	; 0x0a
    36ea:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    36ec:	ed 81       	ldd	r30, Y+5	; 0x05
    36ee:	fe 81       	ldd	r31, Y+6	; 0x06
    36f0:	82 81       	ldd	r24, Z+2	; 0x02
    36f2:	93 81       	ldd	r25, Z+3	; 0x03
    36f4:	9c 83       	std	Y+4, r25	; 0x04
    36f6:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    36f8:	ed 81       	ldd	r30, Y+5	; 0x05
    36fa:	fe 81       	ldd	r31, Y+6	; 0x06
    36fc:	24 81       	ldd	r18, Z+4	; 0x04
    36fe:	35 81       	ldd	r19, Z+5	; 0x05
    3700:	8b 81       	ldd	r24, Y+3	; 0x03
    3702:	9c 81       	ldd	r25, Y+4	; 0x04
    3704:	a9 01       	movw	r20, r18
    3706:	48 1b       	sub	r20, r24
    3708:	59 0b       	sbc	r21, r25
    370a:	ca 01       	movw	r24, r20
    370c:	29 85       	ldd	r18, Y+9	; 0x09
    370e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3710:	3e 87       	std	Y+14, r19	; 0x0e
    3712:	2d 87       	std	Y+13, r18	; 0x0d
    3714:	9c 87       	std	Y+12, r25	; 0x0c
    3716:	8b 87       	std	Y+11, r24	; 0x0b
    3718:	4b 85       	ldd	r20, Y+11	; 0x0b
    371a:	5c 85       	ldd	r21, Y+12	; 0x0c
    371c:	8d 85       	ldd	r24, Y+13	; 0x0d
    371e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3720:	84 17       	cp	r24, r20
    3722:	95 07       	cpc	r25, r21
    3724:	20 f4       	brcc	.+8      	; 0x372e <prvWriteBytesToBuffer+0x62>
    3726:	2d 85       	ldd	r18, Y+13	; 0x0d
    3728:	3e 85       	ldd	r19, Y+14	; 0x0e
    372a:	3c 87       	std	Y+12, r19	; 0x0c
    372c:	2b 87       	std	Y+11, r18	; 0x0b
    372e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3730:	5c 85       	ldd	r21, Y+12	; 0x0c
    3732:	5a 83       	std	Y+2, r21	; 0x02
    3734:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3736:	ed 81       	ldd	r30, Y+5	; 0x05
    3738:	fe 81       	ldd	r31, Y+6	; 0x06
    373a:	24 85       	ldd	r18, Z+12	; 0x0c
    373c:	35 85       	ldd	r19, Z+13	; 0x0d
    373e:	8b 81       	ldd	r24, Y+3	; 0x03
    3740:	9c 81       	ldd	r25, Y+4	; 0x04
    3742:	82 0f       	add	r24, r18
    3744:	93 1f       	adc	r25, r19
    3746:	2f 81       	ldd	r18, Y+7	; 0x07
    3748:	38 85       	ldd	r19, Y+8	; 0x08
    374a:	49 81       	ldd	r20, Y+1	; 0x01
    374c:	5a 81       	ldd	r21, Y+2	; 0x02
    374e:	b9 01       	movw	r22, r18
    3750:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3754:	29 85       	ldd	r18, Y+9	; 0x09
    3756:	3a 85       	ldd	r19, Y+10	; 0x0a
    3758:	89 81       	ldd	r24, Y+1	; 0x01
    375a:	9a 81       	ldd	r25, Y+2	; 0x02
    375c:	82 17       	cp	r24, r18
    375e:	93 07       	cpc	r25, r19
    3760:	b0 f4       	brcc	.+44     	; 0x378e <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3762:	ed 81       	ldd	r30, Y+5	; 0x05
    3764:	fe 81       	ldd	r31, Y+6	; 0x06
    3766:	64 85       	ldd	r22, Z+12	; 0x0c
    3768:	75 85       	ldd	r23, Z+13	; 0x0d
    376a:	2f 81       	ldd	r18, Y+7	; 0x07
    376c:	38 85       	ldd	r19, Y+8	; 0x08
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	9a 81       	ldd	r25, Y+2	; 0x02
    3772:	a9 01       	movw	r20, r18
    3774:	48 0f       	add	r20, r24
    3776:	59 1f       	adc	r21, r25
    3778:	29 85       	ldd	r18, Y+9	; 0x09
    377a:	3a 85       	ldd	r19, Y+10	; 0x0a
    377c:	89 81       	ldd	r24, Y+1	; 0x01
    377e:	9a 81       	ldd	r25, Y+2	; 0x02
    3780:	28 1b       	sub	r18, r24
    3782:	39 0b       	sbc	r19, r25
    3784:	cb 01       	movw	r24, r22
    3786:	ba 01       	movw	r22, r20
    3788:	a9 01       	movw	r20, r18
    378a:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    378e:	2b 81       	ldd	r18, Y+3	; 0x03
    3790:	3c 81       	ldd	r19, Y+4	; 0x04
    3792:	89 85       	ldd	r24, Y+9	; 0x09
    3794:	9a 85       	ldd	r25, Y+10	; 0x0a
    3796:	82 0f       	add	r24, r18
    3798:	93 1f       	adc	r25, r19
    379a:	9c 83       	std	Y+4, r25	; 0x04
    379c:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    379e:	ed 81       	ldd	r30, Y+5	; 0x05
    37a0:	fe 81       	ldd	r31, Y+6	; 0x06
    37a2:	24 81       	ldd	r18, Z+4	; 0x04
    37a4:	35 81       	ldd	r19, Z+5	; 0x05
    37a6:	8b 81       	ldd	r24, Y+3	; 0x03
    37a8:	9c 81       	ldd	r25, Y+4	; 0x04
    37aa:	82 17       	cp	r24, r18
    37ac:	93 07       	cpc	r25, r19
    37ae:	50 f0       	brcs	.+20     	; 0x37c4 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    37b0:	ed 81       	ldd	r30, Y+5	; 0x05
    37b2:	fe 81       	ldd	r31, Y+6	; 0x06
    37b4:	24 81       	ldd	r18, Z+4	; 0x04
    37b6:	35 81       	ldd	r19, Z+5	; 0x05
    37b8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ba:	9c 81       	ldd	r25, Y+4	; 0x04
    37bc:	82 1b       	sub	r24, r18
    37be:	93 0b       	sbc	r25, r19
    37c0:	9c 83       	std	Y+4, r25	; 0x04
    37c2:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    37c4:	ed 81       	ldd	r30, Y+5	; 0x05
    37c6:	fe 81       	ldd	r31, Y+6	; 0x06
    37c8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ca:	9c 81       	ldd	r25, Y+4	; 0x04
    37cc:	93 83       	std	Z+3, r25	; 0x03
    37ce:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    37d0:	89 85       	ldd	r24, Y+9	; 0x09
    37d2:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    37d4:	2e 96       	adiw	r28, 0x0e	; 14
    37d6:	0f b6       	in	r0, 0x3f	; 63
    37d8:	f8 94       	cli
    37da:	de bf       	out	0x3e, r29	; 62
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	cd bf       	out	0x3d, r28	; 61
    37e0:	cf 91       	pop	r28
    37e2:	df 91       	pop	r29
    37e4:	08 95       	ret

000037e6 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    37e6:	df 93       	push	r29
    37e8:	cf 93       	push	r28
    37ea:	cd b7       	in	r28, 0x3d	; 61
    37ec:	de b7       	in	r29, 0x3e	; 62
    37ee:	66 97       	sbiw	r28, 0x16	; 22
    37f0:	0f b6       	in	r0, 0x3f	; 63
    37f2:	f8 94       	cli
    37f4:	de bf       	out	0x3e, r29	; 62
    37f6:	0f be       	out	0x3f, r0	; 63
    37f8:	cd bf       	out	0x3d, r28	; 61
    37fa:	98 87       	std	Y+8, r25	; 0x08
    37fc:	8f 83       	std	Y+7, r24	; 0x07
    37fe:	7a 87       	std	Y+10, r23	; 0x0a
    3800:	69 87       	std	Y+9, r22	; 0x09
    3802:	5c 87       	std	Y+12, r21	; 0x0c
    3804:	4b 87       	std	Y+11, r20	; 0x0b
    3806:	3e 87       	std	Y+14, r19	; 0x0e
    3808:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    380a:	2d 85       	ldd	r18, Y+13	; 0x0d
    380c:	3e 85       	ldd	r19, Y+14	; 0x0e
    380e:	3a 8b       	std	Y+18, r19	; 0x12
    3810:	29 8b       	std	Y+17, r18	; 0x11
    3812:	4b 85       	ldd	r20, Y+11	; 0x0b
    3814:	5c 85       	ldd	r21, Y+12	; 0x0c
    3816:	58 8b       	std	Y+16, r21	; 0x10
    3818:	4f 87       	std	Y+15, r20	; 0x0f
    381a:	8f 85       	ldd	r24, Y+15	; 0x0f
    381c:	98 89       	ldd	r25, Y+16	; 0x10
    381e:	29 89       	ldd	r18, Y+17	; 0x11
    3820:	3a 89       	ldd	r19, Y+18	; 0x12
    3822:	28 17       	cp	r18, r24
    3824:	39 07       	cpc	r19, r25
    3826:	20 f4       	brcc	.+8      	; 0x3830 <prvReadBytesFromBuffer+0x4a>
    3828:	49 89       	ldd	r20, Y+17	; 0x11
    382a:	5a 89       	ldd	r21, Y+18	; 0x12
    382c:	58 8b       	std	Y+16, r21	; 0x10
    382e:	4f 87       	std	Y+15, r20	; 0x0f
    3830:	8f 85       	ldd	r24, Y+15	; 0x0f
    3832:	98 89       	ldd	r25, Y+16	; 0x10
    3834:	9e 83       	std	Y+6, r25	; 0x06
    3836:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3838:	8d 81       	ldd	r24, Y+5	; 0x05
    383a:	9e 81       	ldd	r25, Y+6	; 0x06
    383c:	00 97       	sbiw	r24, 0x00	; 0
    383e:	09 f4       	brne	.+2      	; 0x3842 <prvReadBytesFromBuffer+0x5c>
    3840:	74 c0       	rjmp	.+232    	; 0x392a <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3842:	ef 81       	ldd	r30, Y+7	; 0x07
    3844:	f8 85       	ldd	r31, Y+8	; 0x08
    3846:	80 81       	ld	r24, Z
    3848:	91 81       	ldd	r25, Z+1	; 0x01
    384a:	9a 83       	std	Y+2, r25	; 0x02
    384c:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    384e:	ef 81       	ldd	r30, Y+7	; 0x07
    3850:	f8 85       	ldd	r31, Y+8	; 0x08
    3852:	24 81       	ldd	r18, Z+4	; 0x04
    3854:	35 81       	ldd	r19, Z+5	; 0x05
    3856:	89 81       	ldd	r24, Y+1	; 0x01
    3858:	9a 81       	ldd	r25, Y+2	; 0x02
    385a:	a9 01       	movw	r20, r18
    385c:	48 1b       	sub	r20, r24
    385e:	59 0b       	sbc	r21, r25
    3860:	ca 01       	movw	r24, r20
    3862:	2d 81       	ldd	r18, Y+5	; 0x05
    3864:	3e 81       	ldd	r19, Y+6	; 0x06
    3866:	3e 8b       	std	Y+22, r19	; 0x16
    3868:	2d 8b       	std	Y+21, r18	; 0x15
    386a:	9c 8b       	std	Y+20, r25	; 0x14
    386c:	8b 8b       	std	Y+19, r24	; 0x13
    386e:	4b 89       	ldd	r20, Y+19	; 0x13
    3870:	5c 89       	ldd	r21, Y+20	; 0x14
    3872:	8d 89       	ldd	r24, Y+21	; 0x15
    3874:	9e 89       	ldd	r25, Y+22	; 0x16
    3876:	84 17       	cp	r24, r20
    3878:	95 07       	cpc	r25, r21
    387a:	20 f4       	brcc	.+8      	; 0x3884 <prvReadBytesFromBuffer+0x9e>
    387c:	2d 89       	ldd	r18, Y+21	; 0x15
    387e:	3e 89       	ldd	r19, Y+22	; 0x16
    3880:	3c 8b       	std	Y+20, r19	; 0x14
    3882:	2b 8b       	std	Y+19, r18	; 0x13
    3884:	4b 89       	ldd	r20, Y+19	; 0x13
    3886:	5c 89       	ldd	r21, Y+20	; 0x14
    3888:	5c 83       	std	Y+4, r21	; 0x04
    388a:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    388c:	ef 81       	ldd	r30, Y+7	; 0x07
    388e:	f8 85       	ldd	r31, Y+8	; 0x08
    3890:	24 85       	ldd	r18, Z+12	; 0x0c
    3892:	35 85       	ldd	r19, Z+13	; 0x0d
    3894:	89 81       	ldd	r24, Y+1	; 0x01
    3896:	9a 81       	ldd	r25, Y+2	; 0x02
    3898:	a9 01       	movw	r20, r18
    389a:	48 0f       	add	r20, r24
    389c:	59 1f       	adc	r21, r25
    389e:	89 85       	ldd	r24, Y+9	; 0x09
    38a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    38a2:	2b 81       	ldd	r18, Y+3	; 0x03
    38a4:	3c 81       	ldd	r19, Y+4	; 0x04
    38a6:	ba 01       	movw	r22, r20
    38a8:	a9 01       	movw	r20, r18
    38aa:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    38ae:	2d 81       	ldd	r18, Y+5	; 0x05
    38b0:	3e 81       	ldd	r19, Y+6	; 0x06
    38b2:	8b 81       	ldd	r24, Y+3	; 0x03
    38b4:	9c 81       	ldd	r25, Y+4	; 0x04
    38b6:	82 17       	cp	r24, r18
    38b8:	93 07       	cpc	r25, r19
    38ba:	b0 f4       	brcc	.+44     	; 0x38e8 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    38bc:	29 85       	ldd	r18, Y+9	; 0x09
    38be:	3a 85       	ldd	r19, Y+10	; 0x0a
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	b9 01       	movw	r22, r18
    38c6:	68 0f       	add	r22, r24
    38c8:	79 1f       	adc	r23, r25
    38ca:	ef 81       	ldd	r30, Y+7	; 0x07
    38cc:	f8 85       	ldd	r31, Y+8	; 0x08
    38ce:	44 85       	ldd	r20, Z+12	; 0x0c
    38d0:	55 85       	ldd	r21, Z+13	; 0x0d
    38d2:	2d 81       	ldd	r18, Y+5	; 0x05
    38d4:	3e 81       	ldd	r19, Y+6	; 0x06
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	9c 81       	ldd	r25, Y+4	; 0x04
    38da:	28 1b       	sub	r18, r24
    38dc:	39 0b       	sbc	r19, r25
    38de:	cb 01       	movw	r24, r22
    38e0:	ba 01       	movw	r22, r20
    38e2:	a9 01       	movw	r20, r18
    38e4:	0e 94 2f 2a 	call	0x545e	; 0x545e <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    38e8:	29 81       	ldd	r18, Y+1	; 0x01
    38ea:	3a 81       	ldd	r19, Y+2	; 0x02
    38ec:	8d 81       	ldd	r24, Y+5	; 0x05
    38ee:	9e 81       	ldd	r25, Y+6	; 0x06
    38f0:	82 0f       	add	r24, r18
    38f2:	93 1f       	adc	r25, r19
    38f4:	9a 83       	std	Y+2, r25	; 0x02
    38f6:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    38f8:	ef 81       	ldd	r30, Y+7	; 0x07
    38fa:	f8 85       	ldd	r31, Y+8	; 0x08
    38fc:	24 81       	ldd	r18, Z+4	; 0x04
    38fe:	35 81       	ldd	r19, Z+5	; 0x05
    3900:	89 81       	ldd	r24, Y+1	; 0x01
    3902:	9a 81       	ldd	r25, Y+2	; 0x02
    3904:	82 17       	cp	r24, r18
    3906:	93 07       	cpc	r25, r19
    3908:	50 f0       	brcs	.+20     	; 0x391e <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    390a:	ef 81       	ldd	r30, Y+7	; 0x07
    390c:	f8 85       	ldd	r31, Y+8	; 0x08
    390e:	24 81       	ldd	r18, Z+4	; 0x04
    3910:	35 81       	ldd	r19, Z+5	; 0x05
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	9a 81       	ldd	r25, Y+2	; 0x02
    3916:	82 1b       	sub	r24, r18
    3918:	93 0b       	sbc	r25, r19
    391a:	9a 83       	std	Y+2, r25	; 0x02
    391c:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    391e:	ef 81       	ldd	r30, Y+7	; 0x07
    3920:	f8 85       	ldd	r31, Y+8	; 0x08
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	9a 81       	ldd	r25, Y+2	; 0x02
    3926:	91 83       	std	Z+1, r25	; 0x01
    3928:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    392a:	8d 81       	ldd	r24, Y+5	; 0x05
    392c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    392e:	66 96       	adiw	r28, 0x16	; 22
    3930:	0f b6       	in	r0, 0x3f	; 63
    3932:	f8 94       	cli
    3934:	de bf       	out	0x3e, r29	; 62
    3936:	0f be       	out	0x3f, r0	; 63
    3938:	cd bf       	out	0x3d, r28	; 61
    393a:	cf 91       	pop	r28
    393c:	df 91       	pop	r29
    393e:	08 95       	ret

00003940 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3940:	df 93       	push	r29
    3942:	cf 93       	push	r28
    3944:	00 d0       	rcall	.+0      	; 0x3946 <prvBytesInBuffer+0x6>
    3946:	00 d0       	rcall	.+0      	; 0x3948 <prvBytesInBuffer+0x8>
    3948:	cd b7       	in	r28, 0x3d	; 61
    394a:	de b7       	in	r29, 0x3e	; 62
    394c:	9c 83       	std	Y+4, r25	; 0x04
    394e:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3950:	eb 81       	ldd	r30, Y+3	; 0x03
    3952:	fc 81       	ldd	r31, Y+4	; 0x04
    3954:	24 81       	ldd	r18, Z+4	; 0x04
    3956:	35 81       	ldd	r19, Z+5	; 0x05
    3958:	eb 81       	ldd	r30, Y+3	; 0x03
    395a:	fc 81       	ldd	r31, Y+4	; 0x04
    395c:	82 81       	ldd	r24, Z+2	; 0x02
    395e:	93 81       	ldd	r25, Z+3	; 0x03
    3960:	82 0f       	add	r24, r18
    3962:	93 1f       	adc	r25, r19
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3968:	eb 81       	ldd	r30, Y+3	; 0x03
    396a:	fc 81       	ldd	r31, Y+4	; 0x04
    396c:	20 81       	ld	r18, Z
    396e:	31 81       	ldd	r19, Z+1	; 0x01
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	9a 81       	ldd	r25, Y+2	; 0x02
    3974:	82 1b       	sub	r24, r18
    3976:	93 0b       	sbc	r25, r19
    3978:	9a 83       	std	Y+2, r25	; 0x02
    397a:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    397c:	eb 81       	ldd	r30, Y+3	; 0x03
    397e:	fc 81       	ldd	r31, Y+4	; 0x04
    3980:	24 81       	ldd	r18, Z+4	; 0x04
    3982:	35 81       	ldd	r19, Z+5	; 0x05
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
    3988:	82 17       	cp	r24, r18
    398a:	93 07       	cpc	r25, r19
    398c:	50 f0       	brcs	.+20     	; 0x39a2 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    398e:	eb 81       	ldd	r30, Y+3	; 0x03
    3990:	fc 81       	ldd	r31, Y+4	; 0x04
    3992:	24 81       	ldd	r18, Z+4	; 0x04
    3994:	35 81       	ldd	r19, Z+5	; 0x05
    3996:	89 81       	ldd	r24, Y+1	; 0x01
    3998:	9a 81       	ldd	r25, Y+2	; 0x02
    399a:	82 1b       	sub	r24, r18
    399c:	93 0b       	sbc	r25, r19
    399e:	9a 83       	std	Y+2, r25	; 0x02
    39a0:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    39a2:	89 81       	ldd	r24, Y+1	; 0x01
    39a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39a6:	0f 90       	pop	r0
    39a8:	0f 90       	pop	r0
    39aa:	0f 90       	pop	r0
    39ac:	0f 90       	pop	r0
    39ae:	cf 91       	pop	r28
    39b0:	df 91       	pop	r29
    39b2:	08 95       	ret

000039b4 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    39b4:	0f 93       	push	r16
    39b6:	df 93       	push	r29
    39b8:	cf 93       	push	r28
    39ba:	cd b7       	in	r28, 0x3d	; 61
    39bc:	de b7       	in	r29, 0x3e	; 62
    39be:	29 97       	sbiw	r28, 0x09	; 9
    39c0:	0f b6       	in	r0, 0x3f	; 63
    39c2:	f8 94       	cli
    39c4:	de bf       	out	0x3e, r29	; 62
    39c6:	0f be       	out	0x3f, r0	; 63
    39c8:	cd bf       	out	0x3d, r28	; 61
    39ca:	9a 83       	std	Y+2, r25	; 0x02
    39cc:	89 83       	std	Y+1, r24	; 0x01
    39ce:	7c 83       	std	Y+4, r23	; 0x04
    39d0:	6b 83       	std	Y+3, r22	; 0x03
    39d2:	5e 83       	std	Y+6, r21	; 0x06
    39d4:	4d 83       	std	Y+5, r20	; 0x05
    39d6:	38 87       	std	Y+8, r19	; 0x08
    39d8:	2f 83       	std	Y+7, r18	; 0x07
    39da:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    39dc:	89 81       	ldd	r24, Y+1	; 0x01
    39de:	9a 81       	ldd	r25, Y+2	; 0x02
    39e0:	60 e0       	ldi	r22, 0x00	; 0
    39e2:	70 e0       	ldi	r23, 0x00	; 0
    39e4:	4f e0       	ldi	r20, 0x0F	; 15
    39e6:	50 e0       	ldi	r21, 0x00	; 0
    39e8:	0e 94 38 2a 	call	0x5470	; 0x5470 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    39ec:	e9 81       	ldd	r30, Y+1	; 0x01
    39ee:	fa 81       	ldd	r31, Y+2	; 0x02
    39f0:	8b 81       	ldd	r24, Y+3	; 0x03
    39f2:	9c 81       	ldd	r25, Y+4	; 0x04
    39f4:	95 87       	std	Z+13, r25	; 0x0d
    39f6:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    39f8:	e9 81       	ldd	r30, Y+1	; 0x01
    39fa:	fa 81       	ldd	r31, Y+2	; 0x02
    39fc:	8d 81       	ldd	r24, Y+5	; 0x05
    39fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3a00:	95 83       	std	Z+5, r25	; 0x05
    3a02:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3a04:	e9 81       	ldd	r30, Y+1	; 0x01
    3a06:	fa 81       	ldd	r31, Y+2	; 0x02
    3a08:	8f 81       	ldd	r24, Y+7	; 0x07
    3a0a:	98 85       	ldd	r25, Y+8	; 0x08
    3a0c:	97 83       	std	Z+7, r25	; 0x07
    3a0e:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3a10:	e9 81       	ldd	r30, Y+1	; 0x01
    3a12:	fa 81       	ldd	r31, Y+2	; 0x02
    3a14:	89 85       	ldd	r24, Y+9	; 0x09
    3a16:	86 87       	std	Z+14, r24	; 0x0e
}
    3a18:	29 96       	adiw	r28, 0x09	; 9
    3a1a:	0f b6       	in	r0, 0x3f	; 63
    3a1c:	f8 94       	cli
    3a1e:	de bf       	out	0x3e, r29	; 62
    3a20:	0f be       	out	0x3f, r0	; 63
    3a22:	cd bf       	out	0x3d, r28	; 61
    3a24:	cf 91       	pop	r28
    3a26:	df 91       	pop	r29
    3a28:	0f 91       	pop	r16
    3a2a:	08 95       	ret

00003a2c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3a2c:	8f 92       	push	r8
    3a2e:	9f 92       	push	r9
    3a30:	af 92       	push	r10
    3a32:	bf 92       	push	r11
    3a34:	cf 92       	push	r12
    3a36:	df 92       	push	r13
    3a38:	ef 92       	push	r14
    3a3a:	ff 92       	push	r15
    3a3c:	0f 93       	push	r16
    3a3e:	1f 93       	push	r17
    3a40:	df 93       	push	r29
    3a42:	cf 93       	push	r28
    3a44:	cd b7       	in	r28, 0x3d	; 61
    3a46:	de b7       	in	r29, 0x3e	; 62
    3a48:	60 97       	sbiw	r28, 0x10	; 16
    3a4a:	0f b6       	in	r0, 0x3f	; 63
    3a4c:	f8 94       	cli
    3a4e:	de bf       	out	0x3e, r29	; 62
    3a50:	0f be       	out	0x3f, r0	; 63
    3a52:	cd bf       	out	0x3d, r28	; 61
    3a54:	9f 83       	std	Y+7, r25	; 0x07
    3a56:	8e 83       	std	Y+6, r24	; 0x06
    3a58:	79 87       	std	Y+9, r23	; 0x09
    3a5a:	68 87       	std	Y+8, r22	; 0x08
    3a5c:	5b 87       	std	Y+11, r21	; 0x0b
    3a5e:	4a 87       	std	Y+10, r20	; 0x0a
    3a60:	3d 87       	std	Y+13, r19	; 0x0d
    3a62:	2c 87       	std	Y+12, r18	; 0x0c
    3a64:	0e 87       	std	Y+14, r16	; 0x0e
    3a66:	f8 8a       	std	Y+16, r15	; 0x10
    3a68:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3a6a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a6c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a6e:	0e 94 23 07 	call	0xe46	; 0xe46 <pvPortMalloc>
    3a72:	9a 83       	std	Y+2, r25	; 0x02
    3a74:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3a76:	89 81       	ldd	r24, Y+1	; 0x01
    3a78:	9a 81       	ldd	r25, Y+2	; 0x02
    3a7a:	00 97       	sbiw	r24, 0x00	; 0
    3a7c:	b1 f0       	breq	.+44     	; 0x3aaa <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3a7e:	8a e2       	ldi	r24, 0x2A	; 42
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	0e 94 23 07 	call	0xe46	; 0xe46 <pvPortMalloc>
    3a86:	9d 83       	std	Y+5, r25	; 0x05
    3a88:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a8e:	00 97       	sbiw	r24, 0x00	; 0
    3a90:	39 f0       	breq	.+14     	; 0x3aa0 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3a92:	ec 81       	ldd	r30, Y+4	; 0x04
    3a94:	fd 81       	ldd	r31, Y+5	; 0x05
    3a96:	89 81       	ldd	r24, Y+1	; 0x01
    3a98:	9a 81       	ldd	r25, Y+2	; 0x02
    3a9a:	90 8f       	std	Z+24, r25	; 0x18
    3a9c:	87 8b       	std	Z+23, r24	; 0x17
    3a9e:	07 c0       	rjmp	.+14     	; 0x3aae <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3aa0:	89 81       	ldd	r24, Y+1	; 0x01
    3aa2:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa4:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
    3aa8:	02 c0       	rjmp	.+4      	; 0x3aae <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3aaa:	1d 82       	std	Y+5, r1	; 0x05
    3aac:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3aae:	8c 81       	ldd	r24, Y+4	; 0x04
    3ab0:	9d 81       	ldd	r25, Y+5	; 0x05
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	e9 f0       	breq	.+58     	; 0x3af0 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3ab6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ab8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3aba:	9c 01       	movw	r18, r24
    3abc:	40 e0       	ldi	r20, 0x00	; 0
    3abe:	50 e0       	ldi	r21, 0x00	; 0
    3ac0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ac2:	9f 81       	ldd	r25, Y+7	; 0x07
    3ac4:	68 85       	ldd	r22, Y+8	; 0x08
    3ac6:	79 85       	ldd	r23, Y+9	; 0x09
    3ac8:	ec 85       	ldd	r30, Y+12	; 0x0c
    3aca:	fd 85       	ldd	r31, Y+13	; 0x0d
    3acc:	af 85       	ldd	r26, Y+15	; 0x0f
    3ace:	b8 89       	ldd	r27, Y+16	; 0x10
    3ad0:	ac 80       	ldd	r10, Y+4	; 0x04
    3ad2:	bd 80       	ldd	r11, Y+5	; 0x05
    3ad4:	8f 01       	movw	r16, r30
    3ad6:	ee 84       	ldd	r14, Y+14	; 0x0e
    3ad8:	6d 01       	movw	r12, r26
    3ada:	88 24       	eor	r8, r8
    3adc:	99 24       	eor	r9, r9
    3ade:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3ae2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ae4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ae6:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3aea:	81 e0       	ldi	r24, 0x01	; 1
    3aec:	8b 83       	std	Y+3, r24	; 0x03
    3aee:	02 c0       	rjmp	.+4      	; 0x3af4 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3af0:	8f ef       	ldi	r24, 0xFF	; 255
    3af2:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3af4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3af6:	60 96       	adiw	r28, 0x10	; 16
    3af8:	0f b6       	in	r0, 0x3f	; 63
    3afa:	f8 94       	cli
    3afc:	de bf       	out	0x3e, r29	; 62
    3afe:	0f be       	out	0x3f, r0	; 63
    3b00:	cd bf       	out	0x3d, r28	; 61
    3b02:	cf 91       	pop	r28
    3b04:	df 91       	pop	r29
    3b06:	1f 91       	pop	r17
    3b08:	0f 91       	pop	r16
    3b0a:	ff 90       	pop	r15
    3b0c:	ef 90       	pop	r14
    3b0e:	df 90       	pop	r13
    3b10:	cf 90       	pop	r12
    3b12:	bf 90       	pop	r11
    3b14:	af 90       	pop	r10
    3b16:	9f 90       	pop	r9
    3b18:	8f 90       	pop	r8
    3b1a:	08 95       	ret

00003b1c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3b1c:	8f 92       	push	r8
    3b1e:	9f 92       	push	r9
    3b20:	af 92       	push	r10
    3b22:	bf 92       	push	r11
    3b24:	cf 92       	push	r12
    3b26:	df 92       	push	r13
    3b28:	ef 92       	push	r14
    3b2a:	0f 93       	push	r16
    3b2c:	1f 93       	push	r17
    3b2e:	df 93       	push	r29
    3b30:	cf 93       	push	r28
    3b32:	cd b7       	in	r28, 0x3d	; 61
    3b34:	de b7       	in	r29, 0x3e	; 62
    3b36:	64 97       	sbiw	r28, 0x14	; 20
    3b38:	0f b6       	in	r0, 0x3f	; 63
    3b3a:	f8 94       	cli
    3b3c:	de bf       	out	0x3e, r29	; 62
    3b3e:	0f be       	out	0x3f, r0	; 63
    3b40:	cd bf       	out	0x3d, r28	; 61
    3b42:	9d 83       	std	Y+5, r25	; 0x05
    3b44:	8c 83       	std	Y+4, r24	; 0x04
    3b46:	7f 83       	std	Y+7, r23	; 0x07
    3b48:	6e 83       	std	Y+6, r22	; 0x06
    3b4a:	28 87       	std	Y+8, r18	; 0x08
    3b4c:	39 87       	std	Y+9, r19	; 0x09
    3b4e:	4a 87       	std	Y+10, r20	; 0x0a
    3b50:	5b 87       	std	Y+11, r21	; 0x0b
    3b52:	1d 87       	std	Y+13, r17	; 0x0d
    3b54:	0c 87       	std	Y+12, r16	; 0x0c
    3b56:	ee 86       	std	Y+14, r14	; 0x0e
    3b58:	d8 8a       	std	Y+16, r13	; 0x10
    3b5a:	cf 86       	std	Y+15, r12	; 0x0f
    3b5c:	ba 8a       	std	Y+18, r11	; 0x12
    3b5e:	a9 8a       	std	Y+17, r10	; 0x11
    3b60:	9c 8a       	std	Y+20, r9	; 0x14
    3b62:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3b64:	e9 89       	ldd	r30, Y+17	; 0x11
    3b66:	fa 89       	ldd	r31, Y+18	; 0x12
    3b68:	27 89       	ldd	r18, Z+23	; 0x17
    3b6a:	30 8d       	ldd	r19, Z+24	; 0x18
    3b6c:	88 85       	ldd	r24, Y+8	; 0x08
    3b6e:	99 85       	ldd	r25, Y+9	; 0x09
    3b70:	01 97       	sbiw	r24, 0x01	; 1
    3b72:	82 0f       	add	r24, r18
    3b74:	93 1f       	adc	r25, r19
    3b76:	9b 83       	std	Y+3, r25	; 0x03
    3b78:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    3b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    3b7e:	00 97       	sbiw	r24, 0x00	; 0
    3b80:	51 f1       	breq	.+84     	; 0x3bd6 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3b82:	19 82       	std	Y+1, r1	; 0x01
    3b84:	21 c0       	rjmp	.+66     	; 0x3bc8 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
    3b88:	48 2f       	mov	r20, r24
    3b8a:	50 e0       	ldi	r21, 0x00	; 0
    3b8c:	89 81       	ldd	r24, Y+1	; 0x01
    3b8e:	28 2f       	mov	r18, r24
    3b90:	30 e0       	ldi	r19, 0x00	; 0
    3b92:	8e 81       	ldd	r24, Y+6	; 0x06
    3b94:	9f 81       	ldd	r25, Y+7	; 0x07
    3b96:	fc 01       	movw	r30, r24
    3b98:	e2 0f       	add	r30, r18
    3b9a:	f3 1f       	adc	r31, r19
    3b9c:	20 81       	ld	r18, Z
    3b9e:	89 89       	ldd	r24, Y+17	; 0x11
    3ba0:	9a 89       	ldd	r25, Y+18	; 0x12
    3ba2:	84 0f       	add	r24, r20
    3ba4:	95 1f       	adc	r25, r21
    3ba6:	fc 01       	movw	r30, r24
    3ba8:	79 96       	adiw	r30, 0x19	; 25
    3baa:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	28 2f       	mov	r18, r24
    3bb0:	30 e0       	ldi	r19, 0x00	; 0
    3bb2:	8e 81       	ldd	r24, Y+6	; 0x06
    3bb4:	9f 81       	ldd	r25, Y+7	; 0x07
    3bb6:	fc 01       	movw	r30, r24
    3bb8:	e2 0f       	add	r30, r18
    3bba:	f3 1f       	adc	r31, r19
    3bbc:	80 81       	ld	r24, Z
    3bbe:	88 23       	and	r24, r24
    3bc0:	31 f0       	breq	.+12     	; 0x3bce <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3bc2:	89 81       	ldd	r24, Y+1	; 0x01
    3bc4:	8f 5f       	subi	r24, 0xFF	; 255
    3bc6:	89 83       	std	Y+1, r24	; 0x01
    3bc8:	89 81       	ldd	r24, Y+1	; 0x01
    3bca:	8c 30       	cpi	r24, 0x0C	; 12
    3bcc:	e0 f2       	brcs	.-72     	; 0x3b86 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3bce:	e9 89       	ldd	r30, Y+17	; 0x11
    3bd0:	fa 89       	ldd	r31, Y+18	; 0x12
    3bd2:	14 a2       	std	Z+36, r1	; 0x24
    3bd4:	03 c0       	rjmp	.+6      	; 0x3bdc <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3bd6:	e9 89       	ldd	r30, Y+17	; 0x11
    3bd8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bda:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3bdc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bde:	84 30       	cpi	r24, 0x04	; 4
    3be0:	10 f0       	brcs	.+4      	; 0x3be6 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3be2:	83 e0       	ldi	r24, 0x03	; 3
    3be4:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3be6:	e9 89       	ldd	r30, Y+17	; 0x11
    3be8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bea:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bec:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3bee:	89 89       	ldd	r24, Y+17	; 0x11
    3bf0:	9a 89       	ldd	r25, Y+18	; 0x12
    3bf2:	02 96       	adiw	r24, 0x02	; 2
    3bf4:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3bf8:	89 89       	ldd	r24, Y+17	; 0x11
    3bfa:	9a 89       	ldd	r25, Y+18	; 0x12
    3bfc:	0c 96       	adiw	r24, 0x0c	; 12
    3bfe:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3c02:	e9 89       	ldd	r30, Y+17	; 0x11
    3c04:	fa 89       	ldd	r31, Y+18	; 0x12
    3c06:	89 89       	ldd	r24, Y+17	; 0x11
    3c08:	9a 89       	ldd	r25, Y+18	; 0x12
    3c0a:	91 87       	std	Z+9, r25	; 0x09
    3c0c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c10:	28 2f       	mov	r18, r24
    3c12:	30 e0       	ldi	r19, 0x00	; 0
    3c14:	84 e0       	ldi	r24, 0x04	; 4
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	82 1b       	sub	r24, r18
    3c1a:	93 0b       	sbc	r25, r19
    3c1c:	e9 89       	ldd	r30, Y+17	; 0x11
    3c1e:	fa 89       	ldd	r31, Y+18	; 0x12
    3c20:	95 87       	std	Z+13, r25	; 0x0d
    3c22:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3c24:	e9 89       	ldd	r30, Y+17	; 0x11
    3c26:	fa 89       	ldd	r31, Y+18	; 0x12
    3c28:	89 89       	ldd	r24, Y+17	; 0x11
    3c2a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c2c:	93 8b       	std	Z+19, r25	; 0x13
    3c2e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3c30:	e9 89       	ldd	r30, Y+17	; 0x11
    3c32:	fa 89       	ldd	r31, Y+18	; 0x12
    3c34:	15 a2       	std	Z+37, r1	; 0x25
    3c36:	16 a2       	std	Z+38, r1	; 0x26
    3c38:	17 a2       	std	Z+39, r1	; 0x27
    3c3a:	10 a6       	std	Z+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3c3c:	e9 89       	ldd	r30, Y+17	; 0x11
    3c3e:	fa 89       	ldd	r31, Y+18	; 0x12
    3c40:	11 a6       	std	Z+41, r1	; 0x29
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3c42:	8a 81       	ldd	r24, Y+2	; 0x02
    3c44:	9b 81       	ldd	r25, Y+3	; 0x03
    3c46:	2c 81       	ldd	r18, Y+4	; 0x04
    3c48:	3d 81       	ldd	r19, Y+5	; 0x05
    3c4a:	4c 85       	ldd	r20, Y+12	; 0x0c
    3c4c:	5d 85       	ldd	r21, Y+13	; 0x0d
    3c4e:	b9 01       	movw	r22, r18
    3c50:	0e 94 8c 0b 	call	0x1718	; 0x1718 <pxPortInitialiseStack>
    3c54:	e9 89       	ldd	r30, Y+17	; 0x11
    3c56:	fa 89       	ldd	r31, Y+18	; 0x12
    3c58:	91 83       	std	Z+1, r25	; 0x01
    3c5a:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3c5c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c5e:	98 89       	ldd	r25, Y+16	; 0x10
    3c60:	00 97       	sbiw	r24, 0x00	; 0
    3c62:	31 f0       	breq	.+12     	; 0x3c70 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3c64:	ef 85       	ldd	r30, Y+15	; 0x0f
    3c66:	f8 89       	ldd	r31, Y+16	; 0x10
    3c68:	89 89       	ldd	r24, Y+17	; 0x11
    3c6a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c6c:	91 83       	std	Z+1, r25	; 0x01
    3c6e:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3c70:	64 96       	adiw	r28, 0x14	; 20
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	cd bf       	out	0x3d, r28	; 61
    3c7c:	cf 91       	pop	r28
    3c7e:	df 91       	pop	r29
    3c80:	1f 91       	pop	r17
    3c82:	0f 91       	pop	r16
    3c84:	ef 90       	pop	r14
    3c86:	df 90       	pop	r13
    3c88:	cf 90       	pop	r12
    3c8a:	bf 90       	pop	r11
    3c8c:	af 90       	pop	r10
    3c8e:	9f 90       	pop	r9
    3c90:	8f 90       	pop	r8
    3c92:	08 95       	ret

00003c94 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3c94:	df 93       	push	r29
    3c96:	cf 93       	push	r28
    3c98:	00 d0       	rcall	.+0      	; 0x3c9a <prvAddNewTaskToReadyList+0x6>
    3c9a:	cd b7       	in	r28, 0x3d	; 61
    3c9c:	de b7       	in	r29, 0x3e	; 62
    3c9e:	9a 83       	std	Y+2, r25	; 0x02
    3ca0:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3ca2:	0f b6       	in	r0, 0x3f	; 63
    3ca4:	f8 94       	cli
    3ca6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3ca8:	80 91 91 06 	lds	r24, 0x0691
    3cac:	8f 5f       	subi	r24, 0xFF	; 255
    3cae:	80 93 91 06 	sts	0x0691, r24
		if( pxCurrentTCB == NULL )
    3cb2:	80 91 8e 06 	lds	r24, 0x068E
    3cb6:	90 91 8f 06 	lds	r25, 0x068F
    3cba:	00 97       	sbiw	r24, 0x00	; 0
    3cbc:	69 f4       	brne	.+26     	; 0x3cd8 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3cbe:	89 81       	ldd	r24, Y+1	; 0x01
    3cc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3cc2:	90 93 8f 06 	sts	0x068F, r25
    3cc6:	80 93 8e 06 	sts	0x068E, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3cca:	80 91 91 06 	lds	r24, 0x0691
    3cce:	81 30       	cpi	r24, 0x01	; 1
    3cd0:	b9 f4       	brne	.+46     	; 0x3d00 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3cd2:	0e 94 21 25 	call	0x4a42	; 0x4a42 <prvInitialiseTaskLists>
    3cd6:	14 c0       	rjmp	.+40     	; 0x3d00 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3cd8:	80 91 95 06 	lds	r24, 0x0695
    3cdc:	88 23       	and	r24, r24
    3cde:	81 f4       	brne	.+32     	; 0x3d00 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3ce0:	e0 91 8e 06 	lds	r30, 0x068E
    3ce4:	f0 91 8f 06 	lds	r31, 0x068F
    3ce8:	96 89       	ldd	r25, Z+22	; 0x16
    3cea:	e9 81       	ldd	r30, Y+1	; 0x01
    3cec:	fa 81       	ldd	r31, Y+2	; 0x02
    3cee:	86 89       	ldd	r24, Z+22	; 0x16
    3cf0:	89 17       	cp	r24, r25
    3cf2:	30 f0       	brcs	.+12     	; 0x3d00 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3cf4:	89 81       	ldd	r24, Y+1	; 0x01
    3cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf8:	90 93 8f 06 	sts	0x068F, r25
    3cfc:	80 93 8e 06 	sts	0x068E, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3d00:	80 91 99 06 	lds	r24, 0x0699
    3d04:	8f 5f       	subi	r24, 0xFF	; 255
    3d06:	80 93 99 06 	sts	0x0699, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d0e:	96 89       	ldd	r25, Z+22	; 0x16
    3d10:	80 91 94 06 	lds	r24, 0x0694
    3d14:	89 17       	cp	r24, r25
    3d16:	28 f4       	brcc	.+10     	; 0x3d22 <prvAddNewTaskToReadyList+0x8e>
    3d18:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1c:	86 89       	ldd	r24, Z+22	; 0x16
    3d1e:	80 93 94 06 	sts	0x0694, r24
    3d22:	e9 81       	ldd	r30, Y+1	; 0x01
    3d24:	fa 81       	ldd	r31, Y+2	; 0x02
    3d26:	86 89       	ldd	r24, Z+22	; 0x16
    3d28:	28 2f       	mov	r18, r24
    3d2a:	30 e0       	ldi	r19, 0x00	; 0
    3d2c:	c9 01       	movw	r24, r18
    3d2e:	88 0f       	add	r24, r24
    3d30:	99 1f       	adc	r25, r25
    3d32:	88 0f       	add	r24, r24
    3d34:	99 1f       	adc	r25, r25
    3d36:	88 0f       	add	r24, r24
    3d38:	99 1f       	adc	r25, r25
    3d3a:	82 0f       	add	r24, r18
    3d3c:	93 1f       	adc	r25, r19
    3d3e:	ac 01       	movw	r20, r24
    3d40:	41 56       	subi	r20, 0x61	; 97
    3d42:	59 4f       	sbci	r21, 0xF9	; 249
    3d44:	89 81       	ldd	r24, Y+1	; 0x01
    3d46:	9a 81       	ldd	r25, Y+2	; 0x02
    3d48:	9c 01       	movw	r18, r24
    3d4a:	2e 5f       	subi	r18, 0xFE	; 254
    3d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d4e:	ca 01       	movw	r24, r20
    3d50:	b9 01       	movw	r22, r18
    3d52:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3d56:	0f 90       	pop	r0
    3d58:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3d5a:	80 91 95 06 	lds	r24, 0x0695
    3d5e:	88 23       	and	r24, r24
    3d60:	61 f0       	breq	.+24     	; 0x3d7a <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3d62:	e0 91 8e 06 	lds	r30, 0x068E
    3d66:	f0 91 8f 06 	lds	r31, 0x068F
    3d6a:	96 89       	ldd	r25, Z+22	; 0x16
    3d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d70:	86 89       	ldd	r24, Z+22	; 0x16
    3d72:	98 17       	cp	r25, r24
    3d74:	10 f4       	brcc	.+4      	; 0x3d7a <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3d76:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3d7a:	0f 90       	pop	r0
    3d7c:	0f 90       	pop	r0
    3d7e:	cf 91       	pop	r28
    3d80:	df 91       	pop	r29
    3d82:	08 95       	ret

00003d84 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3d84:	df 93       	push	r29
    3d86:	cf 93       	push	r28
    3d88:	00 d0       	rcall	.+0      	; 0x3d8a <vTaskDelete+0x6>
    3d8a:	00 d0       	rcall	.+0      	; 0x3d8c <vTaskDelete+0x8>
    3d8c:	00 d0       	rcall	.+0      	; 0x3d8e <vTaskDelete+0xa>
    3d8e:	cd b7       	in	r28, 0x3d	; 61
    3d90:	de b7       	in	r29, 0x3e	; 62
    3d92:	9c 83       	std	Y+4, r25	; 0x04
    3d94:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3d96:	0f b6       	in	r0, 0x3f	; 63
    3d98:	f8 94       	cli
    3d9a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3da0:	00 97       	sbiw	r24, 0x00	; 0
    3da2:	39 f4       	brne	.+14     	; 0x3db2 <vTaskDelete+0x2e>
    3da4:	80 91 8e 06 	lds	r24, 0x068E
    3da8:	90 91 8f 06 	lds	r25, 0x068F
    3dac:	9e 83       	std	Y+6, r25	; 0x06
    3dae:	8d 83       	std	Y+5, r24	; 0x05
    3db0:	04 c0       	rjmp	.+8      	; 0x3dba <vTaskDelete+0x36>
    3db2:	8b 81       	ldd	r24, Y+3	; 0x03
    3db4:	9c 81       	ldd	r25, Y+4	; 0x04
    3db6:	9e 83       	std	Y+6, r25	; 0x06
    3db8:	8d 83       	std	Y+5, r24	; 0x05
    3dba:	8d 81       	ldd	r24, Y+5	; 0x05
    3dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    3dbe:	9a 83       	std	Y+2, r25	; 0x02
    3dc0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3dc2:	89 81       	ldd	r24, Y+1	; 0x01
    3dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc6:	02 96       	adiw	r24, 0x02	; 2
    3dc8:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3dcc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dce:	fa 81       	ldd	r31, Y+2	; 0x02
    3dd0:	84 89       	ldd	r24, Z+20	; 0x14
    3dd2:	95 89       	ldd	r25, Z+21	; 0x15
    3dd4:	00 97       	sbiw	r24, 0x00	; 0
    3dd6:	29 f0       	breq	.+10     	; 0x3de2 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3dd8:	89 81       	ldd	r24, Y+1	; 0x01
    3dda:	9a 81       	ldd	r25, Y+2	; 0x02
    3ddc:	0c 96       	adiw	r24, 0x0c	; 12
    3dde:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3de2:	80 91 99 06 	lds	r24, 0x0699
    3de6:	8f 5f       	subi	r24, 0xFF	; 255
    3de8:	80 93 99 06 	sts	0x0699, r24

			if( pxTCB == pxCurrentTCB )
    3dec:	20 91 8e 06 	lds	r18, 0x068E
    3df0:	30 91 8f 06 	lds	r19, 0x068F
    3df4:	89 81       	ldd	r24, Y+1	; 0x01
    3df6:	9a 81       	ldd	r25, Y+2	; 0x02
    3df8:	82 17       	cp	r24, r18
    3dfa:	93 07       	cpc	r25, r19
    3dfc:	81 f4       	brne	.+32     	; 0x3e1e <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3dfe:	89 81       	ldd	r24, Y+1	; 0x01
    3e00:	9a 81       	ldd	r25, Y+2	; 0x02
    3e02:	9c 01       	movw	r18, r24
    3e04:	2e 5f       	subi	r18, 0xFE	; 254
    3e06:	3f 4f       	sbci	r19, 0xFF	; 255
    3e08:	82 ee       	ldi	r24, 0xE2	; 226
    3e0a:	96 e0       	ldi	r25, 0x06	; 6
    3e0c:	b9 01       	movw	r22, r18
    3e0e:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3e12:	80 91 90 06 	lds	r24, 0x0690
    3e16:	8f 5f       	subi	r24, 0xFF	; 255
    3e18:	80 93 90 06 	sts	0x0690, r24
    3e1c:	0b c0       	rjmp	.+22     	; 0x3e34 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3e1e:	80 91 91 06 	lds	r24, 0x0691
    3e22:	81 50       	subi	r24, 0x01	; 1
    3e24:	80 93 91 06 	sts	0x0691, r24
				prvDeleteTCB( pxTCB );
    3e28:	89 81       	ldd	r24, Y+1	; 0x01
    3e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2c:	0e 94 91 25 	call	0x4b22	; 0x4b22 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3e30:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3e34:	0f 90       	pop	r0
    3e36:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3e38:	80 91 95 06 	lds	r24, 0x0695
    3e3c:	88 23       	and	r24, r24
    3e3e:	59 f0       	breq	.+22     	; 0x3e56 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3e40:	20 91 8e 06 	lds	r18, 0x068E
    3e44:	30 91 8f 06 	lds	r19, 0x068F
    3e48:	89 81       	ldd	r24, Y+1	; 0x01
    3e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4c:	82 17       	cp	r24, r18
    3e4e:	93 07       	cpc	r25, r19
    3e50:	11 f4       	brne	.+4      	; 0x3e56 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e52:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3e56:	26 96       	adiw	r28, 0x06	; 6
    3e58:	0f b6       	in	r0, 0x3f	; 63
    3e5a:	f8 94       	cli
    3e5c:	de bf       	out	0x3e, r29	; 62
    3e5e:	0f be       	out	0x3f, r0	; 63
    3e60:	cd bf       	out	0x3d, r28	; 61
    3e62:	cf 91       	pop	r28
    3e64:	df 91       	pop	r29
    3e66:	08 95       	ret

00003e68 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3e68:	df 93       	push	r29
    3e6a:	cf 93       	push	r28
    3e6c:	00 d0       	rcall	.+0      	; 0x3e6e <vTaskDelay+0x6>
    3e6e:	0f 92       	push	r0
    3e70:	cd b7       	in	r28, 0x3d	; 61
    3e72:	de b7       	in	r29, 0x3e	; 62
    3e74:	9b 83       	std	Y+3, r25	; 0x03
    3e76:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3e78:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7e:	00 97       	sbiw	r24, 0x00	; 0
    3e80:	51 f0       	breq	.+20     	; 0x3e96 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3e82:	0e 94 01 21 	call	0x4202	; 0x4202 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3e86:	8a 81       	ldd	r24, Y+2	; 0x02
    3e88:	9b 81       	ldd	r25, Y+3	; 0x03
    3e8a:	60 e0       	ldi	r22, 0x00	; 0
    3e8c:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3e90:	0e 94 0d 21 	call	0x421a	; 0x421a <xTaskResumeAll>
    3e94:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3e96:	89 81       	ldd	r24, Y+1	; 0x01
    3e98:	88 23       	and	r24, r24
    3e9a:	11 f4       	brne	.+4      	; 0x3ea0 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3e9c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3ea0:	0f 90       	pop	r0
    3ea2:	0f 90       	pop	r0
    3ea4:	0f 90       	pop	r0
    3ea6:	cf 91       	pop	r28
    3ea8:	df 91       	pop	r29
    3eaa:	08 95       	ret

00003eac <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3eac:	df 93       	push	r29
    3eae:	cf 93       	push	r28
    3eb0:	00 d0       	rcall	.+0      	; 0x3eb2 <vTaskSuspend+0x6>
    3eb2:	00 d0       	rcall	.+0      	; 0x3eb4 <vTaskSuspend+0x8>
    3eb4:	00 d0       	rcall	.+0      	; 0x3eb6 <vTaskSuspend+0xa>
    3eb6:	cd b7       	in	r28, 0x3d	; 61
    3eb8:	de b7       	in	r29, 0x3e	; 62
    3eba:	9c 83       	std	Y+4, r25	; 0x04
    3ebc:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3ebe:	0f b6       	in	r0, 0x3f	; 63
    3ec0:	f8 94       	cli
    3ec2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec8:	00 97       	sbiw	r24, 0x00	; 0
    3eca:	39 f4       	brne	.+14     	; 0x3eda <vTaskSuspend+0x2e>
    3ecc:	80 91 8e 06 	lds	r24, 0x068E
    3ed0:	90 91 8f 06 	lds	r25, 0x068F
    3ed4:	9e 83       	std	Y+6, r25	; 0x06
    3ed6:	8d 83       	std	Y+5, r24	; 0x05
    3ed8:	04 c0       	rjmp	.+8      	; 0x3ee2 <vTaskSuspend+0x36>
    3eda:	8b 81       	ldd	r24, Y+3	; 0x03
    3edc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ede:	9e 83       	std	Y+6, r25	; 0x06
    3ee0:	8d 83       	std	Y+5, r24	; 0x05
    3ee2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ee4:	9e 81       	ldd	r25, Y+6	; 0x06
    3ee6:	9a 83       	std	Y+2, r25	; 0x02
    3ee8:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3eea:	89 81       	ldd	r24, Y+1	; 0x01
    3eec:	9a 81       	ldd	r25, Y+2	; 0x02
    3eee:	02 96       	adiw	r24, 0x02	; 2
    3ef0:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef8:	84 89       	ldd	r24, Z+20	; 0x14
    3efa:	95 89       	ldd	r25, Z+21	; 0x15
    3efc:	00 97       	sbiw	r24, 0x00	; 0
    3efe:	29 f0       	breq	.+10     	; 0x3f0a <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
    3f02:	9a 81       	ldd	r25, Y+2	; 0x02
    3f04:	0c 96       	adiw	r24, 0x0c	; 12
    3f06:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f0e:	9c 01       	movw	r18, r24
    3f10:	2e 5f       	subi	r18, 0xFE	; 254
    3f12:	3f 4f       	sbci	r19, 0xFF	; 255
    3f14:	8b ee       	ldi	r24, 0xEB	; 235
    3f16:	96 e0       	ldi	r25, 0x06	; 6
    3f18:	b9 01       	movw	r22, r18
    3f1a:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3f1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f20:	fa 81       	ldd	r31, Y+2	; 0x02
    3f22:	81 a5       	ldd	r24, Z+41	; 0x29
    3f24:	81 30       	cpi	r24, 0x01	; 1
    3f26:	19 f4       	brne	.+6      	; 0x3f2e <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3f28:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f2c:	11 a6       	std	Z+41, r1	; 0x29
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3f2e:	0f 90       	pop	r0
    3f30:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3f32:	80 91 95 06 	lds	r24, 0x0695
    3f36:	88 23       	and	r24, r24
    3f38:	39 f0       	breq	.+14     	; 0x3f48 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3f3a:	0f b6       	in	r0, 0x3f	; 63
    3f3c:	f8 94       	cli
    3f3e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3f40:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3f44:	0f 90       	pop	r0
    3f46:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3f48:	20 91 8e 06 	lds	r18, 0x068E
    3f4c:	30 91 8f 06 	lds	r19, 0x068F
    3f50:	89 81       	ldd	r24, Y+1	; 0x01
    3f52:	9a 81       	ldd	r25, Y+2	; 0x02
    3f54:	82 17       	cp	r24, r18
    3f56:	93 07       	cpc	r25, r19
    3f58:	a1 f4       	brne	.+40     	; 0x3f82 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3f5a:	80 91 95 06 	lds	r24, 0x0695
    3f5e:	88 23       	and	r24, r24
    3f60:	19 f0       	breq	.+6      	; 0x3f68 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3f62:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
    3f66:	0d c0       	rjmp	.+26     	; 0x3f82 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3f68:	90 91 eb 06 	lds	r25, 0x06EB
    3f6c:	80 91 91 06 	lds	r24, 0x0691
    3f70:	98 17       	cp	r25, r24
    3f72:	29 f4       	brne	.+10     	; 0x3f7e <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3f74:	10 92 8f 06 	sts	0x068F, r1
    3f78:	10 92 8e 06 	sts	0x068E, r1
    3f7c:	02 c0       	rjmp	.+4      	; 0x3f82 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3f7e:	0e 94 e2 22 	call	0x45c4	; 0x45c4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3f82:	26 96       	adiw	r28, 0x06	; 6
    3f84:	0f b6       	in	r0, 0x3f	; 63
    3f86:	f8 94       	cli
    3f88:	de bf       	out	0x3e, r29	; 62
    3f8a:	0f be       	out	0x3f, r0	; 63
    3f8c:	cd bf       	out	0x3d, r28	; 61
    3f8e:	cf 91       	pop	r28
    3f90:	df 91       	pop	r29
    3f92:	08 95       	ret

00003f94 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3f94:	df 93       	push	r29
    3f96:	cf 93       	push	r28
    3f98:	00 d0       	rcall	.+0      	; 0x3f9a <prvTaskIsTaskSuspended+0x6>
    3f9a:	00 d0       	rcall	.+0      	; 0x3f9c <prvTaskIsTaskSuspended+0x8>
    3f9c:	0f 92       	push	r0
    3f9e:	cd b7       	in	r28, 0x3d	; 61
    3fa0:	de b7       	in	r29, 0x3e	; 62
    3fa2:	9d 83       	std	Y+5, r25	; 0x05
    3fa4:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3fa6:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3fa8:	8c 81       	ldd	r24, Y+4	; 0x04
    3faa:	9d 81       	ldd	r25, Y+5	; 0x05
    3fac:	9a 83       	std	Y+2, r25	; 0x02
    3fae:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	82 85       	ldd	r24, Z+10	; 0x0a
    3fb6:	93 85       	ldd	r25, Z+11	; 0x0b
    3fb8:	26 e0       	ldi	r18, 0x06	; 6
    3fba:	8b 3e       	cpi	r24, 0xEB	; 235
    3fbc:	92 07       	cpc	r25, r18
    3fbe:	81 f4       	brne	.+32     	; 0x3fe0 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc4:	84 89       	ldd	r24, Z+20	; 0x14
    3fc6:	95 89       	ldd	r25, Z+21	; 0x15
    3fc8:	26 e0       	ldi	r18, 0x06	; 6
    3fca:	89 3d       	cpi	r24, 0xD9	; 217
    3fcc:	92 07       	cpc	r25, r18
    3fce:	41 f0       	breq	.+16     	; 0x3fe0 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd4:	84 89       	ldd	r24, Z+20	; 0x14
    3fd6:	95 89       	ldd	r25, Z+21	; 0x15
    3fd8:	00 97       	sbiw	r24, 0x00	; 0
    3fda:	11 f4       	brne	.+4      	; 0x3fe0 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3fdc:	81 e0       	ldi	r24, 0x01	; 1
    3fde:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3fe0:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3fe2:	0f 90       	pop	r0
    3fe4:	0f 90       	pop	r0
    3fe6:	0f 90       	pop	r0
    3fe8:	0f 90       	pop	r0
    3fea:	0f 90       	pop	r0
    3fec:	cf 91       	pop	r28
    3fee:	df 91       	pop	r29
    3ff0:	08 95       	ret

00003ff2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3ff2:	df 93       	push	r29
    3ff4:	cf 93       	push	r28
    3ff6:	00 d0       	rcall	.+0      	; 0x3ff8 <vTaskResume+0x6>
    3ff8:	00 d0       	rcall	.+0      	; 0x3ffa <vTaskResume+0x8>
    3ffa:	cd b7       	in	r28, 0x3d	; 61
    3ffc:	de b7       	in	r29, 0x3e	; 62
    3ffe:	9c 83       	std	Y+4, r25	; 0x04
    4000:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    4002:	8b 81       	ldd	r24, Y+3	; 0x03
    4004:	9c 81       	ldd	r25, Y+4	; 0x04
    4006:	9a 83       	std	Y+2, r25	; 0x02
    4008:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    400a:	20 91 8e 06 	lds	r18, 0x068E
    400e:	30 91 8f 06 	lds	r19, 0x068F
    4012:	89 81       	ldd	r24, Y+1	; 0x01
    4014:	9a 81       	ldd	r25, Y+2	; 0x02
    4016:	82 17       	cp	r24, r18
    4018:	93 07       	cpc	r25, r19
    401a:	09 f4       	brne	.+2      	; 0x401e <vTaskResume+0x2c>
    401c:	47 c0       	rjmp	.+142    	; 0x40ac <vTaskResume+0xba>
    401e:	89 81       	ldd	r24, Y+1	; 0x01
    4020:	9a 81       	ldd	r25, Y+2	; 0x02
    4022:	00 97       	sbiw	r24, 0x00	; 0
    4024:	09 f4       	brne	.+2      	; 0x4028 <vTaskResume+0x36>
    4026:	42 c0       	rjmp	.+132    	; 0x40ac <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4028:	0f b6       	in	r0, 0x3f	; 63
    402a:	f8 94       	cli
    402c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    402e:	89 81       	ldd	r24, Y+1	; 0x01
    4030:	9a 81       	ldd	r25, Y+2	; 0x02
    4032:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <prvTaskIsTaskSuspended>
    4036:	88 23       	and	r24, r24
    4038:	b9 f1       	breq	.+110    	; 0x40a8 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    403a:	89 81       	ldd	r24, Y+1	; 0x01
    403c:	9a 81       	ldd	r25, Y+2	; 0x02
    403e:	02 96       	adiw	r24, 0x02	; 2
    4040:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	96 89       	ldd	r25, Z+22	; 0x16
    404a:	80 91 94 06 	lds	r24, 0x0694
    404e:	89 17       	cp	r24, r25
    4050:	28 f4       	brcc	.+10     	; 0x405c <vTaskResume+0x6a>
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	86 89       	ldd	r24, Z+22	; 0x16
    4058:	80 93 94 06 	sts	0x0694, r24
    405c:	e9 81       	ldd	r30, Y+1	; 0x01
    405e:	fa 81       	ldd	r31, Y+2	; 0x02
    4060:	86 89       	ldd	r24, Z+22	; 0x16
    4062:	28 2f       	mov	r18, r24
    4064:	30 e0       	ldi	r19, 0x00	; 0
    4066:	c9 01       	movw	r24, r18
    4068:	88 0f       	add	r24, r24
    406a:	99 1f       	adc	r25, r25
    406c:	88 0f       	add	r24, r24
    406e:	99 1f       	adc	r25, r25
    4070:	88 0f       	add	r24, r24
    4072:	99 1f       	adc	r25, r25
    4074:	82 0f       	add	r24, r18
    4076:	93 1f       	adc	r25, r19
    4078:	ac 01       	movw	r20, r24
    407a:	41 56       	subi	r20, 0x61	; 97
    407c:	59 4f       	sbci	r21, 0xF9	; 249
    407e:	89 81       	ldd	r24, Y+1	; 0x01
    4080:	9a 81       	ldd	r25, Y+2	; 0x02
    4082:	9c 01       	movw	r18, r24
    4084:	2e 5f       	subi	r18, 0xFE	; 254
    4086:	3f 4f       	sbci	r19, 0xFF	; 255
    4088:	ca 01       	movw	r24, r20
    408a:	b9 01       	movw	r22, r18
    408c:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4090:	e9 81       	ldd	r30, Y+1	; 0x01
    4092:	fa 81       	ldd	r31, Y+2	; 0x02
    4094:	96 89       	ldd	r25, Z+22	; 0x16
    4096:	e0 91 8e 06 	lds	r30, 0x068E
    409a:	f0 91 8f 06 	lds	r31, 0x068F
    409e:	86 89       	ldd	r24, Z+22	; 0x16
    40a0:	98 17       	cp	r25, r24
    40a2:	10 f0       	brcs	.+4      	; 0x40a8 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    40a4:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    40a8:	0f 90       	pop	r0
    40aa:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    40ac:	0f 90       	pop	r0
    40ae:	0f 90       	pop	r0
    40b0:	0f 90       	pop	r0
    40b2:	0f 90       	pop	r0
    40b4:	cf 91       	pop	r28
    40b6:	df 91       	pop	r29
    40b8:	08 95       	ret

000040ba <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    40ba:	df 93       	push	r29
    40bc:	cf 93       	push	r28
    40be:	00 d0       	rcall	.+0      	; 0x40c0 <xTaskResumeFromISR+0x6>
    40c0:	00 d0       	rcall	.+0      	; 0x40c2 <xTaskResumeFromISR+0x8>
    40c2:	00 d0       	rcall	.+0      	; 0x40c4 <xTaskResumeFromISR+0xa>
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
    40c8:	9e 83       	std	Y+6, r25	; 0x06
    40ca:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    40cc:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    40ce:	8d 81       	ldd	r24, Y+5	; 0x05
    40d0:	9e 81       	ldd	r25, Y+6	; 0x06
    40d2:	9b 83       	std	Y+3, r25	; 0x03
    40d4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    40d6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    40d8:	8a 81       	ldd	r24, Y+2	; 0x02
    40da:	9b 81       	ldd	r25, Y+3	; 0x03
    40dc:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <prvTaskIsTaskSuspended>
    40e0:	88 23       	and	r24, r24
    40e2:	09 f4       	brne	.+2      	; 0x40e6 <xTaskResumeFromISR+0x2c>
    40e4:	46 c0       	rjmp	.+140    	; 0x4172 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40e6:	80 91 9e 06 	lds	r24, 0x069E
    40ea:	88 23       	and	r24, r24
    40ec:	c1 f5       	brne	.+112    	; 0x415e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40ee:	ea 81       	ldd	r30, Y+2	; 0x02
    40f0:	fb 81       	ldd	r31, Y+3	; 0x03
    40f2:	96 89       	ldd	r25, Z+22	; 0x16
    40f4:	e0 91 8e 06 	lds	r30, 0x068E
    40f8:	f0 91 8f 06 	lds	r31, 0x068F
    40fc:	86 89       	ldd	r24, Z+22	; 0x16
    40fe:	98 17       	cp	r25, r24
    4100:	10 f0       	brcs	.+4      	; 0x4106 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    4102:	81 e0       	ldi	r24, 0x01	; 1
    4104:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4106:	8a 81       	ldd	r24, Y+2	; 0x02
    4108:	9b 81       	ldd	r25, Y+3	; 0x03
    410a:	02 96       	adiw	r24, 0x02	; 2
    410c:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4110:	ea 81       	ldd	r30, Y+2	; 0x02
    4112:	fb 81       	ldd	r31, Y+3	; 0x03
    4114:	96 89       	ldd	r25, Z+22	; 0x16
    4116:	80 91 94 06 	lds	r24, 0x0694
    411a:	89 17       	cp	r24, r25
    411c:	28 f4       	brcc	.+10     	; 0x4128 <xTaskResumeFromISR+0x6e>
    411e:	ea 81       	ldd	r30, Y+2	; 0x02
    4120:	fb 81       	ldd	r31, Y+3	; 0x03
    4122:	86 89       	ldd	r24, Z+22	; 0x16
    4124:	80 93 94 06 	sts	0x0694, r24
    4128:	ea 81       	ldd	r30, Y+2	; 0x02
    412a:	fb 81       	ldd	r31, Y+3	; 0x03
    412c:	86 89       	ldd	r24, Z+22	; 0x16
    412e:	28 2f       	mov	r18, r24
    4130:	30 e0       	ldi	r19, 0x00	; 0
    4132:	c9 01       	movw	r24, r18
    4134:	88 0f       	add	r24, r24
    4136:	99 1f       	adc	r25, r25
    4138:	88 0f       	add	r24, r24
    413a:	99 1f       	adc	r25, r25
    413c:	88 0f       	add	r24, r24
    413e:	99 1f       	adc	r25, r25
    4140:	82 0f       	add	r24, r18
    4142:	93 1f       	adc	r25, r19
    4144:	ac 01       	movw	r20, r24
    4146:	41 56       	subi	r20, 0x61	; 97
    4148:	59 4f       	sbci	r21, 0xF9	; 249
    414a:	8a 81       	ldd	r24, Y+2	; 0x02
    414c:	9b 81       	ldd	r25, Y+3	; 0x03
    414e:	9c 01       	movw	r18, r24
    4150:	2e 5f       	subi	r18, 0xFE	; 254
    4152:	3f 4f       	sbci	r19, 0xFF	; 255
    4154:	ca 01       	movw	r24, r20
    4156:	b9 01       	movw	r22, r18
    4158:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
    415c:	0a c0       	rjmp	.+20     	; 0x4172 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    415e:	8a 81       	ldd	r24, Y+2	; 0x02
    4160:	9b 81       	ldd	r25, Y+3	; 0x03
    4162:	9c 01       	movw	r18, r24
    4164:	24 5f       	subi	r18, 0xF4	; 244
    4166:	3f 4f       	sbci	r19, 0xFF	; 255
    4168:	89 ed       	ldi	r24, 0xD9	; 217
    416a:	96 e0       	ldi	r25, 0x06	; 6
    416c:	b9 01       	movw	r22, r18
    416e:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4172:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4174:	26 96       	adiw	r28, 0x06	; 6
    4176:	0f b6       	in	r0, 0x3f	; 63
    4178:	f8 94       	cli
    417a:	de bf       	out	0x3e, r29	; 62
    417c:	0f be       	out	0x3f, r0	; 63
    417e:	cd bf       	out	0x3d, r28	; 61
    4180:	cf 91       	pop	r28
    4182:	df 91       	pop	r29
    4184:	08 95       	ret

00004186 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4186:	ef 92       	push	r14
    4188:	ff 92       	push	r15
    418a:	0f 93       	push	r16
    418c:	df 93       	push	r29
    418e:	cf 93       	push	r28
    4190:	0f 92       	push	r0
    4192:	cd b7       	in	r28, 0x3d	; 61
    4194:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4196:	87 e1       	ldi	r24, 0x17	; 23
    4198:	95 e2       	ldi	r25, 0x25	; 37
    419a:	21 ea       	ldi	r18, 0xA1	; 161
    419c:	30 e0       	ldi	r19, 0x00	; 0
    419e:	ec e9       	ldi	r30, 0x9C	; 156
    41a0:	f6 e0       	ldi	r31, 0x06	; 6
    41a2:	b9 01       	movw	r22, r18
    41a4:	45 e5       	ldi	r20, 0x55	; 85
    41a6:	50 e0       	ldi	r21, 0x00	; 0
    41a8:	20 e0       	ldi	r18, 0x00	; 0
    41aa:	30 e0       	ldi	r19, 0x00	; 0
    41ac:	00 e0       	ldi	r16, 0x00	; 0
    41ae:	7f 01       	movw	r14, r30
    41b0:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <xTaskCreate>
    41b4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    41b6:	89 81       	ldd	r24, Y+1	; 0x01
    41b8:	81 30       	cpi	r24, 0x01	; 1
    41ba:	81 f4       	brne	.+32     	; 0x41dc <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    41bc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    41be:	8f ef       	ldi	r24, 0xFF	; 255
    41c0:	9f ef       	ldi	r25, 0xFF	; 255
    41c2:	90 93 9b 06 	sts	0x069B, r25
    41c6:	80 93 9a 06 	sts	0x069A, r24
		xSchedulerRunning = pdTRUE;
    41ca:	81 e0       	ldi	r24, 0x01	; 1
    41cc:	80 93 95 06 	sts	0x0695, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    41d0:	10 92 93 06 	sts	0x0693, r1
    41d4:	10 92 92 06 	sts	0x0692, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    41d8:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    41dc:	0f 90       	pop	r0
    41de:	cf 91       	pop	r28
    41e0:	df 91       	pop	r29
    41e2:	0f 91       	pop	r16
    41e4:	ff 90       	pop	r15
    41e6:	ef 90       	pop	r14
    41e8:	08 95       	ret

000041ea <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    41ea:	df 93       	push	r29
    41ec:	cf 93       	push	r28
    41ee:	cd b7       	in	r28, 0x3d	; 61
    41f0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    41f2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    41f4:	10 92 95 06 	sts	0x0695, r1
	vPortEndScheduler();
    41f8:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vPortEndScheduler>
}
    41fc:	cf 91       	pop	r28
    41fe:	df 91       	pop	r29
    4200:	08 95       	ret

00004202 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4202:	df 93       	push	r29
    4204:	cf 93       	push	r28
    4206:	cd b7       	in	r28, 0x3d	; 61
    4208:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    420a:	80 91 9e 06 	lds	r24, 0x069E
    420e:	8f 5f       	subi	r24, 0xFF	; 255
    4210:	80 93 9e 06 	sts	0x069E, r24
}
    4214:	cf 91       	pop	r28
    4216:	df 91       	pop	r29
    4218:	08 95       	ret

0000421a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    421a:	df 93       	push	r29
    421c:	cf 93       	push	r28
    421e:	00 d0       	rcall	.+0      	; 0x4220 <xTaskResumeAll+0x6>
    4220:	00 d0       	rcall	.+0      	; 0x4222 <xTaskResumeAll+0x8>
    4222:	cd b7       	in	r28, 0x3d	; 61
    4224:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4226:	1c 82       	std	Y+4, r1	; 0x04
    4228:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    422a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    422c:	0f b6       	in	r0, 0x3f	; 63
    422e:	f8 94       	cli
    4230:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4232:	80 91 9e 06 	lds	r24, 0x069E
    4236:	81 50       	subi	r24, 0x01	; 1
    4238:	80 93 9e 06 	sts	0x069E, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    423c:	80 91 9e 06 	lds	r24, 0x069E
    4240:	88 23       	and	r24, r24
    4242:	09 f0       	breq	.+2      	; 0x4246 <xTaskResumeAll+0x2c>
    4244:	73 c0       	rjmp	.+230    	; 0x432c <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4246:	80 91 91 06 	lds	r24, 0x0691
    424a:	88 23       	and	r24, r24
    424c:	09 f4       	brne	.+2      	; 0x4250 <xTaskResumeAll+0x36>
    424e:	6e c0       	rjmp	.+220    	; 0x432c <xTaskResumeAll+0x112>
    4250:	45 c0       	rjmp	.+138    	; 0x42dc <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4252:	e0 91 de 06 	lds	r30, 0x06DE
    4256:	f0 91 df 06 	lds	r31, 0x06DF
    425a:	86 81       	ldd	r24, Z+6	; 0x06
    425c:	97 81       	ldd	r25, Z+7	; 0x07
    425e:	9c 83       	std	Y+4, r25	; 0x04
    4260:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4262:	8b 81       	ldd	r24, Y+3	; 0x03
    4264:	9c 81       	ldd	r25, Y+4	; 0x04
    4266:	0c 96       	adiw	r24, 0x0c	; 12
    4268:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    426c:	8b 81       	ldd	r24, Y+3	; 0x03
    426e:	9c 81       	ldd	r25, Y+4	; 0x04
    4270:	02 96       	adiw	r24, 0x02	; 2
    4272:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4276:	eb 81       	ldd	r30, Y+3	; 0x03
    4278:	fc 81       	ldd	r31, Y+4	; 0x04
    427a:	96 89       	ldd	r25, Z+22	; 0x16
    427c:	80 91 94 06 	lds	r24, 0x0694
    4280:	89 17       	cp	r24, r25
    4282:	28 f4       	brcc	.+10     	; 0x428e <xTaskResumeAll+0x74>
    4284:	eb 81       	ldd	r30, Y+3	; 0x03
    4286:	fc 81       	ldd	r31, Y+4	; 0x04
    4288:	86 89       	ldd	r24, Z+22	; 0x16
    428a:	80 93 94 06 	sts	0x0694, r24
    428e:	eb 81       	ldd	r30, Y+3	; 0x03
    4290:	fc 81       	ldd	r31, Y+4	; 0x04
    4292:	86 89       	ldd	r24, Z+22	; 0x16
    4294:	28 2f       	mov	r18, r24
    4296:	30 e0       	ldi	r19, 0x00	; 0
    4298:	c9 01       	movw	r24, r18
    429a:	88 0f       	add	r24, r24
    429c:	99 1f       	adc	r25, r25
    429e:	88 0f       	add	r24, r24
    42a0:	99 1f       	adc	r25, r25
    42a2:	88 0f       	add	r24, r24
    42a4:	99 1f       	adc	r25, r25
    42a6:	82 0f       	add	r24, r18
    42a8:	93 1f       	adc	r25, r19
    42aa:	ac 01       	movw	r20, r24
    42ac:	41 56       	subi	r20, 0x61	; 97
    42ae:	59 4f       	sbci	r21, 0xF9	; 249
    42b0:	8b 81       	ldd	r24, Y+3	; 0x03
    42b2:	9c 81       	ldd	r25, Y+4	; 0x04
    42b4:	9c 01       	movw	r18, r24
    42b6:	2e 5f       	subi	r18, 0xFE	; 254
    42b8:	3f 4f       	sbci	r19, 0xFF	; 255
    42ba:	ca 01       	movw	r24, r20
    42bc:	b9 01       	movw	r22, r18
    42be:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    42c2:	eb 81       	ldd	r30, Y+3	; 0x03
    42c4:	fc 81       	ldd	r31, Y+4	; 0x04
    42c6:	96 89       	ldd	r25, Z+22	; 0x16
    42c8:	e0 91 8e 06 	lds	r30, 0x068E
    42cc:	f0 91 8f 06 	lds	r31, 0x068F
    42d0:	86 89       	ldd	r24, Z+22	; 0x16
    42d2:	98 17       	cp	r25, r24
    42d4:	18 f0       	brcs	.+6      	; 0x42dc <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    42d6:	81 e0       	ldi	r24, 0x01	; 1
    42d8:	80 93 97 06 	sts	0x0697, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    42dc:	80 91 d9 06 	lds	r24, 0x06D9
    42e0:	88 23       	and	r24, r24
    42e2:	09 f0       	breq	.+2      	; 0x42e6 <xTaskResumeAll+0xcc>
    42e4:	b6 cf       	rjmp	.-148    	; 0x4252 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    42e6:	8b 81       	ldd	r24, Y+3	; 0x03
    42e8:	9c 81       	ldd	r25, Y+4	; 0x04
    42ea:	00 97       	sbiw	r24, 0x00	; 0
    42ec:	11 f0       	breq	.+4      	; 0x42f2 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    42ee:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    42f2:	80 91 96 06 	lds	r24, 0x0696
    42f6:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    42f8:	89 81       	ldd	r24, Y+1	; 0x01
    42fa:	88 23       	and	r24, r24
    42fc:	79 f0       	breq	.+30     	; 0x431c <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    42fe:	0e 94 fd 21 	call	0x43fa	; 0x43fa <xTaskIncrementTick>
    4302:	88 23       	and	r24, r24
    4304:	19 f0       	breq	.+6      	; 0x430c <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4306:	81 e0       	ldi	r24, 0x01	; 1
    4308:	80 93 97 06 	sts	0x0697, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    430c:	89 81       	ldd	r24, Y+1	; 0x01
    430e:	81 50       	subi	r24, 0x01	; 1
    4310:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4312:	89 81       	ldd	r24, Y+1	; 0x01
    4314:	88 23       	and	r24, r24
    4316:	99 f7       	brne	.-26     	; 0x42fe <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4318:	10 92 96 06 	sts	0x0696, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    431c:	80 91 97 06 	lds	r24, 0x0697
    4320:	88 23       	and	r24, r24
    4322:	21 f0       	breq	.+8      	; 0x432c <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4324:	81 e0       	ldi	r24, 0x01	; 1
    4326:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4328:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    432c:	0f 90       	pop	r0
    432e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4330:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4332:	0f 90       	pop	r0
    4334:	0f 90       	pop	r0
    4336:	0f 90       	pop	r0
    4338:	0f 90       	pop	r0
    433a:	cf 91       	pop	r28
    433c:	df 91       	pop	r29
    433e:	08 95       	ret

00004340 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4340:	df 93       	push	r29
    4342:	cf 93       	push	r28
    4344:	00 d0       	rcall	.+0      	; 0x4346 <xTaskGetTickCount+0x6>
    4346:	cd b7       	in	r28, 0x3d	; 61
    4348:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    434a:	0f b6       	in	r0, 0x3f	; 63
    434c:	f8 94       	cli
    434e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4350:	80 91 92 06 	lds	r24, 0x0692
    4354:	90 91 93 06 	lds	r25, 0x0693
    4358:	9a 83       	std	Y+2, r25	; 0x02
    435a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    435c:	0f 90       	pop	r0
    435e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4360:	89 81       	ldd	r24, Y+1	; 0x01
    4362:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4364:	0f 90       	pop	r0
    4366:	0f 90       	pop	r0
    4368:	cf 91       	pop	r28
    436a:	df 91       	pop	r29
    436c:	08 95       	ret

0000436e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    436e:	df 93       	push	r29
    4370:	cf 93       	push	r28
    4372:	00 d0       	rcall	.+0      	; 0x4374 <xTaskGetTickCountFromISR+0x6>
    4374:	0f 92       	push	r0
    4376:	cd b7       	in	r28, 0x3d	; 61
    4378:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    437a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    437c:	80 91 92 06 	lds	r24, 0x0692
    4380:	90 91 93 06 	lds	r25, 0x0693
    4384:	9b 83       	std	Y+3, r25	; 0x03
    4386:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4388:	8a 81       	ldd	r24, Y+2	; 0x02
    438a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    438c:	0f 90       	pop	r0
    438e:	0f 90       	pop	r0
    4390:	0f 90       	pop	r0
    4392:	cf 91       	pop	r28
    4394:	df 91       	pop	r29
    4396:	08 95       	ret

00004398 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4398:	df 93       	push	r29
    439a:	cf 93       	push	r28
    439c:	cd b7       	in	r28, 0x3d	; 61
    439e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    43a0:	80 91 91 06 	lds	r24, 0x0691
}
    43a4:	cf 91       	pop	r28
    43a6:	df 91       	pop	r29
    43a8:	08 95       	ret

000043aa <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    43aa:	df 93       	push	r29
    43ac:	cf 93       	push	r28
    43ae:	00 d0       	rcall	.+0      	; 0x43b0 <pcTaskGetName+0x6>
    43b0:	00 d0       	rcall	.+0      	; 0x43b2 <pcTaskGetName+0x8>
    43b2:	00 d0       	rcall	.+0      	; 0x43b4 <pcTaskGetName+0xa>
    43b4:	cd b7       	in	r28, 0x3d	; 61
    43b6:	de b7       	in	r29, 0x3e	; 62
    43b8:	9c 83       	std	Y+4, r25	; 0x04
    43ba:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    43bc:	8b 81       	ldd	r24, Y+3	; 0x03
    43be:	9c 81       	ldd	r25, Y+4	; 0x04
    43c0:	00 97       	sbiw	r24, 0x00	; 0
    43c2:	39 f4       	brne	.+14     	; 0x43d2 <pcTaskGetName+0x28>
    43c4:	80 91 8e 06 	lds	r24, 0x068E
    43c8:	90 91 8f 06 	lds	r25, 0x068F
    43cc:	9e 83       	std	Y+6, r25	; 0x06
    43ce:	8d 83       	std	Y+5, r24	; 0x05
    43d0:	04 c0       	rjmp	.+8      	; 0x43da <pcTaskGetName+0x30>
    43d2:	8b 81       	ldd	r24, Y+3	; 0x03
    43d4:	9c 81       	ldd	r25, Y+4	; 0x04
    43d6:	9e 83       	std	Y+6, r25	; 0x06
    43d8:	8d 83       	std	Y+5, r24	; 0x05
    43da:	8d 81       	ldd	r24, Y+5	; 0x05
    43dc:	9e 81       	ldd	r25, Y+6	; 0x06
    43de:	9a 83       	std	Y+2, r25	; 0x02
    43e0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    43e2:	89 81       	ldd	r24, Y+1	; 0x01
    43e4:	9a 81       	ldd	r25, Y+2	; 0x02
    43e6:	49 96       	adiw	r24, 0x19	; 25
}
    43e8:	26 96       	adiw	r28, 0x06	; 6
    43ea:	0f b6       	in	r0, 0x3f	; 63
    43ec:	f8 94       	cli
    43ee:	de bf       	out	0x3e, r29	; 62
    43f0:	0f be       	out	0x3f, r0	; 63
    43f2:	cd bf       	out	0x3d, r28	; 61
    43f4:	cf 91       	pop	r28
    43f6:	df 91       	pop	r29
    43f8:	08 95       	ret

000043fa <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    43fa:	df 93       	push	r29
    43fc:	cf 93       	push	r28
    43fe:	cd b7       	in	r28, 0x3d	; 61
    4400:	de b7       	in	r29, 0x3e	; 62
    4402:	29 97       	sbiw	r28, 0x09	; 9
    4404:	0f b6       	in	r0, 0x3f	; 63
    4406:	f8 94       	cli
    4408:	de bf       	out	0x3e, r29	; 62
    440a:	0f be       	out	0x3f, r0	; 63
    440c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    440e:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4410:	80 91 9e 06 	lds	r24, 0x069E
    4414:	88 23       	and	r24, r24
    4416:	09 f0       	breq	.+2      	; 0x441a <xTaskIncrementTick+0x20>
    4418:	c0 c0       	rjmp	.+384    	; 0x459a <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    441a:	80 91 92 06 	lds	r24, 0x0692
    441e:	90 91 93 06 	lds	r25, 0x0693
    4422:	01 96       	adiw	r24, 0x01	; 1
    4424:	9c 83       	std	Y+4, r25	; 0x04
    4426:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4428:	8b 81       	ldd	r24, Y+3	; 0x03
    442a:	9c 81       	ldd	r25, Y+4	; 0x04
    442c:	90 93 93 06 	sts	0x0693, r25
    4430:	80 93 92 06 	sts	0x0692, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4434:	8b 81       	ldd	r24, Y+3	; 0x03
    4436:	9c 81       	ldd	r25, Y+4	; 0x04
    4438:	00 97       	sbiw	r24, 0x00	; 0
    443a:	d9 f4       	brne	.+54     	; 0x4472 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    443c:	80 91 d5 06 	lds	r24, 0x06D5
    4440:	90 91 d6 06 	lds	r25, 0x06D6
    4444:	9a 83       	std	Y+2, r25	; 0x02
    4446:	89 83       	std	Y+1, r24	; 0x01
    4448:	80 91 d7 06 	lds	r24, 0x06D7
    444c:	90 91 d8 06 	lds	r25, 0x06D8
    4450:	90 93 d6 06 	sts	0x06D6, r25
    4454:	80 93 d5 06 	sts	0x06D5, r24
    4458:	89 81       	ldd	r24, Y+1	; 0x01
    445a:	9a 81       	ldd	r25, Y+2	; 0x02
    445c:	90 93 d8 06 	sts	0x06D8, r25
    4460:	80 93 d7 06 	sts	0x06D7, r24
    4464:	80 91 98 06 	lds	r24, 0x0698
    4468:	8f 5f       	subi	r24, 0xFF	; 255
    446a:	80 93 98 06 	sts	0x0698, r24
    446e:	0e 94 a7 25 	call	0x4b4e	; 0x4b4e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4472:	20 91 9a 06 	lds	r18, 0x069A
    4476:	30 91 9b 06 	lds	r19, 0x069B
    447a:	8b 81       	ldd	r24, Y+3	; 0x03
    447c:	9c 81       	ldd	r25, Y+4	; 0x04
    447e:	82 17       	cp	r24, r18
    4480:	93 07       	cpc	r25, r19
    4482:	08 f4       	brcc	.+2      	; 0x4486 <xTaskIncrementTick+0x8c>
    4484:	71 c0       	rjmp	.+226    	; 0x4568 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4486:	e0 91 d5 06 	lds	r30, 0x06D5
    448a:	f0 91 d6 06 	lds	r31, 0x06D6
    448e:	80 81       	ld	r24, Z
    4490:	88 23       	and	r24, r24
    4492:	39 f4       	brne	.+14     	; 0x44a2 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4494:	8f ef       	ldi	r24, 0xFF	; 255
    4496:	9f ef       	ldi	r25, 0xFF	; 255
    4498:	90 93 9b 06 	sts	0x069B, r25
    449c:	80 93 9a 06 	sts	0x069A, r24
    44a0:	63 c0       	rjmp	.+198    	; 0x4568 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44a2:	e0 91 d5 06 	lds	r30, 0x06D5
    44a6:	f0 91 d6 06 	lds	r31, 0x06D6
    44aa:	05 80       	ldd	r0, Z+5	; 0x05
    44ac:	f6 81       	ldd	r31, Z+6	; 0x06
    44ae:	e0 2d       	mov	r30, r0
    44b0:	86 81       	ldd	r24, Z+6	; 0x06
    44b2:	97 81       	ldd	r25, Z+7	; 0x07
    44b4:	99 87       	std	Y+9, r25	; 0x09
    44b6:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    44b8:	e8 85       	ldd	r30, Y+8	; 0x08
    44ba:	f9 85       	ldd	r31, Y+9	; 0x09
    44bc:	82 81       	ldd	r24, Z+2	; 0x02
    44be:	93 81       	ldd	r25, Z+3	; 0x03
    44c0:	9f 83       	std	Y+7, r25	; 0x07
    44c2:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    44c4:	2b 81       	ldd	r18, Y+3	; 0x03
    44c6:	3c 81       	ldd	r19, Y+4	; 0x04
    44c8:	8e 81       	ldd	r24, Y+6	; 0x06
    44ca:	9f 81       	ldd	r25, Y+7	; 0x07
    44cc:	28 17       	cp	r18, r24
    44ce:	39 07       	cpc	r19, r25
    44d0:	38 f4       	brcc	.+14     	; 0x44e0 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    44d2:	8e 81       	ldd	r24, Y+6	; 0x06
    44d4:	9f 81       	ldd	r25, Y+7	; 0x07
    44d6:	90 93 9b 06 	sts	0x069B, r25
    44da:	80 93 9a 06 	sts	0x069A, r24
    44de:	44 c0       	rjmp	.+136    	; 0x4568 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44e0:	88 85       	ldd	r24, Y+8	; 0x08
    44e2:	99 85       	ldd	r25, Y+9	; 0x09
    44e4:	02 96       	adiw	r24, 0x02	; 2
    44e6:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    44ea:	e8 85       	ldd	r30, Y+8	; 0x08
    44ec:	f9 85       	ldd	r31, Y+9	; 0x09
    44ee:	84 89       	ldd	r24, Z+20	; 0x14
    44f0:	95 89       	ldd	r25, Z+21	; 0x15
    44f2:	00 97       	sbiw	r24, 0x00	; 0
    44f4:	29 f0       	breq	.+10     	; 0x4500 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44f6:	88 85       	ldd	r24, Y+8	; 0x08
    44f8:	99 85       	ldd	r25, Y+9	; 0x09
    44fa:	0c 96       	adiw	r24, 0x0c	; 12
    44fc:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4500:	e8 85       	ldd	r30, Y+8	; 0x08
    4502:	f9 85       	ldd	r31, Y+9	; 0x09
    4504:	96 89       	ldd	r25, Z+22	; 0x16
    4506:	80 91 94 06 	lds	r24, 0x0694
    450a:	89 17       	cp	r24, r25
    450c:	28 f4       	brcc	.+10     	; 0x4518 <xTaskIncrementTick+0x11e>
    450e:	e8 85       	ldd	r30, Y+8	; 0x08
    4510:	f9 85       	ldd	r31, Y+9	; 0x09
    4512:	86 89       	ldd	r24, Z+22	; 0x16
    4514:	80 93 94 06 	sts	0x0694, r24
    4518:	e8 85       	ldd	r30, Y+8	; 0x08
    451a:	f9 85       	ldd	r31, Y+9	; 0x09
    451c:	86 89       	ldd	r24, Z+22	; 0x16
    451e:	28 2f       	mov	r18, r24
    4520:	30 e0       	ldi	r19, 0x00	; 0
    4522:	c9 01       	movw	r24, r18
    4524:	88 0f       	add	r24, r24
    4526:	99 1f       	adc	r25, r25
    4528:	88 0f       	add	r24, r24
    452a:	99 1f       	adc	r25, r25
    452c:	88 0f       	add	r24, r24
    452e:	99 1f       	adc	r25, r25
    4530:	82 0f       	add	r24, r18
    4532:	93 1f       	adc	r25, r19
    4534:	ac 01       	movw	r20, r24
    4536:	41 56       	subi	r20, 0x61	; 97
    4538:	59 4f       	sbci	r21, 0xF9	; 249
    453a:	88 85       	ldd	r24, Y+8	; 0x08
    453c:	99 85       	ldd	r25, Y+9	; 0x09
    453e:	9c 01       	movw	r18, r24
    4540:	2e 5f       	subi	r18, 0xFE	; 254
    4542:	3f 4f       	sbci	r19, 0xFF	; 255
    4544:	ca 01       	movw	r24, r20
    4546:	b9 01       	movw	r22, r18
    4548:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    454c:	e8 85       	ldd	r30, Y+8	; 0x08
    454e:	f9 85       	ldd	r31, Y+9	; 0x09
    4550:	96 89       	ldd	r25, Z+22	; 0x16
    4552:	e0 91 8e 06 	lds	r30, 0x068E
    4556:	f0 91 8f 06 	lds	r31, 0x068F
    455a:	86 89       	ldd	r24, Z+22	; 0x16
    455c:	98 17       	cp	r25, r24
    455e:	08 f4       	brcc	.+2      	; 0x4562 <xTaskIncrementTick+0x168>
    4560:	92 cf       	rjmp	.-220    	; 0x4486 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4562:	81 e0       	ldi	r24, 0x01	; 1
    4564:	8d 83       	std	Y+5, r24	; 0x05
    4566:	8f cf       	rjmp	.-226    	; 0x4486 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4568:	e0 91 8e 06 	lds	r30, 0x068E
    456c:	f0 91 8f 06 	lds	r31, 0x068F
    4570:	86 89       	ldd	r24, Z+22	; 0x16
    4572:	28 2f       	mov	r18, r24
    4574:	30 e0       	ldi	r19, 0x00	; 0
    4576:	c9 01       	movw	r24, r18
    4578:	88 0f       	add	r24, r24
    457a:	99 1f       	adc	r25, r25
    457c:	88 0f       	add	r24, r24
    457e:	99 1f       	adc	r25, r25
    4580:	88 0f       	add	r24, r24
    4582:	99 1f       	adc	r25, r25
    4584:	82 0f       	add	r24, r18
    4586:	93 1f       	adc	r25, r19
    4588:	fc 01       	movw	r30, r24
    458a:	e1 56       	subi	r30, 0x61	; 97
    458c:	f9 4f       	sbci	r31, 0xF9	; 249
    458e:	80 81       	ld	r24, Z
    4590:	82 30       	cpi	r24, 0x02	; 2
    4592:	40 f0       	brcs	.+16     	; 0x45a4 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    4594:	81 e0       	ldi	r24, 0x01	; 1
    4596:	8d 83       	std	Y+5, r24	; 0x05
    4598:	05 c0       	rjmp	.+10     	; 0x45a4 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    459a:	80 91 96 06 	lds	r24, 0x0696
    459e:	8f 5f       	subi	r24, 0xFF	; 255
    45a0:	80 93 96 06 	sts	0x0696, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    45a4:	80 91 97 06 	lds	r24, 0x0697
    45a8:	88 23       	and	r24, r24
    45aa:	11 f0       	breq	.+4      	; 0x45b0 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    45ac:	81 e0       	ldi	r24, 0x01	; 1
    45ae:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    45b0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    45b2:	29 96       	adiw	r28, 0x09	; 9
    45b4:	0f b6       	in	r0, 0x3f	; 63
    45b6:	f8 94       	cli
    45b8:	de bf       	out	0x3e, r29	; 62
    45ba:	0f be       	out	0x3f, r0	; 63
    45bc:	cd bf       	out	0x3d, r28	; 61
    45be:	cf 91       	pop	r28
    45c0:	df 91       	pop	r29
    45c2:	08 95       	ret

000045c4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    45c4:	df 93       	push	r29
    45c6:	cf 93       	push	r28
    45c8:	00 d0       	rcall	.+0      	; 0x45ca <vTaskSwitchContext+0x6>
    45ca:	0f 92       	push	r0
    45cc:	cd b7       	in	r28, 0x3d	; 61
    45ce:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    45d0:	80 91 9e 06 	lds	r24, 0x069E
    45d4:	88 23       	and	r24, r24
    45d6:	21 f0       	breq	.+8      	; 0x45e0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    45d8:	81 e0       	ldi	r24, 0x01	; 1
    45da:	80 93 97 06 	sts	0x0697, r24
    45de:	59 c0       	rjmp	.+178    	; 0x4692 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    45e0:	10 92 97 06 	sts	0x0697, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    45e4:	80 91 94 06 	lds	r24, 0x0694
    45e8:	8b 83       	std	Y+3, r24	; 0x03
    45ea:	03 c0       	rjmp	.+6      	; 0x45f2 <vTaskSwitchContext+0x2e>
    45ec:	8b 81       	ldd	r24, Y+3	; 0x03
    45ee:	81 50       	subi	r24, 0x01	; 1
    45f0:	8b 83       	std	Y+3, r24	; 0x03
    45f2:	8b 81       	ldd	r24, Y+3	; 0x03
    45f4:	28 2f       	mov	r18, r24
    45f6:	30 e0       	ldi	r19, 0x00	; 0
    45f8:	c9 01       	movw	r24, r18
    45fa:	88 0f       	add	r24, r24
    45fc:	99 1f       	adc	r25, r25
    45fe:	88 0f       	add	r24, r24
    4600:	99 1f       	adc	r25, r25
    4602:	88 0f       	add	r24, r24
    4604:	99 1f       	adc	r25, r25
    4606:	82 0f       	add	r24, r18
    4608:	93 1f       	adc	r25, r19
    460a:	fc 01       	movw	r30, r24
    460c:	e1 56       	subi	r30, 0x61	; 97
    460e:	f9 4f       	sbci	r31, 0xF9	; 249
    4610:	80 81       	ld	r24, Z
    4612:	88 23       	and	r24, r24
    4614:	59 f3       	breq	.-42     	; 0x45ec <vTaskSwitchContext+0x28>
    4616:	8b 81       	ldd	r24, Y+3	; 0x03
    4618:	28 2f       	mov	r18, r24
    461a:	30 e0       	ldi	r19, 0x00	; 0
    461c:	c9 01       	movw	r24, r18
    461e:	88 0f       	add	r24, r24
    4620:	99 1f       	adc	r25, r25
    4622:	88 0f       	add	r24, r24
    4624:	99 1f       	adc	r25, r25
    4626:	88 0f       	add	r24, r24
    4628:	99 1f       	adc	r25, r25
    462a:	82 0f       	add	r24, r18
    462c:	93 1f       	adc	r25, r19
    462e:	81 56       	subi	r24, 0x61	; 97
    4630:	99 4f       	sbci	r25, 0xF9	; 249
    4632:	9a 83       	std	Y+2, r25	; 0x02
    4634:	89 83       	std	Y+1, r24	; 0x01
    4636:	e9 81       	ldd	r30, Y+1	; 0x01
    4638:	fa 81       	ldd	r31, Y+2	; 0x02
    463a:	01 80       	ldd	r0, Z+1	; 0x01
    463c:	f2 81       	ldd	r31, Z+2	; 0x02
    463e:	e0 2d       	mov	r30, r0
    4640:	82 81       	ldd	r24, Z+2	; 0x02
    4642:	93 81       	ldd	r25, Z+3	; 0x03
    4644:	e9 81       	ldd	r30, Y+1	; 0x01
    4646:	fa 81       	ldd	r31, Y+2	; 0x02
    4648:	92 83       	std	Z+2, r25	; 0x02
    464a:	81 83       	std	Z+1, r24	; 0x01
    464c:	e9 81       	ldd	r30, Y+1	; 0x01
    464e:	fa 81       	ldd	r31, Y+2	; 0x02
    4650:	21 81       	ldd	r18, Z+1	; 0x01
    4652:	32 81       	ldd	r19, Z+2	; 0x02
    4654:	89 81       	ldd	r24, Y+1	; 0x01
    4656:	9a 81       	ldd	r25, Y+2	; 0x02
    4658:	03 96       	adiw	r24, 0x03	; 3
    465a:	28 17       	cp	r18, r24
    465c:	39 07       	cpc	r19, r25
    465e:	59 f4       	brne	.+22     	; 0x4676 <vTaskSwitchContext+0xb2>
    4660:	e9 81       	ldd	r30, Y+1	; 0x01
    4662:	fa 81       	ldd	r31, Y+2	; 0x02
    4664:	01 80       	ldd	r0, Z+1	; 0x01
    4666:	f2 81       	ldd	r31, Z+2	; 0x02
    4668:	e0 2d       	mov	r30, r0
    466a:	82 81       	ldd	r24, Z+2	; 0x02
    466c:	93 81       	ldd	r25, Z+3	; 0x03
    466e:	e9 81       	ldd	r30, Y+1	; 0x01
    4670:	fa 81       	ldd	r31, Y+2	; 0x02
    4672:	92 83       	std	Z+2, r25	; 0x02
    4674:	81 83       	std	Z+1, r24	; 0x01
    4676:	e9 81       	ldd	r30, Y+1	; 0x01
    4678:	fa 81       	ldd	r31, Y+2	; 0x02
    467a:	01 80       	ldd	r0, Z+1	; 0x01
    467c:	f2 81       	ldd	r31, Z+2	; 0x02
    467e:	e0 2d       	mov	r30, r0
    4680:	86 81       	ldd	r24, Z+6	; 0x06
    4682:	97 81       	ldd	r25, Z+7	; 0x07
    4684:	90 93 8f 06 	sts	0x068F, r25
    4688:	80 93 8e 06 	sts	0x068E, r24
    468c:	8b 81       	ldd	r24, Y+3	; 0x03
    468e:	80 93 94 06 	sts	0x0694, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4692:	0f 90       	pop	r0
    4694:	0f 90       	pop	r0
    4696:	0f 90       	pop	r0
    4698:	cf 91       	pop	r28
    469a:	df 91       	pop	r29
    469c:	08 95       	ret

0000469e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    469e:	df 93       	push	r29
    46a0:	cf 93       	push	r28
    46a2:	00 d0       	rcall	.+0      	; 0x46a4 <vTaskPlaceOnEventList+0x6>
    46a4:	00 d0       	rcall	.+0      	; 0x46a6 <vTaskPlaceOnEventList+0x8>
    46a6:	cd b7       	in	r28, 0x3d	; 61
    46a8:	de b7       	in	r29, 0x3e	; 62
    46aa:	9a 83       	std	Y+2, r25	; 0x02
    46ac:	89 83       	std	Y+1, r24	; 0x01
    46ae:	7c 83       	std	Y+4, r23	; 0x04
    46b0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    46b2:	80 91 8e 06 	lds	r24, 0x068E
    46b6:	90 91 8f 06 	lds	r25, 0x068F
    46ba:	9c 01       	movw	r18, r24
    46bc:	24 5f       	subi	r18, 0xF4	; 244
    46be:	3f 4f       	sbci	r19, 0xFF	; 255
    46c0:	89 81       	ldd	r24, Y+1	; 0x01
    46c2:	9a 81       	ldd	r25, Y+2	; 0x02
    46c4:	b9 01       	movw	r22, r18
    46c6:	0e 94 b7 0a 	call	0x156e	; 0x156e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    46ca:	8b 81       	ldd	r24, Y+3	; 0x03
    46cc:	9c 81       	ldd	r25, Y+4	; 0x04
    46ce:	61 e0       	ldi	r22, 0x01	; 1
    46d0:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
}
    46d4:	0f 90       	pop	r0
    46d6:	0f 90       	pop	r0
    46d8:	0f 90       	pop	r0
    46da:	0f 90       	pop	r0
    46dc:	cf 91       	pop	r28
    46de:	df 91       	pop	r29
    46e0:	08 95       	ret

000046e2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    46e2:	df 93       	push	r29
    46e4:	cf 93       	push	r28
    46e6:	00 d0       	rcall	.+0      	; 0x46e8 <vTaskPlaceOnUnorderedEventList+0x6>
    46e8:	00 d0       	rcall	.+0      	; 0x46ea <vTaskPlaceOnUnorderedEventList+0x8>
    46ea:	00 d0       	rcall	.+0      	; 0x46ec <vTaskPlaceOnUnorderedEventList+0xa>
    46ec:	cd b7       	in	r28, 0x3d	; 61
    46ee:	de b7       	in	r29, 0x3e	; 62
    46f0:	9a 83       	std	Y+2, r25	; 0x02
    46f2:	89 83       	std	Y+1, r24	; 0x01
    46f4:	7c 83       	std	Y+4, r23	; 0x04
    46f6:	6b 83       	std	Y+3, r22	; 0x03
    46f8:	5e 83       	std	Y+6, r21	; 0x06
    46fa:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46fc:	e0 91 8e 06 	lds	r30, 0x068E
    4700:	f0 91 8f 06 	lds	r31, 0x068F
    4704:	8b 81       	ldd	r24, Y+3	; 0x03
    4706:	9c 81       	ldd	r25, Y+4	; 0x04
    4708:	90 68       	ori	r25, 0x80	; 128
    470a:	95 87       	std	Z+13, r25	; 0x0d
    470c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    470e:	80 91 8e 06 	lds	r24, 0x068E
    4712:	90 91 8f 06 	lds	r25, 0x068F
    4716:	9c 01       	movw	r18, r24
    4718:	24 5f       	subi	r18, 0xF4	; 244
    471a:	3f 4f       	sbci	r19, 0xFF	; 255
    471c:	89 81       	ldd	r24, Y+1	; 0x01
    471e:	9a 81       	ldd	r25, Y+2	; 0x02
    4720:	b9 01       	movw	r22, r18
    4722:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4726:	8d 81       	ldd	r24, Y+5	; 0x05
    4728:	9e 81       	ldd	r25, Y+6	; 0x06
    472a:	61 e0       	ldi	r22, 0x01	; 1
    472c:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>
}
    4730:	26 96       	adiw	r28, 0x06	; 6
    4732:	0f b6       	in	r0, 0x3f	; 63
    4734:	f8 94       	cli
    4736:	de bf       	out	0x3e, r29	; 62
    4738:	0f be       	out	0x3f, r0	; 63
    473a:	cd bf       	out	0x3d, r28	; 61
    473c:	cf 91       	pop	r28
    473e:	df 91       	pop	r29
    4740:	08 95       	ret

00004742 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4742:	df 93       	push	r29
    4744:	cf 93       	push	r28
    4746:	00 d0       	rcall	.+0      	; 0x4748 <xTaskRemoveFromEventList+0x6>
    4748:	00 d0       	rcall	.+0      	; 0x474a <xTaskRemoveFromEventList+0x8>
    474a:	0f 92       	push	r0
    474c:	cd b7       	in	r28, 0x3d	; 61
    474e:	de b7       	in	r29, 0x3e	; 62
    4750:	9d 83       	std	Y+5, r25	; 0x05
    4752:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4754:	ec 81       	ldd	r30, Y+4	; 0x04
    4756:	fd 81       	ldd	r31, Y+5	; 0x05
    4758:	05 80       	ldd	r0, Z+5	; 0x05
    475a:	f6 81       	ldd	r31, Z+6	; 0x06
    475c:	e0 2d       	mov	r30, r0
    475e:	86 81       	ldd	r24, Z+6	; 0x06
    4760:	97 81       	ldd	r25, Z+7	; 0x07
    4762:	9b 83       	std	Y+3, r25	; 0x03
    4764:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4766:	8a 81       	ldd	r24, Y+2	; 0x02
    4768:	9b 81       	ldd	r25, Y+3	; 0x03
    476a:	0c 96       	adiw	r24, 0x0c	; 12
    476c:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4770:	80 91 9e 06 	lds	r24, 0x069E
    4774:	88 23       	and	r24, r24
    4776:	61 f5       	brne	.+88     	; 0x47d0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4778:	8a 81       	ldd	r24, Y+2	; 0x02
    477a:	9b 81       	ldd	r25, Y+3	; 0x03
    477c:	02 96       	adiw	r24, 0x02	; 2
    477e:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4782:	ea 81       	ldd	r30, Y+2	; 0x02
    4784:	fb 81       	ldd	r31, Y+3	; 0x03
    4786:	96 89       	ldd	r25, Z+22	; 0x16
    4788:	80 91 94 06 	lds	r24, 0x0694
    478c:	89 17       	cp	r24, r25
    478e:	28 f4       	brcc	.+10     	; 0x479a <xTaskRemoveFromEventList+0x58>
    4790:	ea 81       	ldd	r30, Y+2	; 0x02
    4792:	fb 81       	ldd	r31, Y+3	; 0x03
    4794:	86 89       	ldd	r24, Z+22	; 0x16
    4796:	80 93 94 06 	sts	0x0694, r24
    479a:	ea 81       	ldd	r30, Y+2	; 0x02
    479c:	fb 81       	ldd	r31, Y+3	; 0x03
    479e:	86 89       	ldd	r24, Z+22	; 0x16
    47a0:	28 2f       	mov	r18, r24
    47a2:	30 e0       	ldi	r19, 0x00	; 0
    47a4:	c9 01       	movw	r24, r18
    47a6:	88 0f       	add	r24, r24
    47a8:	99 1f       	adc	r25, r25
    47aa:	88 0f       	add	r24, r24
    47ac:	99 1f       	adc	r25, r25
    47ae:	88 0f       	add	r24, r24
    47b0:	99 1f       	adc	r25, r25
    47b2:	82 0f       	add	r24, r18
    47b4:	93 1f       	adc	r25, r19
    47b6:	ac 01       	movw	r20, r24
    47b8:	41 56       	subi	r20, 0x61	; 97
    47ba:	59 4f       	sbci	r21, 0xF9	; 249
    47bc:	8a 81       	ldd	r24, Y+2	; 0x02
    47be:	9b 81       	ldd	r25, Y+3	; 0x03
    47c0:	9c 01       	movw	r18, r24
    47c2:	2e 5f       	subi	r18, 0xFE	; 254
    47c4:	3f 4f       	sbci	r19, 0xFF	; 255
    47c6:	ca 01       	movw	r24, r20
    47c8:	b9 01       	movw	r22, r18
    47ca:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
    47ce:	0a c0       	rjmp	.+20     	; 0x47e4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    47d0:	8a 81       	ldd	r24, Y+2	; 0x02
    47d2:	9b 81       	ldd	r25, Y+3	; 0x03
    47d4:	9c 01       	movw	r18, r24
    47d6:	24 5f       	subi	r18, 0xF4	; 244
    47d8:	3f 4f       	sbci	r19, 0xFF	; 255
    47da:	89 ed       	ldi	r24, 0xD9	; 217
    47dc:	96 e0       	ldi	r25, 0x06	; 6
    47de:	b9 01       	movw	r22, r18
    47e0:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47e4:	ea 81       	ldd	r30, Y+2	; 0x02
    47e6:	fb 81       	ldd	r31, Y+3	; 0x03
    47e8:	96 89       	ldd	r25, Z+22	; 0x16
    47ea:	e0 91 8e 06 	lds	r30, 0x068E
    47ee:	f0 91 8f 06 	lds	r31, 0x068F
    47f2:	86 89       	ldd	r24, Z+22	; 0x16
    47f4:	89 17       	cp	r24, r25
    47f6:	30 f4       	brcc	.+12     	; 0x4804 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    47f8:	81 e0       	ldi	r24, 0x01	; 1
    47fa:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    47fc:	81 e0       	ldi	r24, 0x01	; 1
    47fe:	80 93 97 06 	sts	0x0697, r24
    4802:	01 c0       	rjmp	.+2      	; 0x4806 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4804:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4806:	89 81       	ldd	r24, Y+1	; 0x01
}
    4808:	0f 90       	pop	r0
    480a:	0f 90       	pop	r0
    480c:	0f 90       	pop	r0
    480e:	0f 90       	pop	r0
    4810:	0f 90       	pop	r0
    4812:	cf 91       	pop	r28
    4814:	df 91       	pop	r29
    4816:	08 95       	ret

00004818 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4818:	df 93       	push	r29
    481a:	cf 93       	push	r28
    481c:	00 d0       	rcall	.+0      	; 0x481e <vTaskRemoveFromUnorderedEventList+0x6>
    481e:	00 d0       	rcall	.+0      	; 0x4820 <vTaskRemoveFromUnorderedEventList+0x8>
    4820:	00 d0       	rcall	.+0      	; 0x4822 <vTaskRemoveFromUnorderedEventList+0xa>
    4822:	cd b7       	in	r28, 0x3d	; 61
    4824:	de b7       	in	r29, 0x3e	; 62
    4826:	9c 83       	std	Y+4, r25	; 0x04
    4828:	8b 83       	std	Y+3, r24	; 0x03
    482a:	7e 83       	std	Y+6, r23	; 0x06
    482c:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    482e:	8d 81       	ldd	r24, Y+5	; 0x05
    4830:	9e 81       	ldd	r25, Y+6	; 0x06
    4832:	90 68       	ori	r25, 0x80	; 128
    4834:	eb 81       	ldd	r30, Y+3	; 0x03
    4836:	fc 81       	ldd	r31, Y+4	; 0x04
    4838:	91 83       	std	Z+1, r25	; 0x01
    483a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    483c:	eb 81       	ldd	r30, Y+3	; 0x03
    483e:	fc 81       	ldd	r31, Y+4	; 0x04
    4840:	86 81       	ldd	r24, Z+6	; 0x06
    4842:	97 81       	ldd	r25, Z+7	; 0x07
    4844:	9a 83       	std	Y+2, r25	; 0x02
    4846:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4848:	8b 81       	ldd	r24, Y+3	; 0x03
    484a:	9c 81       	ldd	r25, Y+4	; 0x04
    484c:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4850:	89 81       	ldd	r24, Y+1	; 0x01
    4852:	9a 81       	ldd	r25, Y+2	; 0x02
    4854:	02 96       	adiw	r24, 0x02	; 2
    4856:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    485a:	e9 81       	ldd	r30, Y+1	; 0x01
    485c:	fa 81       	ldd	r31, Y+2	; 0x02
    485e:	96 89       	ldd	r25, Z+22	; 0x16
    4860:	80 91 94 06 	lds	r24, 0x0694
    4864:	89 17       	cp	r24, r25
    4866:	28 f4       	brcc	.+10     	; 0x4872 <vTaskRemoveFromUnorderedEventList+0x5a>
    4868:	e9 81       	ldd	r30, Y+1	; 0x01
    486a:	fa 81       	ldd	r31, Y+2	; 0x02
    486c:	86 89       	ldd	r24, Z+22	; 0x16
    486e:	80 93 94 06 	sts	0x0694, r24
    4872:	e9 81       	ldd	r30, Y+1	; 0x01
    4874:	fa 81       	ldd	r31, Y+2	; 0x02
    4876:	86 89       	ldd	r24, Z+22	; 0x16
    4878:	28 2f       	mov	r18, r24
    487a:	30 e0       	ldi	r19, 0x00	; 0
    487c:	c9 01       	movw	r24, r18
    487e:	88 0f       	add	r24, r24
    4880:	99 1f       	adc	r25, r25
    4882:	88 0f       	add	r24, r24
    4884:	99 1f       	adc	r25, r25
    4886:	88 0f       	add	r24, r24
    4888:	99 1f       	adc	r25, r25
    488a:	82 0f       	add	r24, r18
    488c:	93 1f       	adc	r25, r19
    488e:	ac 01       	movw	r20, r24
    4890:	41 56       	subi	r20, 0x61	; 97
    4892:	59 4f       	sbci	r21, 0xF9	; 249
    4894:	89 81       	ldd	r24, Y+1	; 0x01
    4896:	9a 81       	ldd	r25, Y+2	; 0x02
    4898:	9c 01       	movw	r18, r24
    489a:	2e 5f       	subi	r18, 0xFE	; 254
    489c:	3f 4f       	sbci	r19, 0xFF	; 255
    489e:	ca 01       	movw	r24, r20
    48a0:	b9 01       	movw	r22, r18
    48a2:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    48a6:	e9 81       	ldd	r30, Y+1	; 0x01
    48a8:	fa 81       	ldd	r31, Y+2	; 0x02
    48aa:	96 89       	ldd	r25, Z+22	; 0x16
    48ac:	e0 91 8e 06 	lds	r30, 0x068E
    48b0:	f0 91 8f 06 	lds	r31, 0x068F
    48b4:	86 89       	ldd	r24, Z+22	; 0x16
    48b6:	89 17       	cp	r24, r25
    48b8:	18 f4       	brcc	.+6      	; 0x48c0 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    48ba:	81 e0       	ldi	r24, 0x01	; 1
    48bc:	80 93 97 06 	sts	0x0697, r24
	}
}
    48c0:	26 96       	adiw	r28, 0x06	; 6
    48c2:	0f b6       	in	r0, 0x3f	; 63
    48c4:	f8 94       	cli
    48c6:	de bf       	out	0x3e, r29	; 62
    48c8:	0f be       	out	0x3f, r0	; 63
    48ca:	cd bf       	out	0x3d, r28	; 61
    48cc:	cf 91       	pop	r28
    48ce:	df 91       	pop	r29
    48d0:	08 95       	ret

000048d2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48d2:	df 93       	push	r29
    48d4:	cf 93       	push	r28
    48d6:	00 d0       	rcall	.+0      	; 0x48d8 <vTaskSetTimeOutState+0x6>
    48d8:	cd b7       	in	r28, 0x3d	; 61
    48da:	de b7       	in	r29, 0x3e	; 62
    48dc:	9a 83       	std	Y+2, r25	; 0x02
    48de:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    48e0:	0f b6       	in	r0, 0x3f	; 63
    48e2:	f8 94       	cli
    48e4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    48e6:	80 91 98 06 	lds	r24, 0x0698
    48ea:	e9 81       	ldd	r30, Y+1	; 0x01
    48ec:	fa 81       	ldd	r31, Y+2	; 0x02
    48ee:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    48f0:	80 91 92 06 	lds	r24, 0x0692
    48f4:	90 91 93 06 	lds	r25, 0x0693
    48f8:	e9 81       	ldd	r30, Y+1	; 0x01
    48fa:	fa 81       	ldd	r31, Y+2	; 0x02
    48fc:	92 83       	std	Z+2, r25	; 0x02
    48fe:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4900:	0f 90       	pop	r0
    4902:	0f be       	out	0x3f, r0	; 63
}
    4904:	0f 90       	pop	r0
    4906:	0f 90       	pop	r0
    4908:	cf 91       	pop	r28
    490a:	df 91       	pop	r29
    490c:	08 95       	ret

0000490e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    490e:	df 93       	push	r29
    4910:	cf 93       	push	r28
    4912:	00 d0       	rcall	.+0      	; 0x4914 <vTaskInternalSetTimeOutState+0x6>
    4914:	cd b7       	in	r28, 0x3d	; 61
    4916:	de b7       	in	r29, 0x3e	; 62
    4918:	9a 83       	std	Y+2, r25	; 0x02
    491a:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    491c:	80 91 98 06 	lds	r24, 0x0698
    4920:	e9 81       	ldd	r30, Y+1	; 0x01
    4922:	fa 81       	ldd	r31, Y+2	; 0x02
    4924:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4926:	80 91 92 06 	lds	r24, 0x0692
    492a:	90 91 93 06 	lds	r25, 0x0693
    492e:	e9 81       	ldd	r30, Y+1	; 0x01
    4930:	fa 81       	ldd	r31, Y+2	; 0x02
    4932:	92 83       	std	Z+2, r25	; 0x02
    4934:	81 83       	std	Z+1, r24	; 0x01
}
    4936:	0f 90       	pop	r0
    4938:	0f 90       	pop	r0
    493a:	cf 91       	pop	r28
    493c:	df 91       	pop	r29
    493e:	08 95       	ret

00004940 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4940:	df 93       	push	r29
    4942:	cf 93       	push	r28
    4944:	cd b7       	in	r28, 0x3d	; 61
    4946:	de b7       	in	r29, 0x3e	; 62
    4948:	29 97       	sbiw	r28, 0x09	; 9
    494a:	0f b6       	in	r0, 0x3f	; 63
    494c:	f8 94       	cli
    494e:	de bf       	out	0x3e, r29	; 62
    4950:	0f be       	out	0x3f, r0	; 63
    4952:	cd bf       	out	0x3d, r28	; 61
    4954:	9f 83       	std	Y+7, r25	; 0x07
    4956:	8e 83       	std	Y+6, r24	; 0x06
    4958:	79 87       	std	Y+9, r23	; 0x09
    495a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    495c:	0f b6       	in	r0, 0x3f	; 63
    495e:	f8 94       	cli
    4960:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4962:	80 91 92 06 	lds	r24, 0x0692
    4966:	90 91 93 06 	lds	r25, 0x0693
    496a:	9c 83       	std	Y+4, r25	; 0x04
    496c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    496e:	ee 81       	ldd	r30, Y+6	; 0x06
    4970:	ff 81       	ldd	r31, Y+7	; 0x07
    4972:	21 81       	ldd	r18, Z+1	; 0x01
    4974:	32 81       	ldd	r19, Z+2	; 0x02
    4976:	8b 81       	ldd	r24, Y+3	; 0x03
    4978:	9c 81       	ldd	r25, Y+4	; 0x04
    497a:	82 1b       	sub	r24, r18
    497c:	93 0b       	sbc	r25, r19
    497e:	9a 83       	std	Y+2, r25	; 0x02
    4980:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4982:	e8 85       	ldd	r30, Y+8	; 0x08
    4984:	f9 85       	ldd	r31, Y+9	; 0x09
    4986:	80 81       	ld	r24, Z
    4988:	91 81       	ldd	r25, Z+1	; 0x01
    498a:	2f ef       	ldi	r18, 0xFF	; 255
    498c:	8f 3f       	cpi	r24, 0xFF	; 255
    498e:	92 07       	cpc	r25, r18
    4990:	11 f4       	brne	.+4      	; 0x4996 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4992:	1d 82       	std	Y+5, r1	; 0x05
    4994:	36 c0       	rjmp	.+108    	; 0x4a02 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4996:	ee 81       	ldd	r30, Y+6	; 0x06
    4998:	ff 81       	ldd	r31, Y+7	; 0x07
    499a:	90 81       	ld	r25, Z
    499c:	80 91 98 06 	lds	r24, 0x0698
    49a0:	98 17       	cp	r25, r24
    49a2:	61 f0       	breq	.+24     	; 0x49bc <xTaskCheckForTimeOut+0x7c>
    49a4:	ee 81       	ldd	r30, Y+6	; 0x06
    49a6:	ff 81       	ldd	r31, Y+7	; 0x07
    49a8:	21 81       	ldd	r18, Z+1	; 0x01
    49aa:	32 81       	ldd	r19, Z+2	; 0x02
    49ac:	8b 81       	ldd	r24, Y+3	; 0x03
    49ae:	9c 81       	ldd	r25, Y+4	; 0x04
    49b0:	82 17       	cp	r24, r18
    49b2:	93 07       	cpc	r25, r19
    49b4:	18 f0       	brcs	.+6      	; 0x49bc <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    49b6:	81 e0       	ldi	r24, 0x01	; 1
    49b8:	8d 83       	std	Y+5, r24	; 0x05
    49ba:	23 c0       	rjmp	.+70     	; 0x4a02 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    49bc:	e8 85       	ldd	r30, Y+8	; 0x08
    49be:	f9 85       	ldd	r31, Y+9	; 0x09
    49c0:	20 81       	ld	r18, Z
    49c2:	31 81       	ldd	r19, Z+1	; 0x01
    49c4:	89 81       	ldd	r24, Y+1	; 0x01
    49c6:	9a 81       	ldd	r25, Y+2	; 0x02
    49c8:	82 17       	cp	r24, r18
    49ca:	93 07       	cpc	r25, r19
    49cc:	a0 f4       	brcc	.+40     	; 0x49f6 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    49ce:	e8 85       	ldd	r30, Y+8	; 0x08
    49d0:	f9 85       	ldd	r31, Y+9	; 0x09
    49d2:	20 81       	ld	r18, Z
    49d4:	31 81       	ldd	r19, Z+1	; 0x01
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	9a 81       	ldd	r25, Y+2	; 0x02
    49da:	a9 01       	movw	r20, r18
    49dc:	48 1b       	sub	r20, r24
    49de:	59 0b       	sbc	r21, r25
    49e0:	ca 01       	movw	r24, r20
    49e2:	e8 85       	ldd	r30, Y+8	; 0x08
    49e4:	f9 85       	ldd	r31, Y+9	; 0x09
    49e6:	91 83       	std	Z+1, r25	; 0x01
    49e8:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    49ea:	8e 81       	ldd	r24, Y+6	; 0x06
    49ec:	9f 81       	ldd	r25, Y+7	; 0x07
    49ee:	0e 94 87 24 	call	0x490e	; 0x490e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    49f2:	1d 82       	std	Y+5, r1	; 0x05
    49f4:	06 c0       	rjmp	.+12     	; 0x4a02 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    49f6:	e8 85       	ldd	r30, Y+8	; 0x08
    49f8:	f9 85       	ldd	r31, Y+9	; 0x09
    49fa:	11 82       	std	Z+1, r1	; 0x01
    49fc:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    49fe:	81 e0       	ldi	r24, 0x01	; 1
    4a00:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4a02:	0f 90       	pop	r0
    4a04:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4a06:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4a08:	29 96       	adiw	r28, 0x09	; 9
    4a0a:	0f b6       	in	r0, 0x3f	; 63
    4a0c:	f8 94       	cli
    4a0e:	de bf       	out	0x3e, r29	; 62
    4a10:	0f be       	out	0x3f, r0	; 63
    4a12:	cd bf       	out	0x3d, r28	; 61
    4a14:	cf 91       	pop	r28
    4a16:	df 91       	pop	r29
    4a18:	08 95       	ret

00004a1a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4a1a:	df 93       	push	r29
    4a1c:	cf 93       	push	r28
    4a1e:	cd b7       	in	r28, 0x3d	; 61
    4a20:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4a22:	81 e0       	ldi	r24, 0x01	; 1
    4a24:	80 93 97 06 	sts	0x0697, r24
}
    4a28:	cf 91       	pop	r28
    4a2a:	df 91       	pop	r29
    4a2c:	08 95       	ret

00004a2e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4a2e:	df 93       	push	r29
    4a30:	cf 93       	push	r28
    4a32:	00 d0       	rcall	.+0      	; 0x4a34 <prvIdleTask+0x6>
    4a34:	cd b7       	in	r28, 0x3d	; 61
    4a36:	de b7       	in	r29, 0x3e	; 62
    4a38:	9a 83       	std	Y+2, r25	; 0x02
    4a3a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4a3c:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <prvCheckTasksWaitingTermination>
    4a40:	fd cf       	rjmp	.-6      	; 0x4a3c <prvIdleTask+0xe>

00004a42 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4a42:	df 93       	push	r29
    4a44:	cf 93       	push	r28
    4a46:	0f 92       	push	r0
    4a48:	cd b7       	in	r28, 0x3d	; 61
    4a4a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a4c:	19 82       	std	Y+1, r1	; 0x01
    4a4e:	13 c0       	rjmp	.+38     	; 0x4a76 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4a50:	89 81       	ldd	r24, Y+1	; 0x01
    4a52:	28 2f       	mov	r18, r24
    4a54:	30 e0       	ldi	r19, 0x00	; 0
    4a56:	c9 01       	movw	r24, r18
    4a58:	88 0f       	add	r24, r24
    4a5a:	99 1f       	adc	r25, r25
    4a5c:	88 0f       	add	r24, r24
    4a5e:	99 1f       	adc	r25, r25
    4a60:	88 0f       	add	r24, r24
    4a62:	99 1f       	adc	r25, r25
    4a64:	82 0f       	add	r24, r18
    4a66:	93 1f       	adc	r25, r19
    4a68:	81 56       	subi	r24, 0x61	; 97
    4a6a:	99 4f       	sbci	r25, 0xF9	; 249
    4a6c:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a70:	89 81       	ldd	r24, Y+1	; 0x01
    4a72:	8f 5f       	subi	r24, 0xFF	; 255
    4a74:	89 83       	std	Y+1, r24	; 0x01
    4a76:	89 81       	ldd	r24, Y+1	; 0x01
    4a78:	84 30       	cpi	r24, 0x04	; 4
    4a7a:	50 f3       	brcs	.-44     	; 0x4a50 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4a7c:	83 ec       	ldi	r24, 0xC3	; 195
    4a7e:	96 e0       	ldi	r25, 0x06	; 6
    4a80:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4a84:	8c ec       	ldi	r24, 0xCC	; 204
    4a86:	96 e0       	ldi	r25, 0x06	; 6
    4a88:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4a8c:	89 ed       	ldi	r24, 0xD9	; 217
    4a8e:	96 e0       	ldi	r25, 0x06	; 6
    4a90:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4a94:	82 ee       	ldi	r24, 0xE2	; 226
    4a96:	96 e0       	ldi	r25, 0x06	; 6
    4a98:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4a9c:	8b ee       	ldi	r24, 0xEB	; 235
    4a9e:	96 e0       	ldi	r25, 0x06	; 6
    4aa0:	0e 94 39 0a 	call	0x1472	; 0x1472 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4aa4:	83 ec       	ldi	r24, 0xC3	; 195
    4aa6:	96 e0       	ldi	r25, 0x06	; 6
    4aa8:	90 93 d6 06 	sts	0x06D6, r25
    4aac:	80 93 d5 06 	sts	0x06D5, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4ab0:	8c ec       	ldi	r24, 0xCC	; 204
    4ab2:	96 e0       	ldi	r25, 0x06	; 6
    4ab4:	90 93 d8 06 	sts	0x06D8, r25
    4ab8:	80 93 d7 06 	sts	0x06D7, r24
}
    4abc:	0f 90       	pop	r0
    4abe:	cf 91       	pop	r28
    4ac0:	df 91       	pop	r29
    4ac2:	08 95       	ret

00004ac4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4ac4:	df 93       	push	r29
    4ac6:	cf 93       	push	r28
    4ac8:	00 d0       	rcall	.+0      	; 0x4aca <prvCheckTasksWaitingTermination+0x6>
    4aca:	cd b7       	in	r28, 0x3d	; 61
    4acc:	de b7       	in	r29, 0x3e	; 62
    4ace:	20 c0       	rjmp	.+64     	; 0x4b10 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4ad0:	0f b6       	in	r0, 0x3f	; 63
    4ad2:	f8 94       	cli
    4ad4:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ad6:	e0 91 e7 06 	lds	r30, 0x06E7
    4ada:	f0 91 e8 06 	lds	r31, 0x06E8
    4ade:	86 81       	ldd	r24, Z+6	; 0x06
    4ae0:	97 81       	ldd	r25, Z+7	; 0x07
    4ae2:	9a 83       	std	Y+2, r25	; 0x02
    4ae4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4ae6:	89 81       	ldd	r24, Y+1	; 0x01
    4ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    4aea:	02 96       	adiw	r24, 0x02	; 2
    4aec:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4af0:	80 91 91 06 	lds	r24, 0x0691
    4af4:	81 50       	subi	r24, 0x01	; 1
    4af6:	80 93 91 06 	sts	0x0691, r24
				--uxDeletedTasksWaitingCleanUp;
    4afa:	80 91 90 06 	lds	r24, 0x0690
    4afe:	81 50       	subi	r24, 0x01	; 1
    4b00:	80 93 90 06 	sts	0x0690, r24
			}
			taskEXIT_CRITICAL();
    4b04:	0f 90       	pop	r0
    4b06:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4b08:	89 81       	ldd	r24, Y+1	; 0x01
    4b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b0c:	0e 94 91 25 	call	0x4b22	; 0x4b22 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4b10:	80 91 90 06 	lds	r24, 0x0690
    4b14:	88 23       	and	r24, r24
    4b16:	e1 f6       	brne	.-72     	; 0x4ad0 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4b18:	0f 90       	pop	r0
    4b1a:	0f 90       	pop	r0
    4b1c:	cf 91       	pop	r28
    4b1e:	df 91       	pop	r29
    4b20:	08 95       	ret

00004b22 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4b22:	df 93       	push	r29
    4b24:	cf 93       	push	r28
    4b26:	00 d0       	rcall	.+0      	; 0x4b28 <prvDeleteTCB+0x6>
    4b28:	cd b7       	in	r28, 0x3d	; 61
    4b2a:	de b7       	in	r29, 0x3e	; 62
    4b2c:	9a 83       	std	Y+2, r25	; 0x02
    4b2e:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4b30:	e9 81       	ldd	r30, Y+1	; 0x01
    4b32:	fa 81       	ldd	r31, Y+2	; 0x02
    4b34:	87 89       	ldd	r24, Z+23	; 0x17
    4b36:	90 8d       	ldd	r25, Z+24	; 0x18
    4b38:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
			vPortFree( pxTCB );
    4b3c:	89 81       	ldd	r24, Y+1	; 0x01
    4b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b40:	0e 94 79 07 	call	0xef2	; 0xef2 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4b44:	0f 90       	pop	r0
    4b46:	0f 90       	pop	r0
    4b48:	cf 91       	pop	r28
    4b4a:	df 91       	pop	r29
    4b4c:	08 95       	ret

00004b4e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4b4e:	df 93       	push	r29
    4b50:	cf 93       	push	r28
    4b52:	00 d0       	rcall	.+0      	; 0x4b54 <prvResetNextTaskUnblockTime+0x6>
    4b54:	cd b7       	in	r28, 0x3d	; 61
    4b56:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b58:	e0 91 d5 06 	lds	r30, 0x06D5
    4b5c:	f0 91 d6 06 	lds	r31, 0x06D6
    4b60:	80 81       	ld	r24, Z
    4b62:	88 23       	and	r24, r24
    4b64:	39 f4       	brne	.+14     	; 0x4b74 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4b66:	8f ef       	ldi	r24, 0xFF	; 255
    4b68:	9f ef       	ldi	r25, 0xFF	; 255
    4b6a:	90 93 9b 06 	sts	0x069B, r25
    4b6e:	80 93 9a 06 	sts	0x069A, r24
    4b72:	13 c0       	rjmp	.+38     	; 0x4b9a <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b74:	e0 91 d5 06 	lds	r30, 0x06D5
    4b78:	f0 91 d6 06 	lds	r31, 0x06D6
    4b7c:	05 80       	ldd	r0, Z+5	; 0x05
    4b7e:	f6 81       	ldd	r31, Z+6	; 0x06
    4b80:	e0 2d       	mov	r30, r0
    4b82:	86 81       	ldd	r24, Z+6	; 0x06
    4b84:	97 81       	ldd	r25, Z+7	; 0x07
    4b86:	9a 83       	std	Y+2, r25	; 0x02
    4b88:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4b8a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b8c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b8e:	82 81       	ldd	r24, Z+2	; 0x02
    4b90:	93 81       	ldd	r25, Z+3	; 0x03
    4b92:	90 93 9b 06 	sts	0x069B, r25
    4b96:	80 93 9a 06 	sts	0x069A, r24
	}
}
    4b9a:	0f 90       	pop	r0
    4b9c:	0f 90       	pop	r0
    4b9e:	cf 91       	pop	r28
    4ba0:	df 91       	pop	r29
    4ba2:	08 95       	ret

00004ba4 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4ba4:	df 93       	push	r29
    4ba6:	cf 93       	push	r28
    4ba8:	00 d0       	rcall	.+0      	; 0x4baa <xTaskGetCurrentTaskHandle+0x6>
    4baa:	cd b7       	in	r28, 0x3d	; 61
    4bac:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4bae:	80 91 8e 06 	lds	r24, 0x068E
    4bb2:	90 91 8f 06 	lds	r25, 0x068F
    4bb6:	9a 83       	std	Y+2, r25	; 0x02
    4bb8:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4bba:	89 81       	ldd	r24, Y+1	; 0x01
    4bbc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4bbe:	0f 90       	pop	r0
    4bc0:	0f 90       	pop	r0
    4bc2:	cf 91       	pop	r28
    4bc4:	df 91       	pop	r29
    4bc6:	08 95       	ret

00004bc8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4bc8:	df 93       	push	r29
    4bca:	cf 93       	push	r28
    4bcc:	00 d0       	rcall	.+0      	; 0x4bce <uxTaskResetEventItemValue+0x6>
    4bce:	cd b7       	in	r28, 0x3d	; 61
    4bd0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4bd2:	e0 91 8e 06 	lds	r30, 0x068E
    4bd6:	f0 91 8f 06 	lds	r31, 0x068F
    4bda:	84 85       	ldd	r24, Z+12	; 0x0c
    4bdc:	95 85       	ldd	r25, Z+13	; 0x0d
    4bde:	9a 83       	std	Y+2, r25	; 0x02
    4be0:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4be2:	a0 91 8e 06 	lds	r26, 0x068E
    4be6:	b0 91 8f 06 	lds	r27, 0x068F
    4bea:	e0 91 8e 06 	lds	r30, 0x068E
    4bee:	f0 91 8f 06 	lds	r31, 0x068F
    4bf2:	86 89       	ldd	r24, Z+22	; 0x16
    4bf4:	28 2f       	mov	r18, r24
    4bf6:	30 e0       	ldi	r19, 0x00	; 0
    4bf8:	84 e0       	ldi	r24, 0x04	; 4
    4bfa:	90 e0       	ldi	r25, 0x00	; 0
    4bfc:	82 1b       	sub	r24, r18
    4bfe:	93 0b       	sbc	r25, r19
    4c00:	1d 96       	adiw	r26, 0x0d	; 13
    4c02:	9c 93       	st	X, r25
    4c04:	8e 93       	st	-X, r24
    4c06:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4c08:	89 81       	ldd	r24, Y+1	; 0x01
    4c0a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4c0c:	0f 90       	pop	r0
    4c0e:	0f 90       	pop	r0
    4c10:	cf 91       	pop	r28
    4c12:	df 91       	pop	r29
    4c14:	08 95       	ret

00004c16 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4c16:	df 93       	push	r29
    4c18:	cf 93       	push	r28
    4c1a:	cd b7       	in	r28, 0x3d	; 61
    4c1c:	de b7       	in	r29, 0x3e	; 62
    4c1e:	27 97       	sbiw	r28, 0x07	; 7
    4c20:	0f b6       	in	r0, 0x3f	; 63
    4c22:	f8 94       	cli
    4c24:	de bf       	out	0x3e, r29	; 62
    4c26:	0f be       	out	0x3f, r0	; 63
    4c28:	cd bf       	out	0x3d, r28	; 61
    4c2a:	8d 83       	std	Y+5, r24	; 0x05
    4c2c:	7f 83       	std	Y+7, r23	; 0x07
    4c2e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4c30:	0f b6       	in	r0, 0x3f	; 63
    4c32:	f8 94       	cli
    4c34:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4c36:	e0 91 8e 06 	lds	r30, 0x068E
    4c3a:	f0 91 8f 06 	lds	r31, 0x068F
    4c3e:	85 a1       	ldd	r24, Z+37	; 0x25
    4c40:	96 a1       	ldd	r25, Z+38	; 0x26
    4c42:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c44:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c46:	00 97       	sbiw	r24, 0x00	; 0
    4c48:	a1 05       	cpc	r26, r1
    4c4a:	b1 05       	cpc	r27, r1
    4c4c:	89 f4       	brne	.+34     	; 0x4c70 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c4e:	e0 91 8e 06 	lds	r30, 0x068E
    4c52:	f0 91 8f 06 	lds	r31, 0x068F
    4c56:	81 e0       	ldi	r24, 0x01	; 1
    4c58:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4c5a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c5c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c5e:	00 97       	sbiw	r24, 0x00	; 0
    4c60:	39 f0       	breq	.+14     	; 0x4c70 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4c62:	8e 81       	ldd	r24, Y+6	; 0x06
    4c64:	9f 81       	ldd	r25, Y+7	; 0x07
    4c66:	61 e0       	ldi	r22, 0x01	; 1
    4c68:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4c6c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4c70:	0f 90       	pop	r0
    4c72:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4c74:	0f b6       	in	r0, 0x3f	; 63
    4c76:	f8 94       	cli
    4c78:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4c7a:	e0 91 8e 06 	lds	r30, 0x068E
    4c7e:	f0 91 8f 06 	lds	r31, 0x068F
    4c82:	85 a1       	ldd	r24, Z+37	; 0x25
    4c84:	96 a1       	ldd	r25, Z+38	; 0x26
    4c86:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c88:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c8a:	89 83       	std	Y+1, r24	; 0x01
    4c8c:	9a 83       	std	Y+2, r25	; 0x02
    4c8e:	ab 83       	std	Y+3, r26	; 0x03
    4c90:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4c92:	89 81       	ldd	r24, Y+1	; 0x01
    4c94:	9a 81       	ldd	r25, Y+2	; 0x02
    4c96:	ab 81       	ldd	r26, Y+3	; 0x03
    4c98:	bc 81       	ldd	r27, Y+4	; 0x04
    4c9a:	00 97       	sbiw	r24, 0x00	; 0
    4c9c:	a1 05       	cpc	r26, r1
    4c9e:	b1 05       	cpc	r27, r1
    4ca0:	d9 f0       	breq	.+54     	; 0x4cd8 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4ca2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ca4:	88 23       	and	r24, r24
    4ca6:	49 f0       	breq	.+18     	; 0x4cba <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4ca8:	e0 91 8e 06 	lds	r30, 0x068E
    4cac:	f0 91 8f 06 	lds	r31, 0x068F
    4cb0:	15 a2       	std	Z+37, r1	; 0x25
    4cb2:	16 a2       	std	Z+38, r1	; 0x26
    4cb4:	17 a2       	std	Z+39, r1	; 0x27
    4cb6:	10 a6       	std	Z+40, r1	; 0x28
    4cb8:	0f c0       	rjmp	.+30     	; 0x4cd8 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4cba:	e0 91 8e 06 	lds	r30, 0x068E
    4cbe:	f0 91 8f 06 	lds	r31, 0x068F
    4cc2:	89 81       	ldd	r24, Y+1	; 0x01
    4cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cc6:	ab 81       	ldd	r26, Y+3	; 0x03
    4cc8:	bc 81       	ldd	r27, Y+4	; 0x04
    4cca:	01 97       	sbiw	r24, 0x01	; 1
    4ccc:	a1 09       	sbc	r26, r1
    4cce:	b1 09       	sbc	r27, r1
    4cd0:	85 a3       	std	Z+37, r24	; 0x25
    4cd2:	96 a3       	std	Z+38, r25	; 0x26
    4cd4:	a7 a3       	std	Z+39, r26	; 0x27
    4cd6:	b0 a7       	std	Z+40, r27	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cd8:	e0 91 8e 06 	lds	r30, 0x068E
    4cdc:	f0 91 8f 06 	lds	r31, 0x068F
    4ce0:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4ce2:	0f 90       	pop	r0
    4ce4:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4ce6:	89 81       	ldd	r24, Y+1	; 0x01
    4ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cea:	ab 81       	ldd	r26, Y+3	; 0x03
    4cec:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4cee:	bc 01       	movw	r22, r24
    4cf0:	cd 01       	movw	r24, r26
    4cf2:	27 96       	adiw	r28, 0x07	; 7
    4cf4:	0f b6       	in	r0, 0x3f	; 63
    4cf6:	f8 94       	cli
    4cf8:	de bf       	out	0x3e, r29	; 62
    4cfa:	0f be       	out	0x3f, r0	; 63
    4cfc:	cd bf       	out	0x3d, r28	; 61
    4cfe:	cf 91       	pop	r28
    4d00:	df 91       	pop	r29
    4d02:	08 95       	ret

00004d04 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4d04:	ef 92       	push	r14
    4d06:	ff 92       	push	r15
    4d08:	0f 93       	push	r16
    4d0a:	1f 93       	push	r17
    4d0c:	df 93       	push	r29
    4d0e:	cf 93       	push	r28
    4d10:	cd b7       	in	r28, 0x3d	; 61
    4d12:	de b7       	in	r29, 0x3e	; 62
    4d14:	2d 97       	sbiw	r28, 0x0d	; 13
    4d16:	0f b6       	in	r0, 0x3f	; 63
    4d18:	f8 94       	cli
    4d1a:	de bf       	out	0x3e, r29	; 62
    4d1c:	0f be       	out	0x3f, r0	; 63
    4d1e:	cd bf       	out	0x3d, r28	; 61
    4d20:	6a 83       	std	Y+2, r22	; 0x02
    4d22:	7b 83       	std	Y+3, r23	; 0x03
    4d24:	8c 83       	std	Y+4, r24	; 0x04
    4d26:	9d 83       	std	Y+5, r25	; 0x05
    4d28:	2e 83       	std	Y+6, r18	; 0x06
    4d2a:	3f 83       	std	Y+7, r19	; 0x07
    4d2c:	48 87       	std	Y+8, r20	; 0x08
    4d2e:	59 87       	std	Y+9, r21	; 0x09
    4d30:	1b 87       	std	Y+11, r17	; 0x0b
    4d32:	0a 87       	std	Y+10, r16	; 0x0a
    4d34:	fd 86       	std	Y+13, r15	; 0x0d
    4d36:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4d38:	0f b6       	in	r0, 0x3f	; 63
    4d3a:	f8 94       	cli
    4d3c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4d3e:	e0 91 8e 06 	lds	r30, 0x068E
    4d42:	f0 91 8f 06 	lds	r31, 0x068F
    4d46:	81 a5       	ldd	r24, Z+41	; 0x29
    4d48:	82 30       	cpi	r24, 0x02	; 2
    4d4a:	49 f1       	breq	.+82     	; 0x4d9e <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4d4c:	e0 91 8e 06 	lds	r30, 0x068E
    4d50:	f0 91 8f 06 	lds	r31, 0x068F
    4d54:	25 a1       	ldd	r18, Z+37	; 0x25
    4d56:	36 a1       	ldd	r19, Z+38	; 0x26
    4d58:	47 a1       	ldd	r20, Z+39	; 0x27
    4d5a:	50 a5       	ldd	r21, Z+40	; 0x28
    4d5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4d60:	ac 81       	ldd	r26, Y+4	; 0x04
    4d62:	bd 81       	ldd	r27, Y+5	; 0x05
    4d64:	80 95       	com	r24
    4d66:	90 95       	com	r25
    4d68:	a0 95       	com	r26
    4d6a:	b0 95       	com	r27
    4d6c:	82 23       	and	r24, r18
    4d6e:	93 23       	and	r25, r19
    4d70:	a4 23       	and	r26, r20
    4d72:	b5 23       	and	r27, r21
    4d74:	85 a3       	std	Z+37, r24	; 0x25
    4d76:	96 a3       	std	Z+38, r25	; 0x26
    4d78:	a7 a3       	std	Z+39, r26	; 0x27
    4d7a:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4d7c:	e0 91 8e 06 	lds	r30, 0x068E
    4d80:	f0 91 8f 06 	lds	r31, 0x068F
    4d84:	81 e0       	ldi	r24, 0x01	; 1
    4d86:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4d88:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d8c:	00 97       	sbiw	r24, 0x00	; 0
    4d8e:	39 f0       	breq	.+14     	; 0x4d9e <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4d90:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d92:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d94:	61 e0       	ldi	r22, 0x01	; 1
    4d96:	0e 94 b3 29 	call	0x5366	; 0x5366 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4d9a:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d9e:	0f 90       	pop	r0
    4da0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4da2:	0f b6       	in	r0, 0x3f	; 63
    4da4:	f8 94       	cli
    4da6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4da8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4daa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dac:	00 97       	sbiw	r24, 0x00	; 0
    4dae:	71 f0       	breq	.+28     	; 0x4dcc <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4db0:	e0 91 8e 06 	lds	r30, 0x068E
    4db4:	f0 91 8f 06 	lds	r31, 0x068F
    4db8:	85 a1       	ldd	r24, Z+37	; 0x25
    4dba:	96 a1       	ldd	r25, Z+38	; 0x26
    4dbc:	a7 a1       	ldd	r26, Z+39	; 0x27
    4dbe:	b0 a5       	ldd	r27, Z+40	; 0x28
    4dc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dc4:	80 83       	st	Z, r24
    4dc6:	91 83       	std	Z+1, r25	; 0x01
    4dc8:	a2 83       	std	Z+2, r26	; 0x02
    4dca:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4dcc:	e0 91 8e 06 	lds	r30, 0x068E
    4dd0:	f0 91 8f 06 	lds	r31, 0x068F
    4dd4:	81 a5       	ldd	r24, Z+41	; 0x29
    4dd6:	82 30       	cpi	r24, 0x02	; 2
    4dd8:	11 f0       	breq	.+4      	; 0x4dde <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4dda:	19 82       	std	Y+1, r1	; 0x01
    4ddc:	1a c0       	rjmp	.+52     	; 0x4e12 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4dde:	e0 91 8e 06 	lds	r30, 0x068E
    4de2:	f0 91 8f 06 	lds	r31, 0x068F
    4de6:	25 a1       	ldd	r18, Z+37	; 0x25
    4de8:	36 a1       	ldd	r19, Z+38	; 0x26
    4dea:	47 a1       	ldd	r20, Z+39	; 0x27
    4dec:	50 a5       	ldd	r21, Z+40	; 0x28
    4dee:	8e 81       	ldd	r24, Y+6	; 0x06
    4df0:	9f 81       	ldd	r25, Y+7	; 0x07
    4df2:	a8 85       	ldd	r26, Y+8	; 0x08
    4df4:	b9 85       	ldd	r27, Y+9	; 0x09
    4df6:	80 95       	com	r24
    4df8:	90 95       	com	r25
    4dfa:	a0 95       	com	r26
    4dfc:	b0 95       	com	r27
    4dfe:	82 23       	and	r24, r18
    4e00:	93 23       	and	r25, r19
    4e02:	a4 23       	and	r26, r20
    4e04:	b5 23       	and	r27, r21
    4e06:	85 a3       	std	Z+37, r24	; 0x25
    4e08:	96 a3       	std	Z+38, r25	; 0x26
    4e0a:	a7 a3       	std	Z+39, r26	; 0x27
    4e0c:	b0 a7       	std	Z+40, r27	; 0x28
				xReturn = pdTRUE;
    4e0e:	81 e0       	ldi	r24, 0x01	; 1
    4e10:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e12:	e0 91 8e 06 	lds	r30, 0x068E
    4e16:	f0 91 8f 06 	lds	r31, 0x068F
    4e1a:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4e1c:	0f 90       	pop	r0
    4e1e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4e20:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4e22:	2d 96       	adiw	r28, 0x0d	; 13
    4e24:	0f b6       	in	r0, 0x3f	; 63
    4e26:	f8 94       	cli
    4e28:	de bf       	out	0x3e, r29	; 62
    4e2a:	0f be       	out	0x3f, r0	; 63
    4e2c:	cd bf       	out	0x3d, r28	; 61
    4e2e:	cf 91       	pop	r28
    4e30:	df 91       	pop	r29
    4e32:	1f 91       	pop	r17
    4e34:	0f 91       	pop	r16
    4e36:	ff 90       	pop	r15
    4e38:	ef 90       	pop	r14
    4e3a:	08 95       	ret

00004e3c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4e3c:	0f 93       	push	r16
    4e3e:	1f 93       	push	r17
    4e40:	df 93       	push	r29
    4e42:	cf 93       	push	r28
    4e44:	cd b7       	in	r28, 0x3d	; 61
    4e46:	de b7       	in	r29, 0x3e	; 62
    4e48:	2f 97       	sbiw	r28, 0x0f	; 15
    4e4a:	0f b6       	in	r0, 0x3f	; 63
    4e4c:	f8 94       	cli
    4e4e:	de bf       	out	0x3e, r29	; 62
    4e50:	0f be       	out	0x3f, r0	; 63
    4e52:	cd bf       	out	0x3d, r28	; 61
    4e54:	9e 83       	std	Y+6, r25	; 0x06
    4e56:	8d 83       	std	Y+5, r24	; 0x05
    4e58:	4f 83       	std	Y+7, r20	; 0x07
    4e5a:	58 87       	std	Y+8, r21	; 0x08
    4e5c:	69 87       	std	Y+9, r22	; 0x09
    4e5e:	7a 87       	std	Y+10, r23	; 0x0a
    4e60:	2b 87       	std	Y+11, r18	; 0x0b
    4e62:	1d 87       	std	Y+13, r17	; 0x0d
    4e64:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4e66:	81 e0       	ldi	r24, 0x01	; 1
    4e68:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4e6a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e6c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e6e:	9c 83       	std	Y+4, r25	; 0x04
    4e70:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4e72:	0f b6       	in	r0, 0x3f	; 63
    4e74:	f8 94       	cli
    4e76:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4e78:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e7c:	00 97       	sbiw	r24, 0x00	; 0
    4e7e:	61 f0       	breq	.+24     	; 0x4e98 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e80:	eb 81       	ldd	r30, Y+3	; 0x03
    4e82:	fc 81       	ldd	r31, Y+4	; 0x04
    4e84:	85 a1       	ldd	r24, Z+37	; 0x25
    4e86:	96 a1       	ldd	r25, Z+38	; 0x26
    4e88:	a7 a1       	ldd	r26, Z+39	; 0x27
    4e8a:	b0 a5       	ldd	r27, Z+40	; 0x28
    4e8c:	ec 85       	ldd	r30, Y+12	; 0x0c
    4e8e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4e90:	80 83       	st	Z, r24
    4e92:	91 83       	std	Z+1, r25	; 0x01
    4e94:	a2 83       	std	Z+2, r26	; 0x02
    4e96:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e98:	eb 81       	ldd	r30, Y+3	; 0x03
    4e9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e9c:	81 a5       	ldd	r24, Z+41	; 0x29
    4e9e:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea4:	82 e0       	ldi	r24, 0x02	; 2
    4ea6:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    4ea8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4eaa:	28 2f       	mov	r18, r24
    4eac:	30 e0       	ldi	r19, 0x00	; 0
    4eae:	3f 87       	std	Y+15, r19	; 0x0f
    4eb0:	2e 87       	std	Y+14, r18	; 0x0e
    4eb2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4eb4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4eb6:	82 30       	cpi	r24, 0x02	; 2
    4eb8:	91 05       	cpc	r25, r1
    4eba:	59 f1       	breq	.+86     	; 0x4f12 <xTaskGenericNotify+0xd6>
    4ebc:	2e 85       	ldd	r18, Y+14	; 0x0e
    4ebe:	3f 85       	ldd	r19, Y+15	; 0x0f
    4ec0:	23 30       	cpi	r18, 0x03	; 3
    4ec2:	31 05       	cpc	r19, r1
    4ec4:	34 f4       	brge	.+12     	; 0x4ed2 <xTaskGenericNotify+0x96>
    4ec6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ec8:	9f 85       	ldd	r25, Y+15	; 0x0f
    4eca:	81 30       	cpi	r24, 0x01	; 1
    4ecc:	91 05       	cpc	r25, r1
    4ece:	61 f0       	breq	.+24     	; 0x4ee8 <xTaskGenericNotify+0xac>
    4ed0:	4a c0       	rjmp	.+148    	; 0x4f66 <xTaskGenericNotify+0x12a>
    4ed2:	2e 85       	ldd	r18, Y+14	; 0x0e
    4ed4:	3f 85       	ldd	r19, Y+15	; 0x0f
    4ed6:	23 30       	cpi	r18, 0x03	; 3
    4ed8:	31 05       	cpc	r19, r1
    4eda:	59 f1       	breq	.+86     	; 0x4f32 <xTaskGenericNotify+0xf6>
    4edc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ede:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ee0:	84 30       	cpi	r24, 0x04	; 4
    4ee2:	91 05       	cpc	r25, r1
    4ee4:	89 f1       	breq	.+98     	; 0x4f48 <xTaskGenericNotify+0x10c>
    4ee6:	3f c0       	rjmp	.+126    	; 0x4f66 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    4eea:	fc 81       	ldd	r31, Y+4	; 0x04
    4eec:	25 a1       	ldd	r18, Z+37	; 0x25
    4eee:	36 a1       	ldd	r19, Z+38	; 0x26
    4ef0:	47 a1       	ldd	r20, Z+39	; 0x27
    4ef2:	50 a5       	ldd	r21, Z+40	; 0x28
    4ef4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ef6:	98 85       	ldd	r25, Y+8	; 0x08
    4ef8:	a9 85       	ldd	r26, Y+9	; 0x09
    4efa:	ba 85       	ldd	r27, Y+10	; 0x0a
    4efc:	82 2b       	or	r24, r18
    4efe:	93 2b       	or	r25, r19
    4f00:	a4 2b       	or	r26, r20
    4f02:	b5 2b       	or	r27, r21
    4f04:	eb 81       	ldd	r30, Y+3	; 0x03
    4f06:	fc 81       	ldd	r31, Y+4	; 0x04
    4f08:	85 a3       	std	Z+37, r24	; 0x25
    4f0a:	96 a3       	std	Z+38, r25	; 0x26
    4f0c:	a7 a3       	std	Z+39, r26	; 0x27
    4f0e:	b0 a7       	std	Z+40, r27	; 0x28
    4f10:	2a c0       	rjmp	.+84     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4f12:	eb 81       	ldd	r30, Y+3	; 0x03
    4f14:	fc 81       	ldd	r31, Y+4	; 0x04
    4f16:	85 a1       	ldd	r24, Z+37	; 0x25
    4f18:	96 a1       	ldd	r25, Z+38	; 0x26
    4f1a:	a7 a1       	ldd	r26, Z+39	; 0x27
    4f1c:	b0 a5       	ldd	r27, Z+40	; 0x28
    4f1e:	01 96       	adiw	r24, 0x01	; 1
    4f20:	a1 1d       	adc	r26, r1
    4f22:	b1 1d       	adc	r27, r1
    4f24:	eb 81       	ldd	r30, Y+3	; 0x03
    4f26:	fc 81       	ldd	r31, Y+4	; 0x04
    4f28:	85 a3       	std	Z+37, r24	; 0x25
    4f2a:	96 a3       	std	Z+38, r25	; 0x26
    4f2c:	a7 a3       	std	Z+39, r26	; 0x27
    4f2e:	b0 a7       	std	Z+40, r27	; 0x28
    4f30:	1a c0       	rjmp	.+52     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4f32:	eb 81       	ldd	r30, Y+3	; 0x03
    4f34:	fc 81       	ldd	r31, Y+4	; 0x04
    4f36:	8f 81       	ldd	r24, Y+7	; 0x07
    4f38:	98 85       	ldd	r25, Y+8	; 0x08
    4f3a:	a9 85       	ldd	r26, Y+9	; 0x09
    4f3c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f3e:	85 a3       	std	Z+37, r24	; 0x25
    4f40:	96 a3       	std	Z+38, r25	; 0x26
    4f42:	a7 a3       	std	Z+39, r26	; 0x27
    4f44:	b0 a7       	std	Z+40, r27	; 0x28
    4f46:	0f c0       	rjmp	.+30     	; 0x4f66 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4f48:	89 81       	ldd	r24, Y+1	; 0x01
    4f4a:	82 30       	cpi	r24, 0x02	; 2
    4f4c:	59 f0       	breq	.+22     	; 0x4f64 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f50:	fc 81       	ldd	r31, Y+4	; 0x04
    4f52:	8f 81       	ldd	r24, Y+7	; 0x07
    4f54:	98 85       	ldd	r25, Y+8	; 0x08
    4f56:	a9 85       	ldd	r26, Y+9	; 0x09
    4f58:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f5a:	85 a3       	std	Z+37, r24	; 0x25
    4f5c:	96 a3       	std	Z+38, r25	; 0x26
    4f5e:	a7 a3       	std	Z+39, r26	; 0x27
    4f60:	b0 a7       	std	Z+40, r27	; 0x28
    4f62:	01 c0       	rjmp	.+2      	; 0x4f66 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f64:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f66:	89 81       	ldd	r24, Y+1	; 0x01
    4f68:	81 30       	cpi	r24, 0x01	; 1
    4f6a:	b9 f5       	brne	.+110    	; 0x4fda <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f70:	02 96       	adiw	r24, 0x02	; 2
    4f72:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4f76:	eb 81       	ldd	r30, Y+3	; 0x03
    4f78:	fc 81       	ldd	r31, Y+4	; 0x04
    4f7a:	96 89       	ldd	r25, Z+22	; 0x16
    4f7c:	80 91 94 06 	lds	r24, 0x0694
    4f80:	89 17       	cp	r24, r25
    4f82:	28 f4       	brcc	.+10     	; 0x4f8e <xTaskGenericNotify+0x152>
    4f84:	eb 81       	ldd	r30, Y+3	; 0x03
    4f86:	fc 81       	ldd	r31, Y+4	; 0x04
    4f88:	86 89       	ldd	r24, Z+22	; 0x16
    4f8a:	80 93 94 06 	sts	0x0694, r24
    4f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f90:	fc 81       	ldd	r31, Y+4	; 0x04
    4f92:	86 89       	ldd	r24, Z+22	; 0x16
    4f94:	28 2f       	mov	r18, r24
    4f96:	30 e0       	ldi	r19, 0x00	; 0
    4f98:	c9 01       	movw	r24, r18
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	88 0f       	add	r24, r24
    4fa0:	99 1f       	adc	r25, r25
    4fa2:	88 0f       	add	r24, r24
    4fa4:	99 1f       	adc	r25, r25
    4fa6:	82 0f       	add	r24, r18
    4fa8:	93 1f       	adc	r25, r19
    4faa:	ac 01       	movw	r20, r24
    4fac:	41 56       	subi	r20, 0x61	; 97
    4fae:	59 4f       	sbci	r21, 0xF9	; 249
    4fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4fb4:	9c 01       	movw	r18, r24
    4fb6:	2e 5f       	subi	r18, 0xFE	; 254
    4fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    4fba:	ca 01       	movw	r24, r20
    4fbc:	b9 01       	movw	r22, r18
    4fbe:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fc2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fc4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fc6:	96 89       	ldd	r25, Z+22	; 0x16
    4fc8:	e0 91 8e 06 	lds	r30, 0x068E
    4fcc:	f0 91 8f 06 	lds	r31, 0x068F
    4fd0:	86 89       	ldd	r24, Z+22	; 0x16
    4fd2:	89 17       	cp	r24, r25
    4fd4:	10 f4       	brcc	.+4      	; 0x4fda <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4fd6:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4fda:	0f 90       	pop	r0
    4fdc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4fde:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4fe0:	2f 96       	adiw	r28, 0x0f	; 15
    4fe2:	0f b6       	in	r0, 0x3f	; 63
    4fe4:	f8 94       	cli
    4fe6:	de bf       	out	0x3e, r29	; 62
    4fe8:	0f be       	out	0x3f, r0	; 63
    4fea:	cd bf       	out	0x3d, r28	; 61
    4fec:	cf 91       	pop	r28
    4fee:	df 91       	pop	r29
    4ff0:	1f 91       	pop	r17
    4ff2:	0f 91       	pop	r16
    4ff4:	08 95       	ret

00004ff6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4ff6:	ef 92       	push	r14
    4ff8:	ff 92       	push	r15
    4ffa:	0f 93       	push	r16
    4ffc:	1f 93       	push	r17
    4ffe:	df 93       	push	r29
    5000:	cf 93       	push	r28
    5002:	cd b7       	in	r28, 0x3d	; 61
    5004:	de b7       	in	r29, 0x3e	; 62
    5006:	62 97       	sbiw	r28, 0x12	; 18
    5008:	0f b6       	in	r0, 0x3f	; 63
    500a:	f8 94       	cli
    500c:	de bf       	out	0x3e, r29	; 62
    500e:	0f be       	out	0x3f, r0	; 63
    5010:	cd bf       	out	0x3d, r28	; 61
    5012:	9f 83       	std	Y+7, r25	; 0x07
    5014:	8e 83       	std	Y+6, r24	; 0x06
    5016:	48 87       	std	Y+8, r20	; 0x08
    5018:	59 87       	std	Y+9, r21	; 0x09
    501a:	6a 87       	std	Y+10, r22	; 0x0a
    501c:	7b 87       	std	Y+11, r23	; 0x0b
    501e:	2c 87       	std	Y+12, r18	; 0x0c
    5020:	1e 87       	std	Y+14, r17	; 0x0e
    5022:	0d 87       	std	Y+13, r16	; 0x0d
    5024:	f8 8a       	std	Y+16, r15	; 0x10
    5026:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5028:	81 e0       	ldi	r24, 0x01	; 1
    502a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    502c:	8e 81       	ldd	r24, Y+6	; 0x06
    502e:	9f 81       	ldd	r25, Y+7	; 0x07
    5030:	9d 83       	std	Y+5, r25	; 0x05
    5032:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5034:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5036:	8d 85       	ldd	r24, Y+13	; 0x0d
    5038:	9e 85       	ldd	r25, Y+14	; 0x0e
    503a:	00 97       	sbiw	r24, 0x00	; 0
    503c:	61 f0       	breq	.+24     	; 0x5056 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    503e:	ec 81       	ldd	r30, Y+4	; 0x04
    5040:	fd 81       	ldd	r31, Y+5	; 0x05
    5042:	85 a1       	ldd	r24, Z+37	; 0x25
    5044:	96 a1       	ldd	r25, Z+38	; 0x26
    5046:	a7 a1       	ldd	r26, Z+39	; 0x27
    5048:	b0 a5       	ldd	r27, Z+40	; 0x28
    504a:	ed 85       	ldd	r30, Y+13	; 0x0d
    504c:	fe 85       	ldd	r31, Y+14	; 0x0e
    504e:	80 83       	st	Z, r24
    5050:	91 83       	std	Z+1, r25	; 0x01
    5052:	a2 83       	std	Z+2, r26	; 0x02
    5054:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5056:	ec 81       	ldd	r30, Y+4	; 0x04
    5058:	fd 81       	ldd	r31, Y+5	; 0x05
    505a:	81 a5       	ldd	r24, Z+41	; 0x29
    505c:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    505e:	ec 81       	ldd	r30, Y+4	; 0x04
    5060:	fd 81       	ldd	r31, Y+5	; 0x05
    5062:	82 e0       	ldi	r24, 0x02	; 2
    5064:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    5066:	8c 85       	ldd	r24, Y+12	; 0x0c
    5068:	28 2f       	mov	r18, r24
    506a:	30 e0       	ldi	r19, 0x00	; 0
    506c:	3a 8b       	std	Y+18, r19	; 0x12
    506e:	29 8b       	std	Y+17, r18	; 0x11
    5070:	89 89       	ldd	r24, Y+17	; 0x11
    5072:	9a 89       	ldd	r25, Y+18	; 0x12
    5074:	82 30       	cpi	r24, 0x02	; 2
    5076:	91 05       	cpc	r25, r1
    5078:	59 f1       	breq	.+86     	; 0x50d0 <xTaskGenericNotifyFromISR+0xda>
    507a:	29 89       	ldd	r18, Y+17	; 0x11
    507c:	3a 89       	ldd	r19, Y+18	; 0x12
    507e:	23 30       	cpi	r18, 0x03	; 3
    5080:	31 05       	cpc	r19, r1
    5082:	34 f4       	brge	.+12     	; 0x5090 <xTaskGenericNotifyFromISR+0x9a>
    5084:	89 89       	ldd	r24, Y+17	; 0x11
    5086:	9a 89       	ldd	r25, Y+18	; 0x12
    5088:	81 30       	cpi	r24, 0x01	; 1
    508a:	91 05       	cpc	r25, r1
    508c:	61 f0       	breq	.+24     	; 0x50a6 <xTaskGenericNotifyFromISR+0xb0>
    508e:	4a c0       	rjmp	.+148    	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
    5090:	29 89       	ldd	r18, Y+17	; 0x11
    5092:	3a 89       	ldd	r19, Y+18	; 0x12
    5094:	23 30       	cpi	r18, 0x03	; 3
    5096:	31 05       	cpc	r19, r1
    5098:	59 f1       	breq	.+86     	; 0x50f0 <xTaskGenericNotifyFromISR+0xfa>
    509a:	89 89       	ldd	r24, Y+17	; 0x11
    509c:	9a 89       	ldd	r25, Y+18	; 0x12
    509e:	84 30       	cpi	r24, 0x04	; 4
    50a0:	91 05       	cpc	r25, r1
    50a2:	89 f1       	breq	.+98     	; 0x5106 <xTaskGenericNotifyFromISR+0x110>
    50a4:	3f c0       	rjmp	.+126    	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    50a6:	ec 81       	ldd	r30, Y+4	; 0x04
    50a8:	fd 81       	ldd	r31, Y+5	; 0x05
    50aa:	25 a1       	ldd	r18, Z+37	; 0x25
    50ac:	36 a1       	ldd	r19, Z+38	; 0x26
    50ae:	47 a1       	ldd	r20, Z+39	; 0x27
    50b0:	50 a5       	ldd	r21, Z+40	; 0x28
    50b2:	88 85       	ldd	r24, Y+8	; 0x08
    50b4:	99 85       	ldd	r25, Y+9	; 0x09
    50b6:	aa 85       	ldd	r26, Y+10	; 0x0a
    50b8:	bb 85       	ldd	r27, Y+11	; 0x0b
    50ba:	82 2b       	or	r24, r18
    50bc:	93 2b       	or	r25, r19
    50be:	a4 2b       	or	r26, r20
    50c0:	b5 2b       	or	r27, r21
    50c2:	ec 81       	ldd	r30, Y+4	; 0x04
    50c4:	fd 81       	ldd	r31, Y+5	; 0x05
    50c6:	85 a3       	std	Z+37, r24	; 0x25
    50c8:	96 a3       	std	Z+38, r25	; 0x26
    50ca:	a7 a3       	std	Z+39, r26	; 0x27
    50cc:	b0 a7       	std	Z+40, r27	; 0x28
    50ce:	2a c0       	rjmp	.+84     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    50d0:	ec 81       	ldd	r30, Y+4	; 0x04
    50d2:	fd 81       	ldd	r31, Y+5	; 0x05
    50d4:	85 a1       	ldd	r24, Z+37	; 0x25
    50d6:	96 a1       	ldd	r25, Z+38	; 0x26
    50d8:	a7 a1       	ldd	r26, Z+39	; 0x27
    50da:	b0 a5       	ldd	r27, Z+40	; 0x28
    50dc:	01 96       	adiw	r24, 0x01	; 1
    50de:	a1 1d       	adc	r26, r1
    50e0:	b1 1d       	adc	r27, r1
    50e2:	ec 81       	ldd	r30, Y+4	; 0x04
    50e4:	fd 81       	ldd	r31, Y+5	; 0x05
    50e6:	85 a3       	std	Z+37, r24	; 0x25
    50e8:	96 a3       	std	Z+38, r25	; 0x26
    50ea:	a7 a3       	std	Z+39, r26	; 0x27
    50ec:	b0 a7       	std	Z+40, r27	; 0x28
    50ee:	1a c0       	rjmp	.+52     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    50f0:	ec 81       	ldd	r30, Y+4	; 0x04
    50f2:	fd 81       	ldd	r31, Y+5	; 0x05
    50f4:	88 85       	ldd	r24, Y+8	; 0x08
    50f6:	99 85       	ldd	r25, Y+9	; 0x09
    50f8:	aa 85       	ldd	r26, Y+10	; 0x0a
    50fa:	bb 85       	ldd	r27, Y+11	; 0x0b
    50fc:	85 a3       	std	Z+37, r24	; 0x25
    50fe:	96 a3       	std	Z+38, r25	; 0x26
    5100:	a7 a3       	std	Z+39, r26	; 0x27
    5102:	b0 a7       	std	Z+40, r27	; 0x28
    5104:	0f c0       	rjmp	.+30     	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5106:	8b 81       	ldd	r24, Y+3	; 0x03
    5108:	82 30       	cpi	r24, 0x02	; 2
    510a:	59 f0       	breq	.+22     	; 0x5122 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    510c:	ec 81       	ldd	r30, Y+4	; 0x04
    510e:	fd 81       	ldd	r31, Y+5	; 0x05
    5110:	88 85       	ldd	r24, Y+8	; 0x08
    5112:	99 85       	ldd	r25, Y+9	; 0x09
    5114:	aa 85       	ldd	r26, Y+10	; 0x0a
    5116:	bb 85       	ldd	r27, Y+11	; 0x0b
    5118:	85 a3       	std	Z+37, r24	; 0x25
    511a:	96 a3       	std	Z+38, r25	; 0x26
    511c:	a7 a3       	std	Z+39, r26	; 0x27
    511e:	b0 a7       	std	Z+40, r27	; 0x28
    5120:	01 c0       	rjmp	.+2      	; 0x5124 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5122:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5124:	8b 81       	ldd	r24, Y+3	; 0x03
    5126:	81 30       	cpi	r24, 0x01	; 1
    5128:	09 f0       	breq	.+2      	; 0x512c <xTaskGenericNotifyFromISR+0x136>
    512a:	4f c0       	rjmp	.+158    	; 0x51ca <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    512c:	80 91 9e 06 	lds	r24, 0x069E
    5130:	88 23       	and	r24, r24
    5132:	61 f5       	brne	.+88     	; 0x518c <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5134:	8c 81       	ldd	r24, Y+4	; 0x04
    5136:	9d 81       	ldd	r25, Y+5	; 0x05
    5138:	02 96       	adiw	r24, 0x02	; 2
    513a:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    513e:	ec 81       	ldd	r30, Y+4	; 0x04
    5140:	fd 81       	ldd	r31, Y+5	; 0x05
    5142:	96 89       	ldd	r25, Z+22	; 0x16
    5144:	80 91 94 06 	lds	r24, 0x0694
    5148:	89 17       	cp	r24, r25
    514a:	28 f4       	brcc	.+10     	; 0x5156 <xTaskGenericNotifyFromISR+0x160>
    514c:	ec 81       	ldd	r30, Y+4	; 0x04
    514e:	fd 81       	ldd	r31, Y+5	; 0x05
    5150:	86 89       	ldd	r24, Z+22	; 0x16
    5152:	80 93 94 06 	sts	0x0694, r24
    5156:	ec 81       	ldd	r30, Y+4	; 0x04
    5158:	fd 81       	ldd	r31, Y+5	; 0x05
    515a:	86 89       	ldd	r24, Z+22	; 0x16
    515c:	28 2f       	mov	r18, r24
    515e:	30 e0       	ldi	r19, 0x00	; 0
    5160:	c9 01       	movw	r24, r18
    5162:	88 0f       	add	r24, r24
    5164:	99 1f       	adc	r25, r25
    5166:	88 0f       	add	r24, r24
    5168:	99 1f       	adc	r25, r25
    516a:	88 0f       	add	r24, r24
    516c:	99 1f       	adc	r25, r25
    516e:	82 0f       	add	r24, r18
    5170:	93 1f       	adc	r25, r19
    5172:	ac 01       	movw	r20, r24
    5174:	41 56       	subi	r20, 0x61	; 97
    5176:	59 4f       	sbci	r21, 0xF9	; 249
    5178:	8c 81       	ldd	r24, Y+4	; 0x04
    517a:	9d 81       	ldd	r25, Y+5	; 0x05
    517c:	9c 01       	movw	r18, r24
    517e:	2e 5f       	subi	r18, 0xFE	; 254
    5180:	3f 4f       	sbci	r19, 0xFF	; 255
    5182:	ca 01       	movw	r24, r20
    5184:	b9 01       	movw	r22, r18
    5186:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
    518a:	0a c0       	rjmp	.+20     	; 0x51a0 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    518c:	8c 81       	ldd	r24, Y+4	; 0x04
    518e:	9d 81       	ldd	r25, Y+5	; 0x05
    5190:	9c 01       	movw	r18, r24
    5192:	24 5f       	subi	r18, 0xF4	; 244
    5194:	3f 4f       	sbci	r19, 0xFF	; 255
    5196:	89 ed       	ldi	r24, 0xD9	; 217
    5198:	96 e0       	ldi	r25, 0x06	; 6
    519a:	b9 01       	movw	r22, r18
    519c:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    51a0:	ec 81       	ldd	r30, Y+4	; 0x04
    51a2:	fd 81       	ldd	r31, Y+5	; 0x05
    51a4:	96 89       	ldd	r25, Z+22	; 0x16
    51a6:	e0 91 8e 06 	lds	r30, 0x068E
    51aa:	f0 91 8f 06 	lds	r31, 0x068F
    51ae:	86 89       	ldd	r24, Z+22	; 0x16
    51b0:	89 17       	cp	r24, r25
    51b2:	58 f4       	brcc	.+22     	; 0x51ca <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    51b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    51b6:	98 89       	ldd	r25, Y+16	; 0x10
    51b8:	00 97       	sbiw	r24, 0x00	; 0
    51ba:	21 f0       	breq	.+8      	; 0x51c4 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    51bc:	ef 85       	ldd	r30, Y+15	; 0x0f
    51be:	f8 89       	ldd	r31, Y+16	; 0x10
    51c0:	81 e0       	ldi	r24, 0x01	; 1
    51c2:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    51c4:	81 e0       	ldi	r24, 0x01	; 1
    51c6:	80 93 97 06 	sts	0x0697, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    51ca:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    51cc:	62 96       	adiw	r28, 0x12	; 18
    51ce:	0f b6       	in	r0, 0x3f	; 63
    51d0:	f8 94       	cli
    51d2:	de bf       	out	0x3e, r29	; 62
    51d4:	0f be       	out	0x3f, r0	; 63
    51d6:	cd bf       	out	0x3d, r28	; 61
    51d8:	cf 91       	pop	r28
    51da:	df 91       	pop	r29
    51dc:	1f 91       	pop	r17
    51de:	0f 91       	pop	r16
    51e0:	ff 90       	pop	r15
    51e2:	ef 90       	pop	r14
    51e4:	08 95       	ret

000051e6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    51e6:	df 93       	push	r29
    51e8:	cf 93       	push	r28
    51ea:	cd b7       	in	r28, 0x3d	; 61
    51ec:	de b7       	in	r29, 0x3e	; 62
    51ee:	28 97       	sbiw	r28, 0x08	; 8
    51f0:	0f b6       	in	r0, 0x3f	; 63
    51f2:	f8 94       	cli
    51f4:	de bf       	out	0x3e, r29	; 62
    51f6:	0f be       	out	0x3f, r0	; 63
    51f8:	cd bf       	out	0x3d, r28	; 61
    51fa:	9e 83       	std	Y+6, r25	; 0x06
    51fc:	8d 83       	std	Y+5, r24	; 0x05
    51fe:	78 87       	std	Y+8, r23	; 0x08
    5200:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5202:	8d 81       	ldd	r24, Y+5	; 0x05
    5204:	9e 81       	ldd	r25, Y+6	; 0x06
    5206:	9c 83       	std	Y+4, r25	; 0x04
    5208:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    520a:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    520c:	eb 81       	ldd	r30, Y+3	; 0x03
    520e:	fc 81       	ldd	r31, Y+4	; 0x04
    5210:	81 a5       	ldd	r24, Z+41	; 0x29
    5212:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5214:	eb 81       	ldd	r30, Y+3	; 0x03
    5216:	fc 81       	ldd	r31, Y+4	; 0x04
    5218:	82 e0       	ldi	r24, 0x02	; 2
    521a:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    521c:	eb 81       	ldd	r30, Y+3	; 0x03
    521e:	fc 81       	ldd	r31, Y+4	; 0x04
    5220:	85 a1       	ldd	r24, Z+37	; 0x25
    5222:	96 a1       	ldd	r25, Z+38	; 0x26
    5224:	a7 a1       	ldd	r26, Z+39	; 0x27
    5226:	b0 a5       	ldd	r27, Z+40	; 0x28
    5228:	01 96       	adiw	r24, 0x01	; 1
    522a:	a1 1d       	adc	r26, r1
    522c:	b1 1d       	adc	r27, r1
    522e:	eb 81       	ldd	r30, Y+3	; 0x03
    5230:	fc 81       	ldd	r31, Y+4	; 0x04
    5232:	85 a3       	std	Z+37, r24	; 0x25
    5234:	96 a3       	std	Z+38, r25	; 0x26
    5236:	a7 a3       	std	Z+39, r26	; 0x27
    5238:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    523a:	8a 81       	ldd	r24, Y+2	; 0x02
    523c:	81 30       	cpi	r24, 0x01	; 1
    523e:	09 f0       	breq	.+2      	; 0x5242 <vTaskNotifyGiveFromISR+0x5c>
    5240:	4f c0       	rjmp	.+158    	; 0x52e0 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5242:	80 91 9e 06 	lds	r24, 0x069E
    5246:	88 23       	and	r24, r24
    5248:	61 f5       	brne	.+88     	; 0x52a2 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    524a:	8b 81       	ldd	r24, Y+3	; 0x03
    524c:	9c 81       	ldd	r25, Y+4	; 0x04
    524e:	02 96       	adiw	r24, 0x02	; 2
    5250:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5254:	eb 81       	ldd	r30, Y+3	; 0x03
    5256:	fc 81       	ldd	r31, Y+4	; 0x04
    5258:	96 89       	ldd	r25, Z+22	; 0x16
    525a:	80 91 94 06 	lds	r24, 0x0694
    525e:	89 17       	cp	r24, r25
    5260:	28 f4       	brcc	.+10     	; 0x526c <vTaskNotifyGiveFromISR+0x86>
    5262:	eb 81       	ldd	r30, Y+3	; 0x03
    5264:	fc 81       	ldd	r31, Y+4	; 0x04
    5266:	86 89       	ldd	r24, Z+22	; 0x16
    5268:	80 93 94 06 	sts	0x0694, r24
    526c:	eb 81       	ldd	r30, Y+3	; 0x03
    526e:	fc 81       	ldd	r31, Y+4	; 0x04
    5270:	86 89       	ldd	r24, Z+22	; 0x16
    5272:	28 2f       	mov	r18, r24
    5274:	30 e0       	ldi	r19, 0x00	; 0
    5276:	c9 01       	movw	r24, r18
    5278:	88 0f       	add	r24, r24
    527a:	99 1f       	adc	r25, r25
    527c:	88 0f       	add	r24, r24
    527e:	99 1f       	adc	r25, r25
    5280:	88 0f       	add	r24, r24
    5282:	99 1f       	adc	r25, r25
    5284:	82 0f       	add	r24, r18
    5286:	93 1f       	adc	r25, r19
    5288:	ac 01       	movw	r20, r24
    528a:	41 56       	subi	r20, 0x61	; 97
    528c:	59 4f       	sbci	r21, 0xF9	; 249
    528e:	8b 81       	ldd	r24, Y+3	; 0x03
    5290:	9c 81       	ldd	r25, Y+4	; 0x04
    5292:	9c 01       	movw	r18, r24
    5294:	2e 5f       	subi	r18, 0xFE	; 254
    5296:	3f 4f       	sbci	r19, 0xFF	; 255
    5298:	ca 01       	movw	r24, r20
    529a:	b9 01       	movw	r22, r18
    529c:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
    52a0:	0a c0       	rjmp	.+20     	; 0x52b6 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52a2:	8b 81       	ldd	r24, Y+3	; 0x03
    52a4:	9c 81       	ldd	r25, Y+4	; 0x04
    52a6:	9c 01       	movw	r18, r24
    52a8:	24 5f       	subi	r18, 0xF4	; 244
    52aa:	3f 4f       	sbci	r19, 0xFF	; 255
    52ac:	89 ed       	ldi	r24, 0xD9	; 217
    52ae:	96 e0       	ldi	r25, 0x06	; 6
    52b0:	b9 01       	movw	r22, r18
    52b2:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52b6:	eb 81       	ldd	r30, Y+3	; 0x03
    52b8:	fc 81       	ldd	r31, Y+4	; 0x04
    52ba:	96 89       	ldd	r25, Z+22	; 0x16
    52bc:	e0 91 8e 06 	lds	r30, 0x068E
    52c0:	f0 91 8f 06 	lds	r31, 0x068F
    52c4:	86 89       	ldd	r24, Z+22	; 0x16
    52c6:	89 17       	cp	r24, r25
    52c8:	58 f4       	brcc	.+22     	; 0x52e0 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    52ca:	8f 81       	ldd	r24, Y+7	; 0x07
    52cc:	98 85       	ldd	r25, Y+8	; 0x08
    52ce:	00 97       	sbiw	r24, 0x00	; 0
    52d0:	21 f0       	breq	.+8      	; 0x52da <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    52d2:	ef 81       	ldd	r30, Y+7	; 0x07
    52d4:	f8 85       	ldd	r31, Y+8	; 0x08
    52d6:	81 e0       	ldi	r24, 0x01	; 1
    52d8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    52da:	81 e0       	ldi	r24, 0x01	; 1
    52dc:	80 93 97 06 	sts	0x0697, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    52e0:	28 96       	adiw	r28, 0x08	; 8
    52e2:	0f b6       	in	r0, 0x3f	; 63
    52e4:	f8 94       	cli
    52e6:	de bf       	out	0x3e, r29	; 62
    52e8:	0f be       	out	0x3f, r0	; 63
    52ea:	cd bf       	out	0x3d, r28	; 61
    52ec:	cf 91       	pop	r28
    52ee:	df 91       	pop	r29
    52f0:	08 95       	ret

000052f2 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    52f2:	df 93       	push	r29
    52f4:	cf 93       	push	r28
    52f6:	cd b7       	in	r28, 0x3d	; 61
    52f8:	de b7       	in	r29, 0x3e	; 62
    52fa:	27 97       	sbiw	r28, 0x07	; 7
    52fc:	0f b6       	in	r0, 0x3f	; 63
    52fe:	f8 94       	cli
    5300:	de bf       	out	0x3e, r29	; 62
    5302:	0f be       	out	0x3f, r0	; 63
    5304:	cd bf       	out	0x3d, r28	; 61
    5306:	9d 83       	std	Y+5, r25	; 0x05
    5308:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    530a:	8c 81       	ldd	r24, Y+4	; 0x04
    530c:	9d 81       	ldd	r25, Y+5	; 0x05
    530e:	00 97       	sbiw	r24, 0x00	; 0
    5310:	39 f4       	brne	.+14     	; 0x5320 <xTaskNotifyStateClear+0x2e>
    5312:	80 91 8e 06 	lds	r24, 0x068E
    5316:	90 91 8f 06 	lds	r25, 0x068F
    531a:	9f 83       	std	Y+7, r25	; 0x07
    531c:	8e 83       	std	Y+6, r24	; 0x06
    531e:	04 c0       	rjmp	.+8      	; 0x5328 <xTaskNotifyStateClear+0x36>
    5320:	8c 81       	ldd	r24, Y+4	; 0x04
    5322:	9d 81       	ldd	r25, Y+5	; 0x05
    5324:	9f 83       	std	Y+7, r25	; 0x07
    5326:	8e 83       	std	Y+6, r24	; 0x06
    5328:	8e 81       	ldd	r24, Y+6	; 0x06
    532a:	9f 81       	ldd	r25, Y+7	; 0x07
    532c:	9b 83       	std	Y+3, r25	; 0x03
    532e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5330:	0f b6       	in	r0, 0x3f	; 63
    5332:	f8 94       	cli
    5334:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5336:	ea 81       	ldd	r30, Y+2	; 0x02
    5338:	fb 81       	ldd	r31, Y+3	; 0x03
    533a:	81 a5       	ldd	r24, Z+41	; 0x29
    533c:	82 30       	cpi	r24, 0x02	; 2
    533e:	31 f4       	brne	.+12     	; 0x534c <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5340:	ea 81       	ldd	r30, Y+2	; 0x02
    5342:	fb 81       	ldd	r31, Y+3	; 0x03
    5344:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    5346:	81 e0       	ldi	r24, 0x01	; 1
    5348:	89 83       	std	Y+1, r24	; 0x01
    534a:	01 c0       	rjmp	.+2      	; 0x534e <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    534c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    534e:	0f 90       	pop	r0
    5350:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5352:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5354:	27 96       	adiw	r28, 0x07	; 7
    5356:	0f b6       	in	r0, 0x3f	; 63
    5358:	f8 94       	cli
    535a:	de bf       	out	0x3e, r29	; 62
    535c:	0f be       	out	0x3f, r0	; 63
    535e:	cd bf       	out	0x3d, r28	; 61
    5360:	cf 91       	pop	r28
    5362:	df 91       	pop	r29
    5364:	08 95       	ret

00005366 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5366:	df 93       	push	r29
    5368:	cf 93       	push	r28
    536a:	cd b7       	in	r28, 0x3d	; 61
    536c:	de b7       	in	r29, 0x3e	; 62
    536e:	27 97       	sbiw	r28, 0x07	; 7
    5370:	0f b6       	in	r0, 0x3f	; 63
    5372:	f8 94       	cli
    5374:	de bf       	out	0x3e, r29	; 62
    5376:	0f be       	out	0x3f, r0	; 63
    5378:	cd bf       	out	0x3d, r28	; 61
    537a:	9e 83       	std	Y+6, r25	; 0x06
    537c:	8d 83       	std	Y+5, r24	; 0x05
    537e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5380:	80 91 92 06 	lds	r24, 0x0692
    5384:	90 91 93 06 	lds	r25, 0x0693
    5388:	9a 83       	std	Y+2, r25	; 0x02
    538a:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    538c:	80 91 8e 06 	lds	r24, 0x068E
    5390:	90 91 8f 06 	lds	r25, 0x068F
    5394:	02 96       	adiw	r24, 0x02	; 2
    5396:	0e 94 23 0b 	call	0x1646	; 0x1646 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    539a:	8d 81       	ldd	r24, Y+5	; 0x05
    539c:	9e 81       	ldd	r25, Y+6	; 0x06
    539e:	2f ef       	ldi	r18, 0xFF	; 255
    53a0:	8f 3f       	cpi	r24, 0xFF	; 255
    53a2:	92 07       	cpc	r25, r18
    53a4:	81 f4       	brne	.+32     	; 0x53c6 <prvAddCurrentTaskToDelayedList+0x60>
    53a6:	8f 81       	ldd	r24, Y+7	; 0x07
    53a8:	88 23       	and	r24, r24
    53aa:	69 f0       	breq	.+26     	; 0x53c6 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53ac:	80 91 8e 06 	lds	r24, 0x068E
    53b0:	90 91 8f 06 	lds	r25, 0x068F
    53b4:	9c 01       	movw	r18, r24
    53b6:	2e 5f       	subi	r18, 0xFE	; 254
    53b8:	3f 4f       	sbci	r19, 0xFF	; 255
    53ba:	8b ee       	ldi	r24, 0xEB	; 235
    53bc:	96 e0       	ldi	r25, 0x06	; 6
    53be:	b9 01       	movw	r22, r18
    53c0:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <vListInsertEnd>
    53c4:	43 c0       	rjmp	.+134    	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    53c6:	29 81       	ldd	r18, Y+1	; 0x01
    53c8:	3a 81       	ldd	r19, Y+2	; 0x02
    53ca:	8d 81       	ldd	r24, Y+5	; 0x05
    53cc:	9e 81       	ldd	r25, Y+6	; 0x06
    53ce:	82 0f       	add	r24, r18
    53d0:	93 1f       	adc	r25, r19
    53d2:	9c 83       	std	Y+4, r25	; 0x04
    53d4:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    53d6:	e0 91 8e 06 	lds	r30, 0x068E
    53da:	f0 91 8f 06 	lds	r31, 0x068F
    53de:	8b 81       	ldd	r24, Y+3	; 0x03
    53e0:	9c 81       	ldd	r25, Y+4	; 0x04
    53e2:	93 83       	std	Z+3, r25	; 0x03
    53e4:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    53e6:	2b 81       	ldd	r18, Y+3	; 0x03
    53e8:	3c 81       	ldd	r19, Y+4	; 0x04
    53ea:	89 81       	ldd	r24, Y+1	; 0x01
    53ec:	9a 81       	ldd	r25, Y+2	; 0x02
    53ee:	28 17       	cp	r18, r24
    53f0:	39 07       	cpc	r19, r25
    53f2:	70 f4       	brcc	.+28     	; 0x5410 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53f4:	80 91 d7 06 	lds	r24, 0x06D7
    53f8:	90 91 d8 06 	lds	r25, 0x06D8
    53fc:	20 91 8e 06 	lds	r18, 0x068E
    5400:	30 91 8f 06 	lds	r19, 0x068F
    5404:	2e 5f       	subi	r18, 0xFE	; 254
    5406:	3f 4f       	sbci	r19, 0xFF	; 255
    5408:	b9 01       	movw	r22, r18
    540a:	0e 94 b7 0a 	call	0x156e	; 0x156e <vListInsert>
    540e:	1e c0       	rjmp	.+60     	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5410:	40 91 d5 06 	lds	r20, 0x06D5
    5414:	50 91 d6 06 	lds	r21, 0x06D6
    5418:	80 91 8e 06 	lds	r24, 0x068E
    541c:	90 91 8f 06 	lds	r25, 0x068F
    5420:	9c 01       	movw	r18, r24
    5422:	2e 5f       	subi	r18, 0xFE	; 254
    5424:	3f 4f       	sbci	r19, 0xFF	; 255
    5426:	ca 01       	movw	r24, r20
    5428:	b9 01       	movw	r22, r18
    542a:	0e 94 b7 0a 	call	0x156e	; 0x156e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    542e:	20 91 9a 06 	lds	r18, 0x069A
    5432:	30 91 9b 06 	lds	r19, 0x069B
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	9c 81       	ldd	r25, Y+4	; 0x04
    543a:	82 17       	cp	r24, r18
    543c:	93 07       	cpc	r25, r19
    543e:	30 f4       	brcc	.+12     	; 0x544c <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5440:	8b 81       	ldd	r24, Y+3	; 0x03
    5442:	9c 81       	ldd	r25, Y+4	; 0x04
    5444:	90 93 9b 06 	sts	0x069B, r25
    5448:	80 93 9a 06 	sts	0x069A, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    544c:	27 96       	adiw	r28, 0x07	; 7
    544e:	0f b6       	in	r0, 0x3f	; 63
    5450:	f8 94       	cli
    5452:	de bf       	out	0x3e, r29	; 62
    5454:	0f be       	out	0x3f, r0	; 63
    5456:	cd bf       	out	0x3d, r28	; 61
    5458:	cf 91       	pop	r28
    545a:	df 91       	pop	r29
    545c:	08 95       	ret

0000545e <memcpy>:
    545e:	fb 01       	movw	r30, r22
    5460:	dc 01       	movw	r26, r24
    5462:	02 c0       	rjmp	.+4      	; 0x5468 <memcpy+0xa>
    5464:	01 90       	ld	r0, Z+
    5466:	0d 92       	st	X+, r0
    5468:	41 50       	subi	r20, 0x01	; 1
    546a:	50 40       	sbci	r21, 0x00	; 0
    546c:	d8 f7       	brcc	.-10     	; 0x5464 <memcpy+0x6>
    546e:	08 95       	ret

00005470 <memset>:
    5470:	dc 01       	movw	r26, r24
    5472:	01 c0       	rjmp	.+2      	; 0x5476 <memset+0x6>
    5474:	6d 93       	st	X+, r22
    5476:	41 50       	subi	r20, 0x01	; 1
    5478:	50 40       	sbci	r21, 0x00	; 0
    547a:	e0 f7       	brcc	.-8      	; 0x5474 <memset+0x4>
    547c:	08 95       	ret

0000547e <_exit>:
    547e:	f8 94       	cli

00005480 <__stop_program>:
    5480:	ff cf       	rjmp	.-2      	; 0x5480 <__stop_program>
