
FreeRTOS_SprintsChallenges_Sprint2_UserStory2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005a88  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000078  00800060  00005a88  00005b1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000066b  008000d8  008000d8  00005b94  2**0
                  ALLOC
  3 .stab         0000948c  00000000  00000000  00005b94  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004c42  00000000  00000000  0000f020  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f2 0e 	jmp	0x1de4	; 0x1de4 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e8       	ldi	r30, 0x88	; 136
      68:	fa e5       	ldi	r31, 0x5A	; 90
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3d       	cpi	r26, 0xD8	; 216
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 ed       	ldi	r26, 0xD8	; 216
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 34       	cpi	r26, 0x43	; 67
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 04 0c 	call	0x1808	; 0x1808 <main>
      8a:	0c 94 42 2d 	jmp	0x5a84	; 0x5a84 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	Queue_PushButton_A = xQueueCreate( 3 , sizeof(uint8) );
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <xQueueGenericCreate>
     5a4:	90 93 dd 00 	sts	0x00DD, r25
     5a8:	80 93 dc 00 	sts	0x00DC, r24
	Queue_PushButton_B = xQueueCreate( 3 , sizeof(uint8) );
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <xQueueGenericCreate>
     5b6:	90 93 df 00 	sts	0x00DF, r25
     5ba:	80 93 de 00 	sts	0x00DE, r24

	/*Create Mutex to make one Push Button is pressed*/
	FirstButtonPressed = xSemaphoreCreateMutex();
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	0e 94 2b 10 	call	0x2056	; 0x2056 <xQueueCreateMutex>
     5c4:	90 93 42 07 	sts	0x0742, r25
     5c8:	80 93 41 07 	sts	0x0741, r24



	/*Create 5 Tasks*/
	/*Task for initialize Hardware components*/
	xTaskCreate(All_Hardware_Init_Task  , "Init_Hw_Tasks" , configMINIMAL_STACK_SIZE ,
     5cc:	8b e3       	ldi	r24, 0x3B	; 59
     5ce:	93 e0       	ldi	r25, 0x03	; 3
     5d0:	20 e6       	ldi	r18, 0x60	; 96
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	e8 ed       	ldi	r30, 0xD8	; 216
     5d6:	f0 e0       	ldi	r31, 0x00	; 0
     5d8:	b9 01       	movw	r22, r18
     5da:	46 e9       	ldi	r20, 0x96	; 150
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	20 e0       	ldi	r18, 0x00	; 0
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	06 e0       	ldi	r16, 0x06	; 6
     5e4:	7f 01       	movw	r14, r30
     5e6:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (6 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);

	/*Task of Push Button 1*/
	xTaskCreate(PushButtonA_Task  , "PushButtonA_Task" , configMINIMAL_STACK_SIZE ,
     5ea:	81 e5       	ldi	r24, 0x51	; 81
     5ec:	93 e0       	ldi	r25, 0x03	; 3
     5ee:	2e e6       	ldi	r18, 0x6E	; 110
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	b9 01       	movw	r22, r18
     5f4:	46 e9       	ldi	r20, 0x96	; 150
     5f6:	50 e0       	ldi	r21, 0x00	; 0
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	04 e0       	ldi	r16, 0x04	; 4
     5fe:	ee 24       	eor	r14, r14
     600:	ff 24       	eor	r15, r15
     602:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);

	/*Task of Push Button 2*/
	xTaskCreate(PushButtonB_Task  , "PushButtonB_Task" , configMINIMAL_STACK_SIZE ,
     606:	80 ed       	ldi	r24, 0xD0	; 208
     608:	93 e0       	ldi	r25, 0x03	; 3
     60a:	2f e7       	ldi	r18, 0x7F	; 127
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	46 e9       	ldi	r20, 0x96	; 150
     612:	50 e0       	ldi	r21, 0x00	; 0
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	03 e0       	ldi	r16, 0x03	; 3
     61a:	ee 24       	eor	r14, r14
     61c:	ff 24       	eor	r15, r15
     61e:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);

	/*Task for Led*/
	xTaskCreate(LED_Task  , "LED_Task" , 50 ,
     622:	8a e5       	ldi	r24, 0x5A	; 90
     624:	95 e0       	ldi	r25, 0x05	; 5
     626:	20 e9       	ldi	r18, 0x90	; 144
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	b9 01       	movw	r22, r18
     62c:	42 e3       	ldi	r20, 0x32	; 50
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	02 e0       	ldi	r16, 0x02	; 2
     636:	ee 24       	eor	r14, r14
     638:	ff 24       	eor	r15, r15
     63a:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);

	/*Task for LCD*/
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     63e:	8f e4       	ldi	r24, 0x4F	; 79
     640:	94 e0       	ldi	r25, 0x04	; 4
     642:	29 e9       	ldi	r18, 0x99	; 153
     644:	30 e0       	ldi	r19, 0x00	; 0
     646:	b9 01       	movw	r22, r18
     648:	46 e9       	ldi	r20, 0x96	; 150
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	20 e0       	ldi	r18, 0x00	; 0
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	01 e0       	ldi	r16, 0x01	; 1
     652:	ee 24       	eor	r14, r14
     654:	ff 24       	eor	r15, r15
     656:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);

	/*Suspend this task from the system*/
	vTaskSuspend( InitTask_Flag);
     65a:	80 91 da 00 	lds	r24, 0x00DA
     65e:	90 91 db 00 	lds	r25, 0x00DB
     662:	0e 94 9c 20 	call	0x4138	; 0x4138 <vTaskSuspend>
}
     666:	0f 90       	pop	r0
     668:	0f 90       	pop	r0
     66a:	cf 91       	pop	r28
     66c:	df 91       	pop	r29
     66e:	0f 91       	pop	r16
     670:	ff 90       	pop	r15
     672:	ef 90       	pop	r14
     674:	08 95       	ret

00000676 <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     676:	df 93       	push	r29
     678:	cf 93       	push	r28
     67a:	00 d0       	rcall	.+0      	; 0x67c <All_Hardware_Init_Task+0x6>
     67c:	cd b7       	in	r28, 0x3d	; 61
     67e:	de b7       	in	r29, 0x3e	; 62
     680:	9a 83       	std	Y+2, r25	; 0x02
     682:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		/*initialize Hardware components*/
		PushButton_Init();
     684:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     688:	0e 94 45 09 	call	0x128a	; 0x128a <LCD_init>
		DIO_SetPinDirection(DIO_PIN13,OUTPUT);
     68c:	8d e0       	ldi	r24, 0x0D	; 13
     68e:	61 e0       	ldi	r22, 0x01	; 1
     690:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

		/*Suspend this task from the system*/
		vTaskSuspend( AllHardwareInit_Flag);
     694:	80 91 d8 00 	lds	r24, 0x00D8
     698:	90 91 d9 00 	lds	r25, 0x00D9
     69c:	0e 94 9c 20 	call	0x4138	; 0x4138 <vTaskSuspend>
     6a0:	f1 cf       	rjmp	.-30     	; 0x684 <All_Hardware_Init_Task+0xe>

000006a2 <PushButtonA_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonA_Task(void * a_Task_ptr)
{
     6a2:	df 93       	push	r29
     6a4:	cf 93       	push	r28
     6a6:	00 d0       	rcall	.+0      	; 0x6a8 <PushButtonA_Task+0x6>
     6a8:	00 d0       	rcall	.+0      	; 0x6aa <PushButtonA_Task+0x8>
     6aa:	0f 92       	push	r0
     6ac:	cd b7       	in	r28, 0x3d	; 61
     6ae:	de b7       	in	r29, 0x3e	; 62
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(50);
     6b4:	82 e3       	ldi	r24, 0x32	; 50
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     6c0:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     6c2:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==2)
     6c4:	8a 81       	ldd	r24, Y+2	; 0x02
     6c6:	88 23       	and	r24, r24
     6c8:	79 f4       	brne	.+30     	; 0x6e8 <PushButtonA_Task+0x46>
     6ca:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6ce:	82 30       	cpi	r24, 0x02	; 2
     6d0:	59 f4       	brne	.+22     	; 0x6e8 <PushButtonA_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     6d2:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6d6:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	8f 5f       	subi	r24, 0xFF	; 255
     6dc:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6de:	8a e0       	ldi	r24, 0x0A	; 10
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     6e6:	ee cf       	rjmp	.-36     	; 0x6c4 <PushButtonA_Task+0x22>
		}
		else if(Debouncing == 1)
     6e8:	8a 81       	ldd	r24, Y+2	; 0x02
     6ea:	81 30       	cpi	r24, 0x01	; 1
     6ec:	39 f5       	brne	.+78     	; 0x73c <PushButtonA_Task+0x9a>
		{
			/*Check if other push Button is pressed and if not take Mutex*/
			if (xSemaphoreTake(FirstButtonPressed , 10))
     6ee:	80 91 41 07 	lds	r24, 0x0741
     6f2:	90 91 42 07 	lds	r25, 0x0742
     6f6:	6a e0       	ldi	r22, 0x0A	; 10
     6f8:	70 e0       	ldi	r23, 0x00	; 0
     6fa:	0e 94 4b 12 	call	0x2496	; 0x2496 <xQueueSemaphoreTake>
     6fe:	88 23       	and	r24, r24
     700:	09 f3       	breq	.-62     	; 0x6c4 <PushButtonA_Task+0x22>
			{
				SendData = 1;
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	8b 83       	std	Y+3, r24	; 0x03
     706:	11 c0       	rjmp	.+34     	; 0x72a <PushButtonA_Task+0x88>
				/*check if button is still pressed after de_bouncing time*/
				while(OldPressedValue == Buttons_getPressedButton())
				{
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 2);
     708:	80 91 dc 00 	lds	r24, 0x00DC
     70c:	90 91 dd 00 	lds	r25, 0x00DD
     710:	9e 01       	movw	r18, r28
     712:	2d 5f       	subi	r18, 0xFD	; 253
     714:	3f 4f       	sbci	r19, 0xFF	; 255
     716:	b9 01       	movw	r22, r18
     718:	42 e0       	ldi	r20, 0x02	; 2
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
					vTaskDelay(20);
     722:	84 e1       	ldi	r24, 0x14	; 20
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
			/*Check if other push Button is pressed and if not take Mutex*/
			if (xSemaphoreTake(FirstButtonPressed , 10))
			{
				SendData = 1;
				/*check if button is still pressed after de_bouncing time*/
				while(OldPressedValue == Buttons_getPressedButton())
     72a:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     72e:	98 2f       	mov	r25, r24
     730:	89 81       	ldd	r24, Y+1	; 0x01
     732:	98 17       	cp	r25, r24
     734:	49 f3       	breq	.-46     	; 0x708 <PushButtonA_Task+0x66>
				{
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 2);
					vTaskDelay(20);
				}
				Debouncing = 2;
     736:	82 e0       	ldi	r24, 0x02	; 2
     738:	8a 83       	std	Y+2, r24	; 0x02
     73a:	c4 cf       	rjmp	.-120    	; 0x6c4 <PushButtonA_Task+0x22>
			}
		}
		/*chech if button is released*/
		else if(Debouncing == 2)
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	82 30       	cpi	r24, 0x02	; 2
     740:	d9 f4       	brne	.+54     	; 0x778 <PushButtonA_Task+0xd6>
		{
			/*released Mutex*/
			xSemaphoreGive(FirstButtonPressed);
     742:	80 91 41 07 	lds	r24, 0x0741
     746:	90 91 42 07 	lds	r25, 0x0742
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	70 e0       	ldi	r23, 0x00	; 0
     74e:	40 e0       	ldi	r20, 0x00	; 0
     750:	50 e0       	ldi	r21, 0x00	; 0
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			SendData = 0;
     758:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_A , &SendData , 2);
     75a:	80 91 dc 00 	lds	r24, 0x00DC
     75e:	90 91 dd 00 	lds	r25, 0x00DD
     762:	9e 01       	movw	r18, r28
     764:	2d 5f       	subi	r18, 0xFD	; 253
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	42 e0       	ldi	r20, 0x02	; 2
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	20 e0       	ldi	r18, 0x00	; 0
     770:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			Debouncing = 0;
     774:	1a 82       	std	Y+2, r1	; 0x02
     776:	a6 cf       	rjmp	.-180    	; 0x6c4 <PushButtonA_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     778:	83 e0       	ldi	r24, 0x03	; 3
     77a:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_A , &SendData , 2);
     77c:	80 91 dc 00 	lds	r24, 0x00DC
     780:	90 91 dd 00 	lds	r25, 0x00DD
     784:	9e 01       	movw	r18, r28
     786:	2d 5f       	subi	r18, 0xFD	; 253
     788:	3f 4f       	sbci	r19, 0xFF	; 255
     78a:	b9 01       	movw	r22, r18
     78c:	42 e0       	ldi	r20, 0x02	; 2
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	20 e0       	ldi	r18, 0x00	; 0
     792:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			vTaskDelay(20);
     796:	84 e1       	ldi	r24, 0x14	; 20
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     79e:	92 cf       	rjmp	.-220    	; 0x6c4 <PushButtonA_Task+0x22>

000007a0 <PushButtonB_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonB_Task(void * a_Task_ptr)
{
     7a0:	df 93       	push	r29
     7a2:	cf 93       	push	r28
     7a4:	00 d0       	rcall	.+0      	; 0x7a6 <PushButtonB_Task+0x6>
     7a6:	00 d0       	rcall	.+0      	; 0x7a8 <PushButtonB_Task+0x8>
     7a8:	0f 92       	push	r0
     7aa:	cd b7       	in	r28, 0x3d	; 61
     7ac:	de b7       	in	r29, 0x3e	; 62
     7ae:	9d 83       	std	Y+5, r25	; 0x05
     7b0:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(60);
     7b2:	8c e3       	ldi	r24, 0x3C	; 60
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     7be:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     7c0:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     7c2:	8a 81       	ldd	r24, Y+2	; 0x02
     7c4:	88 23       	and	r24, r24
     7c6:	79 f4       	brne	.+30     	; 0x7e6 <PushButtonB_Task+0x46>
     7c8:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7cc:	81 30       	cpi	r24, 0x01	; 1
     7ce:	59 f4       	brne	.+22     	; 0x7e6 <PushButtonB_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     7d0:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7d4:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     7d6:	8a 81       	ldd	r24, Y+2	; 0x02
     7d8:	8f 5f       	subi	r24, 0xFF	; 255
     7da:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     7dc:	8a e0       	ldi	r24, 0x0A	; 10
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     7e4:	ee cf       	rjmp	.-36     	; 0x7c2 <PushButtonB_Task+0x22>
		}
		else if(Debouncing == 1)
     7e6:	8a 81       	ldd	r24, Y+2	; 0x02
     7e8:	81 30       	cpi	r24, 0x01	; 1
     7ea:	39 f5       	brne	.+78     	; 0x83a <PushButtonB_Task+0x9a>
		{
			/*Check if other push Button is pressed and if not take Mutex*/
			if (xSemaphoreTake(FirstButtonPressed , 10))
     7ec:	80 91 41 07 	lds	r24, 0x0741
     7f0:	90 91 42 07 	lds	r25, 0x0742
     7f4:	6a e0       	ldi	r22, 0x0A	; 10
     7f6:	70 e0       	ldi	r23, 0x00	; 0
     7f8:	0e 94 4b 12 	call	0x2496	; 0x2496 <xQueueSemaphoreTake>
     7fc:	88 23       	and	r24, r24
     7fe:	09 f3       	breq	.-62     	; 0x7c2 <PushButtonB_Task+0x22>
			{
				SendData = 1;
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	11 c0       	rjmp	.+34     	; 0x828 <PushButtonB_Task+0x88>
				/*check if button is still pressed after de_bouncing time*/
				while(OldPressedValue == Buttons_getPressedButton())
				{
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 2);
     806:	80 91 de 00 	lds	r24, 0x00DE
     80a:	90 91 df 00 	lds	r25, 0x00DF
     80e:	9e 01       	movw	r18, r28
     810:	2d 5f       	subi	r18, 0xFD	; 253
     812:	3f 4f       	sbci	r19, 0xFF	; 255
     814:	b9 01       	movw	r22, r18
     816:	42 e0       	ldi	r20, 0x02	; 2
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	20 e0       	ldi	r18, 0x00	; 0
     81c:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
					vTaskDelay(20);
     820:	84 e1       	ldi	r24, 0x14	; 20
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
			/*Check if other push Button is pressed and if not take Mutex*/
			if (xSemaphoreTake(FirstButtonPressed , 10))
			{
				SendData = 1;
				/*check if button is still pressed after de_bouncing time*/
				while(OldPressedValue == Buttons_getPressedButton())
     828:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     82c:	98 2f       	mov	r25, r24
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	98 17       	cp	r25, r24
     832:	49 f3       	breq	.-46     	; 0x806 <PushButtonB_Task+0x66>
				{
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 2);
					vTaskDelay(20);
				}
				Debouncing = 2;
     834:	82 e0       	ldi	r24, 0x02	; 2
     836:	8a 83       	std	Y+2, r24	; 0x02
     838:	c4 cf       	rjmp	.-120    	; 0x7c2 <PushButtonB_Task+0x22>
			}
		}
		/*chech if button is released*/
		else if(Debouncing == 2)
     83a:	8a 81       	ldd	r24, Y+2	; 0x02
     83c:	82 30       	cpi	r24, 0x02	; 2
     83e:	d9 f4       	brne	.+54     	; 0x876 <__stack+0x17>
		{
			/*released Mutex*/
			xSemaphoreGive(FirstButtonPressed);
     840:	80 91 41 07 	lds	r24, 0x0741
     844:	90 91 42 07 	lds	r25, 0x0742
     848:	60 e0       	ldi	r22, 0x00	; 0
     84a:	70 e0       	ldi	r23, 0x00	; 0
     84c:	40 e0       	ldi	r20, 0x00	; 0
     84e:	50 e0       	ldi	r21, 0x00	; 0
     850:	20 e0       	ldi	r18, 0x00	; 0
     852:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			SendData = 0;
     856:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_B , &SendData , 2);
     858:	80 91 de 00 	lds	r24, 0x00DE
     85c:	90 91 df 00 	lds	r25, 0x00DF
     860:	9e 01       	movw	r18, r28
     862:	2d 5f       	subi	r18, 0xFD	; 253
     864:	3f 4f       	sbci	r19, 0xFF	; 255
     866:	b9 01       	movw	r22, r18
     868:	42 e0       	ldi	r20, 0x02	; 2
     86a:	50 e0       	ldi	r21, 0x00	; 0
     86c:	20 e0       	ldi	r18, 0x00	; 0
     86e:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			Debouncing = 0;
     872:	1a 82       	std	Y+2, r1	; 0x02
     874:	a6 cf       	rjmp	.-180    	; 0x7c2 <PushButtonB_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     876:	83 e0       	ldi	r24, 0x03	; 3
     878:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_B , &SendData , 2);
     87a:	80 91 de 00 	lds	r24, 0x00DE
     87e:	90 91 df 00 	lds	r25, 0x00DF
     882:	9e 01       	movw	r18, r28
     884:	2d 5f       	subi	r18, 0xFD	; 253
     886:	3f 4f       	sbci	r19, 0xFF	; 255
     888:	b9 01       	movw	r22, r18
     88a:	42 e0       	ldi	r20, 0x02	; 2
     88c:	50 e0       	ldi	r21, 0x00	; 0
     88e:	20 e0       	ldi	r18, 0x00	; 0
     890:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
			vTaskDelay(20);
     894:	84 e1       	ldi	r24, 0x14	; 20
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     89c:	92 cf       	rjmp	.-220    	; 0x7c2 <PushButtonB_Task+0x22>

0000089e <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     89e:	df 93       	push	r29
     8a0:	cf 93       	push	r28
     8a2:	cd b7       	in	r28, 0x3d	; 61
     8a4:	de b7       	in	r29, 0x3e	; 62
     8a6:	c0 54       	subi	r28, 0x40	; 64
     8a8:	d0 40       	sbci	r29, 0x00	; 0
     8aa:	0f b6       	in	r0, 0x3f	; 63
     8ac:	f8 94       	cli
     8ae:	de bf       	out	0x3e, r29	; 62
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	cd bf       	out	0x3d, r28	; 61
     8b4:	9c a7       	std	Y+44, r25	; 0x2c
     8b6:	8b a7       	std	Y+43, r24	; 0x2b
	vTaskDelay(100);
     8b8:	84 e6       	ldi	r24, 0x64	; 100
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	/*received data from Push Button A Task to display button state on LCD*/
	uint8 PushButton_A_Task_Data = 0;
     8c0:	1a 82       	std	Y+2, r1	; 0x02

	/*received message from Push Button B Task to display button state on LCD*/
	uint8 PushButton_B_Task_Data = 0;
     8c2:	1b 82       	std	Y+3, r1	; 0x03

	/*LED States & Buttons Strings*/
	uint8 Flag = 0;
     8c4:	19 82       	std	Y+1, r1	; 0x01
	uint8 ButtonA[] = "By BUTTON A";
     8c6:	ce 01       	movw	r24, r28
     8c8:	04 96       	adiw	r24, 0x04	; 4
     8ca:	9e a7       	std	Y+46, r25	; 0x2e
     8cc:	8d a7       	std	Y+45, r24	; 0x2d
     8ce:	e2 ea       	ldi	r30, 0xA2	; 162
     8d0:	f0 e0       	ldi	r31, 0x00	; 0
     8d2:	f8 ab       	std	Y+48, r31	; 0x30
     8d4:	ef a7       	std	Y+47, r30	; 0x2f
     8d6:	fc e0       	ldi	r31, 0x0C	; 12
     8d8:	f9 ab       	std	Y+49, r31	; 0x31
     8da:	ef a5       	ldd	r30, Y+47	; 0x2f
     8dc:	f8 a9       	ldd	r31, Y+48	; 0x30
     8de:	00 80       	ld	r0, Z
     8e0:	8f a5       	ldd	r24, Y+47	; 0x2f
     8e2:	98 a9       	ldd	r25, Y+48	; 0x30
     8e4:	01 96       	adiw	r24, 0x01	; 1
     8e6:	98 ab       	std	Y+48, r25	; 0x30
     8e8:	8f a7       	std	Y+47, r24	; 0x2f
     8ea:	ed a5       	ldd	r30, Y+45	; 0x2d
     8ec:	fe a5       	ldd	r31, Y+46	; 0x2e
     8ee:	00 82       	st	Z, r0
     8f0:	8d a5       	ldd	r24, Y+45	; 0x2d
     8f2:	9e a5       	ldd	r25, Y+46	; 0x2e
     8f4:	01 96       	adiw	r24, 0x01	; 1
     8f6:	9e a7       	std	Y+46, r25	; 0x2e
     8f8:	8d a7       	std	Y+45, r24	; 0x2d
     8fa:	99 a9       	ldd	r25, Y+49	; 0x31
     8fc:	91 50       	subi	r25, 0x01	; 1
     8fe:	99 ab       	std	Y+49, r25	; 0x31
     900:	e9 a9       	ldd	r30, Y+49	; 0x31
     902:	ee 23       	and	r30, r30
     904:	51 f7       	brne	.-44     	; 0x8da <LCD_Task+0x3c>
	uint8 ButtonB[] = "By BUTTON B";
     906:	ce 01       	movw	r24, r28
     908:	40 96       	adiw	r24, 0x10	; 16
     90a:	9b ab       	std	Y+51, r25	; 0x33
     90c:	8a ab       	std	Y+50, r24	; 0x32
     90e:	ee ea       	ldi	r30, 0xAE	; 174
     910:	f0 e0       	ldi	r31, 0x00	; 0
     912:	fd ab       	std	Y+53, r31	; 0x35
     914:	ec ab       	std	Y+52, r30	; 0x34
     916:	fc e0       	ldi	r31, 0x0C	; 12
     918:	fe ab       	std	Y+54, r31	; 0x36
     91a:	ec a9       	ldd	r30, Y+52	; 0x34
     91c:	fd a9       	ldd	r31, Y+53	; 0x35
     91e:	00 80       	ld	r0, Z
     920:	8c a9       	ldd	r24, Y+52	; 0x34
     922:	9d a9       	ldd	r25, Y+53	; 0x35
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	9d ab       	std	Y+53, r25	; 0x35
     928:	8c ab       	std	Y+52, r24	; 0x34
     92a:	ea a9       	ldd	r30, Y+50	; 0x32
     92c:	fb a9       	ldd	r31, Y+51	; 0x33
     92e:	00 82       	st	Z, r0
     930:	8a a9       	ldd	r24, Y+50	; 0x32
     932:	9b a9       	ldd	r25, Y+51	; 0x33
     934:	01 96       	adiw	r24, 0x01	; 1
     936:	9b ab       	std	Y+51, r25	; 0x33
     938:	8a ab       	std	Y+50, r24	; 0x32
     93a:	9e a9       	ldd	r25, Y+54	; 0x36
     93c:	91 50       	subi	r25, 0x01	; 1
     93e:	9e ab       	std	Y+54, r25	; 0x36
     940:	ee a9       	ldd	r30, Y+54	; 0x36
     942:	ee 23       	and	r30, r30
     944:	51 f7       	brne	.-44     	; 0x91a <LCD_Task+0x7c>
	uint8 LED_ON[] = "LED ON";
     946:	ce 01       	movw	r24, r28
     948:	4c 96       	adiw	r24, 0x1c	; 28
     94a:	98 af       	std	Y+56, r25	; 0x38
     94c:	8f ab       	std	Y+55, r24	; 0x37
     94e:	ea eb       	ldi	r30, 0xBA	; 186
     950:	f0 e0       	ldi	r31, 0x00	; 0
     952:	fa af       	std	Y+58, r31	; 0x3a
     954:	e9 af       	std	Y+57, r30	; 0x39
     956:	f7 e0       	ldi	r31, 0x07	; 7
     958:	fb af       	std	Y+59, r31	; 0x3b
     95a:	e9 ad       	ldd	r30, Y+57	; 0x39
     95c:	fa ad       	ldd	r31, Y+58	; 0x3a
     95e:	00 80       	ld	r0, Z
     960:	89 ad       	ldd	r24, Y+57	; 0x39
     962:	9a ad       	ldd	r25, Y+58	; 0x3a
     964:	01 96       	adiw	r24, 0x01	; 1
     966:	9a af       	std	Y+58, r25	; 0x3a
     968:	89 af       	std	Y+57, r24	; 0x39
     96a:	ef a9       	ldd	r30, Y+55	; 0x37
     96c:	f8 ad       	ldd	r31, Y+56	; 0x38
     96e:	00 82       	st	Z, r0
     970:	8f a9       	ldd	r24, Y+55	; 0x37
     972:	98 ad       	ldd	r25, Y+56	; 0x38
     974:	01 96       	adiw	r24, 0x01	; 1
     976:	98 af       	std	Y+56, r25	; 0x38
     978:	8f ab       	std	Y+55, r24	; 0x37
     97a:	9b ad       	ldd	r25, Y+59	; 0x3b
     97c:	91 50       	subi	r25, 0x01	; 1
     97e:	9b af       	std	Y+59, r25	; 0x3b
     980:	eb ad       	ldd	r30, Y+59	; 0x3b
     982:	ee 23       	and	r30, r30
     984:	51 f7       	brne	.-44     	; 0x95a <LCD_Task+0xbc>
	uint8 LED_OFF[] = "LED OFF";
     986:	ce 01       	movw	r24, r28
     988:	83 96       	adiw	r24, 0x23	; 35
     98a:	9d af       	std	Y+61, r25	; 0x3d
     98c:	8c af       	std	Y+60, r24	; 0x3c
     98e:	e1 ec       	ldi	r30, 0xC1	; 193
     990:	f0 e0       	ldi	r31, 0x00	; 0
     992:	ff af       	std	Y+63, r31	; 0x3f
     994:	ee af       	std	Y+62, r30	; 0x3e
     996:	f8 e0       	ldi	r31, 0x08	; 8
     998:	21 96       	adiw	r28, 0x01	; 1
     99a:	ff af       	std	Y+63, r31	; 0x3f
     99c:	21 97       	sbiw	r28, 0x01	; 1
     99e:	ee ad       	ldd	r30, Y+62	; 0x3e
     9a0:	ff ad       	ldd	r31, Y+63	; 0x3f
     9a2:	00 80       	ld	r0, Z
     9a4:	8e ad       	ldd	r24, Y+62	; 0x3e
     9a6:	9f ad       	ldd	r25, Y+63	; 0x3f
     9a8:	01 96       	adiw	r24, 0x01	; 1
     9aa:	9f af       	std	Y+63, r25	; 0x3f
     9ac:	8e af       	std	Y+62, r24	; 0x3e
     9ae:	ec ad       	ldd	r30, Y+60	; 0x3c
     9b0:	fd ad       	ldd	r31, Y+61	; 0x3d
     9b2:	00 82       	st	Z, r0
     9b4:	8c ad       	ldd	r24, Y+60	; 0x3c
     9b6:	9d ad       	ldd	r25, Y+61	; 0x3d
     9b8:	01 96       	adiw	r24, 0x01	; 1
     9ba:	9d af       	std	Y+61, r25	; 0x3d
     9bc:	8c af       	std	Y+60, r24	; 0x3c
     9be:	21 96       	adiw	r28, 0x01	; 1
     9c0:	9f ad       	ldd	r25, Y+63	; 0x3f
     9c2:	21 97       	sbiw	r28, 0x01	; 1
     9c4:	91 50       	subi	r25, 0x01	; 1
     9c6:	21 96       	adiw	r28, 0x01	; 1
     9c8:	9f af       	std	Y+63, r25	; 0x3f
     9ca:	21 97       	sbiw	r28, 0x01	; 1
     9cc:	21 96       	adiw	r28, 0x01	; 1
     9ce:	ef ad       	ldd	r30, Y+63	; 0x3f
     9d0:	21 97       	sbiw	r28, 0x01	; 1
     9d2:	ee 23       	and	r30, r30
     9d4:	21 f7       	brne	.-56     	; 0x99e <LCD_Task+0x100>

	while(1)
	{
		/*receive messages from other tasks by queues*/
		xQueueReceive(Queue_PushButton_A , &PushButton_A_Task_Data , 1);
     9d6:	80 91 dc 00 	lds	r24, 0x00DC
     9da:	90 91 dd 00 	lds	r25, 0x00DD
     9de:	9e 01       	movw	r18, r28
     9e0:	2e 5f       	subi	r18, 0xFE	; 254
     9e2:	3f 4f       	sbci	r19, 0xFF	; 255
     9e4:	b9 01       	movw	r22, r18
     9e6:	41 e0       	ldi	r20, 0x01	; 1
     9e8:	50 e0       	ldi	r21, 0x00	; 0
     9ea:	0e 94 a0 11 	call	0x2340	; 0x2340 <xQueueReceive>
		xQueueReceive(Queue_PushButton_B , &PushButton_B_Task_Data , 1);
     9ee:	80 91 de 00 	lds	r24, 0x00DE
     9f2:	90 91 df 00 	lds	r25, 0x00DF
     9f6:	9e 01       	movw	r18, r28
     9f8:	2d 5f       	subi	r18, 0xFD	; 253
     9fa:	3f 4f       	sbci	r19, 0xFF	; 255
     9fc:	b9 01       	movw	r22, r18
     9fe:	41 e0       	ldi	r20, 0x01	; 1
     a00:	50 e0       	ldi	r21, 0x00	; 0
     a02:	0e 94 a0 11 	call	0x2340	; 0x2340 <xQueueReceive>

		/*Check if Button A was pressed*/
		if(PushButton_A_Task_Data == 1)
     a06:	8a 81       	ldd	r24, Y+2	; 0x02
     a08:	81 30       	cpi	r24, 0x01	; 1
     a0a:	f1 f4       	brne	.+60     	; 0xa48 <LCD_Task+0x1aa>
		{
			if(Flag == 0)
     a0c:	89 81       	ldd	r24, Y+1	; 0x01
     a0e:	88 23       	and	r24, r24
     a10:	29 f4       	brne	.+10     	; 0xa1c <LCD_Task+0x17e>
			{
				LCD_clearScreen();
     a12:	0e 94 c4 0a 	call	0x1588	; 0x1588 <LCD_clearScreen>
				Flag = 1;
     a16:	81 e0       	ldi	r24, 0x01	; 1
     a18:	89 83       	std	Y+1, r24	; 0x01
     a1a:	47 c0       	rjmp	.+142    	; 0xaaa <LCD_Task+0x20c>
			}
			else if(Flag == 1)
     a1c:	89 81       	ldd	r24, Y+1	; 0x01
     a1e:	81 30       	cpi	r24, 0x01	; 1
     a20:	09 f0       	breq	.+2      	; 0xa24 <LCD_Task+0x186>
     a22:	43 c0       	rjmp	.+134    	; 0xaaa <LCD_Task+0x20c>
			{
				LCD_displayStringRowColumn(0 , 0 ,LED_ON);
     a24:	9e 01       	movw	r18, r28
     a26:	24 5e       	subi	r18, 0xE4	; 228
     a28:	3f 4f       	sbci	r19, 0xFF	; 255
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	60 e0       	ldi	r22, 0x00	; 0
     a2e:	a9 01       	movw	r20, r18
     a30:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_displayStringRowColumn>
				LCD_displayStringRowColumn(1 , 5 , ButtonA);
     a34:	9e 01       	movw	r18, r28
     a36:	2c 5f       	subi	r18, 0xFC	; 252
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	65 e0       	ldi	r22, 0x05	; 5
     a3e:	a9 01       	movw	r20, r18
     a40:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_displayStringRowColumn>
				PushButton_A_Task_Data = 0;
     a44:	1a 82       	std	Y+2, r1	; 0x02
     a46:	31 c0       	rjmp	.+98     	; 0xaaa <LCD_Task+0x20c>
			{
				/*Do nothing*/
			}
		}
		/*Check if Button B was pressed*/
		else if(PushButton_B_Task_Data == 1)
     a48:	8b 81       	ldd	r24, Y+3	; 0x03
     a4a:	81 30       	cpi	r24, 0x01	; 1
     a4c:	e9 f4       	brne	.+58     	; 0xa88 <LCD_Task+0x1ea>
		{
			if(Flag == 0)
     a4e:	89 81       	ldd	r24, Y+1	; 0x01
     a50:	88 23       	and	r24, r24
     a52:	29 f4       	brne	.+10     	; 0xa5e <LCD_Task+0x1c0>
			{
				LCD_clearScreen();
     a54:	0e 94 c4 0a 	call	0x1588	; 0x1588 <LCD_clearScreen>
				Flag = 2;
     a58:	82 e0       	ldi	r24, 0x02	; 2
     a5a:	89 83       	std	Y+1, r24	; 0x01
     a5c:	26 c0       	rjmp	.+76     	; 0xaaa <LCD_Task+0x20c>
			}
			else if(Flag == 2)
     a5e:	89 81       	ldd	r24, Y+1	; 0x01
     a60:	82 30       	cpi	r24, 0x02	; 2
     a62:	19 f5       	brne	.+70     	; 0xaaa <LCD_Task+0x20c>
			{
				LCD_displayStringRowColumn(0 , 0 ,LED_ON);
     a64:	9e 01       	movw	r18, r28
     a66:	24 5e       	subi	r18, 0xE4	; 228
     a68:	3f 4f       	sbci	r19, 0xFF	; 255
     a6a:	80 e0       	ldi	r24, 0x00	; 0
     a6c:	60 e0       	ldi	r22, 0x00	; 0
     a6e:	a9 01       	movw	r20, r18
     a70:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_displayStringRowColumn>
				LCD_displayStringRowColumn(1 , 5 ,ButtonB);
     a74:	9e 01       	movw	r18, r28
     a76:	20 5f       	subi	r18, 0xF0	; 240
     a78:	3f 4f       	sbci	r19, 0xFF	; 255
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	65 e0       	ldi	r22, 0x05	; 5
     a7e:	a9 01       	movw	r20, r18
     a80:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_displayStringRowColumn>
				PushButton_B_Task_Data = 0;
     a84:	1b 82       	std	Y+3, r1	; 0x03
     a86:	11 c0       	rjmp	.+34     	; 0xaaa <LCD_Task+0x20c>
			}
		}
		/*check if No Button was pressed*/
		else
		{
			if((Flag == 1) || (Flag == 2))
     a88:	89 81       	ldd	r24, Y+1	; 0x01
     a8a:	81 30       	cpi	r24, 0x01	; 1
     a8c:	19 f0       	breq	.+6      	; 0xa94 <LCD_Task+0x1f6>
     a8e:	89 81       	ldd	r24, Y+1	; 0x01
     a90:	82 30       	cpi	r24, 0x02	; 2
     a92:	59 f4       	brne	.+22     	; 0xaaa <LCD_Task+0x20c>
			{
				LCD_clearScreen();
     a94:	0e 94 c4 0a 	call	0x1588	; 0x1588 <LCD_clearScreen>
				LCD_displayStringRowColumn(0 , 0 ,LED_OFF);
     a98:	9e 01       	movw	r18, r28
     a9a:	2d 5d       	subi	r18, 0xDD	; 221
     a9c:	3f 4f       	sbci	r19, 0xFF	; 255
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	60 e0       	ldi	r22, 0x00	; 0
     aa2:	a9 01       	movw	r20, r18
     aa4:	0e 94 ab 0a 	call	0x1556	; 0x1556 <LCD_displayStringRowColumn>
				Flag = 0;
     aa8:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		vTaskDelay(20);
     aaa:	84 e1       	ldi	r24, 0x14	; 20
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     ab2:	91 cf       	rjmp	.-222    	; 0x9d6 <LCD_Task+0x138>

00000ab4 <LED_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LED_Task(void * a_Task_ptr)
{
     ab4:	df 93       	push	r29
     ab6:	cf 93       	push	r28
     ab8:	00 d0       	rcall	.+0      	; 0xaba <LED_Task+0x6>
     aba:	cd b7       	in	r28, 0x3d	; 61
     abc:	de b7       	in	r29, 0x3e	; 62
     abe:	9a 83       	std	Y+2, r25	; 0x02
     ac0:	89 83       	std	Y+1, r24	; 0x01


	while(1)
	{
		/* check if any Buttons were pressed by take Mutex*/
		if (xSemaphoreTake(FirstButtonPressed , 1))
     ac2:	80 91 41 07 	lds	r24, 0x0741
     ac6:	90 91 42 07 	lds	r25, 0x0742
     aca:	61 e0       	ldi	r22, 0x01	; 1
     acc:	70 e0       	ldi	r23, 0x00	; 0
     ace:	0e 94 4b 12 	call	0x2496	; 0x2496 <xQueueSemaphoreTake>
     ad2:	88 23       	and	r24, r24
     ad4:	81 f0       	breq	.+32     	; 0xaf6 <LED_Task+0x42>
		{
			/*LED Off*/
			DIO_WritePin(DIO_PIN13 , LOW);
     ad6:	8d e0       	ldi	r24, 0x0D	; 13
     ad8:	60 e0       	ldi	r22, 0x00	; 0
     ada:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>

			/*release Mutex*/
			xSemaphoreGive(FirstButtonPressed);
     ade:	80 91 41 07 	lds	r24, 0x0741
     ae2:	90 91 42 07 	lds	r25, 0x0742
     ae6:	60 e0       	ldi	r22, 0x00	; 0
     ae8:	70 e0       	ldi	r23, 0x00	; 0
     aea:	40 e0       	ldi	r20, 0x00	; 0
     aec:	50 e0       	ldi	r21, 0x00	; 0
     aee:	20 e0       	ldi	r18, 0x00	; 0
     af0:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
     af4:	04 c0       	rjmp	.+8      	; 0xafe <LED_Task+0x4a>
		}
		else
		{
			/*LED On*/
			DIO_WritePin(DIO_PIN13 , HIGH);
     af6:	8d e0       	ldi	r24, 0x0D	; 13
     af8:	61 e0       	ldi	r22, 0x01	; 1
     afa:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
		}
		vTaskDelay(10);
     afe:	8a e0       	ldi	r24, 0x0A	; 10
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
     b06:	dd cf       	rjmp	.-70     	; 0xac2 <LED_Task+0xe>

00000b08 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     b08:	df 93       	push	r29
     b0a:	cf 93       	push	r28
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <xEventGroupCreate+0x6>
     b0e:	cd b7       	in	r28, 0x3d	; 61
     b10:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     b12:	8b e0       	ldi	r24, 0x0B	; 11
     b14:	90 e0       	ldi	r25, 0x00	; 0
     b16:	0e 94 c9 08 	call	0x1192	; 0x1192 <pvPortMalloc>
     b1a:	9a 83       	std	Y+2, r25	; 0x02
     b1c:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     b1e:	89 81       	ldd	r24, Y+1	; 0x01
     b20:	9a 81       	ldd	r25, Y+2	; 0x02
     b22:	00 97       	sbiw	r24, 0x00	; 0
     b24:	49 f0       	breq	.+18     	; 0xb38 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     b26:	e9 81       	ldd	r30, Y+1	; 0x01
     b28:	fa 81       	ldd	r31, Y+2	; 0x02
     b2a:	11 82       	std	Z+1, r1	; 0x01
     b2c:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     b2e:	89 81       	ldd	r24, Y+1	; 0x01
     b30:	9a 81       	ldd	r25, Y+2	; 0x02
     b32:	02 96       	adiw	r24, 0x02	; 2
     b34:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     b38:	89 81       	ldd	r24, Y+1	; 0x01
     b3a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     b3c:	0f 90       	pop	r0
     b3e:	0f 90       	pop	r0
     b40:	cf 91       	pop	r28
     b42:	df 91       	pop	r29
     b44:	08 95       	ret

00000b46 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	60 97       	sbiw	r28, 0x10	; 16
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	9a 87       	std	Y+10, r25	; 0x0a
     b5c:	89 87       	std	Y+9, r24	; 0x09
     b5e:	7c 87       	std	Y+12, r23	; 0x0c
     b60:	6b 87       	std	Y+11, r22	; 0x0b
     b62:	5e 87       	std	Y+14, r21	; 0x0e
     b64:	4d 87       	std	Y+13, r20	; 0x0d
     b66:	38 8b       	std	Y+16, r19	; 0x10
     b68:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     b6a:	89 85       	ldd	r24, Y+9	; 0x09
     b6c:	9a 85       	ldd	r25, Y+10	; 0x0a
     b6e:	9c 83       	std	Y+4, r25	; 0x04
     b70:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     b72:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     b74:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     b78:	eb 81       	ldd	r30, Y+3	; 0x03
     b7a:	fc 81       	ldd	r31, Y+4	; 0x04
     b7c:	80 81       	ld	r24, Z
     b7e:	91 81       	ldd	r25, Z+1	; 0x01
     b80:	98 87       	std	Y+8, r25	; 0x08
     b82:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     b84:	89 85       	ldd	r24, Y+9	; 0x09
     b86:	9a 85       	ldd	r25, Y+10	; 0x0a
     b88:	2b 85       	ldd	r18, Y+11	; 0x0b
     b8a:	3c 85       	ldd	r19, Y+12	; 0x0c
     b8c:	b9 01       	movw	r22, r18
     b8e:	0e 94 7a 07 	call	0xef4	; 0xef4 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     b92:	2f 81       	ldd	r18, Y+7	; 0x07
     b94:	38 85       	ldd	r19, Y+8	; 0x08
     b96:	8b 85       	ldd	r24, Y+11	; 0x0b
     b98:	9c 85       	ldd	r25, Y+12	; 0x0c
     b9a:	28 2b       	or	r18, r24
     b9c:	39 2b       	or	r19, r25
     b9e:	8d 85       	ldd	r24, Y+13	; 0x0d
     ba0:	9e 85       	ldd	r25, Y+14	; 0x0e
     ba2:	28 23       	and	r18, r24
     ba4:	39 23       	and	r19, r25
     ba6:	8d 85       	ldd	r24, Y+13	; 0x0d
     ba8:	9e 85       	ldd	r25, Y+14	; 0x0e
     baa:	28 17       	cp	r18, r24
     bac:	39 07       	cpc	r19, r25
     bae:	c9 f4       	brne	.+50     	; 0xbe2 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     bb0:	2f 81       	ldd	r18, Y+7	; 0x07
     bb2:	38 85       	ldd	r19, Y+8	; 0x08
     bb4:	8b 85       	ldd	r24, Y+11	; 0x0b
     bb6:	9c 85       	ldd	r25, Y+12	; 0x0c
     bb8:	82 2b       	or	r24, r18
     bba:	93 2b       	or	r25, r19
     bbc:	9e 83       	std	Y+6, r25	; 0x06
     bbe:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     bc0:	eb 81       	ldd	r30, Y+3	; 0x03
     bc2:	fc 81       	ldd	r31, Y+4	; 0x04
     bc4:	20 81       	ld	r18, Z
     bc6:	31 81       	ldd	r19, Z+1	; 0x01
     bc8:	8d 85       	ldd	r24, Y+13	; 0x0d
     bca:	9e 85       	ldd	r25, Y+14	; 0x0e
     bcc:	80 95       	com	r24
     bce:	90 95       	com	r25
     bd0:	82 23       	and	r24, r18
     bd2:	93 23       	and	r25, r19
     bd4:	eb 81       	ldd	r30, Y+3	; 0x03
     bd6:	fc 81       	ldd	r31, Y+4	; 0x04
     bd8:	91 83       	std	Z+1, r25	; 0x01
     bda:	80 83       	st	Z, r24

			xTicksToWait = 0;
     bdc:	18 8a       	std	Y+16, r1	; 0x10
     bde:	1f 86       	std	Y+15, r1	; 0x0f
     be0:	1e c0       	rjmp	.+60     	; 0xc1e <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     be2:	8f 85       	ldd	r24, Y+15	; 0x0f
     be4:	98 89       	ldd	r25, Y+16	; 0x10
     be6:	00 97       	sbiw	r24, 0x00	; 0
     be8:	91 f0       	breq	.+36     	; 0xc0e <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	bc 01       	movw	r22, r24
     bf0:	6e 5f       	subi	r22, 0xFE	; 254
     bf2:	7f 4f       	sbci	r23, 0xFF	; 255
     bf4:	8d 85       	ldd	r24, Y+13	; 0x0d
     bf6:	9e 85       	ldd	r25, Y+14	; 0x0e
     bf8:	9c 01       	movw	r18, r24
     bfa:	35 60       	ori	r19, 0x05	; 5
     bfc:	4f 85       	ldd	r20, Y+15	; 0x0f
     bfe:	58 89       	ldd	r21, Y+16	; 0x10
     c00:	cb 01       	movw	r24, r22
     c02:	b9 01       	movw	r22, r18
     c04:	0e 94 b7 24 	call	0x496e	; 0x496e <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     c08:	1e 82       	std	Y+6, r1	; 0x06
     c0a:	1d 82       	std	Y+5, r1	; 0x05
     c0c:	08 c0       	rjmp	.+16     	; 0xc1e <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     c0e:	eb 81       	ldd	r30, Y+3	; 0x03
     c10:	fc 81       	ldd	r31, Y+4	; 0x04
     c12:	80 81       	ld	r24, Z
     c14:	91 81       	ldd	r25, Z+1	; 0x01
     c16:	9e 83       	std	Y+6, r25	; 0x06
     c18:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     c1e:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
     c22:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     c24:	8f 85       	ldd	r24, Y+15	; 0x0f
     c26:	98 89       	ldd	r25, Y+16	; 0x10
     c28:	00 97       	sbiw	r24, 0x00	; 0
     c2a:	09 f4       	brne	.+2      	; 0xc2e <xEventGroupSync+0xe8>
     c2c:	3a c0       	rjmp	.+116    	; 0xca2 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     c2e:	8a 81       	ldd	r24, Y+2	; 0x02
     c30:	88 23       	and	r24, r24
     c32:	11 f4       	brne	.+4      	; 0xc38 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     c34:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     c38:	0e 94 cf 28 	call	0x519e	; 0x519e <uxTaskResetEventItemValue>
     c3c:	9e 83       	std	Y+6, r25	; 0x06
     c3e:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     c40:	8d 81       	ldd	r24, Y+5	; 0x05
     c42:	9e 81       	ldd	r25, Y+6	; 0x06
     c44:	80 70       	andi	r24, 0x00	; 0
     c46:	92 70       	andi	r25, 0x02	; 2
     c48:	00 97       	sbiw	r24, 0x00	; 0
     c4a:	31 f5       	brne	.+76     	; 0xc98 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     c4c:	0f b6       	in	r0, 0x3f	; 63
     c4e:	f8 94       	cli
     c50:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     c52:	eb 81       	ldd	r30, Y+3	; 0x03
     c54:	fc 81       	ldd	r31, Y+4	; 0x04
     c56:	80 81       	ld	r24, Z
     c58:	91 81       	ldd	r25, Z+1	; 0x01
     c5a:	9e 83       	std	Y+6, r25	; 0x06
     c5c:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     c5e:	2d 81       	ldd	r18, Y+5	; 0x05
     c60:	3e 81       	ldd	r19, Y+6	; 0x06
     c62:	8d 85       	ldd	r24, Y+13	; 0x0d
     c64:	9e 85       	ldd	r25, Y+14	; 0x0e
     c66:	28 23       	and	r18, r24
     c68:	39 23       	and	r19, r25
     c6a:	8d 85       	ldd	r24, Y+13	; 0x0d
     c6c:	9e 85       	ldd	r25, Y+14	; 0x0e
     c6e:	28 17       	cp	r18, r24
     c70:	39 07       	cpc	r19, r25
     c72:	71 f4       	brne	.+28     	; 0xc90 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     c74:	eb 81       	ldd	r30, Y+3	; 0x03
     c76:	fc 81       	ldd	r31, Y+4	; 0x04
     c78:	20 81       	ld	r18, Z
     c7a:	31 81       	ldd	r19, Z+1	; 0x01
     c7c:	8d 85       	ldd	r24, Y+13	; 0x0d
     c7e:	9e 85       	ldd	r25, Y+14	; 0x0e
     c80:	80 95       	com	r24
     c82:	90 95       	com	r25
     c84:	82 23       	and	r24, r18
     c86:	93 23       	and	r25, r19
     c88:	eb 81       	ldd	r30, Y+3	; 0x03
     c8a:	fc 81       	ldd	r31, Y+4	; 0x04
     c8c:	91 83       	std	Z+1, r25	; 0x01
     c8e:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     c90:	0f 90       	pop	r0
     c92:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c98:	8d 81       	ldd	r24, Y+5	; 0x05
     c9a:	9e 81       	ldd	r25, Y+6	; 0x06
     c9c:	90 70       	andi	r25, 0x00	; 0
     c9e:	9e 83       	std	Y+6, r25	; 0x06
     ca0:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     ca2:	8d 81       	ldd	r24, Y+5	; 0x05
     ca4:	9e 81       	ldd	r25, Y+6	; 0x06
}
     ca6:	60 96       	adiw	r28, 0x10	; 16
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	cf 91       	pop	r28
     cb4:	df 91       	pop	r29
     cb6:	08 95       	ret

00000cb8 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     cb8:	0f 93       	push	r16
     cba:	1f 93       	push	r17
     cbc:	df 93       	push	r29
     cbe:	cf 93       	push	r28
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
     cc4:	63 97       	sbiw	r28, 0x13	; 19
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
     cd0:	9d 87       	std	Y+13, r25	; 0x0d
     cd2:	8c 87       	std	Y+12, r24	; 0x0c
     cd4:	7f 87       	std	Y+15, r23	; 0x0f
     cd6:	6e 87       	std	Y+14, r22	; 0x0e
     cd8:	48 8b       	std	Y+16, r20	; 0x10
     cda:	29 8b       	std	Y+17, r18	; 0x11
     cdc:	1b 8b       	std	Y+19, r17	; 0x13
     cde:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     ce0:	8c 85       	ldd	r24, Y+12	; 0x0c
     ce2:	9d 85       	ldd	r25, Y+13	; 0x0d
     ce4:	9b 87       	std	Y+11, r25	; 0x0b
     ce6:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     ce8:	1f 82       	std	Y+7, r1	; 0x07
     cea:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     cec:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     cee:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     cf2:	ea 85       	ldd	r30, Y+10	; 0x0a
     cf4:	fb 85       	ldd	r31, Y+11	; 0x0b
     cf6:	80 81       	ld	r24, Z
     cf8:	91 81       	ldd	r25, Z+1	; 0x01
     cfa:	9a 83       	std	Y+2, r25	; 0x02
     cfc:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     cfe:	89 81       	ldd	r24, Y+1	; 0x01
     d00:	9a 81       	ldd	r25, Y+2	; 0x02
     d02:	2e 85       	ldd	r18, Y+14	; 0x0e
     d04:	3f 85       	ldd	r19, Y+15	; 0x0f
     d06:	b9 01       	movw	r22, r18
     d08:	49 89       	ldd	r20, Y+17	; 0x11
     d0a:	0e 94 97 08 	call	0x112e	; 0x112e <prvTestWaitCondition>
     d0e:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     d10:	8d 81       	ldd	r24, Y+5	; 0x05
     d12:	88 23       	and	r24, r24
     d14:	c1 f0       	breq	.+48     	; 0xd46 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	99 87       	std	Y+9, r25	; 0x09
     d1c:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     d1e:	1b 8a       	std	Y+19, r1	; 0x13
     d20:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     d22:	88 89       	ldd	r24, Y+16	; 0x10
     d24:	88 23       	and	r24, r24
     d26:	e9 f1       	breq	.+122    	; 0xda2 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     d28:	ea 85       	ldd	r30, Y+10	; 0x0a
     d2a:	fb 85       	ldd	r31, Y+11	; 0x0b
     d2c:	20 81       	ld	r18, Z
     d2e:	31 81       	ldd	r19, Z+1	; 0x01
     d30:	8e 85       	ldd	r24, Y+14	; 0x0e
     d32:	9f 85       	ldd	r25, Y+15	; 0x0f
     d34:	80 95       	com	r24
     d36:	90 95       	com	r25
     d38:	82 23       	and	r24, r18
     d3a:	93 23       	and	r25, r19
     d3c:	ea 85       	ldd	r30, Y+10	; 0x0a
     d3e:	fb 85       	ldd	r31, Y+11	; 0x0b
     d40:	91 83       	std	Z+1, r25	; 0x01
     d42:	80 83       	st	Z, r24
     d44:	2e c0       	rjmp	.+92     	; 0xda2 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     d46:	8a 89       	ldd	r24, Y+18	; 0x12
     d48:	9b 89       	ldd	r25, Y+19	; 0x13
     d4a:	00 97       	sbiw	r24, 0x00	; 0
     d4c:	39 f4       	brne	.+14     	; 0xd5c <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     d4e:	89 81       	ldd	r24, Y+1	; 0x01
     d50:	9a 81       	ldd	r25, Y+2	; 0x02
     d52:	99 87       	std	Y+9, r25	; 0x09
     d54:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	8b 83       	std	Y+3, r24	; 0x03
     d5a:	23 c0       	rjmp	.+70     	; 0xda2 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     d5c:	88 89       	ldd	r24, Y+16	; 0x10
     d5e:	88 23       	and	r24, r24
     d60:	29 f0       	breq	.+10     	; 0xd6c <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     d62:	8e 81       	ldd	r24, Y+6	; 0x06
     d64:	9f 81       	ldd	r25, Y+7	; 0x07
     d66:	91 60       	ori	r25, 0x01	; 1
     d68:	9f 83       	std	Y+7, r25	; 0x07
     d6a:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     d6c:	89 89       	ldd	r24, Y+17	; 0x11
     d6e:	88 23       	and	r24, r24
     d70:	29 f0       	breq	.+10     	; 0xd7c <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     d72:	8e 81       	ldd	r24, Y+6	; 0x06
     d74:	9f 81       	ldd	r25, Y+7	; 0x07
     d76:	94 60       	ori	r25, 0x04	; 4
     d78:	9f 83       	std	Y+7, r25	; 0x07
     d7a:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     d7c:	8a 85       	ldd	r24, Y+10	; 0x0a
     d7e:	9b 85       	ldd	r25, Y+11	; 0x0b
     d80:	bc 01       	movw	r22, r24
     d82:	6e 5f       	subi	r22, 0xFE	; 254
     d84:	7f 4f       	sbci	r23, 0xFF	; 255
     d86:	2e 85       	ldd	r18, Y+14	; 0x0e
     d88:	3f 85       	ldd	r19, Y+15	; 0x0f
     d8a:	8e 81       	ldd	r24, Y+6	; 0x06
     d8c:	9f 81       	ldd	r25, Y+7	; 0x07
     d8e:	28 2b       	or	r18, r24
     d90:	39 2b       	or	r19, r25
     d92:	4a 89       	ldd	r20, Y+18	; 0x12
     d94:	5b 89       	ldd	r21, Y+19	; 0x13
     d96:	cb 01       	movw	r24, r22
     d98:	b9 01       	movw	r22, r18
     d9a:	0e 94 b7 24 	call	0x496e	; 0x496e <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     d9e:	19 86       	std	Y+9, r1	; 0x09
     da0:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     da2:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
     da6:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     da8:	8a 89       	ldd	r24, Y+18	; 0x12
     daa:	9b 89       	ldd	r25, Y+19	; 0x13
     dac:	00 97       	sbiw	r24, 0x00	; 0
     dae:	09 f4       	brne	.+2      	; 0xdb2 <xEventGroupWaitBits+0xfa>
     db0:	3c c0       	rjmp	.+120    	; 0xe2a <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     db2:	8c 81       	ldd	r24, Y+4	; 0x04
     db4:	88 23       	and	r24, r24
     db6:	11 f4       	brne	.+4      	; 0xdbc <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     db8:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     dbc:	0e 94 cf 28 	call	0x519e	; 0x519e <uxTaskResetEventItemValue>
     dc0:	99 87       	std	Y+9, r25	; 0x09
     dc2:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     dc4:	88 85       	ldd	r24, Y+8	; 0x08
     dc6:	99 85       	ldd	r25, Y+9	; 0x09
     dc8:	80 70       	andi	r24, 0x00	; 0
     dca:	92 70       	andi	r25, 0x02	; 2
     dcc:	00 97       	sbiw	r24, 0x00	; 0
     dce:	41 f5       	brne	.+80     	; 0xe20 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     dd6:	ea 85       	ldd	r30, Y+10	; 0x0a
     dd8:	fb 85       	ldd	r31, Y+11	; 0x0b
     dda:	80 81       	ld	r24, Z
     ddc:	91 81       	ldd	r25, Z+1	; 0x01
     dde:	99 87       	std	Y+9, r25	; 0x09
     de0:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     de2:	88 85       	ldd	r24, Y+8	; 0x08
     de4:	99 85       	ldd	r25, Y+9	; 0x09
     de6:	2e 85       	ldd	r18, Y+14	; 0x0e
     de8:	3f 85       	ldd	r19, Y+15	; 0x0f
     dea:	b9 01       	movw	r22, r18
     dec:	49 89       	ldd	r20, Y+17	; 0x11
     dee:	0e 94 97 08 	call	0x112e	; 0x112e <prvTestWaitCondition>
     df2:	88 23       	and	r24, r24
     df4:	89 f0       	breq	.+34     	; 0xe18 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     df6:	88 89       	ldd	r24, Y+16	; 0x10
     df8:	88 23       	and	r24, r24
     dfa:	71 f0       	breq	.+28     	; 0xe18 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     dfc:	ea 85       	ldd	r30, Y+10	; 0x0a
     dfe:	fb 85       	ldd	r31, Y+11	; 0x0b
     e00:	20 81       	ld	r18, Z
     e02:	31 81       	ldd	r19, Z+1	; 0x01
     e04:	8e 85       	ldd	r24, Y+14	; 0x0e
     e06:	9f 85       	ldd	r25, Y+15	; 0x0f
     e08:	80 95       	com	r24
     e0a:	90 95       	com	r25
     e0c:	82 23       	and	r24, r18
     e0e:	93 23       	and	r25, r19
     e10:	ea 85       	ldd	r30, Y+10	; 0x0a
     e12:	fb 85       	ldd	r31, Y+11	; 0x0b
     e14:	91 83       	std	Z+1, r25	; 0x01
     e16:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     e1c:	0f 90       	pop	r0
     e1e:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     e20:	88 85       	ldd	r24, Y+8	; 0x08
     e22:	99 85       	ldd	r25, Y+9	; 0x09
     e24:	90 70       	andi	r25, 0x00	; 0
     e26:	99 87       	std	Y+9, r25	; 0x09
     e28:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     e2a:	88 85       	ldd	r24, Y+8	; 0x08
     e2c:	99 85       	ldd	r25, Y+9	; 0x09
}
     e2e:	63 96       	adiw	r28, 0x13	; 19
     e30:	0f b6       	in	r0, 0x3f	; 63
     e32:	f8 94       	cli
     e34:	de bf       	out	0x3e, r29	; 62
     e36:	0f be       	out	0x3f, r0	; 63
     e38:	cd bf       	out	0x3d, r28	; 61
     e3a:	cf 91       	pop	r28
     e3c:	df 91       	pop	r29
     e3e:	1f 91       	pop	r17
     e40:	0f 91       	pop	r16
     e42:	08 95       	ret

00000e44 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     e44:	df 93       	push	r29
     e46:	cf 93       	push	r28
     e48:	cd b7       	in	r28, 0x3d	; 61
     e4a:	de b7       	in	r29, 0x3e	; 62
     e4c:	28 97       	sbiw	r28, 0x08	; 8
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	de bf       	out	0x3e, r29	; 62
     e54:	0f be       	out	0x3f, r0	; 63
     e56:	cd bf       	out	0x3d, r28	; 61
     e58:	9e 83       	std	Y+6, r25	; 0x06
     e5a:	8d 83       	std	Y+5, r24	; 0x05
     e5c:	78 87       	std	Y+8, r23	; 0x08
     e5e:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     e60:	8d 81       	ldd	r24, Y+5	; 0x05
     e62:	9e 81       	ldd	r25, Y+6	; 0x06
     e64:	9c 83       	std	Y+4, r25	; 0x04
     e66:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	f8 94       	cli
     e6c:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     e6e:	eb 81       	ldd	r30, Y+3	; 0x03
     e70:	fc 81       	ldd	r31, Y+4	; 0x04
     e72:	80 81       	ld	r24, Z
     e74:	91 81       	ldd	r25, Z+1	; 0x01
     e76:	9a 83       	std	Y+2, r25	; 0x02
     e78:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     e7a:	eb 81       	ldd	r30, Y+3	; 0x03
     e7c:	fc 81       	ldd	r31, Y+4	; 0x04
     e7e:	20 81       	ld	r18, Z
     e80:	31 81       	ldd	r19, Z+1	; 0x01
     e82:	8f 81       	ldd	r24, Y+7	; 0x07
     e84:	98 85       	ldd	r25, Y+8	; 0x08
     e86:	80 95       	com	r24
     e88:	90 95       	com	r25
     e8a:	82 23       	and	r24, r18
     e8c:	93 23       	and	r25, r19
     e8e:	eb 81       	ldd	r30, Y+3	; 0x03
     e90:	fc 81       	ldd	r31, Y+4	; 0x04
     e92:	91 83       	std	Z+1, r25	; 0x01
     e94:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     e96:	0f 90       	pop	r0
     e98:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     e9a:	89 81       	ldd	r24, Y+1	; 0x01
     e9c:	9a 81       	ldd	r25, Y+2	; 0x02
}
     e9e:	28 96       	adiw	r28, 0x08	; 8
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	de bf       	out	0x3e, r29	; 62
     ea6:	0f be       	out	0x3f, r0	; 63
     ea8:	cd bf       	out	0x3d, r28	; 61
     eaa:	cf 91       	pop	r28
     eac:	df 91       	pop	r29
     eae:	08 95       	ret

00000eb0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	27 97       	sbiw	r28, 0x07	; 7
     eba:	0f b6       	in	r0, 0x3f	; 63
     ebc:	f8 94       	cli
     ebe:	de bf       	out	0x3e, r29	; 62
     ec0:	0f be       	out	0x3f, r0	; 63
     ec2:	cd bf       	out	0x3d, r28	; 61
     ec4:	9f 83       	std	Y+7, r25	; 0x07
     ec6:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     ec8:	8e 81       	ldd	r24, Y+6	; 0x06
     eca:	9f 81       	ldd	r25, Y+7	; 0x07
     ecc:	9c 83       	std	Y+4, r25	; 0x04
     ece:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     ed0:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     ed2:	eb 81       	ldd	r30, Y+3	; 0x03
     ed4:	fc 81       	ldd	r31, Y+4	; 0x04
     ed6:	80 81       	ld	r24, Z
     ed8:	91 81       	ldd	r25, Z+1	; 0x01
     eda:	9a 83       	std	Y+2, r25	; 0x02
     edc:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     ede:	89 81       	ldd	r24, Y+1	; 0x01
     ee0:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     ee2:	27 96       	adiw	r28, 0x07	; 7
     ee4:	0f b6       	in	r0, 0x3f	; 63
     ee6:	f8 94       	cli
     ee8:	de bf       	out	0x3e, r29	; 62
     eea:	0f be       	out	0x3f, r0	; 63
     eec:	cd bf       	out	0x3d, r28	; 61
     eee:	cf 91       	pop	r28
     ef0:	df 91       	pop	r29
     ef2:	08 95       	ret

00000ef4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     ef4:	df 93       	push	r29
     ef6:	cf 93       	push	r28
     ef8:	cd b7       	in	r28, 0x3d	; 61
     efa:	de b7       	in	r29, 0x3e	; 62
     efc:	65 97       	sbiw	r28, 0x15	; 21
     efe:	0f b6       	in	r0, 0x3f	; 63
     f00:	f8 94       	cli
     f02:	de bf       	out	0x3e, r29	; 62
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	cd bf       	out	0x3d, r28	; 61
     f08:	9b 8b       	std	Y+19, r25	; 0x13
     f0a:	8a 8b       	std	Y+18, r24	; 0x12
     f0c:	7d 8b       	std	Y+21, r23	; 0x15
     f0e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     f10:	19 86       	std	Y+9, r1	; 0x09
     f12:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     f14:	8a 89       	ldd	r24, Y+18	; 0x12
     f16:	9b 89       	ldd	r25, Y+19	; 0x13
     f18:	9b 83       	std	Y+3, r25	; 0x03
     f1a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     f1c:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	9b 81       	ldd	r25, Y+3	; 0x03
     f22:	02 96       	adiw	r24, 0x02	; 2
     f24:	9b 87       	std	Y+11, r25	; 0x0b
     f26:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f28:	8a 85       	ldd	r24, Y+10	; 0x0a
     f2a:	9b 85       	ldd	r25, Y+11	; 0x0b
     f2c:	03 96       	adiw	r24, 0x03	; 3
     f2e:	9d 87       	std	Y+13, r25	; 0x0d
     f30:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     f32:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     f36:	ea 85       	ldd	r30, Y+10	; 0x0a
     f38:	fb 85       	ldd	r31, Y+11	; 0x0b
     f3a:	85 81       	ldd	r24, Z+5	; 0x05
     f3c:	96 81       	ldd	r25, Z+6	; 0x06
     f3e:	99 8b       	std	Y+17, r25	; 0x11
     f40:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     f42:	ea 81       	ldd	r30, Y+2	; 0x02
     f44:	fb 81       	ldd	r31, Y+3	; 0x03
     f46:	20 81       	ld	r18, Z
     f48:	31 81       	ldd	r19, Z+1	; 0x01
     f4a:	8c 89       	ldd	r24, Y+20	; 0x14
     f4c:	9d 89       	ldd	r25, Y+21	; 0x15
     f4e:	82 2b       	or	r24, r18
     f50:	93 2b       	or	r25, r19
     f52:	ea 81       	ldd	r30, Y+2	; 0x02
     f54:	fb 81       	ldd	r31, Y+3	; 0x03
     f56:	91 83       	std	Z+1, r25	; 0x01
     f58:	80 83       	st	Z, r24
     f5a:	59 c0       	rjmp	.+178    	; 0x100e <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     f5c:	e8 89       	ldd	r30, Y+16	; 0x10
     f5e:	f9 89       	ldd	r31, Y+17	; 0x11
     f60:	82 81       	ldd	r24, Z+2	; 0x02
     f62:	93 81       	ldd	r25, Z+3	; 0x03
     f64:	9f 87       	std	Y+15, r25	; 0x0f
     f66:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     f68:	e8 89       	ldd	r30, Y+16	; 0x10
     f6a:	f9 89       	ldd	r31, Y+17	; 0x11
     f6c:	80 81       	ld	r24, Z
     f6e:	91 81       	ldd	r25, Z+1	; 0x01
     f70:	9f 83       	std	Y+7, r25	; 0x07
     f72:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     f74:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     f76:	8e 81       	ldd	r24, Y+6	; 0x06
     f78:	9f 81       	ldd	r25, Y+7	; 0x07
     f7a:	80 70       	andi	r24, 0x00	; 0
     f7c:	9d 83       	std	Y+5, r25	; 0x05
     f7e:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     f80:	8e 81       	ldd	r24, Y+6	; 0x06
     f82:	9f 81       	ldd	r25, Y+7	; 0x07
     f84:	90 70       	andi	r25, 0x00	; 0
     f86:	9f 83       	std	Y+7, r25	; 0x07
     f88:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     f8a:	8c 81       	ldd	r24, Y+4	; 0x04
     f8c:	9d 81       	ldd	r25, Y+5	; 0x05
     f8e:	80 70       	andi	r24, 0x00	; 0
     f90:	94 70       	andi	r25, 0x04	; 4
     f92:	00 97       	sbiw	r24, 0x00	; 0
     f94:	69 f4       	brne	.+26     	; 0xfb0 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     f96:	ea 81       	ldd	r30, Y+2	; 0x02
     f98:	fb 81       	ldd	r31, Y+3	; 0x03
     f9a:	20 81       	ld	r18, Z
     f9c:	31 81       	ldd	r19, Z+1	; 0x01
     f9e:	8e 81       	ldd	r24, Y+6	; 0x06
     fa0:	9f 81       	ldd	r25, Y+7	; 0x07
     fa2:	82 23       	and	r24, r18
     fa4:	93 23       	and	r25, r19
     fa6:	00 97       	sbiw	r24, 0x00	; 0
     fa8:	91 f0       	breq	.+36     	; 0xfce <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     faa:	81 e0       	ldi	r24, 0x01	; 1
     fac:	89 83       	std	Y+1, r24	; 0x01
     fae:	0f c0       	rjmp	.+30     	; 0xfce <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     fb0:	ea 81       	ldd	r30, Y+2	; 0x02
     fb2:	fb 81       	ldd	r31, Y+3	; 0x03
     fb4:	20 81       	ld	r18, Z
     fb6:	31 81       	ldd	r19, Z+1	; 0x01
     fb8:	8e 81       	ldd	r24, Y+6	; 0x06
     fba:	9f 81       	ldd	r25, Y+7	; 0x07
     fbc:	28 23       	and	r18, r24
     fbe:	39 23       	and	r19, r25
     fc0:	8e 81       	ldd	r24, Y+6	; 0x06
     fc2:	9f 81       	ldd	r25, Y+7	; 0x07
     fc4:	28 17       	cp	r18, r24
     fc6:	39 07       	cpc	r19, r25
     fc8:	11 f4       	brne	.+4      	; 0xfce <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     fca:	81 e0       	ldi	r24, 0x01	; 1
     fcc:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	88 23       	and	r24, r24
     fd2:	c9 f0       	breq	.+50     	; 0x1006 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     fd4:	8c 81       	ldd	r24, Y+4	; 0x04
     fd6:	9d 81       	ldd	r25, Y+5	; 0x05
     fd8:	80 70       	andi	r24, 0x00	; 0
     fda:	91 70       	andi	r25, 0x01	; 1
     fdc:	00 97       	sbiw	r24, 0x00	; 0
     fde:	41 f0       	breq	.+16     	; 0xff0 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     fe0:	88 85       	ldd	r24, Y+8	; 0x08
     fe2:	99 85       	ldd	r25, Y+9	; 0x09
     fe4:	2e 81       	ldd	r18, Y+6	; 0x06
     fe6:	3f 81       	ldd	r19, Y+7	; 0x07
     fe8:	82 2b       	or	r24, r18
     fea:	93 2b       	or	r25, r19
     fec:	99 87       	std	Y+9, r25	; 0x09
     fee:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     ff0:	ea 81       	ldd	r30, Y+2	; 0x02
     ff2:	fb 81       	ldd	r31, Y+3	; 0x03
     ff4:	80 81       	ld	r24, Z
     ff6:	91 81       	ldd	r25, Z+1	; 0x01
     ff8:	9c 01       	movw	r18, r24
     ffa:	32 60       	ori	r19, 0x02	; 2
     ffc:	88 89       	ldd	r24, Y+16	; 0x10
     ffe:	99 89       	ldd	r25, Y+17	; 0x11
    1000:	b9 01       	movw	r22, r18
    1002:	0e 94 52 25 	call	0x4aa4	; 0x4aa4 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1006:	8e 85       	ldd	r24, Y+14	; 0x0e
    1008:	9f 85       	ldd	r25, Y+15	; 0x0f
    100a:	99 8b       	std	Y+17, r25	; 0x11
    100c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    100e:	28 89       	ldd	r18, Y+16	; 0x10
    1010:	39 89       	ldd	r19, Y+17	; 0x11
    1012:	8c 85       	ldd	r24, Y+12	; 0x0c
    1014:	9d 85       	ldd	r25, Y+13	; 0x0d
    1016:	28 17       	cp	r18, r24
    1018:	39 07       	cpc	r19, r25
    101a:	09 f0       	breq	.+2      	; 0x101e <xEventGroupSetBits+0x12a>
    101c:	9f cf       	rjmp	.-194    	; 0xf5c <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    101e:	ea 81       	ldd	r30, Y+2	; 0x02
    1020:	fb 81       	ldd	r31, Y+3	; 0x03
    1022:	20 81       	ld	r18, Z
    1024:	31 81       	ldd	r19, Z+1	; 0x01
    1026:	88 85       	ldd	r24, Y+8	; 0x08
    1028:	99 85       	ldd	r25, Y+9	; 0x09
    102a:	80 95       	com	r24
    102c:	90 95       	com	r25
    102e:	82 23       	and	r24, r18
    1030:	93 23       	and	r25, r19
    1032:	ea 81       	ldd	r30, Y+2	; 0x02
    1034:	fb 81       	ldd	r31, Y+3	; 0x03
    1036:	91 83       	std	Z+1, r25	; 0x01
    1038:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    103a:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    103e:	ea 81       	ldd	r30, Y+2	; 0x02
    1040:	fb 81       	ldd	r31, Y+3	; 0x03
    1042:	80 81       	ld	r24, Z
    1044:	91 81       	ldd	r25, Z+1	; 0x01
}
    1046:	65 96       	adiw	r28, 0x15	; 21
    1048:	0f b6       	in	r0, 0x3f	; 63
    104a:	f8 94       	cli
    104c:	de bf       	out	0x3e, r29	; 62
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	cd bf       	out	0x3d, r28	; 61
    1052:	cf 91       	pop	r28
    1054:	df 91       	pop	r29
    1056:	08 95       	ret

00001058 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1058:	df 93       	push	r29
    105a:	cf 93       	push	r28
    105c:	00 d0       	rcall	.+0      	; 0x105e <vEventGroupDelete+0x6>
    105e:	00 d0       	rcall	.+0      	; 0x1060 <vEventGroupDelete+0x8>
    1060:	00 d0       	rcall	.+0      	; 0x1062 <vEventGroupDelete+0xa>
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
    1066:	9e 83       	std	Y+6, r25	; 0x06
    1068:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    106a:	8d 81       	ldd	r24, Y+5	; 0x05
    106c:	9e 81       	ldd	r25, Y+6	; 0x06
    106e:	9c 83       	std	Y+4, r25	; 0x04
    1070:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1072:	8b 81       	ldd	r24, Y+3	; 0x03
    1074:	9c 81       	ldd	r25, Y+4	; 0x04
    1076:	02 96       	adiw	r24, 0x02	; 2
    1078:	9a 83       	std	Y+2, r25	; 0x02
    107a:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    107c:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
    1080:	08 c0       	rjmp	.+16     	; 0x1092 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1082:	e9 81       	ldd	r30, Y+1	; 0x01
    1084:	fa 81       	ldd	r31, Y+2	; 0x02
    1086:	85 81       	ldd	r24, Z+5	; 0x05
    1088:	96 81       	ldd	r25, Z+6	; 0x06
    108a:	60 e0       	ldi	r22, 0x00	; 0
    108c:	72 e0       	ldi	r23, 0x02	; 2
    108e:	0e 94 52 25 	call	0x4aa4	; 0x4aa4 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1092:	e9 81       	ldd	r30, Y+1	; 0x01
    1094:	fa 81       	ldd	r31, Y+2	; 0x02
    1096:	80 81       	ld	r24, Z
    1098:	88 23       	and	r24, r24
    109a:	99 f7       	brne	.-26     	; 0x1082 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    109c:	8b 81       	ldd	r24, Y+3	; 0x03
    109e:	9c 81       	ldd	r25, Y+4	; 0x04
    10a0:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    10a4:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
}
    10a8:	26 96       	adiw	r28, 0x06	; 6
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	f8 94       	cli
    10ae:	de bf       	out	0x3e, r29	; 62
    10b0:	0f be       	out	0x3f, r0	; 63
    10b2:	cd bf       	out	0x3d, r28	; 61
    10b4:	cf 91       	pop	r28
    10b6:	df 91       	pop	r29
    10b8:	08 95       	ret

000010ba <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    10ba:	df 93       	push	r29
    10bc:	cf 93       	push	r28
    10be:	00 d0       	rcall	.+0      	; 0x10c0 <vEventGroupSetBitsCallback+0x6>
    10c0:	00 d0       	rcall	.+0      	; 0x10c2 <vEventGroupSetBitsCallback+0x8>
    10c2:	00 d0       	rcall	.+0      	; 0x10c4 <vEventGroupSetBitsCallback+0xa>
    10c4:	cd b7       	in	r28, 0x3d	; 61
    10c6:	de b7       	in	r29, 0x3e	; 62
    10c8:	9a 83       	std	Y+2, r25	; 0x02
    10ca:	89 83       	std	Y+1, r24	; 0x01
    10cc:	4b 83       	std	Y+3, r20	; 0x03
    10ce:	5c 83       	std	Y+4, r21	; 0x04
    10d0:	6d 83       	std	Y+5, r22	; 0x05
    10d2:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    10d4:	89 81       	ldd	r24, Y+1	; 0x01
    10d6:	9a 81       	ldd	r25, Y+2	; 0x02
    10d8:	2b 81       	ldd	r18, Y+3	; 0x03
    10da:	3c 81       	ldd	r19, Y+4	; 0x04
    10dc:	b9 01       	movw	r22, r18
    10de:	0e 94 7a 07 	call	0xef4	; 0xef4 <xEventGroupSetBits>
}
    10e2:	26 96       	adiw	r28, 0x06	; 6
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	de bf       	out	0x3e, r29	; 62
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	cd bf       	out	0x3d, r28	; 61
    10ee:	cf 91       	pop	r28
    10f0:	df 91       	pop	r29
    10f2:	08 95       	ret

000010f4 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <vEventGroupClearBitsCallback+0x6>
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <vEventGroupClearBitsCallback+0x8>
    10fc:	00 d0       	rcall	.+0      	; 0x10fe <vEventGroupClearBitsCallback+0xa>
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	9a 83       	std	Y+2, r25	; 0x02
    1104:	89 83       	std	Y+1, r24	; 0x01
    1106:	4b 83       	std	Y+3, r20	; 0x03
    1108:	5c 83       	std	Y+4, r21	; 0x04
    110a:	6d 83       	std	Y+5, r22	; 0x05
    110c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    110e:	89 81       	ldd	r24, Y+1	; 0x01
    1110:	9a 81       	ldd	r25, Y+2	; 0x02
    1112:	2b 81       	ldd	r18, Y+3	; 0x03
    1114:	3c 81       	ldd	r19, Y+4	; 0x04
    1116:	b9 01       	movw	r22, r18
    1118:	0e 94 22 07 	call	0xe44	; 0xe44 <xEventGroupClearBits>
}
    111c:	26 96       	adiw	r28, 0x06	; 6
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	de bf       	out	0x3e, r29	; 62
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	cd bf       	out	0x3d, r28	; 61
    1128:	cf 91       	pop	r28
    112a:	df 91       	pop	r29
    112c:	08 95       	ret

0000112e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    112e:	df 93       	push	r29
    1130:	cf 93       	push	r28
    1132:	00 d0       	rcall	.+0      	; 0x1134 <prvTestWaitCondition+0x6>
    1134:	00 d0       	rcall	.+0      	; 0x1136 <prvTestWaitCondition+0x8>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <prvTestWaitCondition+0xa>
    1138:	cd b7       	in	r28, 0x3d	; 61
    113a:	de b7       	in	r29, 0x3e	; 62
    113c:	9b 83       	std	Y+3, r25	; 0x03
    113e:	8a 83       	std	Y+2, r24	; 0x02
    1140:	7d 83       	std	Y+5, r23	; 0x05
    1142:	6c 83       	std	Y+4, r22	; 0x04
    1144:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1146:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1148:	8e 81       	ldd	r24, Y+6	; 0x06
    114a:	88 23       	and	r24, r24
    114c:	59 f4       	brne	.+22     	; 0x1164 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    114e:	8a 81       	ldd	r24, Y+2	; 0x02
    1150:	9b 81       	ldd	r25, Y+3	; 0x03
    1152:	2c 81       	ldd	r18, Y+4	; 0x04
    1154:	3d 81       	ldd	r19, Y+5	; 0x05
    1156:	82 23       	and	r24, r18
    1158:	93 23       	and	r25, r19
    115a:	00 97       	sbiw	r24, 0x00	; 0
    115c:	81 f0       	breq	.+32     	; 0x117e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	89 83       	std	Y+1, r24	; 0x01
    1162:	0d c0       	rjmp	.+26     	; 0x117e <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1164:	2a 81       	ldd	r18, Y+2	; 0x02
    1166:	3b 81       	ldd	r19, Y+3	; 0x03
    1168:	8c 81       	ldd	r24, Y+4	; 0x04
    116a:	9d 81       	ldd	r25, Y+5	; 0x05
    116c:	28 23       	and	r18, r24
    116e:	39 23       	and	r19, r25
    1170:	8c 81       	ldd	r24, Y+4	; 0x04
    1172:	9d 81       	ldd	r25, Y+5	; 0x05
    1174:	28 17       	cp	r18, r24
    1176:	39 07       	cpc	r19, r25
    1178:	11 f4       	brne	.+4      	; 0x117e <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    117e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1180:	26 96       	adiw	r28, 0x06	; 6
    1182:	0f b6       	in	r0, 0x3f	; 63
    1184:	f8 94       	cli
    1186:	de bf       	out	0x3e, r29	; 62
    1188:	0f be       	out	0x3f, r0	; 63
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	cf 91       	pop	r28
    118e:	df 91       	pop	r29
    1190:	08 95       	ret

00001192 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1192:	df 93       	push	r29
    1194:	cf 93       	push	r28
    1196:	00 d0       	rcall	.+0      	; 0x1198 <pvPortMalloc+0x6>
    1198:	00 d0       	rcall	.+0      	; 0x119a <pvPortMalloc+0x8>
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
    119e:	9c 83       	std	Y+4, r25	; 0x04
    11a0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    11a2:	1a 82       	std	Y+2, r1	; 0x02
    11a4:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    11a6:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    11aa:	80 91 e2 00 	lds	r24, 0x00E2
    11ae:	90 91 e3 00 	lds	r25, 0x00E3
    11b2:	00 97       	sbiw	r24, 0x00	; 0
    11b4:	31 f4       	brne	.+12     	; 0x11c2 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    11b6:	85 ee       	ldi	r24, 0xE5	; 229
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	90 93 e3 00 	sts	0x00E3, r25
    11be:	80 93 e2 00 	sts	0x00E2, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    11c2:	80 91 e0 00 	lds	r24, 0x00E0
    11c6:	90 91 e1 00 	lds	r25, 0x00E1
    11ca:	2b 81       	ldd	r18, Y+3	; 0x03
    11cc:	3c 81       	ldd	r19, Y+4	; 0x04
    11ce:	82 0f       	add	r24, r18
    11d0:	93 1f       	adc	r25, r19
    11d2:	25 e0       	ldi	r18, 0x05	; 5
    11d4:	8b 3d       	cpi	r24, 0xDB	; 219
    11d6:	92 07       	cpc	r25, r18
    11d8:	38 f5       	brcc	.+78     	; 0x1228 <pvPortMalloc+0x96>
    11da:	20 91 e0 00 	lds	r18, 0x00E0
    11de:	30 91 e1 00 	lds	r19, 0x00E1
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	9c 81       	ldd	r25, Y+4	; 0x04
    11e6:	28 0f       	add	r18, r24
    11e8:	39 1f       	adc	r19, r25
    11ea:	80 91 e0 00 	lds	r24, 0x00E0
    11ee:	90 91 e1 00 	lds	r25, 0x00E1
    11f2:	82 17       	cp	r24, r18
    11f4:	93 07       	cpc	r25, r19
    11f6:	c0 f4       	brcc	.+48     	; 0x1228 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    11f8:	20 91 e2 00 	lds	r18, 0x00E2
    11fc:	30 91 e3 00 	lds	r19, 0x00E3
    1200:	80 91 e0 00 	lds	r24, 0x00E0
    1204:	90 91 e1 00 	lds	r25, 0x00E1
    1208:	82 0f       	add	r24, r18
    120a:	93 1f       	adc	r25, r19
    120c:	9a 83       	std	Y+2, r25	; 0x02
    120e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1210:	20 91 e0 00 	lds	r18, 0x00E0
    1214:	30 91 e1 00 	lds	r19, 0x00E1
    1218:	8b 81       	ldd	r24, Y+3	; 0x03
    121a:	9c 81       	ldd	r25, Y+4	; 0x04
    121c:	82 0f       	add	r24, r18
    121e:	93 1f       	adc	r25, r19
    1220:	90 93 e1 00 	sts	0x00E1, r25
    1224:	80 93 e0 00 	sts	0x00E0, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1228:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    122c:	89 81       	ldd	r24, Y+1	; 0x01
    122e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1230:	0f 90       	pop	r0
    1232:	0f 90       	pop	r0
    1234:	0f 90       	pop	r0
    1236:	0f 90       	pop	r0
    1238:	cf 91       	pop	r28
    123a:	df 91       	pop	r29
    123c:	08 95       	ret

0000123e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	00 d0       	rcall	.+0      	; 0x1244 <vPortFree+0x6>
    1244:	cd b7       	in	r28, 0x3d	; 61
    1246:	de b7       	in	r29, 0x3e	; 62
    1248:	9a 83       	std	Y+2, r25	; 0x02
    124a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    124c:	0f 90       	pop	r0
    124e:	0f 90       	pop	r0
    1250:	cf 91       	pop	r28
    1252:	df 91       	pop	r29
    1254:	08 95       	ret

00001256 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1256:	df 93       	push	r29
    1258:	cf 93       	push	r28
    125a:	cd b7       	in	r28, 0x3d	; 61
    125c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    125e:	10 92 e1 00 	sts	0x00E1, r1
    1262:	10 92 e0 00 	sts	0x00E0, r1
}
    1266:	cf 91       	pop	r28
    1268:	df 91       	pop	r29
    126a:	08 95       	ret

0000126c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	cd b7       	in	r28, 0x3d	; 61
    1272:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1274:	20 91 e0 00 	lds	r18, 0x00E0
    1278:	30 91 e1 00 	lds	r19, 0x00E1
    127c:	8b ed       	ldi	r24, 0xDB	; 219
    127e:	95 e0       	ldi	r25, 0x05	; 5
    1280:	82 1b       	sub	r24, r18
    1282:	93 0b       	sbc	r25, r19
}
    1284:	cf 91       	pop	r28
    1286:	df 91       	pop	r29
    1288:	08 95       	ret

0000128a <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    128a:	df 93       	push	r29
    128c:	cf 93       	push	r28
    128e:	cd b7       	in	r28, 0x3d	; 61
    1290:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1292:	aa e3       	ldi	r26, 0x3A	; 58
    1294:	b0 e0       	ldi	r27, 0x00	; 0
    1296:	ea e3       	ldi	r30, 0x3A	; 58
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	80 81       	ld	r24, Z
    129c:	8e 60       	ori	r24, 0x0E	; 14
    129e:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    12a0:	aa e3       	ldi	r26, 0x3A	; 58
    12a2:	b0 e0       	ldi	r27, 0x00	; 0
    12a4:	ea e3       	ldi	r30, 0x3A	; 58
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	80 81       	ld	r24, Z
    12aa:	80 6f       	ori	r24, 0xF0	; 240
    12ac:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    12ae:	82 e0       	ldi	r24, 0x02	; 2
    12b0:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    12b4:	88 e2       	ldi	r24, 0x28	; 40
    12b6:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    12ba:	8c e0       	ldi	r24, 0x0C	; 12
    12bc:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    12c0:	81 e0       	ldi	r24, 0x01	; 1
    12c2:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>

}
    12c6:	cf 91       	pop	r28
    12c8:	df 91       	pop	r29
    12ca:	08 95       	ret

000012cc <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    12cc:	df 93       	push	r29
    12ce:	cf 93       	push	r28
    12d0:	0f 92       	push	r0
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
    12d6:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    12d8:	ab e3       	ldi	r26, 0x3B	; 59
    12da:	b0 e0       	ldi	r27, 0x00	; 0
    12dc:	eb e3       	ldi	r30, 0x3B	; 59
    12de:	f0 e0       	ldi	r31, 0x00	; 0
    12e0:	80 81       	ld	r24, Z
    12e2:	8d 7f       	andi	r24, 0xFD	; 253
    12e4:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    12e6:	ab e3       	ldi	r26, 0x3B	; 59
    12e8:	b0 e0       	ldi	r27, 0x00	; 0
    12ea:	eb e3       	ldi	r30, 0x3B	; 59
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	8b 7f       	andi	r24, 0xFB	; 251
    12f2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12fc:	ab e3       	ldi	r26, 0x3B	; 59
    12fe:	b0 e0       	ldi	r27, 0x00	; 0
    1300:	eb e3       	ldi	r30, 0x3B	; 59
    1302:	f0 e0       	ldi	r31, 0x00	; 0
    1304:	80 81       	ld	r24, Z
    1306:	88 60       	ori	r24, 0x08	; 8
    1308:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    1312:	ab e3       	ldi	r26, 0x3B	; 59
    1314:	b0 e0       	ldi	r27, 0x00	; 0
    1316:	eb e3       	ldi	r30, 0x3B	; 59
    1318:	f0 e0       	ldi	r31, 0x00	; 0
    131a:	80 81       	ld	r24, Z
    131c:	98 2f       	mov	r25, r24
    131e:	9f 70       	andi	r25, 0x0F	; 15
    1320:	89 81       	ldd	r24, Y+1	; 0x01
    1322:	80 7f       	andi	r24, 0xF0	; 240
    1324:	89 2b       	or	r24, r25
    1326:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1330:	ab e3       	ldi	r26, 0x3B	; 59
    1332:	b0 e0       	ldi	r27, 0x00	; 0
    1334:	eb e3       	ldi	r30, 0x3B	; 59
    1336:	f0 e0       	ldi	r31, 0x00	; 0
    1338:	80 81       	ld	r24, Z
    133a:	87 7f       	andi	r24, 0xF7	; 247
    133c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1346:	ab e3       	ldi	r26, 0x3B	; 59
    1348:	b0 e0       	ldi	r27, 0x00	; 0
    134a:	eb e3       	ldi	r30, 0x3B	; 59
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	80 81       	ld	r24, Z
    1350:	88 60       	ori	r24, 0x08	; 8
    1352:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    135c:	ab e3       	ldi	r26, 0x3B	; 59
    135e:	b0 e0       	ldi	r27, 0x00	; 0
    1360:	eb e3       	ldi	r30, 0x3B	; 59
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	28 2f       	mov	r18, r24
    1368:	2f 70       	andi	r18, 0x0F	; 15
    136a:	89 81       	ldd	r24, Y+1	; 0x01
    136c:	88 2f       	mov	r24, r24
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	82 95       	swap	r24
    1372:	92 95       	swap	r25
    1374:	90 7f       	andi	r25, 0xF0	; 240
    1376:	98 27       	eor	r25, r24
    1378:	80 7f       	andi	r24, 0xF0	; 240
    137a:	98 27       	eor	r25, r24
    137c:	82 2b       	or	r24, r18
    137e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	90 e0       	ldi	r25, 0x00	; 0
    1384:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1388:	ab e3       	ldi	r26, 0x3B	; 59
    138a:	b0 e0       	ldi	r27, 0x00	; 0
    138c:	eb e3       	ldi	r30, 0x3B	; 59
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	80 81       	ld	r24, Z
    1392:	87 7f       	andi	r24, 0xF7	; 247
    1394:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    139e:	0f 90       	pop	r0
    13a0:	cf 91       	pop	r28
    13a2:	df 91       	pop	r29
    13a4:	08 95       	ret

000013a6 <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    13a6:	df 93       	push	r29
    13a8:	cf 93       	push	r28
    13aa:	0f 92       	push	r0
    13ac:	cd b7       	in	r28, 0x3d	; 61
    13ae:	de b7       	in	r29, 0x3e	; 62
    13b0:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    13b2:	ab e3       	ldi	r26, 0x3B	; 59
    13b4:	b0 e0       	ldi	r27, 0x00	; 0
    13b6:	eb e3       	ldi	r30, 0x3B	; 59
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	80 81       	ld	r24, Z
    13bc:	82 60       	ori	r24, 0x02	; 2
    13be:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    13c0:	ab e3       	ldi	r26, 0x3B	; 59
    13c2:	b0 e0       	ldi	r27, 0x00	; 0
    13c4:	eb e3       	ldi	r30, 0x3B	; 59
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	80 81       	ld	r24, Z
    13ca:	8b 7f       	andi	r24, 0xFB	; 251
    13cc:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    13d6:	ab e3       	ldi	r26, 0x3B	; 59
    13d8:	b0 e0       	ldi	r27, 0x00	; 0
    13da:	eb e3       	ldi	r30, 0x3B	; 59
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	80 81       	ld	r24, Z
    13e0:	88 60       	ori	r24, 0x08	; 8
    13e2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    13ec:	ab e3       	ldi	r26, 0x3B	; 59
    13ee:	b0 e0       	ldi	r27, 0x00	; 0
    13f0:	eb e3       	ldi	r30, 0x3B	; 59
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	80 81       	ld	r24, Z
    13f6:	98 2f       	mov	r25, r24
    13f8:	9f 70       	andi	r25, 0x0F	; 15
    13fa:	89 81       	ldd	r24, Y+1	; 0x01
    13fc:	80 7f       	andi	r24, 0xF0	; 240
    13fe:	89 2b       	or	r24, r25
    1400:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    140a:	ab e3       	ldi	r26, 0x3B	; 59
    140c:	b0 e0       	ldi	r27, 0x00	; 0
    140e:	eb e3       	ldi	r30, 0x3B	; 59
    1410:	f0 e0       	ldi	r31, 0x00	; 0
    1412:	80 81       	ld	r24, Z
    1414:	87 7f       	andi	r24, 0xF7	; 247
    1416:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1420:	ab e3       	ldi	r26, 0x3B	; 59
    1422:	b0 e0       	ldi	r27, 0x00	; 0
    1424:	eb e3       	ldi	r30, 0x3B	; 59
    1426:	f0 e0       	ldi	r31, 0x00	; 0
    1428:	80 81       	ld	r24, Z
    142a:	88 60       	ori	r24, 0x08	; 8
    142c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    1436:	ab e3       	ldi	r26, 0x3B	; 59
    1438:	b0 e0       	ldi	r27, 0x00	; 0
    143a:	eb e3       	ldi	r30, 0x3B	; 59
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	80 81       	ld	r24, Z
    1440:	28 2f       	mov	r18, r24
    1442:	2f 70       	andi	r18, 0x0F	; 15
    1444:	89 81       	ldd	r24, Y+1	; 0x01
    1446:	88 2f       	mov	r24, r24
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	82 95       	swap	r24
    144c:	92 95       	swap	r25
    144e:	90 7f       	andi	r25, 0xF0	; 240
    1450:	98 27       	eor	r25, r24
    1452:	80 7f       	andi	r24, 0xF0	; 240
    1454:	98 27       	eor	r25, r24
    1456:	82 2b       	or	r24, r18
    1458:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1462:	ab e3       	ldi	r26, 0x3B	; 59
    1464:	b0 e0       	ldi	r27, 0x00	; 0
    1466:	eb e3       	ldi	r30, 0x3B	; 59
    1468:	f0 e0       	ldi	r31, 0x00	; 0
    146a:	80 81       	ld	r24, Z
    146c:	87 7f       	andi	r24, 0xF7	; 247
    146e:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1478:	0f 90       	pop	r0
    147a:	cf 91       	pop	r28
    147c:	df 91       	pop	r29
    147e:	08 95       	ret

00001480 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1480:	df 93       	push	r29
    1482:	cf 93       	push	r28
    1484:	00 d0       	rcall	.+0      	; 0x1486 <LCD_displayString+0x6>
    1486:	0f 92       	push	r0
    1488:	cd b7       	in	r28, 0x3d	; 61
    148a:	de b7       	in	r29, 0x3e	; 62
    148c:	9b 83       	std	Y+3, r25	; 0x03
    148e:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1490:	19 82       	std	Y+1, r1	; 0x01
    1492:	0e c0       	rjmp	.+28     	; 0x14b0 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1494:	89 81       	ldd	r24, Y+1	; 0x01
    1496:	28 2f       	mov	r18, r24
    1498:	30 e0       	ldi	r19, 0x00	; 0
    149a:	8a 81       	ldd	r24, Y+2	; 0x02
    149c:	9b 81       	ldd	r25, Y+3	; 0x03
    149e:	fc 01       	movw	r30, r24
    14a0:	e2 0f       	add	r30, r18
    14a2:	f3 1f       	adc	r31, r19
    14a4:	80 81       	ld	r24, Z
    14a6:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <LCD_displayCharacter>
		i++;
    14aa:	89 81       	ldd	r24, Y+1	; 0x01
    14ac:	8f 5f       	subi	r24, 0xFF	; 255
    14ae:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    14b0:	89 81       	ldd	r24, Y+1	; 0x01
    14b2:	28 2f       	mov	r18, r24
    14b4:	30 e0       	ldi	r19, 0x00	; 0
    14b6:	8a 81       	ldd	r24, Y+2	; 0x02
    14b8:	9b 81       	ldd	r25, Y+3	; 0x03
    14ba:	fc 01       	movw	r30, r24
    14bc:	e2 0f       	add	r30, r18
    14be:	f3 1f       	adc	r31, r19
    14c0:	80 81       	ld	r24, Z
    14c2:	88 23       	and	r24, r24
    14c4:	39 f7       	brne	.-50     	; 0x1494 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    14c6:	0f 90       	pop	r0
    14c8:	0f 90       	pop	r0
    14ca:	0f 90       	pop	r0
    14cc:	cf 91       	pop	r28
    14ce:	df 91       	pop	r29
    14d0:	08 95       	ret

000014d2 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    14d2:	df 93       	push	r29
    14d4:	cf 93       	push	r28
    14d6:	00 d0       	rcall	.+0      	; 0x14d8 <LCD_goToRowColumn+0x6>
    14d8:	00 d0       	rcall	.+0      	; 0x14da <LCD_goToRowColumn+0x8>
    14da:	0f 92       	push	r0
    14dc:	cd b7       	in	r28, 0x3d	; 61
    14de:	de b7       	in	r29, 0x3e	; 62
    14e0:	8a 83       	std	Y+2, r24	; 0x02
    14e2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    14e4:	8a 81       	ldd	r24, Y+2	; 0x02
    14e6:	28 2f       	mov	r18, r24
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	3d 83       	std	Y+5, r19	; 0x05
    14ec:	2c 83       	std	Y+4, r18	; 0x04
    14ee:	8c 81       	ldd	r24, Y+4	; 0x04
    14f0:	9d 81       	ldd	r25, Y+5	; 0x05
    14f2:	81 30       	cpi	r24, 0x01	; 1
    14f4:	91 05       	cpc	r25, r1
    14f6:	c1 f0       	breq	.+48     	; 0x1528 <LCD_goToRowColumn+0x56>
    14f8:	2c 81       	ldd	r18, Y+4	; 0x04
    14fa:	3d 81       	ldd	r19, Y+5	; 0x05
    14fc:	22 30       	cpi	r18, 0x02	; 2
    14fe:	31 05       	cpc	r19, r1
    1500:	2c f4       	brge	.+10     	; 0x150c <LCD_goToRowColumn+0x3a>
    1502:	8c 81       	ldd	r24, Y+4	; 0x04
    1504:	9d 81       	ldd	r25, Y+5	; 0x05
    1506:	00 97       	sbiw	r24, 0x00	; 0
    1508:	61 f0       	breq	.+24     	; 0x1522 <LCD_goToRowColumn+0x50>
    150a:	19 c0       	rjmp	.+50     	; 0x153e <LCD_goToRowColumn+0x6c>
    150c:	2c 81       	ldd	r18, Y+4	; 0x04
    150e:	3d 81       	ldd	r19, Y+5	; 0x05
    1510:	22 30       	cpi	r18, 0x02	; 2
    1512:	31 05       	cpc	r19, r1
    1514:	69 f0       	breq	.+26     	; 0x1530 <LCD_goToRowColumn+0x5e>
    1516:	8c 81       	ldd	r24, Y+4	; 0x04
    1518:	9d 81       	ldd	r25, Y+5	; 0x05
    151a:	83 30       	cpi	r24, 0x03	; 3
    151c:	91 05       	cpc	r25, r1
    151e:	61 f0       	breq	.+24     	; 0x1538 <LCD_goToRowColumn+0x66>
    1520:	0e c0       	rjmp	.+28     	; 0x153e <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    1522:	8b 81       	ldd	r24, Y+3	; 0x03
    1524:	89 83       	std	Y+1, r24	; 0x01
    1526:	0b c0       	rjmp	.+22     	; 0x153e <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    1528:	8b 81       	ldd	r24, Y+3	; 0x03
    152a:	80 5c       	subi	r24, 0xC0	; 192
    152c:	89 83       	std	Y+1, r24	; 0x01
    152e:	07 c0       	rjmp	.+14     	; 0x153e <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	80 5f       	subi	r24, 0xF0	; 240
    1534:	89 83       	std	Y+1, r24	; 0x01
    1536:	03 c0       	rjmp	.+6      	; 0x153e <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    1538:	8b 81       	ldd	r24, Y+3	; 0x03
    153a:	80 5b       	subi	r24, 0xB0	; 176
    153c:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	80 68       	ori	r24, 0x80	; 128
    1542:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>
}
    1546:	0f 90       	pop	r0
    1548:	0f 90       	pop	r0
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	cf 91       	pop	r28
    1552:	df 91       	pop	r29
    1554:	08 95       	ret

00001556 <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    1556:	df 93       	push	r29
    1558:	cf 93       	push	r28
    155a:	00 d0       	rcall	.+0      	; 0x155c <LCD_displayStringRowColumn+0x6>
    155c:	00 d0       	rcall	.+0      	; 0x155e <LCD_displayStringRowColumn+0x8>
    155e:	cd b7       	in	r28, 0x3d	; 61
    1560:	de b7       	in	r29, 0x3e	; 62
    1562:	89 83       	std	Y+1, r24	; 0x01
    1564:	6a 83       	std	Y+2, r22	; 0x02
    1566:	5c 83       	std	Y+4, r21	; 0x04
    1568:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    156a:	89 81       	ldd	r24, Y+1	; 0x01
    156c:	6a 81       	ldd	r22, Y+2	; 0x02
    156e:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	9c 81       	ldd	r25, Y+4	; 0x04
    1576:	0e 94 40 0a 	call	0x1480	; 0x1480 <LCD_displayString>
}
    157a:	0f 90       	pop	r0
    157c:	0f 90       	pop	r0
    157e:	0f 90       	pop	r0
    1580:	0f 90       	pop	r0
    1582:	cf 91       	pop	r28
    1584:	df 91       	pop	r29
    1586:	08 95       	ret

00001588 <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    1588:	df 93       	push	r29
    158a:	cf 93       	push	r28
    158c:	cd b7       	in	r28, 0x3d	; 61
    158e:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	0e 94 66 09 	call	0x12cc	; 0x12cc <LCD_sendCommand>
}
    1596:	cf 91       	pop	r28
    1598:	df 91       	pop	r29
    159a:	08 95       	ret

0000159c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    159c:	df 93       	push	r29
    159e:	cf 93       	push	r28
    15a0:	00 d0       	rcall	.+0      	; 0x15a2 <vListInitialise+0x6>
    15a2:	cd b7       	in	r28, 0x3d	; 61
    15a4:	de b7       	in	r29, 0x3e	; 62
    15a6:	9a 83       	std	Y+2, r25	; 0x02
    15a8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15aa:	89 81       	ldd	r24, Y+1	; 0x01
    15ac:	9a 81       	ldd	r25, Y+2	; 0x02
    15ae:	03 96       	adiw	r24, 0x03	; 3
    15b0:	e9 81       	ldd	r30, Y+1	; 0x01
    15b2:	fa 81       	ldd	r31, Y+2	; 0x02
    15b4:	92 83       	std	Z+2, r25	; 0x02
    15b6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    15b8:	e9 81       	ldd	r30, Y+1	; 0x01
    15ba:	fa 81       	ldd	r31, Y+2	; 0x02
    15bc:	8f ef       	ldi	r24, 0xFF	; 255
    15be:	9f ef       	ldi	r25, 0xFF	; 255
    15c0:	94 83       	std	Z+4, r25	; 0x04
    15c2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15c4:	89 81       	ldd	r24, Y+1	; 0x01
    15c6:	9a 81       	ldd	r25, Y+2	; 0x02
    15c8:	03 96       	adiw	r24, 0x03	; 3
    15ca:	e9 81       	ldd	r30, Y+1	; 0x01
    15cc:	fa 81       	ldd	r31, Y+2	; 0x02
    15ce:	96 83       	std	Z+6, r25	; 0x06
    15d0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15d2:	89 81       	ldd	r24, Y+1	; 0x01
    15d4:	9a 81       	ldd	r25, Y+2	; 0x02
    15d6:	03 96       	adiw	r24, 0x03	; 3
    15d8:	e9 81       	ldd	r30, Y+1	; 0x01
    15da:	fa 81       	ldd	r31, Y+2	; 0x02
    15dc:	90 87       	std	Z+8, r25	; 0x08
    15de:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    15e0:	e9 81       	ldd	r30, Y+1	; 0x01
    15e2:	fa 81       	ldd	r31, Y+2	; 0x02
    15e4:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    15e6:	0f 90       	pop	r0
    15e8:	0f 90       	pop	r0
    15ea:	cf 91       	pop	r28
    15ec:	df 91       	pop	r29
    15ee:	08 95       	ret

000015f0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    15f0:	df 93       	push	r29
    15f2:	cf 93       	push	r28
    15f4:	00 d0       	rcall	.+0      	; 0x15f6 <vListInitialiseItem+0x6>
    15f6:	cd b7       	in	r28, 0x3d	; 61
    15f8:	de b7       	in	r29, 0x3e	; 62
    15fa:	9a 83       	std	Y+2, r25	; 0x02
    15fc:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    15fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1600:	fa 81       	ldd	r31, Y+2	; 0x02
    1602:	11 86       	std	Z+9, r1	; 0x09
    1604:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1606:	0f 90       	pop	r0
    1608:	0f 90       	pop	r0
    160a:	cf 91       	pop	r28
    160c:	df 91       	pop	r29
    160e:	08 95       	ret

00001610 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1610:	df 93       	push	r29
    1612:	cf 93       	push	r28
    1614:	00 d0       	rcall	.+0      	; 0x1616 <vListInsertEnd+0x6>
    1616:	00 d0       	rcall	.+0      	; 0x1618 <vListInsertEnd+0x8>
    1618:	00 d0       	rcall	.+0      	; 0x161a <vListInsertEnd+0xa>
    161a:	cd b7       	in	r28, 0x3d	; 61
    161c:	de b7       	in	r29, 0x3e	; 62
    161e:	9c 83       	std	Y+4, r25	; 0x04
    1620:	8b 83       	std	Y+3, r24	; 0x03
    1622:	7e 83       	std	Y+6, r23	; 0x06
    1624:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1626:	eb 81       	ldd	r30, Y+3	; 0x03
    1628:	fc 81       	ldd	r31, Y+4	; 0x04
    162a:	81 81       	ldd	r24, Z+1	; 0x01
    162c:	92 81       	ldd	r25, Z+2	; 0x02
    162e:	9a 83       	std	Y+2, r25	; 0x02
    1630:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1632:	ed 81       	ldd	r30, Y+5	; 0x05
    1634:	fe 81       	ldd	r31, Y+6	; 0x06
    1636:	89 81       	ldd	r24, Y+1	; 0x01
    1638:	9a 81       	ldd	r25, Y+2	; 0x02
    163a:	93 83       	std	Z+3, r25	; 0x03
    163c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    163e:	e9 81       	ldd	r30, Y+1	; 0x01
    1640:	fa 81       	ldd	r31, Y+2	; 0x02
    1642:	84 81       	ldd	r24, Z+4	; 0x04
    1644:	95 81       	ldd	r25, Z+5	; 0x05
    1646:	ed 81       	ldd	r30, Y+5	; 0x05
    1648:	fe 81       	ldd	r31, Y+6	; 0x06
    164a:	95 83       	std	Z+5, r25	; 0x05
    164c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    164e:	e9 81       	ldd	r30, Y+1	; 0x01
    1650:	fa 81       	ldd	r31, Y+2	; 0x02
    1652:	04 80       	ldd	r0, Z+4	; 0x04
    1654:	f5 81       	ldd	r31, Z+5	; 0x05
    1656:	e0 2d       	mov	r30, r0
    1658:	8d 81       	ldd	r24, Y+5	; 0x05
    165a:	9e 81       	ldd	r25, Y+6	; 0x06
    165c:	93 83       	std	Z+3, r25	; 0x03
    165e:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1660:	e9 81       	ldd	r30, Y+1	; 0x01
    1662:	fa 81       	ldd	r31, Y+2	; 0x02
    1664:	8d 81       	ldd	r24, Y+5	; 0x05
    1666:	9e 81       	ldd	r25, Y+6	; 0x06
    1668:	95 83       	std	Z+5, r25	; 0x05
    166a:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    166c:	ed 81       	ldd	r30, Y+5	; 0x05
    166e:	fe 81       	ldd	r31, Y+6	; 0x06
    1670:	8b 81       	ldd	r24, Y+3	; 0x03
    1672:	9c 81       	ldd	r25, Y+4	; 0x04
    1674:	91 87       	std	Z+9, r25	; 0x09
    1676:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1678:	eb 81       	ldd	r30, Y+3	; 0x03
    167a:	fc 81       	ldd	r31, Y+4	; 0x04
    167c:	80 81       	ld	r24, Z
    167e:	8f 5f       	subi	r24, 0xFF	; 255
    1680:	eb 81       	ldd	r30, Y+3	; 0x03
    1682:	fc 81       	ldd	r31, Y+4	; 0x04
    1684:	80 83       	st	Z, r24
}
    1686:	26 96       	adiw	r28, 0x06	; 6
    1688:	0f b6       	in	r0, 0x3f	; 63
    168a:	f8 94       	cli
    168c:	de bf       	out	0x3e, r29	; 62
    168e:	0f be       	out	0x3f, r0	; 63
    1690:	cd bf       	out	0x3d, r28	; 61
    1692:	cf 91       	pop	r28
    1694:	df 91       	pop	r29
    1696:	08 95       	ret

00001698 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1698:	df 93       	push	r29
    169a:	cf 93       	push	r28
    169c:	cd b7       	in	r28, 0x3d	; 61
    169e:	de b7       	in	r29, 0x3e	; 62
    16a0:	28 97       	sbiw	r28, 0x08	; 8
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	f8 94       	cli
    16a6:	de bf       	out	0x3e, r29	; 62
    16a8:	0f be       	out	0x3f, r0	; 63
    16aa:	cd bf       	out	0x3d, r28	; 61
    16ac:	9e 83       	std	Y+6, r25	; 0x06
    16ae:	8d 83       	std	Y+5, r24	; 0x05
    16b0:	78 87       	std	Y+8, r23	; 0x08
    16b2:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    16b4:	ef 81       	ldd	r30, Y+7	; 0x07
    16b6:	f8 85       	ldd	r31, Y+8	; 0x08
    16b8:	80 81       	ld	r24, Z
    16ba:	91 81       	ldd	r25, Z+1	; 0x01
    16bc:	9a 83       	std	Y+2, r25	; 0x02
    16be:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    16c2:	9a 81       	ldd	r25, Y+2	; 0x02
    16c4:	2f ef       	ldi	r18, 0xFF	; 255
    16c6:	8f 3f       	cpi	r24, 0xFF	; 255
    16c8:	92 07       	cpc	r25, r18
    16ca:	39 f4       	brne	.+14     	; 0x16da <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16cc:	ed 81       	ldd	r30, Y+5	; 0x05
    16ce:	fe 81       	ldd	r31, Y+6	; 0x06
    16d0:	87 81       	ldd	r24, Z+7	; 0x07
    16d2:	90 85       	ldd	r25, Z+8	; 0x08
    16d4:	9c 83       	std	Y+4, r25	; 0x04
    16d6:	8b 83       	std	Y+3, r24	; 0x03
    16d8:	18 c0       	rjmp	.+48     	; 0x170a <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    16da:	8d 81       	ldd	r24, Y+5	; 0x05
    16dc:	9e 81       	ldd	r25, Y+6	; 0x06
    16de:	03 96       	adiw	r24, 0x03	; 3
    16e0:	9c 83       	std	Y+4, r25	; 0x04
    16e2:	8b 83       	std	Y+3, r24	; 0x03
    16e4:	06 c0       	rjmp	.+12     	; 0x16f2 <vListInsert+0x5a>
    16e6:	eb 81       	ldd	r30, Y+3	; 0x03
    16e8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ea:	82 81       	ldd	r24, Z+2	; 0x02
    16ec:	93 81       	ldd	r25, Z+3	; 0x03
    16ee:	9c 83       	std	Y+4, r25	; 0x04
    16f0:	8b 83       	std	Y+3, r24	; 0x03
    16f2:	eb 81       	ldd	r30, Y+3	; 0x03
    16f4:	fc 81       	ldd	r31, Y+4	; 0x04
    16f6:	02 80       	ldd	r0, Z+2	; 0x02
    16f8:	f3 81       	ldd	r31, Z+3	; 0x03
    16fa:	e0 2d       	mov	r30, r0
    16fc:	20 81       	ld	r18, Z
    16fe:	31 81       	ldd	r19, Z+1	; 0x01
    1700:	89 81       	ldd	r24, Y+1	; 0x01
    1702:	9a 81       	ldd	r25, Y+2	; 0x02
    1704:	82 17       	cp	r24, r18
    1706:	93 07       	cpc	r25, r19
    1708:	70 f7       	brcc	.-36     	; 0x16e6 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    170a:	eb 81       	ldd	r30, Y+3	; 0x03
    170c:	fc 81       	ldd	r31, Y+4	; 0x04
    170e:	82 81       	ldd	r24, Z+2	; 0x02
    1710:	93 81       	ldd	r25, Z+3	; 0x03
    1712:	ef 81       	ldd	r30, Y+7	; 0x07
    1714:	f8 85       	ldd	r31, Y+8	; 0x08
    1716:	93 83       	std	Z+3, r25	; 0x03
    1718:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    171a:	ef 81       	ldd	r30, Y+7	; 0x07
    171c:	f8 85       	ldd	r31, Y+8	; 0x08
    171e:	02 80       	ldd	r0, Z+2	; 0x02
    1720:	f3 81       	ldd	r31, Z+3	; 0x03
    1722:	e0 2d       	mov	r30, r0
    1724:	8f 81       	ldd	r24, Y+7	; 0x07
    1726:	98 85       	ldd	r25, Y+8	; 0x08
    1728:	95 83       	std	Z+5, r25	; 0x05
    172a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    172c:	ef 81       	ldd	r30, Y+7	; 0x07
    172e:	f8 85       	ldd	r31, Y+8	; 0x08
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
    1732:	9c 81       	ldd	r25, Y+4	; 0x04
    1734:	95 83       	std	Z+5, r25	; 0x05
    1736:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1738:	eb 81       	ldd	r30, Y+3	; 0x03
    173a:	fc 81       	ldd	r31, Y+4	; 0x04
    173c:	8f 81       	ldd	r24, Y+7	; 0x07
    173e:	98 85       	ldd	r25, Y+8	; 0x08
    1740:	93 83       	std	Z+3, r25	; 0x03
    1742:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1744:	ef 81       	ldd	r30, Y+7	; 0x07
    1746:	f8 85       	ldd	r31, Y+8	; 0x08
    1748:	8d 81       	ldd	r24, Y+5	; 0x05
    174a:	9e 81       	ldd	r25, Y+6	; 0x06
    174c:	91 87       	std	Z+9, r25	; 0x09
    174e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1750:	ed 81       	ldd	r30, Y+5	; 0x05
    1752:	fe 81       	ldd	r31, Y+6	; 0x06
    1754:	80 81       	ld	r24, Z
    1756:	8f 5f       	subi	r24, 0xFF	; 255
    1758:	ed 81       	ldd	r30, Y+5	; 0x05
    175a:	fe 81       	ldd	r31, Y+6	; 0x06
    175c:	80 83       	st	Z, r24
}
    175e:	28 96       	adiw	r28, 0x08	; 8
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	0f be       	out	0x3f, r0	; 63
    1768:	cd bf       	out	0x3d, r28	; 61
    176a:	cf 91       	pop	r28
    176c:	df 91       	pop	r29
    176e:	08 95       	ret

00001770 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1770:	df 93       	push	r29
    1772:	cf 93       	push	r28
    1774:	00 d0       	rcall	.+0      	; 0x1776 <uxListRemove+0x6>
    1776:	00 d0       	rcall	.+0      	; 0x1778 <uxListRemove+0x8>
    1778:	cd b7       	in	r28, 0x3d	; 61
    177a:	de b7       	in	r29, 0x3e	; 62
    177c:	9c 83       	std	Y+4, r25	; 0x04
    177e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1780:	eb 81       	ldd	r30, Y+3	; 0x03
    1782:	fc 81       	ldd	r31, Y+4	; 0x04
    1784:	80 85       	ldd	r24, Z+8	; 0x08
    1786:	91 85       	ldd	r25, Z+9	; 0x09
    1788:	9a 83       	std	Y+2, r25	; 0x02
    178a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    178c:	eb 81       	ldd	r30, Y+3	; 0x03
    178e:	fc 81       	ldd	r31, Y+4	; 0x04
    1790:	a2 81       	ldd	r26, Z+2	; 0x02
    1792:	b3 81       	ldd	r27, Z+3	; 0x03
    1794:	eb 81       	ldd	r30, Y+3	; 0x03
    1796:	fc 81       	ldd	r31, Y+4	; 0x04
    1798:	84 81       	ldd	r24, Z+4	; 0x04
    179a:	95 81       	ldd	r25, Z+5	; 0x05
    179c:	15 96       	adiw	r26, 0x05	; 5
    179e:	9c 93       	st	X, r25
    17a0:	8e 93       	st	-X, r24
    17a2:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    17a4:	eb 81       	ldd	r30, Y+3	; 0x03
    17a6:	fc 81       	ldd	r31, Y+4	; 0x04
    17a8:	a4 81       	ldd	r26, Z+4	; 0x04
    17aa:	b5 81       	ldd	r27, Z+5	; 0x05
    17ac:	eb 81       	ldd	r30, Y+3	; 0x03
    17ae:	fc 81       	ldd	r31, Y+4	; 0x04
    17b0:	82 81       	ldd	r24, Z+2	; 0x02
    17b2:	93 81       	ldd	r25, Z+3	; 0x03
    17b4:	13 96       	adiw	r26, 0x03	; 3
    17b6:	9c 93       	st	X, r25
    17b8:	8e 93       	st	-X, r24
    17ba:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    17bc:	e9 81       	ldd	r30, Y+1	; 0x01
    17be:	fa 81       	ldd	r31, Y+2	; 0x02
    17c0:	21 81       	ldd	r18, Z+1	; 0x01
    17c2:	32 81       	ldd	r19, Z+2	; 0x02
    17c4:	8b 81       	ldd	r24, Y+3	; 0x03
    17c6:	9c 81       	ldd	r25, Y+4	; 0x04
    17c8:	28 17       	cp	r18, r24
    17ca:	39 07       	cpc	r19, r25
    17cc:	41 f4       	brne	.+16     	; 0x17de <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    17ce:	eb 81       	ldd	r30, Y+3	; 0x03
    17d0:	fc 81       	ldd	r31, Y+4	; 0x04
    17d2:	84 81       	ldd	r24, Z+4	; 0x04
    17d4:	95 81       	ldd	r25, Z+5	; 0x05
    17d6:	e9 81       	ldd	r30, Y+1	; 0x01
    17d8:	fa 81       	ldd	r31, Y+2	; 0x02
    17da:	92 83       	std	Z+2, r25	; 0x02
    17dc:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    17de:	eb 81       	ldd	r30, Y+3	; 0x03
    17e0:	fc 81       	ldd	r31, Y+4	; 0x04
    17e2:	11 86       	std	Z+9, r1	; 0x09
    17e4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17e6:	e9 81       	ldd	r30, Y+1	; 0x01
    17e8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ea:	80 81       	ld	r24, Z
    17ec:	81 50       	subi	r24, 0x01	; 1
    17ee:	e9 81       	ldd	r30, Y+1	; 0x01
    17f0:	fa 81       	ldd	r31, Y+2	; 0x02
    17f2:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    17f4:	e9 81       	ldd	r30, Y+1	; 0x01
    17f6:	fa 81       	ldd	r31, Y+2	; 0x02
    17f8:	80 81       	ld	r24, Z
}
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	cf 91       	pop	r28
    1804:	df 91       	pop	r29
    1806:	08 95       	ret

00001808 <main>:

#include "UserTasks.h"


void main(void)
{
    1808:	ef 92       	push	r14
    180a:	ff 92       	push	r15
    180c:	0f 93       	push	r16
    180e:	df 93       	push	r29
    1810:	cf 93       	push	r28
    1812:	cd b7       	in	r28, 0x3d	; 61
    1814:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    1816:	83 ec       	ldi	r24, 0xC3	; 195
    1818:	92 e0       	ldi	r25, 0x02	; 2
    181a:	29 ec       	ldi	r18, 0xC9	; 201
    181c:	30 e0       	ldi	r19, 0x00	; 0
    181e:	ea ed       	ldi	r30, 0xDA	; 218
    1820:	f0 e0       	ldi	r31, 0x00	; 0
    1822:	b9 01       	movw	r22, r18
    1824:	46 e9       	ldi	r20, 0x96	; 150
    1826:	50 e0       	ldi	r21, 0x00	; 0
    1828:	20 e0       	ldi	r18, 0x00	; 0
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	05 e0       	ldi	r16, 0x05	; 5
    182e:	7f 01       	movw	r14, r30
    1830:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &InitTask_Flag);

	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    1834:	8c e0       	ldi	r24, 0x0C	; 12
    1836:	61 e0       	ldi	r22, 0x01	; 1
    1838:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	vTaskStartScheduler();
    183c:	0e 94 09 22 	call	0x4412	; 0x4412 <vTaskStartScheduler>
    1840:	ff cf       	rjmp	.-2      	; 0x1840 <main+0x38>

00001842 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1842:	df 93       	push	r29
    1844:	cf 93       	push	r28
    1846:	cd b7       	in	r28, 0x3d	; 61
    1848:	de b7       	in	r29, 0x3e	; 62
    184a:	28 97       	sbiw	r28, 0x08	; 8
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	de bf       	out	0x3e, r29	; 62
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	cd bf       	out	0x3d, r28	; 61
    1856:	9c 83       	std	Y+4, r25	; 0x04
    1858:	8b 83       	std	Y+3, r24	; 0x03
    185a:	7e 83       	std	Y+6, r23	; 0x06
    185c:	6d 83       	std	Y+5, r22	; 0x05
    185e:	58 87       	std	Y+8, r21	; 0x08
    1860:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1862:	eb 81       	ldd	r30, Y+3	; 0x03
    1864:	fc 81       	ldd	r31, Y+4	; 0x04
    1866:	81 e1       	ldi	r24, 0x11	; 17
    1868:	80 83       	st	Z, r24
	pxTopOfStack--;
    186a:	8b 81       	ldd	r24, Y+3	; 0x03
    186c:	9c 81       	ldd	r25, Y+4	; 0x04
    186e:	01 97       	sbiw	r24, 0x01	; 1
    1870:	9c 83       	std	Y+4, r25	; 0x04
    1872:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1874:	eb 81       	ldd	r30, Y+3	; 0x03
    1876:	fc 81       	ldd	r31, Y+4	; 0x04
    1878:	82 e2       	ldi	r24, 0x22	; 34
    187a:	80 83       	st	Z, r24
	pxTopOfStack--;
    187c:	8b 81       	ldd	r24, Y+3	; 0x03
    187e:	9c 81       	ldd	r25, Y+4	; 0x04
    1880:	01 97       	sbiw	r24, 0x01	; 1
    1882:	9c 83       	std	Y+4, r25	; 0x04
    1884:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1886:	eb 81       	ldd	r30, Y+3	; 0x03
    1888:	fc 81       	ldd	r31, Y+4	; 0x04
    188a:	83 e3       	ldi	r24, 0x33	; 51
    188c:	80 83       	st	Z, r24
	pxTopOfStack--;
    188e:	8b 81       	ldd	r24, Y+3	; 0x03
    1890:	9c 81       	ldd	r25, Y+4	; 0x04
    1892:	01 97       	sbiw	r24, 0x01	; 1
    1894:	9c 83       	std	Y+4, r25	; 0x04
    1896:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1898:	8d 81       	ldd	r24, Y+5	; 0x05
    189a:	9e 81       	ldd	r25, Y+6	; 0x06
    189c:	9a 83       	std	Y+2, r25	; 0x02
    189e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    18a0:	89 81       	ldd	r24, Y+1	; 0x01
    18a2:	eb 81       	ldd	r30, Y+3	; 0x03
    18a4:	fc 81       	ldd	r31, Y+4	; 0x04
    18a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	9c 83       	std	Y+4, r25	; 0x04
    18b0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	9a 81       	ldd	r25, Y+2	; 0x02
    18b6:	89 2f       	mov	r24, r25
    18b8:	99 27       	eor	r25, r25
    18ba:	9a 83       	std	Y+2, r25	; 0x02
    18bc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    18be:	89 81       	ldd	r24, Y+1	; 0x01
    18c0:	eb 81       	ldd	r30, Y+3	; 0x03
    18c2:	fc 81       	ldd	r31, Y+4	; 0x04
    18c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	9c 81       	ldd	r25, Y+4	; 0x04
    18ca:	01 97       	sbiw	r24, 0x01	; 1
    18cc:	9c 83       	std	Y+4, r25	; 0x04
    18ce:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    18d0:	eb 81       	ldd	r30, Y+3	; 0x03
    18d2:	fc 81       	ldd	r31, Y+4	; 0x04
    18d4:	10 82       	st	Z, r1
	pxTopOfStack--;
    18d6:	8b 81       	ldd	r24, Y+3	; 0x03
    18d8:	9c 81       	ldd	r25, Y+4	; 0x04
    18da:	01 97       	sbiw	r24, 0x01	; 1
    18dc:	9c 83       	std	Y+4, r25	; 0x04
    18de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    18e0:	eb 81       	ldd	r30, Y+3	; 0x03
    18e2:	fc 81       	ldd	r31, Y+4	; 0x04
    18e4:	80 e8       	ldi	r24, 0x80	; 128
    18e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18e8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ea:	9c 81       	ldd	r25, Y+4	; 0x04
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	9c 83       	std	Y+4, r25	; 0x04
    18f0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    18f2:	eb 81       	ldd	r30, Y+3	; 0x03
    18f4:	fc 81       	ldd	r31, Y+4	; 0x04
    18f6:	10 82       	st	Z, r1
	pxTopOfStack--;
    18f8:	8b 81       	ldd	r24, Y+3	; 0x03
    18fa:	9c 81       	ldd	r25, Y+4	; 0x04
    18fc:	01 97       	sbiw	r24, 0x01	; 1
    18fe:	9c 83       	std	Y+4, r25	; 0x04
    1900:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1902:	eb 81       	ldd	r30, Y+3	; 0x03
    1904:	fc 81       	ldd	r31, Y+4	; 0x04
    1906:	82 e0       	ldi	r24, 0x02	; 2
    1908:	80 83       	st	Z, r24
	pxTopOfStack--;
    190a:	8b 81       	ldd	r24, Y+3	; 0x03
    190c:	9c 81       	ldd	r25, Y+4	; 0x04
    190e:	01 97       	sbiw	r24, 0x01	; 1
    1910:	9c 83       	std	Y+4, r25	; 0x04
    1912:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1914:	eb 81       	ldd	r30, Y+3	; 0x03
    1916:	fc 81       	ldd	r31, Y+4	; 0x04
    1918:	83 e0       	ldi	r24, 0x03	; 3
    191a:	80 83       	st	Z, r24
	pxTopOfStack--;
    191c:	8b 81       	ldd	r24, Y+3	; 0x03
    191e:	9c 81       	ldd	r25, Y+4	; 0x04
    1920:	01 97       	sbiw	r24, 0x01	; 1
    1922:	9c 83       	std	Y+4, r25	; 0x04
    1924:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1926:	eb 81       	ldd	r30, Y+3	; 0x03
    1928:	fc 81       	ldd	r31, Y+4	; 0x04
    192a:	84 e0       	ldi	r24, 0x04	; 4
    192c:	80 83       	st	Z, r24
	pxTopOfStack--;
    192e:	8b 81       	ldd	r24, Y+3	; 0x03
    1930:	9c 81       	ldd	r25, Y+4	; 0x04
    1932:	01 97       	sbiw	r24, 0x01	; 1
    1934:	9c 83       	std	Y+4, r25	; 0x04
    1936:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1938:	eb 81       	ldd	r30, Y+3	; 0x03
    193a:	fc 81       	ldd	r31, Y+4	; 0x04
    193c:	85 e0       	ldi	r24, 0x05	; 5
    193e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	01 97       	sbiw	r24, 0x01	; 1
    1946:	9c 83       	std	Y+4, r25	; 0x04
    1948:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    194a:	eb 81       	ldd	r30, Y+3	; 0x03
    194c:	fc 81       	ldd	r31, Y+4	; 0x04
    194e:	86 e0       	ldi	r24, 0x06	; 6
    1950:	80 83       	st	Z, r24
	pxTopOfStack--;
    1952:	8b 81       	ldd	r24, Y+3	; 0x03
    1954:	9c 81       	ldd	r25, Y+4	; 0x04
    1956:	01 97       	sbiw	r24, 0x01	; 1
    1958:	9c 83       	std	Y+4, r25	; 0x04
    195a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    195c:	eb 81       	ldd	r30, Y+3	; 0x03
    195e:	fc 81       	ldd	r31, Y+4	; 0x04
    1960:	87 e0       	ldi	r24, 0x07	; 7
    1962:	80 83       	st	Z, r24
	pxTopOfStack--;
    1964:	8b 81       	ldd	r24, Y+3	; 0x03
    1966:	9c 81       	ldd	r25, Y+4	; 0x04
    1968:	01 97       	sbiw	r24, 0x01	; 1
    196a:	9c 83       	std	Y+4, r25	; 0x04
    196c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    196e:	eb 81       	ldd	r30, Y+3	; 0x03
    1970:	fc 81       	ldd	r31, Y+4	; 0x04
    1972:	88 e0       	ldi	r24, 0x08	; 8
    1974:	80 83       	st	Z, r24
	pxTopOfStack--;
    1976:	8b 81       	ldd	r24, Y+3	; 0x03
    1978:	9c 81       	ldd	r25, Y+4	; 0x04
    197a:	01 97       	sbiw	r24, 0x01	; 1
    197c:	9c 83       	std	Y+4, r25	; 0x04
    197e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1980:	eb 81       	ldd	r30, Y+3	; 0x03
    1982:	fc 81       	ldd	r31, Y+4	; 0x04
    1984:	89 e0       	ldi	r24, 0x09	; 9
    1986:	80 83       	st	Z, r24
	pxTopOfStack--;
    1988:	8b 81       	ldd	r24, Y+3	; 0x03
    198a:	9c 81       	ldd	r25, Y+4	; 0x04
    198c:	01 97       	sbiw	r24, 0x01	; 1
    198e:	9c 83       	std	Y+4, r25	; 0x04
    1990:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1992:	eb 81       	ldd	r30, Y+3	; 0x03
    1994:	fc 81       	ldd	r31, Y+4	; 0x04
    1996:	80 e1       	ldi	r24, 0x10	; 16
    1998:	80 83       	st	Z, r24
	pxTopOfStack--;
    199a:	8b 81       	ldd	r24, Y+3	; 0x03
    199c:	9c 81       	ldd	r25, Y+4	; 0x04
    199e:	01 97       	sbiw	r24, 0x01	; 1
    19a0:	9c 83       	std	Y+4, r25	; 0x04
    19a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    19a4:	eb 81       	ldd	r30, Y+3	; 0x03
    19a6:	fc 81       	ldd	r31, Y+4	; 0x04
    19a8:	81 e1       	ldi	r24, 0x11	; 17
    19aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ac:	8b 81       	ldd	r24, Y+3	; 0x03
    19ae:	9c 81       	ldd	r25, Y+4	; 0x04
    19b0:	01 97       	sbiw	r24, 0x01	; 1
    19b2:	9c 83       	std	Y+4, r25	; 0x04
    19b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    19b6:	eb 81       	ldd	r30, Y+3	; 0x03
    19b8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ba:	82 e1       	ldi	r24, 0x12	; 18
    19bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    19be:	8b 81       	ldd	r24, Y+3	; 0x03
    19c0:	9c 81       	ldd	r25, Y+4	; 0x04
    19c2:	01 97       	sbiw	r24, 0x01	; 1
    19c4:	9c 83       	std	Y+4, r25	; 0x04
    19c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    19c8:	eb 81       	ldd	r30, Y+3	; 0x03
    19ca:	fc 81       	ldd	r31, Y+4	; 0x04
    19cc:	83 e1       	ldi	r24, 0x13	; 19
    19ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    19d0:	8b 81       	ldd	r24, Y+3	; 0x03
    19d2:	9c 81       	ldd	r25, Y+4	; 0x04
    19d4:	01 97       	sbiw	r24, 0x01	; 1
    19d6:	9c 83       	std	Y+4, r25	; 0x04
    19d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    19da:	eb 81       	ldd	r30, Y+3	; 0x03
    19dc:	fc 81       	ldd	r31, Y+4	; 0x04
    19de:	84 e1       	ldi	r24, 0x14	; 20
    19e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	9c 81       	ldd	r25, Y+4	; 0x04
    19e6:	01 97       	sbiw	r24, 0x01	; 1
    19e8:	9c 83       	std	Y+4, r25	; 0x04
    19ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    19ec:	eb 81       	ldd	r30, Y+3	; 0x03
    19ee:	fc 81       	ldd	r31, Y+4	; 0x04
    19f0:	85 e1       	ldi	r24, 0x15	; 21
    19f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    19f4:	8b 81       	ldd	r24, Y+3	; 0x03
    19f6:	9c 81       	ldd	r25, Y+4	; 0x04
    19f8:	01 97       	sbiw	r24, 0x01	; 1
    19fa:	9c 83       	std	Y+4, r25	; 0x04
    19fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    19fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1a00:	fc 81       	ldd	r31, Y+4	; 0x04
    1a02:	86 e1       	ldi	r24, 0x16	; 22
    1a04:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a06:	8b 81       	ldd	r24, Y+3	; 0x03
    1a08:	9c 81       	ldd	r25, Y+4	; 0x04
    1a0a:	01 97       	sbiw	r24, 0x01	; 1
    1a0c:	9c 83       	std	Y+4, r25	; 0x04
    1a0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1a10:	eb 81       	ldd	r30, Y+3	; 0x03
    1a12:	fc 81       	ldd	r31, Y+4	; 0x04
    1a14:	87 e1       	ldi	r24, 0x17	; 23
    1a16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a18:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1c:	01 97       	sbiw	r24, 0x01	; 1
    1a1e:	9c 83       	std	Y+4, r25	; 0x04
    1a20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1a22:	eb 81       	ldd	r30, Y+3	; 0x03
    1a24:	fc 81       	ldd	r31, Y+4	; 0x04
    1a26:	88 e1       	ldi	r24, 0x18	; 24
    1a28:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2e:	01 97       	sbiw	r24, 0x01	; 1
    1a30:	9c 83       	std	Y+4, r25	; 0x04
    1a32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1a34:	eb 81       	ldd	r30, Y+3	; 0x03
    1a36:	fc 81       	ldd	r31, Y+4	; 0x04
    1a38:	89 e1       	ldi	r24, 0x19	; 25
    1a3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a40:	01 97       	sbiw	r24, 0x01	; 1
    1a42:	9c 83       	std	Y+4, r25	; 0x04
    1a44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1a46:	eb 81       	ldd	r30, Y+3	; 0x03
    1a48:	fc 81       	ldd	r31, Y+4	; 0x04
    1a4a:	80 e2       	ldi	r24, 0x20	; 32
    1a4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a50:	9c 81       	ldd	r25, Y+4	; 0x04
    1a52:	01 97       	sbiw	r24, 0x01	; 1
    1a54:	9c 83       	std	Y+4, r25	; 0x04
    1a56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1a58:	eb 81       	ldd	r30, Y+3	; 0x03
    1a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a5c:	81 e2       	ldi	r24, 0x21	; 33
    1a5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	9c 83       	std	Y+4, r25	; 0x04
    1a68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a6e:	82 e2       	ldi	r24, 0x22	; 34
    1a70:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a72:	8b 81       	ldd	r24, Y+3	; 0x03
    1a74:	9c 81       	ldd	r25, Y+4	; 0x04
    1a76:	01 97       	sbiw	r24, 0x01	; 1
    1a78:	9c 83       	std	Y+4, r25	; 0x04
    1a7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a80:	83 e2       	ldi	r24, 0x23	; 35
    1a82:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a84:	8b 81       	ldd	r24, Y+3	; 0x03
    1a86:	9c 81       	ldd	r25, Y+4	; 0x04
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	9c 83       	std	Y+4, r25	; 0x04
    1a8c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1a8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1a90:	98 85       	ldd	r25, Y+8	; 0x08
    1a92:	9a 83       	std	Y+2, r25	; 0x02
    1a94:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a9c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa2:	01 97       	sbiw	r24, 0x01	; 1
    1aa4:	9c 83       	std	Y+4, r25	; 0x04
    1aa6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	89 2f       	mov	r24, r25
    1aae:	99 27       	eor	r25, r25
    1ab0:	9a 83       	std	Y+2, r25	; 0x02
    1ab2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1ab4:	89 81       	ldd	r24, Y+1	; 0x01
    1ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aba:	80 83       	st	Z, r24
	pxTopOfStack--;
    1abc:	8b 81       	ldd	r24, Y+3	; 0x03
    1abe:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac0:	01 97       	sbiw	r24, 0x01	; 1
    1ac2:	9c 83       	std	Y+4, r25	; 0x04
    1ac4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1ac6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aca:	86 e2       	ldi	r24, 0x26	; 38
    1acc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ace:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad2:	01 97       	sbiw	r24, 0x01	; 1
    1ad4:	9c 83       	std	Y+4, r25	; 0x04
    1ad6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    1ada:	fc 81       	ldd	r31, Y+4	; 0x04
    1adc:	87 e2       	ldi	r24, 0x27	; 39
    1ade:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae4:	01 97       	sbiw	r24, 0x01	; 1
    1ae6:	9c 83       	std	Y+4, r25	; 0x04
    1ae8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1aea:	eb 81       	ldd	r30, Y+3	; 0x03
    1aec:	fc 81       	ldd	r31, Y+4	; 0x04
    1aee:	88 e2       	ldi	r24, 0x28	; 40
    1af0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1af2:	8b 81       	ldd	r24, Y+3	; 0x03
    1af4:	9c 81       	ldd	r25, Y+4	; 0x04
    1af6:	01 97       	sbiw	r24, 0x01	; 1
    1af8:	9c 83       	std	Y+4, r25	; 0x04
    1afa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1afc:	eb 81       	ldd	r30, Y+3	; 0x03
    1afe:	fc 81       	ldd	r31, Y+4	; 0x04
    1b00:	89 e2       	ldi	r24, 0x29	; 41
    1b02:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b04:	8b 81       	ldd	r24, Y+3	; 0x03
    1b06:	9c 81       	ldd	r25, Y+4	; 0x04
    1b08:	01 97       	sbiw	r24, 0x01	; 1
    1b0a:	9c 83       	std	Y+4, r25	; 0x04
    1b0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b10:	fc 81       	ldd	r31, Y+4	; 0x04
    1b12:	80 e3       	ldi	r24, 0x30	; 48
    1b14:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b16:	8b 81       	ldd	r24, Y+3	; 0x03
    1b18:	9c 81       	ldd	r25, Y+4	; 0x04
    1b1a:	01 97       	sbiw	r24, 0x01	; 1
    1b1c:	9c 83       	std	Y+4, r25	; 0x04
    1b1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1b20:	eb 81       	ldd	r30, Y+3	; 0x03
    1b22:	fc 81       	ldd	r31, Y+4	; 0x04
    1b24:	81 e3       	ldi	r24, 0x31	; 49
    1b26:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	01 97       	sbiw	r24, 0x01	; 1
    1b2e:	9c 83       	std	Y+4, r25	; 0x04
    1b30:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1b32:	8b 81       	ldd	r24, Y+3	; 0x03
    1b34:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1b36:	28 96       	adiw	r28, 0x08	; 8
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	de bf       	out	0x3e, r29	; 62
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	cd bf       	out	0x3d, r28	; 61
    1b42:	cf 91       	pop	r28
    1b44:	df 91       	pop	r29
    1b46:	08 95       	ret

00001b48 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1b48:	df 93       	push	r29
    1b4a:	cf 93       	push	r28
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1b50:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1b54:	a0 91 c0 06 	lds	r26, 0x06C0
    1b58:	b0 91 c1 06 	lds	r27, 0x06C1
    1b5c:	cd 91       	ld	r28, X+
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	dd 91       	ld	r29, X+
    1b62:	de bf       	out	0x3e, r29	; 62
    1b64:	ff 91       	pop	r31
    1b66:	ef 91       	pop	r30
    1b68:	df 91       	pop	r29
    1b6a:	cf 91       	pop	r28
    1b6c:	bf 91       	pop	r27
    1b6e:	af 91       	pop	r26
    1b70:	9f 91       	pop	r25
    1b72:	8f 91       	pop	r24
    1b74:	7f 91       	pop	r23
    1b76:	6f 91       	pop	r22
    1b78:	5f 91       	pop	r21
    1b7a:	4f 91       	pop	r20
    1b7c:	3f 91       	pop	r19
    1b7e:	2f 91       	pop	r18
    1b80:	1f 91       	pop	r17
    1b82:	0f 91       	pop	r16
    1b84:	ff 90       	pop	r15
    1b86:	ef 90       	pop	r14
    1b88:	df 90       	pop	r13
    1b8a:	cf 90       	pop	r12
    1b8c:	bf 90       	pop	r11
    1b8e:	af 90       	pop	r10
    1b90:	9f 90       	pop	r9
    1b92:	8f 90       	pop	r8
    1b94:	7f 90       	pop	r7
    1b96:	6f 90       	pop	r6
    1b98:	5f 90       	pop	r5
    1b9a:	4f 90       	pop	r4
    1b9c:	3f 90       	pop	r3
    1b9e:	2f 90       	pop	r2
    1ba0:	1f 90       	pop	r1
    1ba2:	0f 90       	pop	r0
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1ba8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1baa:	81 e0       	ldi	r24, 0x01	; 1
}
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1bb2:	df 93       	push	r29
    1bb4:	cf 93       	push	r28
    1bb6:	cd b7       	in	r28, 0x3d	; 61
    1bb8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1bba:	cf 91       	pop	r28
    1bbc:	df 91       	pop	r29
    1bbe:	08 95       	ret

00001bc0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1bc0:	0f 92       	push	r0
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	0f 92       	push	r0
    1bc8:	1f 92       	push	r1
    1bca:	11 24       	eor	r1, r1
    1bcc:	2f 92       	push	r2
    1bce:	3f 92       	push	r3
    1bd0:	4f 92       	push	r4
    1bd2:	5f 92       	push	r5
    1bd4:	6f 92       	push	r6
    1bd6:	7f 92       	push	r7
    1bd8:	8f 92       	push	r8
    1bda:	9f 92       	push	r9
    1bdc:	af 92       	push	r10
    1bde:	bf 92       	push	r11
    1be0:	cf 92       	push	r12
    1be2:	df 92       	push	r13
    1be4:	ef 92       	push	r14
    1be6:	ff 92       	push	r15
    1be8:	0f 93       	push	r16
    1bea:	1f 93       	push	r17
    1bec:	2f 93       	push	r18
    1bee:	3f 93       	push	r19
    1bf0:	4f 93       	push	r20
    1bf2:	5f 93       	push	r21
    1bf4:	6f 93       	push	r22
    1bf6:	7f 93       	push	r23
    1bf8:	8f 93       	push	r24
    1bfa:	9f 93       	push	r25
    1bfc:	af 93       	push	r26
    1bfe:	bf 93       	push	r27
    1c00:	cf 93       	push	r28
    1c02:	df 93       	push	r29
    1c04:	ef 93       	push	r30
    1c06:	ff 93       	push	r31
    1c08:	a0 91 c0 06 	lds	r26, 0x06C0
    1c0c:	b0 91 c1 06 	lds	r27, 0x06C1
    1c10:	0d b6       	in	r0, 0x3d	; 61
    1c12:	0d 92       	st	X+, r0
    1c14:	0e b6       	in	r0, 0x3e	; 62
    1c16:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c18:	0e 94 28 24 	call	0x4850	; 0x4850 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c1c:	a0 91 c0 06 	lds	r26, 0x06C0
    1c20:	b0 91 c1 06 	lds	r27, 0x06C1
    1c24:	cd 91       	ld	r28, X+
    1c26:	cd bf       	out	0x3d, r28	; 61
    1c28:	dd 91       	ld	r29, X+
    1c2a:	de bf       	out	0x3e, r29	; 62
    1c2c:	ff 91       	pop	r31
    1c2e:	ef 91       	pop	r30
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	bf 91       	pop	r27
    1c36:	af 91       	pop	r26
    1c38:	9f 91       	pop	r25
    1c3a:	8f 91       	pop	r24
    1c3c:	7f 91       	pop	r23
    1c3e:	6f 91       	pop	r22
    1c40:	5f 91       	pop	r21
    1c42:	4f 91       	pop	r20
    1c44:	3f 91       	pop	r19
    1c46:	2f 91       	pop	r18
    1c48:	1f 91       	pop	r17
    1c4a:	0f 91       	pop	r16
    1c4c:	ff 90       	pop	r15
    1c4e:	ef 90       	pop	r14
    1c50:	df 90       	pop	r13
    1c52:	cf 90       	pop	r12
    1c54:	bf 90       	pop	r11
    1c56:	af 90       	pop	r10
    1c58:	9f 90       	pop	r9
    1c5a:	8f 90       	pop	r8
    1c5c:	7f 90       	pop	r7
    1c5e:	6f 90       	pop	r6
    1c60:	5f 90       	pop	r5
    1c62:	4f 90       	pop	r4
    1c64:	3f 90       	pop	r3
    1c66:	2f 90       	pop	r2
    1c68:	1f 90       	pop	r1
    1c6a:	0f 90       	pop	r0
    1c6c:	0f be       	out	0x3f, r0	; 63
    1c6e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c70:	08 95       	ret

00001c72 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c72:	0f 92       	push	r0
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	0f 92       	push	r0
    1c7a:	1f 92       	push	r1
    1c7c:	11 24       	eor	r1, r1
    1c7e:	2f 92       	push	r2
    1c80:	3f 92       	push	r3
    1c82:	4f 92       	push	r4
    1c84:	5f 92       	push	r5
    1c86:	6f 92       	push	r6
    1c88:	7f 92       	push	r7
    1c8a:	8f 92       	push	r8
    1c8c:	9f 92       	push	r9
    1c8e:	af 92       	push	r10
    1c90:	bf 92       	push	r11
    1c92:	cf 92       	push	r12
    1c94:	df 92       	push	r13
    1c96:	ef 92       	push	r14
    1c98:	ff 92       	push	r15
    1c9a:	0f 93       	push	r16
    1c9c:	1f 93       	push	r17
    1c9e:	2f 93       	push	r18
    1ca0:	3f 93       	push	r19
    1ca2:	4f 93       	push	r20
    1ca4:	5f 93       	push	r21
    1ca6:	6f 93       	push	r22
    1ca8:	7f 93       	push	r23
    1caa:	8f 93       	push	r24
    1cac:	9f 93       	push	r25
    1cae:	af 93       	push	r26
    1cb0:	bf 93       	push	r27
    1cb2:	cf 93       	push	r28
    1cb4:	df 93       	push	r29
    1cb6:	ef 93       	push	r30
    1cb8:	ff 93       	push	r31
    1cba:	a0 91 c0 06 	lds	r26, 0x06C0
    1cbe:	b0 91 c1 06 	lds	r27, 0x06C1
    1cc2:	0d b6       	in	r0, 0x3d	; 61
    1cc4:	0d 92       	st	X+, r0
    1cc6:	0e b6       	in	r0, 0x3e	; 62
    1cc8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1cca:	0e 94 43 23 	call	0x4686	; 0x4686 <xTaskIncrementTick>
    1cce:	88 23       	and	r24, r24
    1cd0:	11 f0       	breq	.+4      	; 0x1cd6 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1cd2:	0e 94 28 24 	call	0x4850	; 0x4850 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1cd6:	a0 91 c0 06 	lds	r26, 0x06C0
    1cda:	b0 91 c1 06 	lds	r27, 0x06C1
    1cde:	cd 91       	ld	r28, X+
    1ce0:	cd bf       	out	0x3d, r28	; 61
    1ce2:	dd 91       	ld	r29, X+
    1ce4:	de bf       	out	0x3e, r29	; 62
    1ce6:	ff 91       	pop	r31
    1ce8:	ef 91       	pop	r30
    1cea:	df 91       	pop	r29
    1cec:	cf 91       	pop	r28
    1cee:	bf 91       	pop	r27
    1cf0:	af 91       	pop	r26
    1cf2:	9f 91       	pop	r25
    1cf4:	8f 91       	pop	r24
    1cf6:	7f 91       	pop	r23
    1cf8:	6f 91       	pop	r22
    1cfa:	5f 91       	pop	r21
    1cfc:	4f 91       	pop	r20
    1cfe:	3f 91       	pop	r19
    1d00:	2f 91       	pop	r18
    1d02:	1f 91       	pop	r17
    1d04:	0f 91       	pop	r16
    1d06:	ff 90       	pop	r15
    1d08:	ef 90       	pop	r14
    1d0a:	df 90       	pop	r13
    1d0c:	cf 90       	pop	r12
    1d0e:	bf 90       	pop	r11
    1d10:	af 90       	pop	r10
    1d12:	9f 90       	pop	r9
    1d14:	8f 90       	pop	r8
    1d16:	7f 90       	pop	r7
    1d18:	6f 90       	pop	r6
    1d1a:	5f 90       	pop	r5
    1d1c:	4f 90       	pop	r4
    1d1e:	3f 90       	pop	r3
    1d20:	2f 90       	pop	r2
    1d22:	1f 90       	pop	r1
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63
    1d28:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d2a:	08 95       	ret

00001d2c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1d2c:	df 93       	push	r29
    1d2e:	cf 93       	push	r28
    1d30:	00 d0       	rcall	.+0      	; 0x1d32 <prvSetupTimerInterrupt+0x6>
    1d32:	00 d0       	rcall	.+0      	; 0x1d34 <prvSetupTimerInterrupt+0x8>
    1d34:	00 d0       	rcall	.+0      	; 0x1d36 <prvSetupTimerInterrupt+0xa>
    1d36:	cd b7       	in	r28, 0x3d	; 61
    1d38:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1d3a:	80 e4       	ldi	r24, 0x40	; 64
    1d3c:	9f e1       	ldi	r25, 0x1F	; 31
    1d3e:	a0 e0       	ldi	r26, 0x00	; 0
    1d40:	b0 e0       	ldi	r27, 0x00	; 0
    1d42:	8b 83       	std	Y+3, r24	; 0x03
    1d44:	9c 83       	std	Y+4, r25	; 0x04
    1d46:	ad 83       	std	Y+5, r26	; 0x05
    1d48:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d4e:	ad 81       	ldd	r26, Y+5	; 0x05
    1d50:	be 81       	ldd	r27, Y+6	; 0x06
    1d52:	68 94       	set
    1d54:	15 f8       	bld	r1, 5
    1d56:	b6 95       	lsr	r27
    1d58:	a7 95       	ror	r26
    1d5a:	97 95       	ror	r25
    1d5c:	87 95       	ror	r24
    1d5e:	16 94       	lsr	r1
    1d60:	d1 f7       	brne	.-12     	; 0x1d56 <prvSetupTimerInterrupt+0x2a>
    1d62:	8b 83       	std	Y+3, r24	; 0x03
    1d64:	9c 83       	std	Y+4, r25	; 0x04
    1d66:	ad 83       	std	Y+5, r26	; 0x05
    1d68:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6e:	ad 81       	ldd	r26, Y+5	; 0x05
    1d70:	be 81       	ldd	r27, Y+6	; 0x06
    1d72:	01 97       	sbiw	r24, 0x01	; 1
    1d74:	a1 09       	sbc	r26, r1
    1d76:	b1 09       	sbc	r27, r1
    1d78:	8b 83       	std	Y+3, r24	; 0x03
    1d7a:	9c 83       	std	Y+4, r25	; 0x04
    1d7c:	ad 83       	std	Y+5, r26	; 0x05
    1d7e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1d80:	8b 81       	ldd	r24, Y+3	; 0x03
    1d82:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1d84:	8b 81       	ldd	r24, Y+3	; 0x03
    1d86:	9c 81       	ldd	r25, Y+4	; 0x04
    1d88:	ad 81       	ldd	r26, Y+5	; 0x05
    1d8a:	be 81       	ldd	r27, Y+6	; 0x06
    1d8c:	89 2f       	mov	r24, r25
    1d8e:	9a 2f       	mov	r25, r26
    1d90:	ab 2f       	mov	r26, r27
    1d92:	bb 27       	eor	r27, r27
    1d94:	8b 83       	std	Y+3, r24	; 0x03
    1d96:	9c 83       	std	Y+4, r25	; 0x04
    1d98:	ad 83       	std	Y+5, r26	; 0x05
    1d9a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1d9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d9e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1da0:	eb e4       	ldi	r30, 0x4B	; 75
    1da2:	f0 e0       	ldi	r31, 0x00	; 0
    1da4:	8a 81       	ldd	r24, Y+2	; 0x02
    1da6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1da8:	ea e4       	ldi	r30, 0x4A	; 74
    1daa:	f0 e0       	ldi	r31, 0x00	; 0
    1dac:	89 81       	ldd	r24, Y+1	; 0x01
    1dae:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1db0:	8b e0       	ldi	r24, 0x0B	; 11
    1db2:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1db4:	ee e4       	ldi	r30, 0x4E	; 78
    1db6:	f0 e0       	ldi	r31, 0x00	; 0
    1db8:	89 81       	ldd	r24, Y+1	; 0x01
    1dba:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1dbc:	e9 e5       	ldi	r30, 0x59	; 89
    1dbe:	f0 e0       	ldi	r31, 0x00	; 0
    1dc0:	80 81       	ld	r24, Z
    1dc2:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1dc4:	89 81       	ldd	r24, Y+1	; 0x01
    1dc6:	80 61       	ori	r24, 0x10	; 16
    1dc8:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1dca:	e9 e5       	ldi	r30, 0x59	; 89
    1dcc:	f0 e0       	ldi	r31, 0x00	; 0
    1dce:	89 81       	ldd	r24, Y+1	; 0x01
    1dd0:	80 83       	st	Z, r24
}
    1dd2:	26 96       	adiw	r28, 0x06	; 6
    1dd4:	0f b6       	in	r0, 0x3f	; 63
    1dd6:	f8 94       	cli
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	0f be       	out	0x3f, r0	; 63
    1ddc:	cd bf       	out	0x3d, r28	; 61
    1dde:	cf 91       	pop	r28
    1de0:	df 91       	pop	r29
    1de2:	08 95       	ret

00001de4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1de4:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1de8:	18 95       	reti

00001dea <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1dea:	df 93       	push	r29
    1dec:	cf 93       	push	r28
    1dee:	00 d0       	rcall	.+0      	; 0x1df0 <xQueueGenericReset+0x6>
    1df0:	00 d0       	rcall	.+0      	; 0x1df2 <xQueueGenericReset+0x8>
    1df2:	0f 92       	push	r0
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	9c 83       	std	Y+4, r25	; 0x04
    1dfa:	8b 83       	std	Y+3, r24	; 0x03
    1dfc:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1e00:	9c 81       	ldd	r25, Y+4	; 0x04
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e06:	0f b6       	in	r0, 0x3f	; 63
    1e08:	f8 94       	cli
    1e0a:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e10:	40 81       	ld	r20, Z
    1e12:	51 81       	ldd	r21, Z+1	; 0x01
    1e14:	e9 81       	ldd	r30, Y+1	; 0x01
    1e16:	fa 81       	ldd	r31, Y+2	; 0x02
    1e18:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e1a:	28 2f       	mov	r18, r24
    1e1c:	30 e0       	ldi	r19, 0x00	; 0
    1e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e20:	fa 81       	ldd	r31, Y+2	; 0x02
    1e22:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e24:	88 2f       	mov	r24, r24
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	bc 01       	movw	r22, r24
    1e2a:	26 9f       	mul	r18, r22
    1e2c:	c0 01       	movw	r24, r0
    1e2e:	27 9f       	mul	r18, r23
    1e30:	90 0d       	add	r25, r0
    1e32:	36 9f       	mul	r19, r22
    1e34:	90 0d       	add	r25, r0
    1e36:	11 24       	eor	r1, r1
    1e38:	84 0f       	add	r24, r20
    1e3a:	95 1f       	adc	r25, r21
    1e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e40:	95 83       	std	Z+5, r25	; 0x05
    1e42:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e44:	e9 81       	ldd	r30, Y+1	; 0x01
    1e46:	fa 81       	ldd	r31, Y+2	; 0x02
    1e48:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4e:	80 81       	ld	r24, Z
    1e50:	91 81       	ldd	r25, Z+1	; 0x01
    1e52:	e9 81       	ldd	r30, Y+1	; 0x01
    1e54:	fa 81       	ldd	r31, Y+2	; 0x02
    1e56:	93 83       	std	Z+3, r25	; 0x03
    1e58:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5e:	40 81       	ld	r20, Z
    1e60:	51 81       	ldd	r21, Z+1	; 0x01
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e68:	88 2f       	mov	r24, r24
    1e6a:	90 e0       	ldi	r25, 0x00	; 0
    1e6c:	9c 01       	movw	r18, r24
    1e6e:	21 50       	subi	r18, 0x01	; 1
    1e70:	30 40       	sbci	r19, 0x00	; 0
    1e72:	e9 81       	ldd	r30, Y+1	; 0x01
    1e74:	fa 81       	ldd	r31, Y+2	; 0x02
    1e76:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e78:	88 2f       	mov	r24, r24
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	bc 01       	movw	r22, r24
    1e7e:	26 9f       	mul	r18, r22
    1e80:	c0 01       	movw	r24, r0
    1e82:	27 9f       	mul	r18, r23
    1e84:	90 0d       	add	r25, r0
    1e86:	36 9f       	mul	r19, r22
    1e88:	90 0d       	add	r25, r0
    1e8a:	11 24       	eor	r1, r1
    1e8c:	84 0f       	add	r24, r20
    1e8e:	95 1f       	adc	r25, r21
    1e90:	e9 81       	ldd	r30, Y+1	; 0x01
    1e92:	fa 81       	ldd	r31, Y+2	; 0x02
    1e94:	97 83       	std	Z+7, r25	; 0x07
    1e96:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1e98:	e9 81       	ldd	r30, Y+1	; 0x01
    1e9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e9c:	8f ef       	ldi	r24, 0xFF	; 255
    1e9e:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea4:	8f ef       	ldi	r24, 0xFF	; 255
    1ea6:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1ea8:	8d 81       	ldd	r24, Y+5	; 0x05
    1eaa:	88 23       	and	r24, r24
    1eac:	79 f4       	brne	.+30     	; 0x1ecc <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1eae:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb2:	80 85       	ldd	r24, Z+8	; 0x08
    1eb4:	88 23       	and	r24, r24
    1eb6:	a1 f0       	breq	.+40     	; 0x1ee0 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eb8:	89 81       	ldd	r24, Y+1	; 0x01
    1eba:	9a 81       	ldd	r25, Y+2	; 0x02
    1ebc:	08 96       	adiw	r24, 0x08	; 8
    1ebe:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    1ec2:	88 23       	and	r24, r24
    1ec4:	69 f0       	breq	.+26     	; 0x1ee0 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1ec6:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    1eca:	0a c0       	rjmp	.+20     	; 0x1ee0 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1ecc:	89 81       	ldd	r24, Y+1	; 0x01
    1ece:	9a 81       	ldd	r25, Y+2	; 0x02
    1ed0:	08 96       	adiw	r24, 0x08	; 8
    1ed2:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    1eda:	41 96       	adiw	r24, 0x11	; 17
    1edc:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
}
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	0f 90       	pop	r0
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	cf 91       	pop	r28
    1ef2:	df 91       	pop	r29
    1ef4:	08 95       	ret

00001ef6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1ef6:	0f 93       	push	r16
    1ef8:	1f 93       	push	r17
    1efa:	df 93       	push	r29
    1efc:	cf 93       	push	r28
    1efe:	cd b7       	in	r28, 0x3d	; 61
    1f00:	de b7       	in	r29, 0x3e	; 62
    1f02:	29 97       	sbiw	r28, 0x09	; 9
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	8f 83       	std	Y+7, r24	; 0x07
    1f10:	68 87       	std	Y+8, r22	; 0x08
    1f12:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1f14:	88 85       	ldd	r24, Y+8	; 0x08
    1f16:	88 23       	and	r24, r24
    1f18:	19 f4       	brne	.+6      	; 0x1f20 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1f1a:	1c 82       	std	Y+4, r1	; 0x04
    1f1c:	1b 82       	std	Y+3, r1	; 0x03
    1f1e:	10 c0       	rjmp	.+32     	; 0x1f40 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f20:	8f 81       	ldd	r24, Y+7	; 0x07
    1f22:	28 2f       	mov	r18, r24
    1f24:	30 e0       	ldi	r19, 0x00	; 0
    1f26:	88 85       	ldd	r24, Y+8	; 0x08
    1f28:	88 2f       	mov	r24, r24
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	ac 01       	movw	r20, r24
    1f2e:	24 9f       	mul	r18, r20
    1f30:	c0 01       	movw	r24, r0
    1f32:	25 9f       	mul	r18, r21
    1f34:	90 0d       	add	r25, r0
    1f36:	34 9f       	mul	r19, r20
    1f38:	90 0d       	add	r25, r0
    1f3a:	11 24       	eor	r1, r1
    1f3c:	9c 83       	std	Y+4, r25	; 0x04
    1f3e:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1f40:	8b 81       	ldd	r24, Y+3	; 0x03
    1f42:	9c 81       	ldd	r25, Y+4	; 0x04
    1f44:	4f 96       	adiw	r24, 0x1f	; 31
    1f46:	0e 94 c9 08 	call	0x1192	; 0x1192 <pvPortMalloc>
    1f4a:	9e 83       	std	Y+6, r25	; 0x06
    1f4c:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f50:	9e 81       	ldd	r25, Y+6	; 0x06
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	a1 f0       	breq	.+40     	; 0x1f7e <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1f56:	8d 81       	ldd	r24, Y+5	; 0x05
    1f58:	9e 81       	ldd	r25, Y+6	; 0x06
    1f5a:	9a 83       	std	Y+2, r25	; 0x02
    1f5c:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f5e:	89 81       	ldd	r24, Y+1	; 0x01
    1f60:	9a 81       	ldd	r25, Y+2	; 0x02
    1f62:	4f 96       	adiw	r24, 0x1f	; 31
    1f64:	9a 83       	std	Y+2, r25	; 0x02
    1f66:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1f68:	29 81       	ldd	r18, Y+1	; 0x01
    1f6a:	3a 81       	ldd	r19, Y+2	; 0x02
    1f6c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f6e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f70:	8f 81       	ldd	r24, Y+7	; 0x07
    1f72:	68 85       	ldd	r22, Y+8	; 0x08
    1f74:	a9 01       	movw	r20, r18
    1f76:	29 85       	ldd	r18, Y+9	; 0x09
    1f78:	8f 01       	movw	r16, r30
    1f7a:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1f7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f80:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1f82:	29 96       	adiw	r28, 0x09	; 9
    1f84:	0f b6       	in	r0, 0x3f	; 63
    1f86:	f8 94       	cli
    1f88:	de bf       	out	0x3e, r29	; 62
    1f8a:	0f be       	out	0x3f, r0	; 63
    1f8c:	cd bf       	out	0x3d, r28	; 61
    1f8e:	cf 91       	pop	r28
    1f90:	df 91       	pop	r29
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	08 95       	ret

00001f98 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1f98:	0f 93       	push	r16
    1f9a:	1f 93       	push	r17
    1f9c:	df 93       	push	r29
    1f9e:	cf 93       	push	r28
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	27 97       	sbiw	r28, 0x07	; 7
    1fa6:	0f b6       	in	r0, 0x3f	; 63
    1fa8:	f8 94       	cli
    1faa:	de bf       	out	0x3e, r29	; 62
    1fac:	0f be       	out	0x3f, r0	; 63
    1fae:	cd bf       	out	0x3d, r28	; 61
    1fb0:	89 83       	std	Y+1, r24	; 0x01
    1fb2:	6a 83       	std	Y+2, r22	; 0x02
    1fb4:	5c 83       	std	Y+4, r21	; 0x04
    1fb6:	4b 83       	std	Y+3, r20	; 0x03
    1fb8:	2d 83       	std	Y+5, r18	; 0x05
    1fba:	1f 83       	std	Y+7, r17	; 0x07
    1fbc:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc0:	88 23       	and	r24, r24
    1fc2:	39 f4       	brne	.+14     	; 0x1fd2 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1fc4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fc6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fc8:	ee 81       	ldd	r30, Y+6	; 0x06
    1fca:	ff 81       	ldd	r31, Y+7	; 0x07
    1fcc:	91 83       	std	Z+1, r25	; 0x01
    1fce:	80 83       	st	Z, r24
    1fd0:	06 c0       	rjmp	.+12     	; 0x1fde <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	ee 81       	ldd	r30, Y+6	; 0x06
    1fd8:	ff 81       	ldd	r31, Y+7	; 0x07
    1fda:	91 83       	std	Z+1, r25	; 0x01
    1fdc:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1fde:	ee 81       	ldd	r30, Y+6	; 0x06
    1fe0:	ff 81       	ldd	r31, Y+7	; 0x07
    1fe2:	89 81       	ldd	r24, Y+1	; 0x01
    1fe4:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1fe6:	ee 81       	ldd	r30, Y+6	; 0x06
    1fe8:	ff 81       	ldd	r31, Y+7	; 0x07
    1fea:	8a 81       	ldd	r24, Y+2	; 0x02
    1fec:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1fee:	8e 81       	ldd	r24, Y+6	; 0x06
    1ff0:	9f 81       	ldd	r25, Y+7	; 0x07
    1ff2:	61 e0       	ldi	r22, 0x01	; 1
    1ff4:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1ff8:	27 96       	adiw	r28, 0x07	; 7
    1ffa:	0f b6       	in	r0, 0x3f	; 63
    1ffc:	f8 94       	cli
    1ffe:	de bf       	out	0x3e, r29	; 62
    2000:	0f be       	out	0x3f, r0	; 63
    2002:	cd bf       	out	0x3d, r28	; 61
    2004:	cf 91       	pop	r28
    2006:	df 91       	pop	r29
    2008:	1f 91       	pop	r17
    200a:	0f 91       	pop	r16
    200c:	08 95       	ret

0000200e <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    200e:	df 93       	push	r29
    2010:	cf 93       	push	r28
    2012:	00 d0       	rcall	.+0      	; 0x2014 <prvInitialiseMutex+0x6>
    2014:	cd b7       	in	r28, 0x3d	; 61
    2016:	de b7       	in	r29, 0x3e	; 62
    2018:	9a 83       	std	Y+2, r25	; 0x02
    201a:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    201c:	89 81       	ldd	r24, Y+1	; 0x01
    201e:	9a 81       	ldd	r25, Y+2	; 0x02
    2020:	00 97       	sbiw	r24, 0x00	; 0
    2022:	a1 f0       	breq	.+40     	; 0x204c <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    2024:	e9 81       	ldd	r30, Y+1	; 0x01
    2026:	fa 81       	ldd	r31, Y+2	; 0x02
    2028:	15 82       	std	Z+5, r1	; 0x05
    202a:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    202c:	e9 81       	ldd	r30, Y+1	; 0x01
    202e:	fa 81       	ldd	r31, Y+2	; 0x02
    2030:	11 82       	std	Z+1, r1	; 0x01
    2032:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    2034:	e9 81       	ldd	r30, Y+1	; 0x01
    2036:	fa 81       	ldd	r31, Y+2	; 0x02
    2038:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	9a 81       	ldd	r25, Y+2	; 0x02
    203e:	60 e0       	ldi	r22, 0x00	; 0
    2040:	70 e0       	ldi	r23, 0x00	; 0
    2042:	40 e0       	ldi	r20, 0x00	; 0
    2044:	50 e0       	ldi	r21, 0x00	; 0
    2046:	20 e0       	ldi	r18, 0x00	; 0
    2048:	0e 94 4b 10 	call	0x2096	; 0x2096 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    204c:	0f 90       	pop	r0
    204e:	0f 90       	pop	r0
    2050:	cf 91       	pop	r28
    2052:	df 91       	pop	r29
    2054:	08 95       	ret

00002056 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2056:	df 93       	push	r29
    2058:	cf 93       	push	r28
    205a:	00 d0       	rcall	.+0      	; 0x205c <xQueueCreateMutex+0x6>
    205c:	00 d0       	rcall	.+0      	; 0x205e <xQueueCreateMutex+0x8>
    205e:	0f 92       	push	r0
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	8a 83       	std	Y+2, r24	; 0x02
    206a:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    206c:	8a 81       	ldd	r24, Y+2	; 0x02
    206e:	69 81       	ldd	r22, Y+1	; 0x01
    2070:	4d 81       	ldd	r20, Y+5	; 0x05
    2072:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <xQueueGenericCreate>
    2076:	9c 83       	std	Y+4, r25	; 0x04
    2078:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    207a:	8b 81       	ldd	r24, Y+3	; 0x03
    207c:	9c 81       	ldd	r25, Y+4	; 0x04
    207e:	0e 94 07 10 	call	0x200e	; 0x200e <prvInitialiseMutex>

		return xNewQueue;
    2082:	8b 81       	ldd	r24, Y+3	; 0x03
    2084:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	cf 91       	pop	r28
    2092:	df 91       	pop	r29
    2094:	08 95       	ret

00002096 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2096:	df 93       	push	r29
    2098:	cf 93       	push	r28
    209a:	cd b7       	in	r28, 0x3d	; 61
    209c:	de b7       	in	r29, 0x3e	; 62
    209e:	2f 97       	sbiw	r28, 0x0f	; 15
    20a0:	0f b6       	in	r0, 0x3f	; 63
    20a2:	f8 94       	cli
    20a4:	de bf       	out	0x3e, r29	; 62
    20a6:	0f be       	out	0x3f, r0	; 63
    20a8:	cd bf       	out	0x3d, r28	; 61
    20aa:	99 87       	std	Y+9, r25	; 0x09
    20ac:	88 87       	std	Y+8, r24	; 0x08
    20ae:	7b 87       	std	Y+11, r23	; 0x0b
    20b0:	6a 87       	std	Y+10, r22	; 0x0a
    20b2:	5d 87       	std	Y+13, r21	; 0x0d
    20b4:	4c 87       	std	Y+12, r20	; 0x0c
    20b6:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    20b8:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    20ba:	88 85       	ldd	r24, Y+8	; 0x08
    20bc:	99 85       	ldd	r25, Y+9	; 0x09
    20be:	9a 83       	std	Y+2, r25	; 0x02
    20c0:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20c2:	0f b6       	in	r0, 0x3f	; 63
    20c4:	f8 94       	cli
    20c6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    20c8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ca:	fa 81       	ldd	r31, Y+2	; 0x02
    20cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    20ce:	e9 81       	ldd	r30, Y+1	; 0x01
    20d0:	fa 81       	ldd	r31, Y+2	; 0x02
    20d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    20d4:	98 17       	cp	r25, r24
    20d6:	18 f0       	brcs	.+6      	; 0x20de <xQueueGenericSend+0x48>
    20d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    20da:	82 30       	cpi	r24, 0x02	; 2
    20dc:	11 f5       	brne	.+68     	; 0x2122 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20de:	89 81       	ldd	r24, Y+1	; 0x01
    20e0:	9a 81       	ldd	r25, Y+2	; 0x02
    20e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    20e4:	3b 85       	ldd	r19, Y+11	; 0x0b
    20e6:	b9 01       	movw	r22, r18
    20e8:	4e 85       	ldd	r20, Y+14	; 0x0e
    20ea:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <prvCopyDataToQueue>
    20ee:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20f0:	e9 81       	ldd	r30, Y+1	; 0x01
    20f2:	fa 81       	ldd	r31, Y+2	; 0x02
    20f4:	81 89       	ldd	r24, Z+17	; 0x11
    20f6:	88 23       	and	r24, r24
    20f8:	51 f0       	breq	.+20     	; 0x210e <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20fa:	89 81       	ldd	r24, Y+1	; 0x01
    20fc:	9a 81       	ldd	r25, Y+2	; 0x02
    20fe:	41 96       	adiw	r24, 0x11	; 17
    2100:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2104:	88 23       	and	r24, r24
    2106:	41 f0       	breq	.+16     	; 0x2118 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2108:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    210c:	05 c0       	rjmp	.+10     	; 0x2118 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    210e:	8b 81       	ldd	r24, Y+3	; 0x03
    2110:	88 23       	and	r24, r24
    2112:	11 f0       	breq	.+4      	; 0x2118 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2114:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2118:	0f 90       	pop	r0
    211a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	8f 87       	std	Y+15, r24	; 0x0f
    2120:	5c c0       	rjmp	.+184    	; 0x21da <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2122:	8c 85       	ldd	r24, Y+12	; 0x0c
    2124:	9d 85       	ldd	r25, Y+13	; 0x0d
    2126:	00 97       	sbiw	r24, 0x00	; 0
    2128:	21 f4       	brne	.+8      	; 0x2132 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    212e:	1f 86       	std	Y+15, r1	; 0x0f
    2130:	54 c0       	rjmp	.+168    	; 0x21da <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2132:	8c 81       	ldd	r24, Y+4	; 0x04
    2134:	88 23       	and	r24, r24
    2136:	31 f4       	brne	.+12     	; 0x2144 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2138:	ce 01       	movw	r24, r28
    213a:	05 96       	adiw	r24, 0x05	; 5
    213c:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2148:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	0f 92       	push	r0
    2152:	e9 81       	ldd	r30, Y+1	; 0x01
    2154:	fa 81       	ldd	r31, Y+2	; 0x02
    2156:	85 8d       	ldd	r24, Z+29	; 0x1d
    2158:	8f 3f       	cpi	r24, 0xFF	; 255
    215a:	19 f4       	brne	.+6      	; 0x2162 <xQueueGenericSend+0xcc>
    215c:	e9 81       	ldd	r30, Y+1	; 0x01
    215e:	fa 81       	ldd	r31, Y+2	; 0x02
    2160:	15 8e       	std	Z+29, r1	; 0x1d
    2162:	e9 81       	ldd	r30, Y+1	; 0x01
    2164:	fa 81       	ldd	r31, Y+2	; 0x02
    2166:	86 8d       	ldd	r24, Z+30	; 0x1e
    2168:	8f 3f       	cpi	r24, 0xFF	; 255
    216a:	19 f4       	brne	.+6      	; 0x2172 <xQueueGenericSend+0xdc>
    216c:	e9 81       	ldd	r30, Y+1	; 0x01
    216e:	fa 81       	ldd	r31, Y+2	; 0x02
    2170:	16 8e       	std	Z+30, r1	; 0x1e
    2172:	0f 90       	pop	r0
    2174:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2176:	ce 01       	movw	r24, r28
    2178:	05 96       	adiw	r24, 0x05	; 5
    217a:	9e 01       	movw	r18, r28
    217c:	24 5f       	subi	r18, 0xF4	; 244
    217e:	3f 4f       	sbci	r19, 0xFF	; 255
    2180:	b9 01       	movw	r22, r18
    2182:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <xTaskCheckForTimeOut>
    2186:	88 23       	and	r24, r24
    2188:	09 f5       	brne	.+66     	; 0x21cc <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    218a:	89 81       	ldd	r24, Y+1	; 0x01
    218c:	9a 81       	ldd	r25, Y+2	; 0x02
    218e:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <prvIsQueueFull>
    2192:	88 23       	and	r24, r24
    2194:	a1 f0       	breq	.+40     	; 0x21be <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2196:	89 81       	ldd	r24, Y+1	; 0x01
    2198:	9a 81       	ldd	r25, Y+2	; 0x02
    219a:	08 96       	adiw	r24, 0x08	; 8
    219c:	2c 85       	ldd	r18, Y+12	; 0x0c
    219e:	3d 85       	ldd	r19, Y+13	; 0x0d
    21a0:	b9 01       	movw	r22, r18
    21a2:	0e 94 95 24 	call	0x492a	; 0x492a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    21a6:	89 81       	ldd	r24, Y+1	; 0x01
    21a8:	9a 81       	ldd	r25, Y+2	; 0x02
    21aa:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    21ae:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    21b2:	88 23       	and	r24, r24
    21b4:	09 f0       	breq	.+2      	; 0x21b8 <xQueueGenericSend+0x122>
    21b6:	85 cf       	rjmp	.-246    	; 0x20c2 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    21b8:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    21bc:	82 cf       	rjmp	.-252    	; 0x20c2 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    21be:	89 81       	ldd	r24, Y+1	; 0x01
    21c0:	9a 81       	ldd	r25, Y+2	; 0x02
    21c2:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    21c6:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    21ca:	7b cf       	rjmp	.-266    	; 0x20c2 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    21cc:	89 81       	ldd	r24, Y+1	; 0x01
    21ce:	9a 81       	ldd	r25, Y+2	; 0x02
    21d0:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21d4:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    21d8:	1f 86       	std	Y+15, r1	; 0x0f
    21da:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    21dc:	2f 96       	adiw	r28, 0x0f	; 15
    21de:	0f b6       	in	r0, 0x3f	; 63
    21e0:	f8 94       	cli
    21e2:	de bf       	out	0x3e, r29	; 62
    21e4:	0f be       	out	0x3f, r0	; 63
    21e6:	cd bf       	out	0x3d, r28	; 61
    21e8:	cf 91       	pop	r28
    21ea:	df 91       	pop	r29
    21ec:	08 95       	ret

000021ee <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    21ee:	df 93       	push	r29
    21f0:	cf 93       	push	r28
    21f2:	cd b7       	in	r28, 0x3d	; 61
    21f4:	de b7       	in	r29, 0x3e	; 62
    21f6:	2c 97       	sbiw	r28, 0x0c	; 12
    21f8:	0f b6       	in	r0, 0x3f	; 63
    21fa:	f8 94       	cli
    21fc:	de bf       	out	0x3e, r29	; 62
    21fe:	0f be       	out	0x3f, r0	; 63
    2200:	cd bf       	out	0x3d, r28	; 61
    2202:	9f 83       	std	Y+7, r25	; 0x07
    2204:	8e 83       	std	Y+6, r24	; 0x06
    2206:	79 87       	std	Y+9, r23	; 0x09
    2208:	68 87       	std	Y+8, r22	; 0x08
    220a:	5b 87       	std	Y+11, r21	; 0x0b
    220c:	4a 87       	std	Y+10, r20	; 0x0a
    220e:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2210:	8e 81       	ldd	r24, Y+6	; 0x06
    2212:	9f 81       	ldd	r25, Y+7	; 0x07
    2214:	9b 83       	std	Y+3, r25	; 0x03
    2216:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2218:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    221a:	ea 81       	ldd	r30, Y+2	; 0x02
    221c:	fb 81       	ldd	r31, Y+3	; 0x03
    221e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2220:	ea 81       	ldd	r30, Y+2	; 0x02
    2222:	fb 81       	ldd	r31, Y+3	; 0x03
    2224:	83 8d       	ldd	r24, Z+27	; 0x1b
    2226:	98 17       	cp	r25, r24
    2228:	18 f0       	brcs	.+6      	; 0x2230 <xQueueGenericSendFromISR+0x42>
    222a:	8c 85       	ldd	r24, Y+12	; 0x0c
    222c:	82 30       	cpi	r24, 0x02	; 2
    222e:	61 f5       	brne	.+88     	; 0x2288 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2230:	ea 81       	ldd	r30, Y+2	; 0x02
    2232:	fb 81       	ldd	r31, Y+3	; 0x03
    2234:	86 8d       	ldd	r24, Z+30	; 0x1e
    2236:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2238:	8a 81       	ldd	r24, Y+2	; 0x02
    223a:	9b 81       	ldd	r25, Y+3	; 0x03
    223c:	28 85       	ldd	r18, Y+8	; 0x08
    223e:	39 85       	ldd	r19, Y+9	; 0x09
    2240:	b9 01       	movw	r22, r18
    2242:	4c 85       	ldd	r20, Y+12	; 0x0c
    2244:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2248:	89 81       	ldd	r24, Y+1	; 0x01
    224a:	8f 3f       	cpi	r24, 0xFF	; 255
    224c:	a9 f4       	brne	.+42     	; 0x2278 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    224e:	ea 81       	ldd	r30, Y+2	; 0x02
    2250:	fb 81       	ldd	r31, Y+3	; 0x03
    2252:	81 89       	ldd	r24, Z+17	; 0x11
    2254:	88 23       	and	r24, r24
    2256:	a9 f0       	breq	.+42     	; 0x2282 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2258:	8a 81       	ldd	r24, Y+2	; 0x02
    225a:	9b 81       	ldd	r25, Y+3	; 0x03
    225c:	41 96       	adiw	r24, 0x11	; 17
    225e:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2262:	88 23       	and	r24, r24
    2264:	71 f0       	breq	.+28     	; 0x2282 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2266:	8a 85       	ldd	r24, Y+10	; 0x0a
    2268:	9b 85       	ldd	r25, Y+11	; 0x0b
    226a:	00 97       	sbiw	r24, 0x00	; 0
    226c:	51 f0       	breq	.+20     	; 0x2282 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    226e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2270:	fb 85       	ldd	r31, Y+11	; 0x0b
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	80 83       	st	Z, r24
    2276:	05 c0       	rjmp	.+10     	; 0x2282 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2278:	89 81       	ldd	r24, Y+1	; 0x01
    227a:	8f 5f       	subi	r24, 0xFF	; 255
    227c:	ea 81       	ldd	r30, Y+2	; 0x02
    227e:	fb 81       	ldd	r31, Y+3	; 0x03
    2280:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2282:	81 e0       	ldi	r24, 0x01	; 1
    2284:	8d 83       	std	Y+5, r24	; 0x05
    2286:	01 c0       	rjmp	.+2      	; 0x228a <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2288:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    228a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    228c:	2c 96       	adiw	r28, 0x0c	; 12
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	de bf       	out	0x3e, r29	; 62
    2294:	0f be       	out	0x3f, r0	; 63
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	cf 91       	pop	r28
    229a:	df 91       	pop	r29
    229c:	08 95       	ret

0000229e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    229e:	df 93       	push	r29
    22a0:	cf 93       	push	r28
    22a2:	cd b7       	in	r28, 0x3d	; 61
    22a4:	de b7       	in	r29, 0x3e	; 62
    22a6:	2a 97       	sbiw	r28, 0x0a	; 10
    22a8:	0f b6       	in	r0, 0x3f	; 63
    22aa:	f8 94       	cli
    22ac:	de bf       	out	0x3e, r29	; 62
    22ae:	0f be       	out	0x3f, r0	; 63
    22b0:	cd bf       	out	0x3d, r28	; 61
    22b2:	98 87       	std	Y+8, r25	; 0x08
    22b4:	8f 83       	std	Y+7, r24	; 0x07
    22b6:	7a 87       	std	Y+10, r23	; 0x0a
    22b8:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    22ba:	8f 81       	ldd	r24, Y+7	; 0x07
    22bc:	98 85       	ldd	r25, Y+8	; 0x08
    22be:	9c 83       	std	Y+4, r25	; 0x04
    22c0:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    22c2:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22c4:	eb 81       	ldd	r30, Y+3	; 0x03
    22c6:	fc 81       	ldd	r31, Y+4	; 0x04
    22c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22ca:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    22cc:	eb 81       	ldd	r30, Y+3	; 0x03
    22ce:	fc 81       	ldd	r31, Y+4	; 0x04
    22d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    22d2:	8a 81       	ldd	r24, Y+2	; 0x02
    22d4:	89 17       	cp	r24, r25
    22d6:	48 f5       	brcc	.+82     	; 0x232a <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    22d8:	eb 81       	ldd	r30, Y+3	; 0x03
    22da:	fc 81       	ldd	r31, Y+4	; 0x04
    22dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    22de:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    22e0:	8a 81       	ldd	r24, Y+2	; 0x02
    22e2:	8f 5f       	subi	r24, 0xFF	; 255
    22e4:	eb 81       	ldd	r30, Y+3	; 0x03
    22e6:	fc 81       	ldd	r31, Y+4	; 0x04
    22e8:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    22ea:	89 81       	ldd	r24, Y+1	; 0x01
    22ec:	8f 3f       	cpi	r24, 0xFF	; 255
    22ee:	a9 f4       	brne	.+42     	; 0x231a <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22f0:	eb 81       	ldd	r30, Y+3	; 0x03
    22f2:	fc 81       	ldd	r31, Y+4	; 0x04
    22f4:	81 89       	ldd	r24, Z+17	; 0x11
    22f6:	88 23       	and	r24, r24
    22f8:	a9 f0       	breq	.+42     	; 0x2324 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22fa:	8b 81       	ldd	r24, Y+3	; 0x03
    22fc:	9c 81       	ldd	r25, Y+4	; 0x04
    22fe:	41 96       	adiw	r24, 0x11	; 17
    2300:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2304:	88 23       	and	r24, r24
    2306:	71 f0       	breq	.+28     	; 0x2324 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2308:	89 85       	ldd	r24, Y+9	; 0x09
    230a:	9a 85       	ldd	r25, Y+10	; 0x0a
    230c:	00 97       	sbiw	r24, 0x00	; 0
    230e:	51 f0       	breq	.+20     	; 0x2324 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2310:	e9 85       	ldd	r30, Y+9	; 0x09
    2312:	fa 85       	ldd	r31, Y+10	; 0x0a
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	80 83       	st	Z, r24
    2318:	05 c0       	rjmp	.+10     	; 0x2324 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    231a:	89 81       	ldd	r24, Y+1	; 0x01
    231c:	8f 5f       	subi	r24, 0xFF	; 255
    231e:	eb 81       	ldd	r30, Y+3	; 0x03
    2320:	fc 81       	ldd	r31, Y+4	; 0x04
    2322:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	8e 83       	std	Y+6, r24	; 0x06
    2328:	01 c0       	rjmp	.+2      	; 0x232c <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    232a:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    232c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    232e:	2a 96       	adiw	r28, 0x0a	; 10
    2330:	0f b6       	in	r0, 0x3f	; 63
    2332:	f8 94       	cli
    2334:	de bf       	out	0x3e, r29	; 62
    2336:	0f be       	out	0x3f, r0	; 63
    2338:	cd bf       	out	0x3d, r28	; 61
    233a:	cf 91       	pop	r28
    233c:	df 91       	pop	r29
    233e:	08 95       	ret

00002340 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2340:	df 93       	push	r29
    2342:	cf 93       	push	r28
    2344:	cd b7       	in	r28, 0x3d	; 61
    2346:	de b7       	in	r29, 0x3e	; 62
    2348:	2e 97       	sbiw	r28, 0x0e	; 14
    234a:	0f b6       	in	r0, 0x3f	; 63
    234c:	f8 94       	cli
    234e:	de bf       	out	0x3e, r29	; 62
    2350:	0f be       	out	0x3f, r0	; 63
    2352:	cd bf       	out	0x3d, r28	; 61
    2354:	99 87       	std	Y+9, r25	; 0x09
    2356:	88 87       	std	Y+8, r24	; 0x08
    2358:	7b 87       	std	Y+11, r23	; 0x0b
    235a:	6a 87       	std	Y+10, r22	; 0x0a
    235c:	5d 87       	std	Y+13, r21	; 0x0d
    235e:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2360:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2362:	88 85       	ldd	r24, Y+8	; 0x08
    2364:	99 85       	ldd	r25, Y+9	; 0x09
    2366:	9b 83       	std	Y+3, r25	; 0x03
    2368:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    236a:	0f b6       	in	r0, 0x3f	; 63
    236c:	f8 94       	cli
    236e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2370:	ea 81       	ldd	r30, Y+2	; 0x02
    2372:	fb 81       	ldd	r31, Y+3	; 0x03
    2374:	82 8d       	ldd	r24, Z+26	; 0x1a
    2376:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	88 23       	and	r24, r24
    237c:	f9 f0       	breq	.+62     	; 0x23bc <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
    2380:	9b 81       	ldd	r25, Y+3	; 0x03
    2382:	2a 85       	ldd	r18, Y+10	; 0x0a
    2384:	3b 85       	ldd	r19, Y+11	; 0x0b
    2386:	b9 01       	movw	r22, r18
    2388:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    238c:	89 81       	ldd	r24, Y+1	; 0x01
    238e:	81 50       	subi	r24, 0x01	; 1
    2390:	ea 81       	ldd	r30, Y+2	; 0x02
    2392:	fb 81       	ldd	r31, Y+3	; 0x03
    2394:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2396:	ea 81       	ldd	r30, Y+2	; 0x02
    2398:	fb 81       	ldd	r31, Y+3	; 0x03
    239a:	80 85       	ldd	r24, Z+8	; 0x08
    239c:	88 23       	and	r24, r24
    239e:	49 f0       	breq	.+18     	; 0x23b2 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23a0:	8a 81       	ldd	r24, Y+2	; 0x02
    23a2:	9b 81       	ldd	r25, Y+3	; 0x03
    23a4:	08 96       	adiw	r24, 0x08	; 8
    23a6:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    23aa:	88 23       	and	r24, r24
    23ac:	11 f0       	breq	.+4      	; 0x23b2 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    23ae:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	8e 87       	std	Y+14, r24	; 0x0e
    23ba:	63 c0       	rjmp	.+198    	; 0x2482 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    23be:	9d 85       	ldd	r25, Y+13	; 0x0d
    23c0:	00 97       	sbiw	r24, 0x00	; 0
    23c2:	21 f4       	brne	.+8      	; 0x23cc <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23c4:	0f 90       	pop	r0
    23c6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23c8:	1e 86       	std	Y+14, r1	; 0x0e
    23ca:	5b c0       	rjmp	.+182    	; 0x2482 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    23cc:	8c 81       	ldd	r24, Y+4	; 0x04
    23ce:	88 23       	and	r24, r24
    23d0:	31 f4       	brne	.+12     	; 0x23de <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    23d2:	ce 01       	movw	r24, r28
    23d4:	05 96       	adiw	r24, 0x05	; 5
    23d6:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    23da:	81 e0       	ldi	r24, 0x01	; 1
    23dc:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    23de:	0f 90       	pop	r0
    23e0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23e2:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
    23ec:	ea 81       	ldd	r30, Y+2	; 0x02
    23ee:	fb 81       	ldd	r31, Y+3	; 0x03
    23f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    23f2:	8f 3f       	cpi	r24, 0xFF	; 255
    23f4:	19 f4       	brne	.+6      	; 0x23fc <xQueueReceive+0xbc>
    23f6:	ea 81       	ldd	r30, Y+2	; 0x02
    23f8:	fb 81       	ldd	r31, Y+3	; 0x03
    23fa:	15 8e       	std	Z+29, r1	; 0x1d
    23fc:	ea 81       	ldd	r30, Y+2	; 0x02
    23fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2400:	86 8d       	ldd	r24, Z+30	; 0x1e
    2402:	8f 3f       	cpi	r24, 0xFF	; 255
    2404:	19 f4       	brne	.+6      	; 0x240c <xQueueReceive+0xcc>
    2406:	ea 81       	ldd	r30, Y+2	; 0x02
    2408:	fb 81       	ldd	r31, Y+3	; 0x03
    240a:	16 8e       	std	Z+30, r1	; 0x1e
    240c:	0f 90       	pop	r0
    240e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2410:	ce 01       	movw	r24, r28
    2412:	05 96       	adiw	r24, 0x05	; 5
    2414:	9e 01       	movw	r18, r28
    2416:	24 5f       	subi	r18, 0xF4	; 244
    2418:	3f 4f       	sbci	r19, 0xFF	; 255
    241a:	b9 01       	movw	r22, r18
    241c:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <xTaskCheckForTimeOut>
    2420:	88 23       	and	r24, r24
    2422:	09 f5       	brne	.+66     	; 0x2466 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2424:	8a 81       	ldd	r24, Y+2	; 0x02
    2426:	9b 81       	ldd	r25, Y+3	; 0x03
    2428:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    242c:	88 23       	and	r24, r24
    242e:	a1 f0       	breq	.+40     	; 0x2458 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	9b 81       	ldd	r25, Y+3	; 0x03
    2434:	41 96       	adiw	r24, 0x11	; 17
    2436:	2c 85       	ldd	r18, Y+12	; 0x0c
    2438:	3d 85       	ldd	r19, Y+13	; 0x0d
    243a:	b9 01       	movw	r22, r18
    243c:	0e 94 95 24 	call	0x492a	; 0x492a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2440:	8a 81       	ldd	r24, Y+2	; 0x02
    2442:	9b 81       	ldd	r25, Y+3	; 0x03
    2444:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2448:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    244c:	88 23       	and	r24, r24
    244e:	09 f0       	breq	.+2      	; 0x2452 <xQueueReceive+0x112>
    2450:	8c cf       	rjmp	.-232    	; 0x236a <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2452:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    2456:	89 cf       	rjmp	.-238    	; 0x236a <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2458:	8a 81       	ldd	r24, Y+2	; 0x02
    245a:	9b 81       	ldd	r25, Y+3	; 0x03
    245c:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2460:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    2464:	82 cf       	rjmp	.-252    	; 0x236a <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    246e:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2472:	8a 81       	ldd	r24, Y+2	; 0x02
    2474:	9b 81       	ldd	r25, Y+3	; 0x03
    2476:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    247a:	88 23       	and	r24, r24
    247c:	09 f4       	brne	.+2      	; 0x2480 <xQueueReceive+0x140>
    247e:	75 cf       	rjmp	.-278    	; 0x236a <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2480:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2482:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2484:	2e 96       	adiw	r28, 0x0e	; 14
    2486:	0f b6       	in	r0, 0x3f	; 63
    2488:	f8 94       	cli
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	0f be       	out	0x3f, r0	; 63
    248e:	cd bf       	out	0x3d, r28	; 61
    2490:	cf 91       	pop	r28
    2492:	df 91       	pop	r29
    2494:	08 95       	ret

00002496 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2496:	df 93       	push	r29
    2498:	cf 93       	push	r28
    249a:	cd b7       	in	r28, 0x3d	; 61
    249c:	de b7       	in	r29, 0x3e	; 62
    249e:	2e 97       	sbiw	r28, 0x0e	; 14
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	de bf       	out	0x3e, r29	; 62
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	cd bf       	out	0x3d, r28	; 61
    24aa:	9b 87       	std	Y+11, r25	; 0x0b
    24ac:	8a 87       	std	Y+10, r24	; 0x0a
    24ae:	7d 87       	std	Y+13, r23	; 0x0d
    24b0:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    24b2:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    24b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    24b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    24b8:	9d 83       	std	Y+5, r25	; 0x05
    24ba:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    24bc:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    24be:	0f b6       	in	r0, 0x3f	; 63
    24c0:	f8 94       	cli
    24c2:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    24c4:	ec 81       	ldd	r30, Y+4	; 0x04
    24c6:	fd 81       	ldd	r31, Y+5	; 0x05
    24c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    24ca:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    24cc:	8a 81       	ldd	r24, Y+2	; 0x02
    24ce:	88 23       	and	r24, r24
    24d0:	21 f1       	breq	.+72     	; 0x251a <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    24d2:	8a 81       	ldd	r24, Y+2	; 0x02
    24d4:	81 50       	subi	r24, 0x01	; 1
    24d6:	ec 81       	ldd	r30, Y+4	; 0x04
    24d8:	fd 81       	ldd	r31, Y+5	; 0x05
    24da:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    24dc:	ec 81       	ldd	r30, Y+4	; 0x04
    24de:	fd 81       	ldd	r31, Y+5	; 0x05
    24e0:	80 81       	ld	r24, Z
    24e2:	91 81       	ldd	r25, Z+1	; 0x01
    24e4:	00 97       	sbiw	r24, 0x00	; 0
    24e6:	31 f4       	brne	.+12     	; 0x24f4 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    24e8:	0e 94 f6 28 	call	0x51ec	; 0x51ec <pvTaskIncrementMutexHeldCount>
    24ec:	ec 81       	ldd	r30, Y+4	; 0x04
    24ee:	fd 81       	ldd	r31, Y+5	; 0x05
    24f0:	95 83       	std	Z+5, r25	; 0x05
    24f2:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24f4:	ec 81       	ldd	r30, Y+4	; 0x04
    24f6:	fd 81       	ldd	r31, Y+5	; 0x05
    24f8:	80 85       	ldd	r24, Z+8	; 0x08
    24fa:	88 23       	and	r24, r24
    24fc:	49 f0       	breq	.+18     	; 0x2510 <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2500:	9d 81       	ldd	r25, Y+5	; 0x05
    2502:	08 96       	adiw	r24, 0x08	; 8
    2504:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2508:	88 23       	and	r24, r24
    250a:	11 f0       	breq	.+4      	; 0x2510 <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    250c:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2510:	0f 90       	pop	r0
    2512:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	8e 87       	std	Y+14, r24	; 0x0e
    2518:	89 c0       	rjmp	.+274    	; 0x262c <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    251a:	8c 85       	ldd	r24, Y+12	; 0x0c
    251c:	9d 85       	ldd	r25, Y+13	; 0x0d
    251e:	00 97       	sbiw	r24, 0x00	; 0
    2520:	21 f4       	brne	.+8      	; 0x252a <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2526:	1e 86       	std	Y+14, r1	; 0x0e
    2528:	81 c0       	rjmp	.+258    	; 0x262c <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    252a:	8e 81       	ldd	r24, Y+6	; 0x06
    252c:	88 23       	and	r24, r24
    252e:	31 f4       	brne	.+12     	; 0x253c <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2530:	ce 01       	movw	r24, r28
    2532:	07 96       	adiw	r24, 0x07	; 7
    2534:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    253c:	0f 90       	pop	r0
    253e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2540:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	0f 92       	push	r0
    254a:	ec 81       	ldd	r30, Y+4	; 0x04
    254c:	fd 81       	ldd	r31, Y+5	; 0x05
    254e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2550:	8f 3f       	cpi	r24, 0xFF	; 255
    2552:	19 f4       	brne	.+6      	; 0x255a <xQueueSemaphoreTake+0xc4>
    2554:	ec 81       	ldd	r30, Y+4	; 0x04
    2556:	fd 81       	ldd	r31, Y+5	; 0x05
    2558:	15 8e       	std	Z+29, r1	; 0x1d
    255a:	ec 81       	ldd	r30, Y+4	; 0x04
    255c:	fd 81       	ldd	r31, Y+5	; 0x05
    255e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2560:	8f 3f       	cpi	r24, 0xFF	; 255
    2562:	19 f4       	brne	.+6      	; 0x256a <xQueueSemaphoreTake+0xd4>
    2564:	ec 81       	ldd	r30, Y+4	; 0x04
    2566:	fd 81       	ldd	r31, Y+5	; 0x05
    2568:	16 8e       	std	Z+30, r1	; 0x1e
    256a:	0f 90       	pop	r0
    256c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    256e:	ce 01       	movw	r24, r28
    2570:	07 96       	adiw	r24, 0x07	; 7
    2572:	9e 01       	movw	r18, r28
    2574:	24 5f       	subi	r18, 0xF4	; 244
    2576:	3f 4f       	sbci	r19, 0xFF	; 255
    2578:	b9 01       	movw	r22, r18
    257a:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <xTaskCheckForTimeOut>
    257e:	88 23       	and	r24, r24
    2580:	99 f5       	brne	.+102    	; 0x25e8 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2582:	8c 81       	ldd	r24, Y+4	; 0x04
    2584:	9d 81       	ldd	r25, Y+5	; 0x05
    2586:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    258a:	88 23       	and	r24, r24
    258c:	31 f1       	breq	.+76     	; 0x25da <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    258e:	ec 81       	ldd	r30, Y+4	; 0x04
    2590:	fd 81       	ldd	r31, Y+5	; 0x05
    2592:	80 81       	ld	r24, Z
    2594:	91 81       	ldd	r25, Z+1	; 0x01
    2596:	00 97       	sbiw	r24, 0x00	; 0
    2598:	61 f4       	brne	.+24     	; 0x25b2 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    259a:	0f b6       	in	r0, 0x3f	; 63
    259c:	f8 94       	cli
    259e:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    25a0:	ec 81       	ldd	r30, Y+4	; 0x04
    25a2:	fd 81       	ldd	r31, Y+5	; 0x05
    25a4:	84 81       	ldd	r24, Z+4	; 0x04
    25a6:	95 81       	ldd	r25, Z+5	; 0x05
    25a8:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <xTaskPriorityInherit>
    25ac:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    25ae:	0f 90       	pop	r0
    25b0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    25b2:	8c 81       	ldd	r24, Y+4	; 0x04
    25b4:	9d 81       	ldd	r25, Y+5	; 0x05
    25b6:	41 96       	adiw	r24, 0x11	; 17
    25b8:	2c 85       	ldd	r18, Y+12	; 0x0c
    25ba:	3d 85       	ldd	r19, Y+13	; 0x0d
    25bc:	b9 01       	movw	r22, r18
    25be:	0e 94 95 24 	call	0x492a	; 0x492a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    25c2:	8c 81       	ldd	r24, Y+4	; 0x04
    25c4:	9d 81       	ldd	r25, Y+5	; 0x05
    25c6:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    25ca:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    25ce:	88 23       	and	r24, r24
    25d0:	09 f0       	breq	.+2      	; 0x25d4 <xQueueSemaphoreTake+0x13e>
    25d2:	75 cf       	rjmp	.-278    	; 0x24be <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    25d4:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    25d8:	72 cf       	rjmp	.-284    	; 0x24be <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    25da:	8c 81       	ldd	r24, Y+4	; 0x04
    25dc:	9d 81       	ldd	r25, Y+5	; 0x05
    25de:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    25e2:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    25e6:	6b cf       	rjmp	.-298    	; 0x24be <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    25e8:	8c 81       	ldd	r24, Y+4	; 0x04
    25ea:	9d 81       	ldd	r25, Y+5	; 0x05
    25ec:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    25f0:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25f4:	8c 81       	ldd	r24, Y+4	; 0x04
    25f6:	9d 81       	ldd	r25, Y+5	; 0x05
    25f8:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    25fc:	88 23       	and	r24, r24
    25fe:	09 f4       	brne	.+2      	; 0x2602 <xQueueSemaphoreTake+0x16c>
    2600:	5e cf       	rjmp	.-324    	; 0x24be <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	88 23       	and	r24, r24
    2606:	89 f0       	breq	.+34     	; 0x262a <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    2608:	0f b6       	in	r0, 0x3f	; 63
    260a:	f8 94       	cli
    260c:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    260e:	8c 81       	ldd	r24, Y+4	; 0x04
    2610:	9d 81       	ldd	r25, Y+5	; 0x05
    2612:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvGetDisinheritPriorityAfterTimeout>
    2616:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    2618:	ec 81       	ldd	r30, Y+4	; 0x04
    261a:	fd 81       	ldd	r31, Y+5	; 0x05
    261c:	84 81       	ldd	r24, Z+4	; 0x04
    261e:	95 81       	ldd	r25, Z+5	; 0x05
    2620:	69 81       	ldd	r22, Y+1	; 0x01
    2622:	0e 94 3a 28 	call	0x5074	; 0x5074 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    2626:	0f 90       	pop	r0
    2628:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    262a:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    262c:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    262e:	2e 96       	adiw	r28, 0x0e	; 14
    2630:	0f b6       	in	r0, 0x3f	; 63
    2632:	f8 94       	cli
    2634:	de bf       	out	0x3e, r29	; 62
    2636:	0f be       	out	0x3f, r0	; 63
    2638:	cd bf       	out	0x3d, r28	; 61
    263a:	cf 91       	pop	r28
    263c:	df 91       	pop	r29
    263e:	08 95       	ret

00002640 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2640:	df 93       	push	r29
    2642:	cf 93       	push	r28
    2644:	cd b7       	in	r28, 0x3d	; 61
    2646:	de b7       	in	r29, 0x3e	; 62
    2648:	60 97       	sbiw	r28, 0x10	; 16
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	de bf       	out	0x3e, r29	; 62
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	cd bf       	out	0x3d, r28	; 61
    2654:	9b 87       	std	Y+11, r25	; 0x0b
    2656:	8a 87       	std	Y+10, r24	; 0x0a
    2658:	7d 87       	std	Y+13, r23	; 0x0d
    265a:	6c 87       	std	Y+12, r22	; 0x0c
    265c:	5f 87       	std	Y+15, r21	; 0x0f
    265e:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2660:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2662:	8a 85       	ldd	r24, Y+10	; 0x0a
    2664:	9b 85       	ldd	r25, Y+11	; 0x0b
    2666:	9b 83       	std	Y+3, r25	; 0x03
    2668:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2670:	ea 81       	ldd	r30, Y+2	; 0x02
    2672:	fb 81       	ldd	r31, Y+3	; 0x03
    2674:	82 8d       	ldd	r24, Z+26	; 0x1a
    2676:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	88 23       	and	r24, r24
    267c:	31 f1       	breq	.+76     	; 0x26ca <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    267e:	ea 81       	ldd	r30, Y+2	; 0x02
    2680:	fb 81       	ldd	r31, Y+3	; 0x03
    2682:	86 81       	ldd	r24, Z+6	; 0x06
    2684:	97 81       	ldd	r25, Z+7	; 0x07
    2686:	9d 83       	std	Y+5, r25	; 0x05
    2688:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    268a:	8a 81       	ldd	r24, Y+2	; 0x02
    268c:	9b 81       	ldd	r25, Y+3	; 0x03
    268e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2690:	3d 85       	ldd	r19, Y+13	; 0x0d
    2692:	b9 01       	movw	r22, r18
    2694:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2698:	ea 81       	ldd	r30, Y+2	; 0x02
    269a:	fb 81       	ldd	r31, Y+3	; 0x03
    269c:	8c 81       	ldd	r24, Y+4	; 0x04
    269e:	9d 81       	ldd	r25, Y+5	; 0x05
    26a0:	97 83       	std	Z+7, r25	; 0x07
    26a2:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26a4:	ea 81       	ldd	r30, Y+2	; 0x02
    26a6:	fb 81       	ldd	r31, Y+3	; 0x03
    26a8:	81 89       	ldd	r24, Z+17	; 0x11
    26aa:	88 23       	and	r24, r24
    26ac:	49 f0       	breq	.+18     	; 0x26c0 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26ae:	8a 81       	ldd	r24, Y+2	; 0x02
    26b0:	9b 81       	ldd	r25, Y+3	; 0x03
    26b2:	41 96       	adiw	r24, 0x11	; 17
    26b4:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    26b8:	88 23       	and	r24, r24
    26ba:	11 f0       	breq	.+4      	; 0x26c0 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    26bc:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    26c0:	0f 90       	pop	r0
    26c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	88 8b       	std	Y+16, r24	; 0x10
    26c8:	63 c0       	rjmp	.+198    	; 0x2790 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    26ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    26cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	21 f4       	brne	.+8      	; 0x26da <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    26d2:	0f 90       	pop	r0
    26d4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    26d6:	18 8a       	std	Y+16, r1	; 0x10
    26d8:	5b c0       	rjmp	.+182    	; 0x2790 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    26da:	8e 81       	ldd	r24, Y+6	; 0x06
    26dc:	88 23       	and	r24, r24
    26de:	31 f4       	brne	.+12     	; 0x26ec <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    26e0:	ce 01       	movw	r24, r28
    26e2:	07 96       	adiw	r24, 0x07	; 7
    26e4:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26e8:	81 e0       	ldi	r24, 0x01	; 1
    26ea:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    26ec:	0f 90       	pop	r0
    26ee:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26f0:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26f4:	0f b6       	in	r0, 0x3f	; 63
    26f6:	f8 94       	cli
    26f8:	0f 92       	push	r0
    26fa:	ea 81       	ldd	r30, Y+2	; 0x02
    26fc:	fb 81       	ldd	r31, Y+3	; 0x03
    26fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2700:	8f 3f       	cpi	r24, 0xFF	; 255
    2702:	19 f4       	brne	.+6      	; 0x270a <xQueuePeek+0xca>
    2704:	ea 81       	ldd	r30, Y+2	; 0x02
    2706:	fb 81       	ldd	r31, Y+3	; 0x03
    2708:	15 8e       	std	Z+29, r1	; 0x1d
    270a:	ea 81       	ldd	r30, Y+2	; 0x02
    270c:	fb 81       	ldd	r31, Y+3	; 0x03
    270e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2710:	8f 3f       	cpi	r24, 0xFF	; 255
    2712:	19 f4       	brne	.+6      	; 0x271a <xQueuePeek+0xda>
    2714:	ea 81       	ldd	r30, Y+2	; 0x02
    2716:	fb 81       	ldd	r31, Y+3	; 0x03
    2718:	16 8e       	std	Z+30, r1	; 0x1e
    271a:	0f 90       	pop	r0
    271c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    271e:	ce 01       	movw	r24, r28
    2720:	07 96       	adiw	r24, 0x07	; 7
    2722:	9e 01       	movw	r18, r28
    2724:	22 5f       	subi	r18, 0xF2	; 242
    2726:	3f 4f       	sbci	r19, 0xFF	; 255
    2728:	b9 01       	movw	r22, r18
    272a:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <xTaskCheckForTimeOut>
    272e:	88 23       	and	r24, r24
    2730:	09 f5       	brne	.+66     	; 0x2774 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2732:	8a 81       	ldd	r24, Y+2	; 0x02
    2734:	9b 81       	ldd	r25, Y+3	; 0x03
    2736:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    273a:	88 23       	and	r24, r24
    273c:	a1 f0       	breq	.+40     	; 0x2766 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    273e:	8a 81       	ldd	r24, Y+2	; 0x02
    2740:	9b 81       	ldd	r25, Y+3	; 0x03
    2742:	41 96       	adiw	r24, 0x11	; 17
    2744:	2e 85       	ldd	r18, Y+14	; 0x0e
    2746:	3f 85       	ldd	r19, Y+15	; 0x0f
    2748:	b9 01       	movw	r22, r18
    274a:	0e 94 95 24 	call	0x492a	; 0x492a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    274e:	8a 81       	ldd	r24, Y+2	; 0x02
    2750:	9b 81       	ldd	r25, Y+3	; 0x03
    2752:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2756:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    275a:	88 23       	and	r24, r24
    275c:	09 f0       	breq	.+2      	; 0x2760 <xQueuePeek+0x120>
    275e:	85 cf       	rjmp	.-246    	; 0x266a <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2760:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    2764:	82 cf       	rjmp	.-252    	; 0x266a <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2766:	8a 81       	ldd	r24, Y+2	; 0x02
    2768:	9b 81       	ldd	r25, Y+3	; 0x03
    276a:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    276e:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    2772:	7b cf       	rjmp	.-266    	; 0x266a <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2774:	8a 81       	ldd	r24, Y+2	; 0x02
    2776:	9b 81       	ldd	r25, Y+3	; 0x03
    2778:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    277c:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2780:	8a 81       	ldd	r24, Y+2	; 0x02
    2782:	9b 81       	ldd	r25, Y+3	; 0x03
    2784:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueEmpty>
    2788:	88 23       	and	r24, r24
    278a:	09 f4       	brne	.+2      	; 0x278e <xQueuePeek+0x14e>
    278c:	6e cf       	rjmp	.-292    	; 0x266a <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    278e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2790:	88 89       	ldd	r24, Y+16	; 0x10
}
    2792:	60 96       	adiw	r28, 0x10	; 16
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	de bf       	out	0x3e, r29	; 62
    279a:	0f be       	out	0x3f, r0	; 63
    279c:	cd bf       	out	0x3d, r28	; 61
    279e:	cf 91       	pop	r28
    27a0:	df 91       	pop	r29
    27a2:	08 95       	ret

000027a4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    27a4:	df 93       	push	r29
    27a6:	cf 93       	push	r28
    27a8:	cd b7       	in	r28, 0x3d	; 61
    27aa:	de b7       	in	r29, 0x3e	; 62
    27ac:	2c 97       	sbiw	r28, 0x0c	; 12
    27ae:	0f b6       	in	r0, 0x3f	; 63
    27b0:	f8 94       	cli
    27b2:	de bf       	out	0x3e, r29	; 62
    27b4:	0f be       	out	0x3f, r0	; 63
    27b6:	cd bf       	out	0x3d, r28	; 61
    27b8:	98 87       	std	Y+8, r25	; 0x08
    27ba:	8f 83       	std	Y+7, r24	; 0x07
    27bc:	7a 87       	std	Y+10, r23	; 0x0a
    27be:	69 87       	std	Y+9, r22	; 0x09
    27c0:	5c 87       	std	Y+12, r21	; 0x0c
    27c2:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    27c4:	8f 81       	ldd	r24, Y+7	; 0x07
    27c6:	98 85       	ldd	r25, Y+8	; 0x08
    27c8:	9c 83       	std	Y+4, r25	; 0x04
    27ca:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27cc:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27ce:	eb 81       	ldd	r30, Y+3	; 0x03
    27d0:	fc 81       	ldd	r31, Y+4	; 0x04
    27d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    27d4:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    27d6:	8a 81       	ldd	r24, Y+2	; 0x02
    27d8:	88 23       	and	r24, r24
    27da:	81 f1       	breq	.+96     	; 0x283c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    27dc:	eb 81       	ldd	r30, Y+3	; 0x03
    27de:	fc 81       	ldd	r31, Y+4	; 0x04
    27e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    27e2:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    27e4:	8b 81       	ldd	r24, Y+3	; 0x03
    27e6:	9c 81       	ldd	r25, Y+4	; 0x04
    27e8:	29 85       	ldd	r18, Y+9	; 0x09
    27ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    27ec:	b9 01       	movw	r22, r18
    27ee:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    27f2:	8a 81       	ldd	r24, Y+2	; 0x02
    27f4:	81 50       	subi	r24, 0x01	; 1
    27f6:	eb 81       	ldd	r30, Y+3	; 0x03
    27f8:	fc 81       	ldd	r31, Y+4	; 0x04
    27fa:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    27fc:	89 81       	ldd	r24, Y+1	; 0x01
    27fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2800:	a9 f4       	brne	.+42     	; 0x282c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2802:	eb 81       	ldd	r30, Y+3	; 0x03
    2804:	fc 81       	ldd	r31, Y+4	; 0x04
    2806:	80 85       	ldd	r24, Z+8	; 0x08
    2808:	88 23       	and	r24, r24
    280a:	a9 f0       	breq	.+42     	; 0x2836 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    280c:	8b 81       	ldd	r24, Y+3	; 0x03
    280e:	9c 81       	ldd	r25, Y+4	; 0x04
    2810:	08 96       	adiw	r24, 0x08	; 8
    2812:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2816:	88 23       	and	r24, r24
    2818:	71 f0       	breq	.+28     	; 0x2836 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    281a:	8b 85       	ldd	r24, Y+11	; 0x0b
    281c:	9c 85       	ldd	r25, Y+12	; 0x0c
    281e:	00 97       	sbiw	r24, 0x00	; 0
    2820:	51 f0       	breq	.+20     	; 0x2836 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2822:	eb 85       	ldd	r30, Y+11	; 0x0b
    2824:	fc 85       	ldd	r31, Y+12	; 0x0c
    2826:	81 e0       	ldi	r24, 0x01	; 1
    2828:	80 83       	st	Z, r24
    282a:	05 c0       	rjmp	.+10     	; 0x2836 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    282c:	89 81       	ldd	r24, Y+1	; 0x01
    282e:	8f 5f       	subi	r24, 0xFF	; 255
    2830:	eb 81       	ldd	r30, Y+3	; 0x03
    2832:	fc 81       	ldd	r31, Y+4	; 0x04
    2834:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2836:	81 e0       	ldi	r24, 0x01	; 1
    2838:	8e 83       	std	Y+6, r24	; 0x06
    283a:	01 c0       	rjmp	.+2      	; 0x283e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    283c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    283e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2840:	2c 96       	adiw	r28, 0x0c	; 12
    2842:	0f b6       	in	r0, 0x3f	; 63
    2844:	f8 94       	cli
    2846:	de bf       	out	0x3e, r29	; 62
    2848:	0f be       	out	0x3f, r0	; 63
    284a:	cd bf       	out	0x3d, r28	; 61
    284c:	cf 91       	pop	r28
    284e:	df 91       	pop	r29
    2850:	08 95       	ret

00002852 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2852:	df 93       	push	r29
    2854:	cf 93       	push	r28
    2856:	cd b7       	in	r28, 0x3d	; 61
    2858:	de b7       	in	r29, 0x3e	; 62
    285a:	2a 97       	sbiw	r28, 0x0a	; 10
    285c:	0f b6       	in	r0, 0x3f	; 63
    285e:	f8 94       	cli
    2860:	de bf       	out	0x3e, r29	; 62
    2862:	0f be       	out	0x3f, r0	; 63
    2864:	cd bf       	out	0x3d, r28	; 61
    2866:	98 87       	std	Y+8, r25	; 0x08
    2868:	8f 83       	std	Y+7, r24	; 0x07
    286a:	7a 87       	std	Y+10, r23	; 0x0a
    286c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    286e:	8f 81       	ldd	r24, Y+7	; 0x07
    2870:	98 85       	ldd	r25, Y+8	; 0x08
    2872:	9a 83       	std	Y+2, r25	; 0x02
    2874:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2876:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2878:	e9 81       	ldd	r30, Y+1	; 0x01
    287a:	fa 81       	ldd	r31, Y+2	; 0x02
    287c:	82 8d       	ldd	r24, Z+26	; 0x1a
    287e:	88 23       	and	r24, r24
    2880:	b1 f0       	breq	.+44     	; 0x28ae <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2882:	e9 81       	ldd	r30, Y+1	; 0x01
    2884:	fa 81       	ldd	r31, Y+2	; 0x02
    2886:	86 81       	ldd	r24, Z+6	; 0x06
    2888:	97 81       	ldd	r25, Z+7	; 0x07
    288a:	9c 83       	std	Y+4, r25	; 0x04
    288c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    288e:	89 81       	ldd	r24, Y+1	; 0x01
    2890:	9a 81       	ldd	r25, Y+2	; 0x02
    2892:	29 85       	ldd	r18, Y+9	; 0x09
    2894:	3a 85       	ldd	r19, Y+10	; 0x0a
    2896:	b9 01       	movw	r22, r18
    2898:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    289c:	e9 81       	ldd	r30, Y+1	; 0x01
    289e:	fa 81       	ldd	r31, Y+2	; 0x02
    28a0:	8b 81       	ldd	r24, Y+3	; 0x03
    28a2:	9c 81       	ldd	r25, Y+4	; 0x04
    28a4:	97 83       	std	Z+7, r25	; 0x07
    28a6:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	8e 83       	std	Y+6, r24	; 0x06
    28ac:	01 c0       	rjmp	.+2      	; 0x28b0 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    28ae:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    28b0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    28b2:	2a 96       	adiw	r28, 0x0a	; 10
    28b4:	0f b6       	in	r0, 0x3f	; 63
    28b6:	f8 94       	cli
    28b8:	de bf       	out	0x3e, r29	; 62
    28ba:	0f be       	out	0x3f, r0	; 63
    28bc:	cd bf       	out	0x3d, r28	; 61
    28be:	cf 91       	pop	r28
    28c0:	df 91       	pop	r29
    28c2:	08 95       	ret

000028c4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    28c4:	df 93       	push	r29
    28c6:	cf 93       	push	r28
    28c8:	00 d0       	rcall	.+0      	; 0x28ca <uxQueueMessagesWaiting+0x6>
    28ca:	0f 92       	push	r0
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	9b 83       	std	Y+3, r25	; 0x03
    28d2:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    28d4:	0f b6       	in	r0, 0x3f	; 63
    28d6:	f8 94       	cli
    28d8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    28da:	ea 81       	ldd	r30, Y+2	; 0x02
    28dc:	fb 81       	ldd	r31, Y+3	; 0x03
    28de:	82 8d       	ldd	r24, Z+26	; 0x1a
    28e0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    28e2:	0f 90       	pop	r0
    28e4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28e8:	0f 90       	pop	r0
    28ea:	0f 90       	pop	r0
    28ec:	0f 90       	pop	r0
    28ee:	cf 91       	pop	r28
    28f0:	df 91       	pop	r29
    28f2:	08 95       	ret

000028f4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    28f4:	df 93       	push	r29
    28f6:	cf 93       	push	r28
    28f8:	00 d0       	rcall	.+0      	; 0x28fa <uxQueueSpacesAvailable+0x6>
    28fa:	00 d0       	rcall	.+0      	; 0x28fc <uxQueueSpacesAvailable+0x8>
    28fc:	0f 92       	push	r0
    28fe:	cd b7       	in	r28, 0x3d	; 61
    2900:	de b7       	in	r29, 0x3e	; 62
    2902:	9d 83       	std	Y+5, r25	; 0x05
    2904:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2906:	8c 81       	ldd	r24, Y+4	; 0x04
    2908:	9d 81       	ldd	r25, Y+5	; 0x05
    290a:	9a 83       	std	Y+2, r25	; 0x02
    290c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    290e:	0f b6       	in	r0, 0x3f	; 63
    2910:	f8 94       	cli
    2912:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2914:	e9 81       	ldd	r30, Y+1	; 0x01
    2916:	fa 81       	ldd	r31, Y+2	; 0x02
    2918:	93 8d       	ldd	r25, Z+27	; 0x1b
    291a:	e9 81       	ldd	r30, Y+1	; 0x01
    291c:	fa 81       	ldd	r31, Y+2	; 0x02
    291e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2920:	29 2f       	mov	r18, r25
    2922:	28 1b       	sub	r18, r24
    2924:	82 2f       	mov	r24, r18
    2926:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2928:	0f 90       	pop	r0
    292a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    292c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    292e:	0f 90       	pop	r0
    2930:	0f 90       	pop	r0
    2932:	0f 90       	pop	r0
    2934:	0f 90       	pop	r0
    2936:	0f 90       	pop	r0
    2938:	cf 91       	pop	r28
    293a:	df 91       	pop	r29
    293c:	08 95       	ret

0000293e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    293e:	df 93       	push	r29
    2940:	cf 93       	push	r28
    2942:	00 d0       	rcall	.+0      	; 0x2944 <uxQueueMessagesWaitingFromISR+0x6>
    2944:	00 d0       	rcall	.+0      	; 0x2946 <uxQueueMessagesWaitingFromISR+0x8>
    2946:	0f 92       	push	r0
    2948:	cd b7       	in	r28, 0x3d	; 61
    294a:	de b7       	in	r29, 0x3e	; 62
    294c:	9d 83       	std	Y+5, r25	; 0x05
    294e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2950:	8c 81       	ldd	r24, Y+4	; 0x04
    2952:	9d 81       	ldd	r25, Y+5	; 0x05
    2954:	9a 83       	std	Y+2, r25	; 0x02
    2956:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2958:	e9 81       	ldd	r30, Y+1	; 0x01
    295a:	fa 81       	ldd	r31, Y+2	; 0x02
    295c:	82 8d       	ldd	r24, Z+26	; 0x1a
    295e:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2960:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2962:	0f 90       	pop	r0
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	0f 90       	pop	r0
    296a:	0f 90       	pop	r0
    296c:	cf 91       	pop	r28
    296e:	df 91       	pop	r29
    2970:	08 95       	ret

00002972 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2972:	df 93       	push	r29
    2974:	cf 93       	push	r28
    2976:	00 d0       	rcall	.+0      	; 0x2978 <vQueueDelete+0x6>
    2978:	00 d0       	rcall	.+0      	; 0x297a <vQueueDelete+0x8>
    297a:	cd b7       	in	r28, 0x3d	; 61
    297c:	de b7       	in	r29, 0x3e	; 62
    297e:	9c 83       	std	Y+4, r25	; 0x04
    2980:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2982:	8b 81       	ldd	r24, Y+3	; 0x03
    2984:	9c 81       	ldd	r25, Y+4	; 0x04
    2986:	9a 83       	std	Y+2, r25	; 0x02
    2988:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    298a:	89 81       	ldd	r24, Y+1	; 0x01
    298c:	9a 81       	ldd	r25, Y+2	; 0x02
    298e:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2992:	0f 90       	pop	r0
    2994:	0f 90       	pop	r0
    2996:	0f 90       	pop	r0
    2998:	0f 90       	pop	r0
    299a:	cf 91       	pop	r28
    299c:	df 91       	pop	r29
    299e:	08 95       	ret

000029a0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    29a0:	df 93       	push	r29
    29a2:	cf 93       	push	r28
    29a4:	00 d0       	rcall	.+0      	; 0x29a6 <prvGetDisinheritPriorityAfterTimeout+0x6>
    29a6:	0f 92       	push	r0
    29a8:	cd b7       	in	r28, 0x3d	; 61
    29aa:	de b7       	in	r29, 0x3e	; 62
    29ac:	9b 83       	std	Y+3, r25	; 0x03
    29ae:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    29b0:	ea 81       	ldd	r30, Y+2	; 0x02
    29b2:	fb 81       	ldd	r31, Y+3	; 0x03
    29b4:	81 89       	ldd	r24, Z+17	; 0x11
    29b6:	88 23       	and	r24, r24
    29b8:	61 f0       	breq	.+24     	; 0x29d2 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    29ba:	ea 81       	ldd	r30, Y+2	; 0x02
    29bc:	fb 81       	ldd	r31, Y+3	; 0x03
    29be:	06 88       	ldd	r0, Z+22	; 0x16
    29c0:	f7 89       	ldd	r31, Z+23	; 0x17
    29c2:	e0 2d       	mov	r30, r0
    29c4:	80 81       	ld	r24, Z
    29c6:	91 81       	ldd	r25, Z+1	; 0x01
    29c8:	98 2f       	mov	r25, r24
    29ca:	87 e0       	ldi	r24, 0x07	; 7
    29cc:	89 1b       	sub	r24, r25
    29ce:	89 83       	std	Y+1, r24	; 0x01
    29d0:	01 c0       	rjmp	.+2      	; 0x29d4 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    29d2:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    29d4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    29d6:	0f 90       	pop	r0
    29d8:	0f 90       	pop	r0
    29da:	0f 90       	pop	r0
    29dc:	cf 91       	pop	r28
    29de:	df 91       	pop	r29
    29e0:	08 95       	ret

000029e2 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    29e2:	df 93       	push	r29
    29e4:	cf 93       	push	r28
    29e6:	cd b7       	in	r28, 0x3d	; 61
    29e8:	de b7       	in	r29, 0x3e	; 62
    29ea:	27 97       	sbiw	r28, 0x07	; 7
    29ec:	0f b6       	in	r0, 0x3f	; 63
    29ee:	f8 94       	cli
    29f0:	de bf       	out	0x3e, r29	; 62
    29f2:	0f be       	out	0x3f, r0	; 63
    29f4:	cd bf       	out	0x3d, r28	; 61
    29f6:	9c 83       	std	Y+4, r25	; 0x04
    29f8:	8b 83       	std	Y+3, r24	; 0x03
    29fa:	7e 83       	std	Y+6, r23	; 0x06
    29fc:	6d 83       	std	Y+5, r22	; 0x05
    29fe:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2a00:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2a02:	eb 81       	ldd	r30, Y+3	; 0x03
    2a04:	fc 81       	ldd	r31, Y+4	; 0x04
    2a06:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a08:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a10:	88 23       	and	r24, r24
    2a12:	99 f4       	brne	.+38     	; 0x2a3a <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2a14:	eb 81       	ldd	r30, Y+3	; 0x03
    2a16:	fc 81       	ldd	r31, Y+4	; 0x04
    2a18:	80 81       	ld	r24, Z
    2a1a:	91 81       	ldd	r25, Z+1	; 0x01
    2a1c:	00 97       	sbiw	r24, 0x00	; 0
    2a1e:	09 f0       	breq	.+2      	; 0x2a22 <prvCopyDataToQueue+0x40>
    2a20:	89 c0       	rjmp	.+274    	; 0x2b34 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    2a22:	eb 81       	ldd	r30, Y+3	; 0x03
    2a24:	fc 81       	ldd	r31, Y+4	; 0x04
    2a26:	84 81       	ldd	r24, Z+4	; 0x04
    2a28:	95 81       	ldd	r25, Z+5	; 0x05
    2a2a:	0e 94 c8 27 	call	0x4f90	; 0x4f90 <xTaskPriorityDisinherit>
    2a2e:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    2a30:	eb 81       	ldd	r30, Y+3	; 0x03
    2a32:	fc 81       	ldd	r31, Y+4	; 0x04
    2a34:	15 82       	std	Z+5, r1	; 0x05
    2a36:	14 82       	std	Z+4, r1	; 0x04
    2a38:	7d c0       	rjmp	.+250    	; 0x2b34 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2a3a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a3c:	88 23       	and	r24, r24
    2a3e:	99 f5       	brne	.+102    	; 0x2aa6 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2a40:	eb 81       	ldd	r30, Y+3	; 0x03
    2a42:	fc 81       	ldd	r31, Y+4	; 0x04
    2a44:	62 81       	ldd	r22, Z+2	; 0x02
    2a46:	73 81       	ldd	r23, Z+3	; 0x03
    2a48:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a4e:	48 2f       	mov	r20, r24
    2a50:	50 e0       	ldi	r21, 0x00	; 0
    2a52:	2d 81       	ldd	r18, Y+5	; 0x05
    2a54:	3e 81       	ldd	r19, Y+6	; 0x06
    2a56:	cb 01       	movw	r24, r22
    2a58:	b9 01       	movw	r22, r18
    2a5a:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a5e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a60:	fc 81       	ldd	r31, Y+4	; 0x04
    2a62:	22 81       	ldd	r18, Z+2	; 0x02
    2a64:	33 81       	ldd	r19, Z+3	; 0x03
    2a66:	eb 81       	ldd	r30, Y+3	; 0x03
    2a68:	fc 81       	ldd	r31, Y+4	; 0x04
    2a6a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a6c:	88 2f       	mov	r24, r24
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	82 0f       	add	r24, r18
    2a72:	93 1f       	adc	r25, r19
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	93 83       	std	Z+3, r25	; 0x03
    2a7a:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a80:	22 81       	ldd	r18, Z+2	; 0x02
    2a82:	33 81       	ldd	r19, Z+3	; 0x03
    2a84:	eb 81       	ldd	r30, Y+3	; 0x03
    2a86:	fc 81       	ldd	r31, Y+4	; 0x04
    2a88:	84 81       	ldd	r24, Z+4	; 0x04
    2a8a:	95 81       	ldd	r25, Z+5	; 0x05
    2a8c:	28 17       	cp	r18, r24
    2a8e:	39 07       	cpc	r19, r25
    2a90:	08 f4       	brcc	.+2      	; 0x2a94 <prvCopyDataToQueue+0xb2>
    2a92:	50 c0       	rjmp	.+160    	; 0x2b34 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2a94:	eb 81       	ldd	r30, Y+3	; 0x03
    2a96:	fc 81       	ldd	r31, Y+4	; 0x04
    2a98:	80 81       	ld	r24, Z
    2a9a:	91 81       	ldd	r25, Z+1	; 0x01
    2a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa0:	93 83       	std	Z+3, r25	; 0x03
    2aa2:	82 83       	std	Z+2, r24	; 0x02
    2aa4:	47 c0       	rjmp	.+142    	; 0x2b34 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aaa:	66 81       	ldd	r22, Z+6	; 0x06
    2aac:	77 81       	ldd	r23, Z+7	; 0x07
    2aae:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ab4:	48 2f       	mov	r20, r24
    2ab6:	50 e0       	ldi	r21, 0x00	; 0
    2ab8:	2d 81       	ldd	r18, Y+5	; 0x05
    2aba:	3e 81       	ldd	r19, Y+6	; 0x06
    2abc:	cb 01       	movw	r24, r22
    2abe:	b9 01       	movw	r22, r18
    2ac0:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2ac4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac8:	26 81       	ldd	r18, Z+6	; 0x06
    2aca:	37 81       	ldd	r19, Z+7	; 0x07
    2acc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ace:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ad2:	88 2f       	mov	r24, r24
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	90 95       	com	r25
    2ad8:	81 95       	neg	r24
    2ada:	9f 4f       	sbci	r25, 0xFF	; 255
    2adc:	82 0f       	add	r24, r18
    2ade:	93 1f       	adc	r25, r19
    2ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae4:	97 83       	std	Z+7, r25	; 0x07
    2ae6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aea:	fc 81       	ldd	r31, Y+4	; 0x04
    2aec:	26 81       	ldd	r18, Z+6	; 0x06
    2aee:	37 81       	ldd	r19, Z+7	; 0x07
    2af0:	eb 81       	ldd	r30, Y+3	; 0x03
    2af2:	fc 81       	ldd	r31, Y+4	; 0x04
    2af4:	80 81       	ld	r24, Z
    2af6:	91 81       	ldd	r25, Z+1	; 0x01
    2af8:	28 17       	cp	r18, r24
    2afa:	39 07       	cpc	r19, r25
    2afc:	90 f4       	brcc	.+36     	; 0x2b22 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2afe:	eb 81       	ldd	r30, Y+3	; 0x03
    2b00:	fc 81       	ldd	r31, Y+4	; 0x04
    2b02:	24 81       	ldd	r18, Z+4	; 0x04
    2b04:	35 81       	ldd	r19, Z+5	; 0x05
    2b06:	eb 81       	ldd	r30, Y+3	; 0x03
    2b08:	fc 81       	ldd	r31, Y+4	; 0x04
    2b0a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b0c:	88 2f       	mov	r24, r24
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	90 95       	com	r25
    2b12:	81 95       	neg	r24
    2b14:	9f 4f       	sbci	r25, 0xFF	; 255
    2b16:	82 0f       	add	r24, r18
    2b18:	93 1f       	adc	r25, r19
    2b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1e:	97 83       	std	Z+7, r25	; 0x07
    2b20:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2b22:	8f 81       	ldd	r24, Y+7	; 0x07
    2b24:	82 30       	cpi	r24, 0x02	; 2
    2b26:	31 f4       	brne	.+12     	; 0x2b34 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b28:	89 81       	ldd	r24, Y+1	; 0x01
    2b2a:	88 23       	and	r24, r24
    2b2c:	19 f0       	breq	.+6      	; 0x2b34 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2b2e:	89 81       	ldd	r24, Y+1	; 0x01
    2b30:	81 50       	subi	r24, 0x01	; 1
    2b32:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	8f 5f       	subi	r24, 0xFF	; 255
    2b38:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b3c:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2b3e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2b40:	27 96       	adiw	r28, 0x07	; 7
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	f8 94       	cli
    2b46:	de bf       	out	0x3e, r29	; 62
    2b48:	0f be       	out	0x3f, r0	; 63
    2b4a:	cd bf       	out	0x3d, r28	; 61
    2b4c:	cf 91       	pop	r28
    2b4e:	df 91       	pop	r29
    2b50:	08 95       	ret

00002b52 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2b52:	df 93       	push	r29
    2b54:	cf 93       	push	r28
    2b56:	00 d0       	rcall	.+0      	; 0x2b58 <prvCopyDataFromQueue+0x6>
    2b58:	00 d0       	rcall	.+0      	; 0x2b5a <prvCopyDataFromQueue+0x8>
    2b5a:	cd b7       	in	r28, 0x3d	; 61
    2b5c:	de b7       	in	r29, 0x3e	; 62
    2b5e:	9a 83       	std	Y+2, r25	; 0x02
    2b60:	89 83       	std	Y+1, r24	; 0x01
    2b62:	7c 83       	std	Y+4, r23	; 0x04
    2b64:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b66:	e9 81       	ldd	r30, Y+1	; 0x01
    2b68:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b6c:	88 23       	and	r24, r24
    2b6e:	89 f1       	breq	.+98     	; 0x2bd2 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2b70:	e9 81       	ldd	r30, Y+1	; 0x01
    2b72:	fa 81       	ldd	r31, Y+2	; 0x02
    2b74:	26 81       	ldd	r18, Z+6	; 0x06
    2b76:	37 81       	ldd	r19, Z+7	; 0x07
    2b78:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b7e:	88 2f       	mov	r24, r24
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	82 0f       	add	r24, r18
    2b84:	93 1f       	adc	r25, r19
    2b86:	e9 81       	ldd	r30, Y+1	; 0x01
    2b88:	fa 81       	ldd	r31, Y+2	; 0x02
    2b8a:	97 83       	std	Z+7, r25	; 0x07
    2b8c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b90:	fa 81       	ldd	r31, Y+2	; 0x02
    2b92:	26 81       	ldd	r18, Z+6	; 0x06
    2b94:	37 81       	ldd	r19, Z+7	; 0x07
    2b96:	e9 81       	ldd	r30, Y+1	; 0x01
    2b98:	fa 81       	ldd	r31, Y+2	; 0x02
    2b9a:	84 81       	ldd	r24, Z+4	; 0x04
    2b9c:	95 81       	ldd	r25, Z+5	; 0x05
    2b9e:	28 17       	cp	r18, r24
    2ba0:	39 07       	cpc	r19, r25
    2ba2:	40 f0       	brcs	.+16     	; 0x2bb4 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	80 81       	ld	r24, Z
    2baa:	91 81       	ldd	r25, Z+1	; 0x01
    2bac:	e9 81       	ldd	r30, Y+1	; 0x01
    2bae:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb0:	97 83       	std	Z+7, r25	; 0x07
    2bb2:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2bb8:	46 81       	ldd	r20, Z+6	; 0x06
    2bba:	57 81       	ldd	r21, Z+7	; 0x07
    2bbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bc2:	28 2f       	mov	r18, r24
    2bc4:	30 e0       	ldi	r19, 0x00	; 0
    2bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bca:	ba 01       	movw	r22, r20
    2bcc:	a9 01       	movw	r20, r18
    2bce:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>
	}
}
    2bd2:	0f 90       	pop	r0
    2bd4:	0f 90       	pop	r0
    2bd6:	0f 90       	pop	r0
    2bd8:	0f 90       	pop	r0
    2bda:	cf 91       	pop	r28
    2bdc:	df 91       	pop	r29
    2bde:	08 95       	ret

00002be0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2be0:	df 93       	push	r29
    2be2:	cf 93       	push	r28
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <prvUnlockQueue+0x6>
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <prvUnlockQueue+0x8>
    2be8:	cd b7       	in	r28, 0x3d	; 61
    2bea:	de b7       	in	r29, 0x3e	; 62
    2bec:	9c 83       	std	Y+4, r25	; 0x04
    2bee:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2bf0:	0f b6       	in	r0, 0x3f	; 63
    2bf2:	f8 94       	cli
    2bf4:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bfc:	8a 83       	std	Y+2, r24	; 0x02
    2bfe:	11 c0       	rjmp	.+34     	; 0x2c22 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c00:	eb 81       	ldd	r30, Y+3	; 0x03
    2c02:	fc 81       	ldd	r31, Y+4	; 0x04
    2c04:	81 89       	ldd	r24, Z+17	; 0x11
    2c06:	88 23       	and	r24, r24
    2c08:	79 f0       	breq	.+30     	; 0x2c28 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c0a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c0c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0e:	41 96       	adiw	r24, 0x11	; 17
    2c10:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2c14:	88 23       	and	r24, r24
    2c16:	11 f0       	breq	.+4      	; 0x2c1c <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2c18:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	81 50       	subi	r24, 0x01	; 1
    2c20:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2c22:	8a 81       	ldd	r24, Y+2	; 0x02
    2c24:	18 16       	cp	r1, r24
    2c26:	64 f3       	brlt	.-40     	; 0x2c00 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2c28:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2c:	8f ef       	ldi	r24, 0xFF	; 255
    2c2e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2c30:	0f 90       	pop	r0
    2c32:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	f8 94       	cli
    2c38:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2c3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c40:	89 83       	std	Y+1, r24	; 0x01
    2c42:	11 c0       	rjmp	.+34     	; 0x2c66 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2c44:	eb 81       	ldd	r30, Y+3	; 0x03
    2c46:	fc 81       	ldd	r31, Y+4	; 0x04
    2c48:	80 85       	ldd	r24, Z+8	; 0x08
    2c4a:	88 23       	and	r24, r24
    2c4c:	79 f0       	breq	.+30     	; 0x2c6c <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c50:	9c 81       	ldd	r25, Y+4	; 0x04
    2c52:	08 96       	adiw	r24, 0x08	; 8
    2c54:	0e 94 e7 24 	call	0x49ce	; 0x49ce <xTaskRemoveFromEventList>
    2c58:	88 23       	and	r24, r24
    2c5a:	11 f0       	breq	.+4      	; 0x2c60 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2c5c:	0e 94 53 26 	call	0x4ca6	; 0x4ca6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2c60:	89 81       	ldd	r24, Y+1	; 0x01
    2c62:	81 50       	subi	r24, 0x01	; 1
    2c64:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2c66:	89 81       	ldd	r24, Y+1	; 0x01
    2c68:	18 16       	cp	r1, r24
    2c6a:	64 f3       	brlt	.-40     	; 0x2c44 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c70:	8f ef       	ldi	r24, 0xFF	; 255
    2c72:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2c74:	0f 90       	pop	r0
    2c76:	0f be       	out	0x3f, r0	; 63
}
    2c78:	0f 90       	pop	r0
    2c7a:	0f 90       	pop	r0
    2c7c:	0f 90       	pop	r0
    2c7e:	0f 90       	pop	r0
    2c80:	cf 91       	pop	r28
    2c82:	df 91       	pop	r29
    2c84:	08 95       	ret

00002c86 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2c86:	df 93       	push	r29
    2c88:	cf 93       	push	r28
    2c8a:	00 d0       	rcall	.+0      	; 0x2c8c <prvIsQueueEmpty+0x6>
    2c8c:	0f 92       	push	r0
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	9b 83       	std	Y+3, r25	; 0x03
    2c94:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2c96:	0f b6       	in	r0, 0x3f	; 63
    2c98:	f8 94       	cli
    2c9a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ca0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ca2:	88 23       	and	r24, r24
    2ca4:	19 f4       	brne	.+6      	; 0x2cac <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	89 83       	std	Y+1, r24	; 0x01
    2caa:	01 c0       	rjmp	.+2      	; 0x2cae <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2cac:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2cae:	0f 90       	pop	r0
    2cb0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2cb2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cb4:	0f 90       	pop	r0
    2cb6:	0f 90       	pop	r0
    2cb8:	0f 90       	pop	r0
    2cba:	cf 91       	pop	r28
    2cbc:	df 91       	pop	r29
    2cbe:	08 95       	ret

00002cc0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2cc0:	df 93       	push	r29
    2cc2:	cf 93       	push	r28
    2cc4:	00 d0       	rcall	.+0      	; 0x2cc6 <xQueueIsQueueEmptyFromISR+0x6>
    2cc6:	00 d0       	rcall	.+0      	; 0x2cc8 <xQueueIsQueueEmptyFromISR+0x8>
    2cc8:	0f 92       	push	r0
    2cca:	cd b7       	in	r28, 0x3d	; 61
    2ccc:	de b7       	in	r29, 0x3e	; 62
    2cce:	9d 83       	std	Y+5, r25	; 0x05
    2cd0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2cd2:	8c 81       	ldd	r24, Y+4	; 0x04
    2cd4:	9d 81       	ldd	r25, Y+5	; 0x05
    2cd6:	9a 83       	std	Y+2, r25	; 0x02
    2cd8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2cda:	e9 81       	ldd	r30, Y+1	; 0x01
    2cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2cde:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ce0:	88 23       	and	r24, r24
    2ce2:	19 f4       	brne	.+6      	; 0x2cea <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2ce4:	81 e0       	ldi	r24, 0x01	; 1
    2ce6:	8b 83       	std	Y+3, r24	; 0x03
    2ce8:	01 c0       	rjmp	.+2      	; 0x2cec <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2cea:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2cec:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2cee:	0f 90       	pop	r0
    2cf0:	0f 90       	pop	r0
    2cf2:	0f 90       	pop	r0
    2cf4:	0f 90       	pop	r0
    2cf6:	0f 90       	pop	r0
    2cf8:	cf 91       	pop	r28
    2cfa:	df 91       	pop	r29
    2cfc:	08 95       	ret

00002cfe <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2cfe:	df 93       	push	r29
    2d00:	cf 93       	push	r28
    2d02:	00 d0       	rcall	.+0      	; 0x2d04 <prvIsQueueFull+0x6>
    2d04:	0f 92       	push	r0
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
    2d0a:	9b 83       	std	Y+3, r25	; 0x03
    2d0c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2d0e:	0f b6       	in	r0, 0x3f	; 63
    2d10:	f8 94       	cli
    2d12:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d14:	ea 81       	ldd	r30, Y+2	; 0x02
    2d16:	fb 81       	ldd	r31, Y+3	; 0x03
    2d18:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d20:	98 17       	cp	r25, r24
    2d22:	19 f4       	brne	.+6      	; 0x2d2a <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2d24:	81 e0       	ldi	r24, 0x01	; 1
    2d26:	89 83       	std	Y+1, r24	; 0x01
    2d28:	01 c0       	rjmp	.+2      	; 0x2d2c <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2d2a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2d2c:	0f 90       	pop	r0
    2d2e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2d30:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d32:	0f 90       	pop	r0
    2d34:	0f 90       	pop	r0
    2d36:	0f 90       	pop	r0
    2d38:	cf 91       	pop	r28
    2d3a:	df 91       	pop	r29
    2d3c:	08 95       	ret

00002d3e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2d3e:	df 93       	push	r29
    2d40:	cf 93       	push	r28
    2d42:	00 d0       	rcall	.+0      	; 0x2d44 <xQueueIsQueueFullFromISR+0x6>
    2d44:	00 d0       	rcall	.+0      	; 0x2d46 <xQueueIsQueueFullFromISR+0x8>
    2d46:	0f 92       	push	r0
    2d48:	cd b7       	in	r28, 0x3d	; 61
    2d4a:	de b7       	in	r29, 0x3e	; 62
    2d4c:	9d 83       	std	Y+5, r25	; 0x05
    2d4e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2d50:	8c 81       	ldd	r24, Y+4	; 0x04
    2d52:	9d 81       	ldd	r25, Y+5	; 0x05
    2d54:	9a 83       	std	Y+2, r25	; 0x02
    2d56:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2d58:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d5c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d60:	fa 81       	ldd	r31, Y+2	; 0x02
    2d62:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d64:	98 17       	cp	r25, r24
    2d66:	19 f4       	brne	.+6      	; 0x2d6e <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	8b 83       	std	Y+3, r24	; 0x03
    2d6c:	01 c0       	rjmp	.+2      	; 0x2d70 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2d6e:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2d70:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2d72:	0f 90       	pop	r0
    2d74:	0f 90       	pop	r0
    2d76:	0f 90       	pop	r0
    2d78:	0f 90       	pop	r0
    2d7a:	0f 90       	pop	r0
    2d7c:	cf 91       	pop	r28
    2d7e:	df 91       	pop	r29
    2d80:	08 95       	ret

00002d82 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2d82:	0f 93       	push	r16
    2d84:	df 93       	push	r29
    2d86:	cf 93       	push	r28
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
    2d8c:	28 97       	sbiw	r28, 0x08	; 8
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	f8 94       	cli
    2d92:	de bf       	out	0x3e, r29	; 62
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	cd bf       	out	0x3d, r28	; 61
    2d98:	9d 83       	std	Y+5, r25	; 0x05
    2d9a:	8c 83       	std	Y+4, r24	; 0x04
    2d9c:	7f 83       	std	Y+7, r23	; 0x07
    2d9e:	6e 83       	std	Y+6, r22	; 0x06
    2da0:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2da2:	88 85       	ldd	r24, Y+8	; 0x08
    2da4:	81 30       	cpi	r24, 0x01	; 1
    2da6:	19 f4       	brne	.+6      	; 0x2dae <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2da8:	81 e0       	ldi	r24, 0x01	; 1
    2daa:	89 83       	std	Y+1, r24	; 0x01
    2dac:	01 c0       	rjmp	.+2      	; 0x2db0 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2dae:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2db0:	8e 81       	ldd	r24, Y+6	; 0x06
    2db2:	9f 81       	ldd	r25, Y+7	; 0x07
    2db4:	00 97       	sbiw	r24, 0x00	; 0
    2db6:	21 f4       	brne	.+8      	; 0x2dc0 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2db8:	81 e0       	ldi	r24, 0x01	; 1
    2dba:	90 e0       	ldi	r25, 0x00	; 0
    2dbc:	9f 83       	std	Y+7, r25	; 0x07
    2dbe:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2dc0:	8c 81       	ldd	r24, Y+4	; 0x04
    2dc2:	9d 81       	ldd	r25, Y+5	; 0x05
    2dc4:	01 96       	adiw	r24, 0x01	; 1
    2dc6:	9d 83       	std	Y+5, r25	; 0x05
    2dc8:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2dca:	8c 81       	ldd	r24, Y+4	; 0x04
    2dcc:	9d 81       	ldd	r25, Y+5	; 0x05
    2dce:	0f 96       	adiw	r24, 0x0f	; 15
    2dd0:	0e 94 c9 08 	call	0x1192	; 0x1192 <pvPortMalloc>
    2dd4:	9b 83       	std	Y+3, r25	; 0x03
    2dd6:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dda:	9b 81       	ldd	r25, Y+3	; 0x03
    2ddc:	00 97       	sbiw	r24, 0x00	; 0
    2dde:	89 f0       	breq	.+34     	; 0x2e02 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2de0:	6a 81       	ldd	r22, Y+2	; 0x02
    2de2:	7b 81       	ldd	r23, Y+3	; 0x03
    2de4:	8a 81       	ldd	r24, Y+2	; 0x02
    2de6:	9b 81       	ldd	r25, Y+3	; 0x03
    2de8:	9c 01       	movw	r18, r24
    2dea:	21 5f       	subi	r18, 0xF1	; 241
    2dec:	3f 4f       	sbci	r19, 0xFF	; 255
    2dee:	4c 81       	ldd	r20, Y+4	; 0x04
    2df0:	5d 81       	ldd	r21, Y+5	; 0x05
    2df2:	ee 81       	ldd	r30, Y+6	; 0x06
    2df4:	ff 81       	ldd	r31, Y+7	; 0x07
    2df6:	cb 01       	movw	r24, r22
    2df8:	b9 01       	movw	r22, r18
    2dfa:	9f 01       	movw	r18, r30
    2dfc:	09 81       	ldd	r16, Y+1	; 0x01
    2dfe:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2e02:	8a 81       	ldd	r24, Y+2	; 0x02
    2e04:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2e06:	28 96       	adiw	r28, 0x08	; 8
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	f8 94       	cli
    2e0c:	de bf       	out	0x3e, r29	; 62
    2e0e:	0f be       	out	0x3f, r0	; 63
    2e10:	cd bf       	out	0x3d, r28	; 61
    2e12:	cf 91       	pop	r28
    2e14:	df 91       	pop	r29
    2e16:	0f 91       	pop	r16
    2e18:	08 95       	ret

00002e1a <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2e1a:	df 93       	push	r29
    2e1c:	cf 93       	push	r28
    2e1e:	00 d0       	rcall	.+0      	; 0x2e20 <vStreamBufferDelete+0x6>
    2e20:	00 d0       	rcall	.+0      	; 0x2e22 <vStreamBufferDelete+0x8>
    2e22:	cd b7       	in	r28, 0x3d	; 61
    2e24:	de b7       	in	r29, 0x3e	; 62
    2e26:	9c 83       	std	Y+4, r25	; 0x04
    2e28:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	9a 83       	std	Y+2, r25	; 0x02
    2e30:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2e32:	e9 81       	ldd	r30, Y+1	; 0x01
    2e34:	fa 81       	ldd	r31, Y+2	; 0x02
    2e36:	86 85       	ldd	r24, Z+14	; 0x0e
    2e38:	88 2f       	mov	r24, r24
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	82 70       	andi	r24, 0x02	; 2
    2e3e:	90 70       	andi	r25, 0x00	; 0
    2e40:	00 97       	sbiw	r24, 0x00	; 0
    2e42:	29 f4       	brne	.+10     	; 0x2e4e <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2e44:	89 81       	ldd	r24, Y+1	; 0x01
    2e46:	9a 81       	ldd	r25, Y+2	; 0x02
    2e48:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
    2e4c:	08 c0       	rjmp	.+16     	; 0x2e5e <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2e4e:	89 81       	ldd	r24, Y+1	; 0x01
    2e50:	9a 81       	ldd	r25, Y+2	; 0x02
    2e52:	60 e0       	ldi	r22, 0x00	; 0
    2e54:	70 e0       	ldi	r23, 0x00	; 0
    2e56:	4f e0       	ldi	r20, 0x0F	; 15
    2e58:	50 e0       	ldi	r21, 0x00	; 0
    2e5a:	0e 94 3b 2d 	call	0x5a76	; 0x5a76 <memset>
	}
}
    2e5e:	0f 90       	pop	r0
    2e60:	0f 90       	pop	r0
    2e62:	0f 90       	pop	r0
    2e64:	0f 90       	pop	r0
    2e66:	cf 91       	pop	r28
    2e68:	df 91       	pop	r29
    2e6a:	08 95       	ret

00002e6c <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2e6c:	0f 93       	push	r16
    2e6e:	df 93       	push	r29
    2e70:	cf 93       	push	r28
    2e72:	00 d0       	rcall	.+0      	; 0x2e74 <xStreamBufferReset+0x8>
    2e74:	00 d0       	rcall	.+0      	; 0x2e76 <xStreamBufferReset+0xa>
    2e76:	0f 92       	push	r0
    2e78:	cd b7       	in	r28, 0x3d	; 61
    2e7a:	de b7       	in	r29, 0x3e	; 62
    2e7c:	9d 83       	std	Y+5, r25	; 0x05
    2e7e:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2e80:	8c 81       	ldd	r24, Y+4	; 0x04
    2e82:	9d 81       	ldd	r25, Y+5	; 0x05
    2e84:	9b 83       	std	Y+3, r25	; 0x03
    2e86:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2e88:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2e8a:	0f b6       	in	r0, 0x3f	; 63
    2e8c:	f8 94       	cli
    2e8e:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2e90:	ea 81       	ldd	r30, Y+2	; 0x02
    2e92:	fb 81       	ldd	r31, Y+3	; 0x03
    2e94:	80 85       	ldd	r24, Z+8	; 0x08
    2e96:	91 85       	ldd	r25, Z+9	; 0x09
    2e98:	00 97       	sbiw	r24, 0x00	; 0
    2e9a:	f1 f4       	brne	.+60     	; 0x2ed8 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2e9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ea0:	82 85       	ldd	r24, Z+10	; 0x0a
    2ea2:	93 85       	ldd	r25, Z+11	; 0x0b
    2ea4:	00 97       	sbiw	r24, 0x00	; 0
    2ea6:	c1 f4       	brne	.+48     	; 0x2ed8 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2ea8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eaa:	fb 81       	ldd	r31, Y+3	; 0x03
    2eac:	24 85       	ldd	r18, Z+12	; 0x0c
    2eae:	35 85       	ldd	r19, Z+13	; 0x0d
    2eb0:	ea 81       	ldd	r30, Y+2	; 0x02
    2eb2:	fb 81       	ldd	r31, Y+3	; 0x03
    2eb4:	44 81       	ldd	r20, Z+4	; 0x04
    2eb6:	55 81       	ldd	r21, Z+5	; 0x05
    2eb8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eba:	fb 81       	ldd	r31, Y+3	; 0x03
    2ebc:	a6 81       	ldd	r26, Z+6	; 0x06
    2ebe:	b7 81       	ldd	r27, Z+7	; 0x07
    2ec0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ec2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ec4:	e6 85       	ldd	r30, Z+14	; 0x0e
    2ec6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eca:	b9 01       	movw	r22, r18
    2ecc:	9d 01       	movw	r18, r26
    2ece:	0e 2f       	mov	r16, r30
    2ed0:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2ed4:	81 e0       	ldi	r24, 0x01	; 1
    2ed6:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2ed8:	0f 90       	pop	r0
    2eda:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2edc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ede:	0f 90       	pop	r0
    2ee0:	0f 90       	pop	r0
    2ee2:	0f 90       	pop	r0
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	cf 91       	pop	r28
    2eea:	df 91       	pop	r29
    2eec:	0f 91       	pop	r16
    2eee:	08 95       	ret

00002ef0 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2ef0:	df 93       	push	r29
    2ef2:	cf 93       	push	r28
    2ef4:	cd b7       	in	r28, 0x3d	; 61
    2ef6:	de b7       	in	r29, 0x3e	; 62
    2ef8:	27 97       	sbiw	r28, 0x07	; 7
    2efa:	0f b6       	in	r0, 0x3f	; 63
    2efc:	f8 94       	cli
    2efe:	de bf       	out	0x3e, r29	; 62
    2f00:	0f be       	out	0x3f, r0	; 63
    2f02:	cd bf       	out	0x3d, r28	; 61
    2f04:	9d 83       	std	Y+5, r25	; 0x05
    2f06:	8c 83       	std	Y+4, r24	; 0x04
    2f08:	7f 83       	std	Y+7, r23	; 0x07
    2f0a:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f0c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f0e:	9d 81       	ldd	r25, Y+5	; 0x05
    2f10:	9b 83       	std	Y+3, r25	; 0x03
    2f12:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2f14:	8e 81       	ldd	r24, Y+6	; 0x06
    2f16:	9f 81       	ldd	r25, Y+7	; 0x07
    2f18:	00 97       	sbiw	r24, 0x00	; 0
    2f1a:	21 f4       	brne	.+8      	; 0x2f24 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	9f 83       	std	Y+7, r25	; 0x07
    2f22:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2f24:	ea 81       	ldd	r30, Y+2	; 0x02
    2f26:	fb 81       	ldd	r31, Y+3	; 0x03
    2f28:	24 81       	ldd	r18, Z+4	; 0x04
    2f2a:	35 81       	ldd	r19, Z+5	; 0x05
    2f2c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f2e:	9f 81       	ldd	r25, Y+7	; 0x07
    2f30:	28 17       	cp	r18, r24
    2f32:	39 07       	cpc	r19, r25
    2f34:	48 f0       	brcs	.+18     	; 0x2f48 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2f36:	ea 81       	ldd	r30, Y+2	; 0x02
    2f38:	fb 81       	ldd	r31, Y+3	; 0x03
    2f3a:	8e 81       	ldd	r24, Y+6	; 0x06
    2f3c:	9f 81       	ldd	r25, Y+7	; 0x07
    2f3e:	97 83       	std	Z+7, r25	; 0x07
    2f40:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	89 83       	std	Y+1, r24	; 0x01
    2f46:	01 c0       	rjmp	.+2      	; 0x2f4a <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2f48:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2f4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f4c:	27 96       	adiw	r28, 0x07	; 7
    2f4e:	0f b6       	in	r0, 0x3f	; 63
    2f50:	f8 94       	cli
    2f52:	de bf       	out	0x3e, r29	; 62
    2f54:	0f be       	out	0x3f, r0	; 63
    2f56:	cd bf       	out	0x3d, r28	; 61
    2f58:	cf 91       	pop	r28
    2f5a:	df 91       	pop	r29
    2f5c:	08 95       	ret

00002f5e <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2f5e:	df 93       	push	r29
    2f60:	cf 93       	push	r28
    2f62:	00 d0       	rcall	.+0      	; 0x2f64 <xStreamBufferSpacesAvailable+0x6>
    2f64:	00 d0       	rcall	.+0      	; 0x2f66 <xStreamBufferSpacesAvailable+0x8>
    2f66:	00 d0       	rcall	.+0      	; 0x2f68 <xStreamBufferSpacesAvailable+0xa>
    2f68:	cd b7       	in	r28, 0x3d	; 61
    2f6a:	de b7       	in	r29, 0x3e	; 62
    2f6c:	9e 83       	std	Y+6, r25	; 0x06
    2f6e:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f70:	8d 81       	ldd	r24, Y+5	; 0x05
    2f72:	9e 81       	ldd	r25, Y+6	; 0x06
    2f74:	9c 83       	std	Y+4, r25	; 0x04
    2f76:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2f78:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7c:	24 81       	ldd	r18, Z+4	; 0x04
    2f7e:	35 81       	ldd	r19, Z+5	; 0x05
    2f80:	eb 81       	ldd	r30, Y+3	; 0x03
    2f82:	fc 81       	ldd	r31, Y+4	; 0x04
    2f84:	80 81       	ld	r24, Z
    2f86:	91 81       	ldd	r25, Z+1	; 0x01
    2f88:	82 0f       	add	r24, r18
    2f8a:	93 1f       	adc	r25, r19
    2f8c:	9a 83       	std	Y+2, r25	; 0x02
    2f8e:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2f90:	eb 81       	ldd	r30, Y+3	; 0x03
    2f92:	fc 81       	ldd	r31, Y+4	; 0x04
    2f94:	22 81       	ldd	r18, Z+2	; 0x02
    2f96:	33 81       	ldd	r19, Z+3	; 0x03
    2f98:	89 81       	ldd	r24, Y+1	; 0x01
    2f9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2f9c:	82 1b       	sub	r24, r18
    2f9e:	93 0b       	sbc	r25, r19
    2fa0:	9a 83       	std	Y+2, r25	; 0x02
    2fa2:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
    2fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa8:	01 97       	sbiw	r24, 0x01	; 1
    2faa:	9a 83       	std	Y+2, r25	; 0x02
    2fac:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2fae:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb2:	24 81       	ldd	r18, Z+4	; 0x04
    2fb4:	35 81       	ldd	r19, Z+5	; 0x05
    2fb6:	89 81       	ldd	r24, Y+1	; 0x01
    2fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fba:	82 17       	cp	r24, r18
    2fbc:	93 07       	cpc	r25, r19
    2fbe:	50 f0       	brcs	.+20     	; 0x2fd4 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc4:	24 81       	ldd	r18, Z+4	; 0x04
    2fc6:	35 81       	ldd	r19, Z+5	; 0x05
    2fc8:	89 81       	ldd	r24, Y+1	; 0x01
    2fca:	9a 81       	ldd	r25, Y+2	; 0x02
    2fcc:	82 1b       	sub	r24, r18
    2fce:	93 0b       	sbc	r25, r19
    2fd0:	9a 83       	std	Y+2, r25	; 0x02
    2fd2:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2fd4:	89 81       	ldd	r24, Y+1	; 0x01
    2fd6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2fd8:	26 96       	adiw	r28, 0x06	; 6
    2fda:	0f b6       	in	r0, 0x3f	; 63
    2fdc:	f8 94       	cli
    2fde:	de bf       	out	0x3e, r29	; 62
    2fe0:	0f be       	out	0x3f, r0	; 63
    2fe2:	cd bf       	out	0x3d, r28	; 61
    2fe4:	cf 91       	pop	r28
    2fe6:	df 91       	pop	r29
    2fe8:	08 95       	ret

00002fea <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2fea:	df 93       	push	r29
    2fec:	cf 93       	push	r28
    2fee:	00 d0       	rcall	.+0      	; 0x2ff0 <xStreamBufferBytesAvailable+0x6>
    2ff0:	00 d0       	rcall	.+0      	; 0x2ff2 <xStreamBufferBytesAvailable+0x8>
    2ff2:	00 d0       	rcall	.+0      	; 0x2ff4 <xStreamBufferBytesAvailable+0xa>
    2ff4:	cd b7       	in	r28, 0x3d	; 61
    2ff6:	de b7       	in	r29, 0x3e	; 62
    2ff8:	9e 83       	std	Y+6, r25	; 0x06
    2ffa:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ffc:	8d 81       	ldd	r24, Y+5	; 0x05
    2ffe:	9e 81       	ldd	r25, Y+6	; 0x06
    3000:	9c 83       	std	Y+4, r25	; 0x04
    3002:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3004:	8b 81       	ldd	r24, Y+3	; 0x03
    3006:	9c 81       	ldd	r25, Y+4	; 0x04
    3008:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    300c:	9a 83       	std	Y+2, r25	; 0x02
    300e:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    3010:	89 81       	ldd	r24, Y+1	; 0x01
    3012:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3014:	26 96       	adiw	r28, 0x06	; 6
    3016:	0f b6       	in	r0, 0x3f	; 63
    3018:	f8 94       	cli
    301a:	de bf       	out	0x3e, r29	; 62
    301c:	0f be       	out	0x3f, r0	; 63
    301e:	cd bf       	out	0x3d, r28	; 61
    3020:	cf 91       	pop	r28
    3022:	df 91       	pop	r29
    3024:	08 95       	ret

00003026 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3026:	ef 92       	push	r14
    3028:	ff 92       	push	r15
    302a:	0f 93       	push	r16
    302c:	1f 93       	push	r17
    302e:	df 93       	push	r29
    3030:	cf 93       	push	r28
    3032:	cd b7       	in	r28, 0x3d	; 61
    3034:	de b7       	in	r29, 0x3e	; 62
    3036:	63 97       	sbiw	r28, 0x13	; 19
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	f8 94       	cli
    303c:	de bf       	out	0x3e, r29	; 62
    303e:	0f be       	out	0x3f, r0	; 63
    3040:	cd bf       	out	0x3d, r28	; 61
    3042:	9d 87       	std	Y+13, r25	; 0x0d
    3044:	8c 87       	std	Y+12, r24	; 0x0c
    3046:	7f 87       	std	Y+15, r23	; 0x0f
    3048:	6e 87       	std	Y+14, r22	; 0x0e
    304a:	59 8b       	std	Y+17, r21	; 0x11
    304c:	48 8b       	std	Y+16, r20	; 0x10
    304e:	3b 8b       	std	Y+19, r19	; 0x13
    3050:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3052:	8c 85       	ldd	r24, Y+12	; 0x0c
    3054:	9d 85       	ldd	r25, Y+13	; 0x0d
    3056:	98 87       	std	Y+8, r25	; 0x08
    3058:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    305a:	1c 82       	std	Y+4, r1	; 0x04
    305c:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    305e:	88 89       	ldd	r24, Y+16	; 0x10
    3060:	99 89       	ldd	r25, Y+17	; 0x11
    3062:	9a 83       	std	Y+2, r25	; 0x02
    3064:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3066:	ef 81       	ldd	r30, Y+7	; 0x07
    3068:	f8 85       	ldd	r31, Y+8	; 0x08
    306a:	86 85       	ldd	r24, Z+14	; 0x0e
    306c:	88 2f       	mov	r24, r24
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	81 70       	andi	r24, 0x01	; 1
    3072:	90 70       	andi	r25, 0x00	; 0
    3074:	88 23       	and	r24, r24
    3076:	29 f0       	breq	.+10     	; 0x3082 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3078:	89 81       	ldd	r24, Y+1	; 0x01
    307a:	9a 81       	ldd	r25, Y+2	; 0x02
    307c:	02 96       	adiw	r24, 0x02	; 2
    307e:	9a 83       	std	Y+2, r25	; 0x02
    3080:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3082:	8a 89       	ldd	r24, Y+18	; 0x12
    3084:	9b 89       	ldd	r25, Y+19	; 0x13
    3086:	00 97       	sbiw	r24, 0x00	; 0
    3088:	09 f4       	brne	.+2      	; 0x308c <xStreamBufferSend+0x66>
    308a:	40 c0       	rjmp	.+128    	; 0x310c <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    308c:	ce 01       	movw	r24, r28
    308e:	09 96       	adiw	r24, 0x09	; 9
    3090:	0e 94 af 25 	call	0x4b5e	; 0x4b5e <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3094:	0f b6       	in	r0, 0x3f	; 63
    3096:	f8 94       	cli
    3098:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    309a:	8f 81       	ldd	r24, Y+7	; 0x07
    309c:	98 85       	ldd	r25, Y+8	; 0x08
    309e:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <xStreamBufferSpacesAvailable>
    30a2:	9c 83       	std	Y+4, r25	; 0x04
    30a4:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    30a6:	2b 81       	ldd	r18, Y+3	; 0x03
    30a8:	3c 81       	ldd	r19, Y+4	; 0x04
    30aa:	89 81       	ldd	r24, Y+1	; 0x01
    30ac:	9a 81       	ldd	r25, Y+2	; 0x02
    30ae:	28 17       	cp	r18, r24
    30b0:	39 07       	cpc	r19, r25
    30b2:	50 f5       	brcc	.+84     	; 0x3108 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    30b4:	80 e0       	ldi	r24, 0x00	; 0
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	0e 94 7c 2c 	call	0x58f8	; 0x58f8 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    30bc:	0e 94 18 27 	call	0x4e30	; 0x4e30 <xTaskGetCurrentTaskHandle>
    30c0:	ef 81       	ldd	r30, Y+7	; 0x07
    30c2:	f8 85       	ldd	r31, Y+8	; 0x08
    30c4:	93 87       	std	Z+11, r25	; 0x0b
    30c6:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    30c8:	0f 90       	pop	r0
    30ca:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    30cc:	ea 89       	ldd	r30, Y+18	; 0x12
    30ce:	fb 89       	ldd	r31, Y+19	; 0x13
    30d0:	60 e0       	ldi	r22, 0x00	; 0
    30d2:	70 e0       	ldi	r23, 0x00	; 0
    30d4:	80 e0       	ldi	r24, 0x00	; 0
    30d6:	90 e0       	ldi	r25, 0x00	; 0
    30d8:	20 e0       	ldi	r18, 0x00	; 0
    30da:	30 e0       	ldi	r19, 0x00	; 0
    30dc:	40 e0       	ldi	r20, 0x00	; 0
    30de:	50 e0       	ldi	r21, 0x00	; 0
    30e0:	00 e0       	ldi	r16, 0x00	; 0
    30e2:	10 e0       	ldi	r17, 0x00	; 0
    30e4:	7f 01       	movw	r14, r30
    30e6:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    30ea:	ef 81       	ldd	r30, Y+7	; 0x07
    30ec:	f8 85       	ldd	r31, Y+8	; 0x08
    30ee:	13 86       	std	Z+11, r1	; 0x0b
    30f0:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    30f2:	ce 01       	movw	r24, r28
    30f4:	09 96       	adiw	r24, 0x09	; 9
    30f6:	9e 01       	movw	r18, r28
    30f8:	2e 5e       	subi	r18, 0xEE	; 238
    30fa:	3f 4f       	sbci	r19, 0xFF	; 255
    30fc:	b9 01       	movw	r22, r18
    30fe:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <xTaskCheckForTimeOut>
    3102:	88 23       	and	r24, r24
    3104:	39 f2       	breq	.-114    	; 0x3094 <xStreamBufferSend+0x6e>
    3106:	02 c0       	rjmp	.+4      	; 0x310c <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3108:	0f 90       	pop	r0
    310a:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    310c:	8b 81       	ldd	r24, Y+3	; 0x03
    310e:	9c 81       	ldd	r25, Y+4	; 0x04
    3110:	00 97       	sbiw	r24, 0x00	; 0
    3112:	31 f4       	brne	.+12     	; 0x3120 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3114:	8f 81       	ldd	r24, Y+7	; 0x07
    3116:	98 85       	ldd	r25, Y+8	; 0x08
    3118:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <xStreamBufferSpacesAvailable>
    311c:	9c 83       	std	Y+4, r25	; 0x04
    311e:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3120:	8f 81       	ldd	r24, Y+7	; 0x07
    3122:	98 85       	ldd	r25, Y+8	; 0x08
    3124:	2e 85       	ldd	r18, Y+14	; 0x0e
    3126:	3f 85       	ldd	r19, Y+15	; 0x0f
    3128:	48 89       	ldd	r20, Y+16	; 0x10
    312a:	59 89       	ldd	r21, Y+17	; 0x11
    312c:	eb 81       	ldd	r30, Y+3	; 0x03
    312e:	fc 81       	ldd	r31, Y+4	; 0x04
    3130:	a9 81       	ldd	r26, Y+1	; 0x01
    3132:	ba 81       	ldd	r27, Y+2	; 0x02
    3134:	b9 01       	movw	r22, r18
    3136:	9f 01       	movw	r18, r30
    3138:	8d 01       	movw	r16, r26
    313a:	0e 94 58 19 	call	0x32b0	; 0x32b0 <prvWriteMessageToBuffer>
    313e:	9e 83       	std	Y+6, r25	; 0x06
    3140:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    3142:	8d 81       	ldd	r24, Y+5	; 0x05
    3144:	9e 81       	ldd	r25, Y+6	; 0x06
    3146:	00 97       	sbiw	r24, 0x00	; 0
    3148:	39 f1       	breq	.+78     	; 0x3198 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    314a:	8f 81       	ldd	r24, Y+7	; 0x07
    314c:	98 85       	ldd	r25, Y+8	; 0x08
    314e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    3152:	9c 01       	movw	r18, r24
    3154:	ef 81       	ldd	r30, Y+7	; 0x07
    3156:	f8 85       	ldd	r31, Y+8	; 0x08
    3158:	86 81       	ldd	r24, Z+6	; 0x06
    315a:	97 81       	ldd	r25, Z+7	; 0x07
    315c:	28 17       	cp	r18, r24
    315e:	39 07       	cpc	r19, r25
    3160:	d8 f0       	brcs	.+54     	; 0x3198 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3162:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
    3166:	ef 81       	ldd	r30, Y+7	; 0x07
    3168:	f8 85       	ldd	r31, Y+8	; 0x08
    316a:	80 85       	ldd	r24, Z+8	; 0x08
    316c:	91 85       	ldd	r25, Z+9	; 0x09
    316e:	00 97       	sbiw	r24, 0x00	; 0
    3170:	89 f0       	breq	.+34     	; 0x3194 <xStreamBufferSend+0x16e>
    3172:	ef 81       	ldd	r30, Y+7	; 0x07
    3174:	f8 85       	ldd	r31, Y+8	; 0x08
    3176:	80 85       	ldd	r24, Z+8	; 0x08
    3178:	91 85       	ldd	r25, Z+9	; 0x09
    317a:	40 e0       	ldi	r20, 0x00	; 0
    317c:	50 e0       	ldi	r21, 0x00	; 0
    317e:	60 e0       	ldi	r22, 0x00	; 0
    3180:	70 e0       	ldi	r23, 0x00	; 0
    3182:	20 e0       	ldi	r18, 0x00	; 0
    3184:	00 e0       	ldi	r16, 0x00	; 0
    3186:	10 e0       	ldi	r17, 0x00	; 0
    3188:	0e 94 21 2a 	call	0x5442	; 0x5442 <xTaskGenericNotify>
    318c:	ef 81       	ldd	r30, Y+7	; 0x07
    318e:	f8 85       	ldd	r31, Y+8	; 0x08
    3190:	11 86       	std	Z+9, r1	; 0x09
    3192:	10 86       	std	Z+8, r1	; 0x08
    3194:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3198:	8d 81       	ldd	r24, Y+5	; 0x05
    319a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    319c:	63 96       	adiw	r28, 0x13	; 19
    319e:	0f b6       	in	r0, 0x3f	; 63
    31a0:	f8 94       	cli
    31a2:	de bf       	out	0x3e, r29	; 62
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	cf 91       	pop	r28
    31aa:	df 91       	pop	r29
    31ac:	1f 91       	pop	r17
    31ae:	0f 91       	pop	r16
    31b0:	ff 90       	pop	r15
    31b2:	ef 90       	pop	r14
    31b4:	08 95       	ret

000031b6 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    31b6:	ef 92       	push	r14
    31b8:	ff 92       	push	r15
    31ba:	0f 93       	push	r16
    31bc:	1f 93       	push	r17
    31be:	df 93       	push	r29
    31c0:	cf 93       	push	r28
    31c2:	cd b7       	in	r28, 0x3d	; 61
    31c4:	de b7       	in	r29, 0x3e	; 62
    31c6:	61 97       	sbiw	r28, 0x11	; 17
    31c8:	0f b6       	in	r0, 0x3f	; 63
    31ca:	f8 94       	cli
    31cc:	de bf       	out	0x3e, r29	; 62
    31ce:	0f be       	out	0x3f, r0	; 63
    31d0:	cd bf       	out	0x3d, r28	; 61
    31d2:	9b 87       	std	Y+11, r25	; 0x0b
    31d4:	8a 87       	std	Y+10, r24	; 0x0a
    31d6:	7d 87       	std	Y+13, r23	; 0x0d
    31d8:	6c 87       	std	Y+12, r22	; 0x0c
    31da:	5f 87       	std	Y+15, r21	; 0x0f
    31dc:	4e 87       	std	Y+14, r20	; 0x0e
    31de:	39 8b       	std	Y+17, r19	; 0x11
    31e0:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    31e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    31e6:	99 87       	std	Y+9, r25	; 0x09
    31e8:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    31ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    31ee:	9b 83       	std	Y+3, r25	; 0x03
    31f0:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    31f2:	e8 85       	ldd	r30, Y+8	; 0x08
    31f4:	f9 85       	ldd	r31, Y+9	; 0x09
    31f6:	86 85       	ldd	r24, Z+14	; 0x0e
    31f8:	88 2f       	mov	r24, r24
    31fa:	90 e0       	ldi	r25, 0x00	; 0
    31fc:	81 70       	andi	r24, 0x01	; 1
    31fe:	90 70       	andi	r25, 0x00	; 0
    3200:	88 23       	and	r24, r24
    3202:	29 f0       	breq	.+10     	; 0x320e <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3204:	8a 81       	ldd	r24, Y+2	; 0x02
    3206:	9b 81       	ldd	r25, Y+3	; 0x03
    3208:	02 96       	adiw	r24, 0x02	; 2
    320a:	9b 83       	std	Y+3, r25	; 0x03
    320c:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    320e:	88 85       	ldd	r24, Y+8	; 0x08
    3210:	99 85       	ldd	r25, Y+9	; 0x09
    3212:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <xStreamBufferSpacesAvailable>
    3216:	9d 83       	std	Y+5, r25	; 0x05
    3218:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    321a:	88 85       	ldd	r24, Y+8	; 0x08
    321c:	99 85       	ldd	r25, Y+9	; 0x09
    321e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3220:	3d 85       	ldd	r19, Y+13	; 0x0d
    3222:	4e 85       	ldd	r20, Y+14	; 0x0e
    3224:	5f 85       	ldd	r21, Y+15	; 0x0f
    3226:	ec 81       	ldd	r30, Y+4	; 0x04
    3228:	fd 81       	ldd	r31, Y+5	; 0x05
    322a:	aa 81       	ldd	r26, Y+2	; 0x02
    322c:	bb 81       	ldd	r27, Y+3	; 0x03
    322e:	b9 01       	movw	r22, r18
    3230:	9f 01       	movw	r18, r30
    3232:	8d 01       	movw	r16, r26
    3234:	0e 94 58 19 	call	0x32b0	; 0x32b0 <prvWriteMessageToBuffer>
    3238:	9f 83       	std	Y+7, r25	; 0x07
    323a:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    323c:	8e 81       	ldd	r24, Y+6	; 0x06
    323e:	9f 81       	ldd	r25, Y+7	; 0x07
    3240:	00 97       	sbiw	r24, 0x00	; 0
    3242:	39 f1       	breq	.+78     	; 0x3292 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    3244:	88 85       	ldd	r24, Y+8	; 0x08
    3246:	99 85       	ldd	r25, Y+9	; 0x09
    3248:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    324c:	9c 01       	movw	r18, r24
    324e:	e8 85       	ldd	r30, Y+8	; 0x08
    3250:	f9 85       	ldd	r31, Y+9	; 0x09
    3252:	86 81       	ldd	r24, Z+6	; 0x06
    3254:	97 81       	ldd	r25, Z+7	; 0x07
    3256:	28 17       	cp	r18, r24
    3258:	39 07       	cpc	r19, r25
    325a:	d8 f0       	brcs	.+54     	; 0x3292 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    325c:	19 82       	std	Y+1, r1	; 0x01
    325e:	e8 85       	ldd	r30, Y+8	; 0x08
    3260:	f9 85       	ldd	r31, Y+9	; 0x09
    3262:	80 85       	ldd	r24, Z+8	; 0x08
    3264:	91 85       	ldd	r25, Z+9	; 0x09
    3266:	00 97       	sbiw	r24, 0x00	; 0
    3268:	a1 f0       	breq	.+40     	; 0x3292 <xStreamBufferSendFromISR+0xdc>
    326a:	e8 85       	ldd	r30, Y+8	; 0x08
    326c:	f9 85       	ldd	r31, Y+9	; 0x09
    326e:	80 85       	ldd	r24, Z+8	; 0x08
    3270:	91 85       	ldd	r25, Z+9	; 0x09
    3272:	e8 89       	ldd	r30, Y+16	; 0x10
    3274:	f9 89       	ldd	r31, Y+17	; 0x11
    3276:	40 e0       	ldi	r20, 0x00	; 0
    3278:	50 e0       	ldi	r21, 0x00	; 0
    327a:	60 e0       	ldi	r22, 0x00	; 0
    327c:	70 e0       	ldi	r23, 0x00	; 0
    327e:	20 e0       	ldi	r18, 0x00	; 0
    3280:	00 e0       	ldi	r16, 0x00	; 0
    3282:	10 e0       	ldi	r17, 0x00	; 0
    3284:	7f 01       	movw	r14, r30
    3286:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xTaskGenericNotifyFromISR>
    328a:	e8 85       	ldd	r30, Y+8	; 0x08
    328c:	f9 85       	ldd	r31, Y+9	; 0x09
    328e:	11 86       	std	Z+9, r1	; 0x09
    3290:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3292:	8e 81       	ldd	r24, Y+6	; 0x06
    3294:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3296:	61 96       	adiw	r28, 0x11	; 17
    3298:	0f b6       	in	r0, 0x3f	; 63
    329a:	f8 94       	cli
    329c:	de bf       	out	0x3e, r29	; 62
    329e:	0f be       	out	0x3f, r0	; 63
    32a0:	cd bf       	out	0x3d, r28	; 61
    32a2:	cf 91       	pop	r28
    32a4:	df 91       	pop	r29
    32a6:	1f 91       	pop	r17
    32a8:	0f 91       	pop	r16
    32aa:	ff 90       	pop	r15
    32ac:	ef 90       	pop	r14
    32ae:	08 95       	ret

000032b0 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    32b0:	0f 93       	push	r16
    32b2:	1f 93       	push	r17
    32b4:	df 93       	push	r29
    32b6:	cf 93       	push	r28
    32b8:	cd b7       	in	r28, 0x3d	; 61
    32ba:	de b7       	in	r29, 0x3e	; 62
    32bc:	61 97       	sbiw	r28, 0x11	; 17
    32be:	0f b6       	in	r0, 0x3f	; 63
    32c0:	f8 94       	cli
    32c2:	de bf       	out	0x3e, r29	; 62
    32c4:	0f be       	out	0x3f, r0	; 63
    32c6:	cd bf       	out	0x3d, r28	; 61
    32c8:	9d 83       	std	Y+5, r25	; 0x05
    32ca:	8c 83       	std	Y+4, r24	; 0x04
    32cc:	7f 83       	std	Y+7, r23	; 0x07
    32ce:	6e 83       	std	Y+6, r22	; 0x06
    32d0:	59 87       	std	Y+9, r21	; 0x09
    32d2:	48 87       	std	Y+8, r20	; 0x08
    32d4:	3b 87       	std	Y+11, r19	; 0x0b
    32d6:	2a 87       	std	Y+10, r18	; 0x0a
    32d8:	1d 87       	std	Y+13, r17	; 0x0d
    32da:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    32dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    32de:	9b 85       	ldd	r25, Y+11	; 0x0b
    32e0:	00 97       	sbiw	r24, 0x00	; 0
    32e2:	11 f4       	brne	.+4      	; 0x32e8 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    32e4:	1b 82       	std	Y+3, r1	; 0x03
    32e6:	38 c0       	rjmp	.+112    	; 0x3358 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    32e8:	ec 81       	ldd	r30, Y+4	; 0x04
    32ea:	fd 81       	ldd	r31, Y+5	; 0x05
    32ec:	86 85       	ldd	r24, Z+14	; 0x0e
    32ee:	88 2f       	mov	r24, r24
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	81 70       	andi	r24, 0x01	; 1
    32f4:	90 70       	andi	r25, 0x00	; 0
    32f6:	00 97       	sbiw	r24, 0x00	; 0
    32f8:	d1 f4       	brne	.+52     	; 0x332e <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    32fe:	28 85       	ldd	r18, Y+8	; 0x08
    3300:	39 85       	ldd	r19, Y+9	; 0x09
    3302:	39 8b       	std	Y+17, r19	; 0x11
    3304:	28 8b       	std	Y+16, r18	; 0x10
    3306:	8a 85       	ldd	r24, Y+10	; 0x0a
    3308:	9b 85       	ldd	r25, Y+11	; 0x0b
    330a:	9f 87       	std	Y+15, r25	; 0x0f
    330c:	8e 87       	std	Y+14, r24	; 0x0e
    330e:	2e 85       	ldd	r18, Y+14	; 0x0e
    3310:	3f 85       	ldd	r19, Y+15	; 0x0f
    3312:	88 89       	ldd	r24, Y+16	; 0x10
    3314:	99 89       	ldd	r25, Y+17	; 0x11
    3316:	82 17       	cp	r24, r18
    3318:	93 07       	cpc	r25, r19
    331a:	20 f4       	brcc	.+8      	; 0x3324 <prvWriteMessageToBuffer+0x74>
    331c:	28 89       	ldd	r18, Y+16	; 0x10
    331e:	39 89       	ldd	r19, Y+17	; 0x11
    3320:	3f 87       	std	Y+15, r19	; 0x0f
    3322:	2e 87       	std	Y+14, r18	; 0x0e
    3324:	8e 85       	ldd	r24, Y+14	; 0x0e
    3326:	9f 85       	ldd	r25, Y+15	; 0x0f
    3328:	99 87       	std	Y+9, r25	; 0x09
    332a:	88 87       	std	Y+8, r24	; 0x08
    332c:	15 c0       	rjmp	.+42     	; 0x3358 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    332e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3330:	3b 85       	ldd	r19, Y+11	; 0x0b
    3332:	8c 85       	ldd	r24, Y+12	; 0x0c
    3334:	9d 85       	ldd	r25, Y+13	; 0x0d
    3336:	28 17       	cp	r18, r24
    3338:	39 07       	cpc	r19, r25
    333a:	68 f0       	brcs	.+26     	; 0x3356 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    333c:	81 e0       	ldi	r24, 0x01	; 1
    333e:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    3340:	9e 01       	movw	r18, r28
    3342:	28 5f       	subi	r18, 0xF8	; 248
    3344:	3f 4f       	sbci	r19, 0xFF	; 255
    3346:	8c 81       	ldd	r24, Y+4	; 0x04
    3348:	9d 81       	ldd	r25, Y+5	; 0x05
    334a:	b9 01       	movw	r22, r18
    334c:	42 e0       	ldi	r20, 0x02	; 2
    334e:	50 e0       	ldi	r21, 0x00	; 0
    3350:	0e 94 a5 1c 	call	0x394a	; 0x394a <prvWriteBytesToBuffer>
    3354:	01 c0       	rjmp	.+2      	; 0x3358 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3356:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3358:	8b 81       	ldd	r24, Y+3	; 0x03
    335a:	88 23       	and	r24, r24
    335c:	61 f0       	breq	.+24     	; 0x3376 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    335e:	2e 81       	ldd	r18, Y+6	; 0x06
    3360:	3f 81       	ldd	r19, Y+7	; 0x07
    3362:	48 85       	ldd	r20, Y+8	; 0x08
    3364:	59 85       	ldd	r21, Y+9	; 0x09
    3366:	8c 81       	ldd	r24, Y+4	; 0x04
    3368:	9d 81       	ldd	r25, Y+5	; 0x05
    336a:	b9 01       	movw	r22, r18
    336c:	0e 94 a5 1c 	call	0x394a	; 0x394a <prvWriteBytesToBuffer>
    3370:	9a 83       	std	Y+2, r25	; 0x02
    3372:	89 83       	std	Y+1, r24	; 0x01
    3374:	02 c0       	rjmp	.+4      	; 0x337a <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3376:	1a 82       	std	Y+2, r1	; 0x02
    3378:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    337a:	89 81       	ldd	r24, Y+1	; 0x01
    337c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    337e:	61 96       	adiw	r28, 0x11	; 17
    3380:	0f b6       	in	r0, 0x3f	; 63
    3382:	f8 94       	cli
    3384:	de bf       	out	0x3e, r29	; 62
    3386:	0f be       	out	0x3f, r0	; 63
    3388:	cd bf       	out	0x3d, r28	; 61
    338a:	cf 91       	pop	r28
    338c:	df 91       	pop	r29
    338e:	1f 91       	pop	r17
    3390:	0f 91       	pop	r16
    3392:	08 95       	ret

00003394 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3394:	ef 92       	push	r14
    3396:	ff 92       	push	r15
    3398:	0f 93       	push	r16
    339a:	1f 93       	push	r17
    339c:	df 93       	push	r29
    339e:	cf 93       	push	r28
    33a0:	cd b7       	in	r28, 0x3d	; 61
    33a2:	de b7       	in	r29, 0x3e	; 62
    33a4:	60 97       	sbiw	r28, 0x10	; 16
    33a6:	0f b6       	in	r0, 0x3f	; 63
    33a8:	f8 94       	cli
    33aa:	de bf       	out	0x3e, r29	; 62
    33ac:	0f be       	out	0x3f, r0	; 63
    33ae:	cd bf       	out	0x3d, r28	; 61
    33b0:	9a 87       	std	Y+10, r25	; 0x0a
    33b2:	89 87       	std	Y+9, r24	; 0x09
    33b4:	7c 87       	std	Y+12, r23	; 0x0c
    33b6:	6b 87       	std	Y+11, r22	; 0x0b
    33b8:	5e 87       	std	Y+14, r21	; 0x0e
    33ba:	4d 87       	std	Y+13, r20	; 0x0d
    33bc:	38 8b       	std	Y+16, r19	; 0x10
    33be:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    33c0:	89 85       	ldd	r24, Y+9	; 0x09
    33c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    33c4:	98 87       	std	Y+8, r25	; 0x08
    33c6:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    33c8:	1e 82       	std	Y+6, r1	; 0x06
    33ca:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    33cc:	ef 81       	ldd	r30, Y+7	; 0x07
    33ce:	f8 85       	ldd	r31, Y+8	; 0x08
    33d0:	86 85       	ldd	r24, Z+14	; 0x0e
    33d2:	88 2f       	mov	r24, r24
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	81 70       	andi	r24, 0x01	; 1
    33d8:	90 70       	andi	r25, 0x00	; 0
    33da:	88 23       	and	r24, r24
    33dc:	29 f0       	breq	.+10     	; 0x33e8 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    33de:	82 e0       	ldi	r24, 0x02	; 2
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	9a 83       	std	Y+2, r25	; 0x02
    33e4:	89 83       	std	Y+1, r24	; 0x01
    33e6:	02 c0       	rjmp	.+4      	; 0x33ec <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    33e8:	1a 82       	std	Y+2, r1	; 0x02
    33ea:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    33ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    33ee:	98 89       	ldd	r25, Y+16	; 0x10
    33f0:	00 97       	sbiw	r24, 0x00	; 0
    33f2:	09 f4       	brne	.+2      	; 0x33f6 <xStreamBufferReceive+0x62>
    33f4:	3d c0       	rjmp	.+122    	; 0x3470 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    33f6:	0f b6       	in	r0, 0x3f	; 63
    33f8:	f8 94       	cli
    33fa:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    33fc:	8f 81       	ldd	r24, Y+7	; 0x07
    33fe:	98 85       	ldd	r25, Y+8	; 0x08
    3400:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    3404:	9c 83       	std	Y+4, r25	; 0x04
    3406:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    3408:	2b 81       	ldd	r18, Y+3	; 0x03
    340a:	3c 81       	ldd	r19, Y+4	; 0x04
    340c:	89 81       	ldd	r24, Y+1	; 0x01
    340e:	9a 81       	ldd	r25, Y+2	; 0x02
    3410:	82 17       	cp	r24, r18
    3412:	93 07       	cpc	r25, r19
    3414:	50 f0       	brcs	.+20     	; 0x342a <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3416:	80 e0       	ldi	r24, 0x00	; 0
    3418:	90 e0       	ldi	r25, 0x00	; 0
    341a:	0e 94 7c 2c 	call	0x58f8	; 0x58f8 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    341e:	0e 94 18 27 	call	0x4e30	; 0x4e30 <xTaskGetCurrentTaskHandle>
    3422:	ef 81       	ldd	r30, Y+7	; 0x07
    3424:	f8 85       	ldd	r31, Y+8	; 0x08
    3426:	91 87       	std	Z+9, r25	; 0x09
    3428:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    342a:	0f 90       	pop	r0
    342c:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    342e:	2b 81       	ldd	r18, Y+3	; 0x03
    3430:	3c 81       	ldd	r19, Y+4	; 0x04
    3432:	89 81       	ldd	r24, Y+1	; 0x01
    3434:	9a 81       	ldd	r25, Y+2	; 0x02
    3436:	82 17       	cp	r24, r18
    3438:	93 07       	cpc	r25, r19
    343a:	00 f1       	brcs	.+64     	; 0x347c <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    343c:	ef 85       	ldd	r30, Y+15	; 0x0f
    343e:	f8 89       	ldd	r31, Y+16	; 0x10
    3440:	60 e0       	ldi	r22, 0x00	; 0
    3442:	70 e0       	ldi	r23, 0x00	; 0
    3444:	80 e0       	ldi	r24, 0x00	; 0
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	20 e0       	ldi	r18, 0x00	; 0
    344a:	30 e0       	ldi	r19, 0x00	; 0
    344c:	40 e0       	ldi	r20, 0x00	; 0
    344e:	50 e0       	ldi	r21, 0x00	; 0
    3450:	00 e0       	ldi	r16, 0x00	; 0
    3452:	10 e0       	ldi	r17, 0x00	; 0
    3454:	7f 01       	movw	r14, r30
    3456:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    345a:	ef 81       	ldd	r30, Y+7	; 0x07
    345c:	f8 85       	ldd	r31, Y+8	; 0x08
    345e:	11 86       	std	Z+9, r1	; 0x09
    3460:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3462:	8f 81       	ldd	r24, Y+7	; 0x07
    3464:	98 85       	ldd	r25, Y+8	; 0x08
    3466:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    346a:	9c 83       	std	Y+4, r25	; 0x04
    346c:	8b 83       	std	Y+3, r24	; 0x03
    346e:	06 c0       	rjmp	.+12     	; 0x347c <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3470:	8f 81       	ldd	r24, Y+7	; 0x07
    3472:	98 85       	ldd	r25, Y+8	; 0x08
    3474:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    3478:	9c 83       	std	Y+4, r25	; 0x04
    347a:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    347c:	2b 81       	ldd	r18, Y+3	; 0x03
    347e:	3c 81       	ldd	r19, Y+4	; 0x04
    3480:	89 81       	ldd	r24, Y+1	; 0x01
    3482:	9a 81       	ldd	r25, Y+2	; 0x02
    3484:	82 17       	cp	r24, r18
    3486:	93 07       	cpc	r25, r19
    3488:	80 f5       	brcc	.+96     	; 0x34ea <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    348a:	8f 81       	ldd	r24, Y+7	; 0x07
    348c:	98 85       	ldd	r25, Y+8	; 0x08
    348e:	2b 85       	ldd	r18, Y+11	; 0x0b
    3490:	3c 85       	ldd	r19, Y+12	; 0x0c
    3492:	4d 85       	ldd	r20, Y+13	; 0x0d
    3494:	5e 85       	ldd	r21, Y+14	; 0x0e
    3496:	eb 81       	ldd	r30, Y+3	; 0x03
    3498:	fc 81       	ldd	r31, Y+4	; 0x04
    349a:	a9 81       	ldd	r26, Y+1	; 0x01
    349c:	ba 81       	ldd	r27, Y+2	; 0x02
    349e:	b9 01       	movw	r22, r18
    34a0:	9f 01       	movw	r18, r30
    34a2:	8d 01       	movw	r16, r26
    34a4:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvReadMessageFromBuffer>
    34a8:	9e 83       	std	Y+6, r25	; 0x06
    34aa:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    34ac:	8d 81       	ldd	r24, Y+5	; 0x05
    34ae:	9e 81       	ldd	r25, Y+6	; 0x06
    34b0:	00 97       	sbiw	r24, 0x00	; 0
    34b2:	d9 f0       	breq	.+54     	; 0x34ea <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    34b4:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
    34b8:	ef 81       	ldd	r30, Y+7	; 0x07
    34ba:	f8 85       	ldd	r31, Y+8	; 0x08
    34bc:	82 85       	ldd	r24, Z+10	; 0x0a
    34be:	93 85       	ldd	r25, Z+11	; 0x0b
    34c0:	00 97       	sbiw	r24, 0x00	; 0
    34c2:	89 f0       	breq	.+34     	; 0x34e6 <xStreamBufferReceive+0x152>
    34c4:	ef 81       	ldd	r30, Y+7	; 0x07
    34c6:	f8 85       	ldd	r31, Y+8	; 0x08
    34c8:	82 85       	ldd	r24, Z+10	; 0x0a
    34ca:	93 85       	ldd	r25, Z+11	; 0x0b
    34cc:	40 e0       	ldi	r20, 0x00	; 0
    34ce:	50 e0       	ldi	r21, 0x00	; 0
    34d0:	60 e0       	ldi	r22, 0x00	; 0
    34d2:	70 e0       	ldi	r23, 0x00	; 0
    34d4:	20 e0       	ldi	r18, 0x00	; 0
    34d6:	00 e0       	ldi	r16, 0x00	; 0
    34d8:	10 e0       	ldi	r17, 0x00	; 0
    34da:	0e 94 21 2a 	call	0x5442	; 0x5442 <xTaskGenericNotify>
    34de:	ef 81       	ldd	r30, Y+7	; 0x07
    34e0:	f8 85       	ldd	r31, Y+8	; 0x08
    34e2:	13 86       	std	Z+11, r1	; 0x0b
    34e4:	12 86       	std	Z+10, r1	; 0x0a
    34e6:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    34ea:	8d 81       	ldd	r24, Y+5	; 0x05
    34ec:	9e 81       	ldd	r25, Y+6	; 0x06
}
    34ee:	60 96       	adiw	r28, 0x10	; 16
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	cf 91       	pop	r28
    34fc:	df 91       	pop	r29
    34fe:	1f 91       	pop	r17
    3500:	0f 91       	pop	r16
    3502:	ff 90       	pop	r15
    3504:	ef 90       	pop	r14
    3506:	08 95       	ret

00003508 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    3508:	df 93       	push	r29
    350a:	cf 93       	push	r28
    350c:	cd b7       	in	r28, 0x3d	; 61
    350e:	de b7       	in	r29, 0x3e	; 62
    3510:	2c 97       	sbiw	r28, 0x0c	; 12
    3512:	0f b6       	in	r0, 0x3f	; 63
    3514:	f8 94       	cli
    3516:	de bf       	out	0x3e, r29	; 62
    3518:	0f be       	out	0x3f, r0	; 63
    351a:	cd bf       	out	0x3d, r28	; 61
    351c:	9c 87       	std	Y+12, r25	; 0x0c
    351e:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3520:	8b 85       	ldd	r24, Y+11	; 0x0b
    3522:	9c 85       	ldd	r25, Y+12	; 0x0c
    3524:	98 87       	std	Y+8, r25	; 0x08
    3526:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3528:	ef 81       	ldd	r30, Y+7	; 0x07
    352a:	f8 85       	ldd	r31, Y+8	; 0x08
    352c:	86 85       	ldd	r24, Z+14	; 0x0e
    352e:	88 2f       	mov	r24, r24
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	81 70       	andi	r24, 0x01	; 1
    3534:	90 70       	andi	r25, 0x00	; 0
    3536:	88 23       	and	r24, r24
    3538:	61 f1       	breq	.+88     	; 0x3592 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    353a:	8f 81       	ldd	r24, Y+7	; 0x07
    353c:	98 85       	ldd	r25, Y+8	; 0x08
    353e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    3542:	9c 83       	std	Y+4, r25	; 0x04
    3544:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    3546:	8b 81       	ldd	r24, Y+3	; 0x03
    3548:	9c 81       	ldd	r25, Y+4	; 0x04
    354a:	83 30       	cpi	r24, 0x03	; 3
    354c:	91 05       	cpc	r25, r1
    354e:	f0 f0       	brcs	.+60     	; 0x358c <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    3550:	ef 81       	ldd	r30, Y+7	; 0x07
    3552:	f8 85       	ldd	r31, Y+8	; 0x08
    3554:	80 81       	ld	r24, Z
    3556:	91 81       	ldd	r25, Z+1	; 0x01
    3558:	9a 83       	std	Y+2, r25	; 0x02
    355a:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    355c:	9e 01       	movw	r18, r28
    355e:	27 5f       	subi	r18, 0xF7	; 247
    3560:	3f 4f       	sbci	r19, 0xFF	; 255
    3562:	8f 81       	ldd	r24, Y+7	; 0x07
    3564:	98 85       	ldd	r25, Y+8	; 0x08
    3566:	eb 81       	ldd	r30, Y+3	; 0x03
    3568:	fc 81       	ldd	r31, Y+4	; 0x04
    356a:	b9 01       	movw	r22, r18
    356c:	42 e0       	ldi	r20, 0x02	; 2
    356e:	50 e0       	ldi	r21, 0x00	; 0
    3570:	9f 01       	movw	r18, r30
    3572:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3576:	89 85       	ldd	r24, Y+9	; 0x09
    3578:	9a 85       	ldd	r25, Y+10	; 0x0a
    357a:	9e 83       	std	Y+6, r25	; 0x06
    357c:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    357e:	ef 81       	ldd	r30, Y+7	; 0x07
    3580:	f8 85       	ldd	r31, Y+8	; 0x08
    3582:	89 81       	ldd	r24, Y+1	; 0x01
    3584:	9a 81       	ldd	r25, Y+2	; 0x02
    3586:	91 83       	std	Z+1, r25	; 0x01
    3588:	80 83       	st	Z, r24
    358a:	05 c0       	rjmp	.+10     	; 0x3596 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    358c:	1e 82       	std	Y+6, r1	; 0x06
    358e:	1d 82       	std	Y+5, r1	; 0x05
    3590:	02 c0       	rjmp	.+4      	; 0x3596 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3592:	1e 82       	std	Y+6, r1	; 0x06
    3594:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3596:	8d 81       	ldd	r24, Y+5	; 0x05
    3598:	9e 81       	ldd	r25, Y+6	; 0x06
}
    359a:	2c 96       	adiw	r28, 0x0c	; 12
    359c:	0f b6       	in	r0, 0x3f	; 63
    359e:	f8 94       	cli
    35a0:	de bf       	out	0x3e, r29	; 62
    35a2:	0f be       	out	0x3f, r0	; 63
    35a4:	cd bf       	out	0x3d, r28	; 61
    35a6:	cf 91       	pop	r28
    35a8:	df 91       	pop	r29
    35aa:	08 95       	ret

000035ac <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    35ac:	ef 92       	push	r14
    35ae:	ff 92       	push	r15
    35b0:	0f 93       	push	r16
    35b2:	1f 93       	push	r17
    35b4:	df 93       	push	r29
    35b6:	cf 93       	push	r28
    35b8:	cd b7       	in	r28, 0x3d	; 61
    35ba:	de b7       	in	r29, 0x3e	; 62
    35bc:	61 97       	sbiw	r28, 0x11	; 17
    35be:	0f b6       	in	r0, 0x3f	; 63
    35c0:	f8 94       	cli
    35c2:	de bf       	out	0x3e, r29	; 62
    35c4:	0f be       	out	0x3f, r0	; 63
    35c6:	cd bf       	out	0x3d, r28	; 61
    35c8:	9b 87       	std	Y+11, r25	; 0x0b
    35ca:	8a 87       	std	Y+10, r24	; 0x0a
    35cc:	7d 87       	std	Y+13, r23	; 0x0d
    35ce:	6c 87       	std	Y+12, r22	; 0x0c
    35d0:	5f 87       	std	Y+15, r21	; 0x0f
    35d2:	4e 87       	std	Y+14, r20	; 0x0e
    35d4:	39 8b       	std	Y+17, r19	; 0x11
    35d6:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    35d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    35da:	9b 85       	ldd	r25, Y+11	; 0x0b
    35dc:	99 87       	std	Y+9, r25	; 0x09
    35de:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    35e0:	1f 82       	std	Y+7, r1	; 0x07
    35e2:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    35e4:	e8 85       	ldd	r30, Y+8	; 0x08
    35e6:	f9 85       	ldd	r31, Y+9	; 0x09
    35e8:	86 85       	ldd	r24, Z+14	; 0x0e
    35ea:	88 2f       	mov	r24, r24
    35ec:	90 e0       	ldi	r25, 0x00	; 0
    35ee:	81 70       	andi	r24, 0x01	; 1
    35f0:	90 70       	andi	r25, 0x00	; 0
    35f2:	88 23       	and	r24, r24
    35f4:	29 f0       	breq	.+10     	; 0x3600 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    35f6:	82 e0       	ldi	r24, 0x02	; 2
    35f8:	90 e0       	ldi	r25, 0x00	; 0
    35fa:	9b 83       	std	Y+3, r25	; 0x03
    35fc:	8a 83       	std	Y+2, r24	; 0x02
    35fe:	02 c0       	rjmp	.+4      	; 0x3604 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3600:	1b 82       	std	Y+3, r1	; 0x03
    3602:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3604:	88 85       	ldd	r24, Y+8	; 0x08
    3606:	99 85       	ldd	r25, Y+9	; 0x09
    3608:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <prvBytesInBuffer>
    360c:	9d 83       	std	Y+5, r25	; 0x05
    360e:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3610:	2c 81       	ldd	r18, Y+4	; 0x04
    3612:	3d 81       	ldd	r19, Y+5	; 0x05
    3614:	8a 81       	ldd	r24, Y+2	; 0x02
    3616:	9b 81       	ldd	r25, Y+3	; 0x03
    3618:	82 17       	cp	r24, r18
    361a:	93 07       	cpc	r25, r19
    361c:	80 f5       	brcc	.+96     	; 0x367e <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    361e:	88 85       	ldd	r24, Y+8	; 0x08
    3620:	99 85       	ldd	r25, Y+9	; 0x09
    3622:	2c 85       	ldd	r18, Y+12	; 0x0c
    3624:	3d 85       	ldd	r19, Y+13	; 0x0d
    3626:	4e 85       	ldd	r20, Y+14	; 0x0e
    3628:	5f 85       	ldd	r21, Y+15	; 0x0f
    362a:	ec 81       	ldd	r30, Y+4	; 0x04
    362c:	fd 81       	ldd	r31, Y+5	; 0x05
    362e:	aa 81       	ldd	r26, Y+2	; 0x02
    3630:	bb 81       	ldd	r27, Y+3	; 0x03
    3632:	b9 01       	movw	r22, r18
    3634:	9f 01       	movw	r18, r30
    3636:	8d 01       	movw	r16, r26
    3638:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvReadMessageFromBuffer>
    363c:	9f 83       	std	Y+7, r25	; 0x07
    363e:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3640:	8e 81       	ldd	r24, Y+6	; 0x06
    3642:	9f 81       	ldd	r25, Y+7	; 0x07
    3644:	00 97       	sbiw	r24, 0x00	; 0
    3646:	d9 f0       	breq	.+54     	; 0x367e <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    3648:	19 82       	std	Y+1, r1	; 0x01
    364a:	e8 85       	ldd	r30, Y+8	; 0x08
    364c:	f9 85       	ldd	r31, Y+9	; 0x09
    364e:	82 85       	ldd	r24, Z+10	; 0x0a
    3650:	93 85       	ldd	r25, Z+11	; 0x0b
    3652:	00 97       	sbiw	r24, 0x00	; 0
    3654:	a1 f0       	breq	.+40     	; 0x367e <xStreamBufferReceiveFromISR+0xd2>
    3656:	e8 85       	ldd	r30, Y+8	; 0x08
    3658:	f9 85       	ldd	r31, Y+9	; 0x09
    365a:	82 85       	ldd	r24, Z+10	; 0x0a
    365c:	93 85       	ldd	r25, Z+11	; 0x0b
    365e:	e8 89       	ldd	r30, Y+16	; 0x10
    3660:	f9 89       	ldd	r31, Y+17	; 0x11
    3662:	40 e0       	ldi	r20, 0x00	; 0
    3664:	50 e0       	ldi	r21, 0x00	; 0
    3666:	60 e0       	ldi	r22, 0x00	; 0
    3668:	70 e0       	ldi	r23, 0x00	; 0
    366a:	20 e0       	ldi	r18, 0x00	; 0
    366c:	00 e0       	ldi	r16, 0x00	; 0
    366e:	10 e0       	ldi	r17, 0x00	; 0
    3670:	7f 01       	movw	r14, r30
    3672:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xTaskGenericNotifyFromISR>
    3676:	e8 85       	ldd	r30, Y+8	; 0x08
    3678:	f9 85       	ldd	r31, Y+9	; 0x09
    367a:	13 86       	std	Z+11, r1	; 0x0b
    367c:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    367e:	8e 81       	ldd	r24, Y+6	; 0x06
    3680:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3682:	61 96       	adiw	r28, 0x11	; 17
    3684:	0f b6       	in	r0, 0x3f	; 63
    3686:	f8 94       	cli
    3688:	de bf       	out	0x3e, r29	; 62
    368a:	0f be       	out	0x3f, r0	; 63
    368c:	cd bf       	out	0x3d, r28	; 61
    368e:	cf 91       	pop	r28
    3690:	df 91       	pop	r29
    3692:	1f 91       	pop	r17
    3694:	0f 91       	pop	r16
    3696:	ff 90       	pop	r15
    3698:	ef 90       	pop	r14
    369a:	08 95       	ret

0000369c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    369c:	0f 93       	push	r16
    369e:	1f 93       	push	r17
    36a0:	df 93       	push	r29
    36a2:	cf 93       	push	r28
    36a4:	cd b7       	in	r28, 0x3d	; 61
    36a6:	de b7       	in	r29, 0x3e	; 62
    36a8:	62 97       	sbiw	r28, 0x12	; 18
    36aa:	0f b6       	in	r0, 0x3f	; 63
    36ac:	f8 94       	cli
    36ae:	de bf       	out	0x3e, r29	; 62
    36b0:	0f be       	out	0x3f, r0	; 63
    36b2:	cd bf       	out	0x3d, r28	; 61
    36b4:	9a 87       	std	Y+10, r25	; 0x0a
    36b6:	89 87       	std	Y+9, r24	; 0x09
    36b8:	7c 87       	std	Y+12, r23	; 0x0c
    36ba:	6b 87       	std	Y+11, r22	; 0x0b
    36bc:	5e 87       	std	Y+14, r21	; 0x0e
    36be:	4d 87       	std	Y+13, r20	; 0x0d
    36c0:	38 8b       	std	Y+16, r19	; 0x10
    36c2:	2f 87       	std	Y+15, r18	; 0x0f
    36c4:	1a 8b       	std	Y+18, r17	; 0x12
    36c6:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    36c8:	89 89       	ldd	r24, Y+17	; 0x11
    36ca:	9a 89       	ldd	r25, Y+18	; 0x12
    36cc:	00 97       	sbiw	r24, 0x00	; 0
    36ce:	91 f1       	breq	.+100    	; 0x3734 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    36d0:	e9 85       	ldd	r30, Y+9	; 0x09
    36d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    36d4:	80 81       	ld	r24, Z
    36d6:	91 81       	ldd	r25, Z+1	; 0x01
    36d8:	9e 83       	std	Y+6, r25	; 0x06
    36da:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    36dc:	ae 01       	movw	r20, r28
    36de:	49 5f       	subi	r20, 0xF9	; 249
    36e0:	5f 4f       	sbci	r21, 0xFF	; 255
    36e2:	89 85       	ldd	r24, Y+9	; 0x09
    36e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    36e6:	29 89       	ldd	r18, Y+17	; 0x11
    36e8:	3a 89       	ldd	r19, Y+18	; 0x12
    36ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    36ec:	f8 89       	ldd	r31, Y+16	; 0x10
    36ee:	ba 01       	movw	r22, r20
    36f0:	a9 01       	movw	r20, r18
    36f2:	9f 01       	movw	r18, r30
    36f4:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    36f8:	8f 81       	ldd	r24, Y+7	; 0x07
    36fa:	98 85       	ldd	r25, Y+8	; 0x08
    36fc:	9a 83       	std	Y+2, r25	; 0x02
    36fe:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3700:	2f 85       	ldd	r18, Y+15	; 0x0f
    3702:	38 89       	ldd	r19, Y+16	; 0x10
    3704:	89 89       	ldd	r24, Y+17	; 0x11
    3706:	9a 89       	ldd	r25, Y+18	; 0x12
    3708:	a9 01       	movw	r20, r18
    370a:	48 1b       	sub	r20, r24
    370c:	59 0b       	sbc	r21, r25
    370e:	ca 01       	movw	r24, r20
    3710:	98 8b       	std	Y+16, r25	; 0x10
    3712:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3714:	29 81       	ldd	r18, Y+1	; 0x01
    3716:	3a 81       	ldd	r19, Y+2	; 0x02
    3718:	8d 85       	ldd	r24, Y+13	; 0x0d
    371a:	9e 85       	ldd	r25, Y+14	; 0x0e
    371c:	82 17       	cp	r24, r18
    371e:	93 07       	cpc	r25, r19
    3720:	68 f4       	brcc	.+26     	; 0x373c <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    3722:	e9 85       	ldd	r30, Y+9	; 0x09
    3724:	fa 85       	ldd	r31, Y+10	; 0x0a
    3726:	8d 81       	ldd	r24, Y+5	; 0x05
    3728:	9e 81       	ldd	r25, Y+6	; 0x06
    372a:	91 83       	std	Z+1, r25	; 0x01
    372c:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    372e:	1a 82       	std	Y+2, r1	; 0x02
    3730:	19 82       	std	Y+1, r1	; 0x01
    3732:	04 c0       	rjmp	.+8      	; 0x373c <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    3734:	8d 85       	ldd	r24, Y+13	; 0x0d
    3736:	9e 85       	ldd	r25, Y+14	; 0x0e
    3738:	9a 83       	std	Y+2, r25	; 0x02
    373a:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    373c:	4b 85       	ldd	r20, Y+11	; 0x0b
    373e:	5c 85       	ldd	r21, Y+12	; 0x0c
    3740:	89 85       	ldd	r24, Y+9	; 0x09
    3742:	9a 85       	ldd	r25, Y+10	; 0x0a
    3744:	29 81       	ldd	r18, Y+1	; 0x01
    3746:	3a 81       	ldd	r19, Y+2	; 0x02
    3748:	ef 85       	ldd	r30, Y+15	; 0x0f
    374a:	f8 89       	ldd	r31, Y+16	; 0x10
    374c:	ba 01       	movw	r22, r20
    374e:	a9 01       	movw	r20, r18
    3750:	9f 01       	movw	r18, r30
    3752:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <prvReadBytesFromBuffer>
    3756:	9c 83       	std	Y+4, r25	; 0x04
    3758:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    375a:	8b 81       	ldd	r24, Y+3	; 0x03
    375c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    375e:	62 96       	adiw	r28, 0x12	; 18
    3760:	0f b6       	in	r0, 0x3f	; 63
    3762:	f8 94       	cli
    3764:	de bf       	out	0x3e, r29	; 62
    3766:	0f be       	out	0x3f, r0	; 63
    3768:	cd bf       	out	0x3d, r28	; 61
    376a:	cf 91       	pop	r28
    376c:	df 91       	pop	r29
    376e:	1f 91       	pop	r17
    3770:	0f 91       	pop	r16
    3772:	08 95       	ret

00003774 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3774:	df 93       	push	r29
    3776:	cf 93       	push	r28
    3778:	cd b7       	in	r28, 0x3d	; 61
    377a:	de b7       	in	r29, 0x3e	; 62
    377c:	27 97       	sbiw	r28, 0x07	; 7
    377e:	0f b6       	in	r0, 0x3f	; 63
    3780:	f8 94       	cli
    3782:	de bf       	out	0x3e, r29	; 62
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	cd bf       	out	0x3d, r28	; 61
    3788:	9f 83       	std	Y+7, r25	; 0x07
    378a:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    378c:	8e 81       	ldd	r24, Y+6	; 0x06
    378e:	9f 81       	ldd	r25, Y+7	; 0x07
    3790:	9d 83       	std	Y+5, r25	; 0x05
    3792:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3794:	ec 81       	ldd	r30, Y+4	; 0x04
    3796:	fd 81       	ldd	r31, Y+5	; 0x05
    3798:	80 81       	ld	r24, Z
    379a:	91 81       	ldd	r25, Z+1	; 0x01
    379c:	9a 83       	std	Y+2, r25	; 0x02
    379e:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    37a0:	ec 81       	ldd	r30, Y+4	; 0x04
    37a2:	fd 81       	ldd	r31, Y+5	; 0x05
    37a4:	22 81       	ldd	r18, Z+2	; 0x02
    37a6:	33 81       	ldd	r19, Z+3	; 0x03
    37a8:	89 81       	ldd	r24, Y+1	; 0x01
    37aa:	9a 81       	ldd	r25, Y+2	; 0x02
    37ac:	28 17       	cp	r18, r24
    37ae:	39 07       	cpc	r19, r25
    37b0:	19 f4       	brne	.+6      	; 0x37b8 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	8b 83       	std	Y+3, r24	; 0x03
    37b6:	01 c0       	rjmp	.+2      	; 0x37ba <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    37b8:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    37ba:	8b 81       	ldd	r24, Y+3	; 0x03
}
    37bc:	27 96       	adiw	r28, 0x07	; 7
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	08 95       	ret

000037ce <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	cd b7       	in	r28, 0x3d	; 61
    37d4:	de b7       	in	r29, 0x3e	; 62
    37d6:	27 97       	sbiw	r28, 0x07	; 7
    37d8:	0f b6       	in	r0, 0x3f	; 63
    37da:	f8 94       	cli
    37dc:	de bf       	out	0x3e, r29	; 62
    37de:	0f be       	out	0x3f, r0	; 63
    37e0:	cd bf       	out	0x3d, r28	; 61
    37e2:	9f 83       	std	Y+7, r25	; 0x07
    37e4:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    37e6:	8e 81       	ldd	r24, Y+6	; 0x06
    37e8:	9f 81       	ldd	r25, Y+7	; 0x07
    37ea:	9a 83       	std	Y+2, r25	; 0x02
    37ec:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    37ee:	e9 81       	ldd	r30, Y+1	; 0x01
    37f0:	fa 81       	ldd	r31, Y+2	; 0x02
    37f2:	86 85       	ldd	r24, Z+14	; 0x0e
    37f4:	88 2f       	mov	r24, r24
    37f6:	90 e0       	ldi	r25, 0x00	; 0
    37f8:	81 70       	andi	r24, 0x01	; 1
    37fa:	90 70       	andi	r25, 0x00	; 0
    37fc:	88 23       	and	r24, r24
    37fe:	29 f0       	breq	.+10     	; 0x380a <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3800:	82 e0       	ldi	r24, 0x02	; 2
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	9c 83       	std	Y+4, r25	; 0x04
    3806:	8b 83       	std	Y+3, r24	; 0x03
    3808:	02 c0       	rjmp	.+4      	; 0x380e <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    380a:	1c 82       	std	Y+4, r1	; 0x04
    380c:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    380e:	8e 81       	ldd	r24, Y+6	; 0x06
    3810:	9f 81       	ldd	r25, Y+7	; 0x07
    3812:	0e 94 af 17 	call	0x2f5e	; 0x2f5e <xStreamBufferSpacesAvailable>
    3816:	9c 01       	movw	r18, r24
    3818:	8b 81       	ldd	r24, Y+3	; 0x03
    381a:	9c 81       	ldd	r25, Y+4	; 0x04
    381c:	82 17       	cp	r24, r18
    381e:	93 07       	cpc	r25, r19
    3820:	18 f0       	brcs	.+6      	; 0x3828 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	8d 83       	std	Y+5, r24	; 0x05
    3826:	01 c0       	rjmp	.+2      	; 0x382a <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    3828:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    382a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    382c:	27 96       	adiw	r28, 0x07	; 7
    382e:	0f b6       	in	r0, 0x3f	; 63
    3830:	f8 94       	cli
    3832:	de bf       	out	0x3e, r29	; 62
    3834:	0f be       	out	0x3f, r0	; 63
    3836:	cd bf       	out	0x3d, r28	; 61
    3838:	cf 91       	pop	r28
    383a:	df 91       	pop	r29
    383c:	08 95       	ret

0000383e <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    383e:	ef 92       	push	r14
    3840:	ff 92       	push	r15
    3842:	0f 93       	push	r16
    3844:	1f 93       	push	r17
    3846:	df 93       	push	r29
    3848:	cf 93       	push	r28
    384a:	cd b7       	in	r28, 0x3d	; 61
    384c:	de b7       	in	r29, 0x3e	; 62
    384e:	28 97       	sbiw	r28, 0x08	; 8
    3850:	0f b6       	in	r0, 0x3f	; 63
    3852:	f8 94       	cli
    3854:	de bf       	out	0x3e, r29	; 62
    3856:	0f be       	out	0x3f, r0	; 63
    3858:	cd bf       	out	0x3d, r28	; 61
    385a:	9e 83       	std	Y+6, r25	; 0x06
    385c:	8d 83       	std	Y+5, r24	; 0x05
    385e:	78 87       	std	Y+8, r23	; 0x08
    3860:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3862:	8d 81       	ldd	r24, Y+5	; 0x05
    3864:	9e 81       	ldd	r25, Y+6	; 0x06
    3866:	9c 83       	std	Y+4, r25	; 0x04
    3868:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    386a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    386c:	eb 81       	ldd	r30, Y+3	; 0x03
    386e:	fc 81       	ldd	r31, Y+4	; 0x04
    3870:	80 85       	ldd	r24, Z+8	; 0x08
    3872:	91 85       	ldd	r25, Z+9	; 0x09
    3874:	00 97       	sbiw	r24, 0x00	; 0
    3876:	b9 f0       	breq	.+46     	; 0x38a6 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3878:	eb 81       	ldd	r30, Y+3	; 0x03
    387a:	fc 81       	ldd	r31, Y+4	; 0x04
    387c:	80 85       	ldd	r24, Z+8	; 0x08
    387e:	91 85       	ldd	r25, Z+9	; 0x09
    3880:	ef 81       	ldd	r30, Y+7	; 0x07
    3882:	f8 85       	ldd	r31, Y+8	; 0x08
    3884:	40 e0       	ldi	r20, 0x00	; 0
    3886:	50 e0       	ldi	r21, 0x00	; 0
    3888:	60 e0       	ldi	r22, 0x00	; 0
    388a:	70 e0       	ldi	r23, 0x00	; 0
    388c:	20 e0       	ldi	r18, 0x00	; 0
    388e:	00 e0       	ldi	r16, 0x00	; 0
    3890:	10 e0       	ldi	r17, 0x00	; 0
    3892:	7f 01       	movw	r14, r30
    3894:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3898:	eb 81       	ldd	r30, Y+3	; 0x03
    389a:	fc 81       	ldd	r31, Y+4	; 0x04
    389c:	11 86       	std	Z+9, r1	; 0x09
    389e:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    38a0:	81 e0       	ldi	r24, 0x01	; 1
    38a2:	8a 83       	std	Y+2, r24	; 0x02
    38a4:	01 c0       	rjmp	.+2      	; 0x38a8 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    38a6:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    38a8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    38aa:	28 96       	adiw	r28, 0x08	; 8
    38ac:	0f b6       	in	r0, 0x3f	; 63
    38ae:	f8 94       	cli
    38b0:	de bf       	out	0x3e, r29	; 62
    38b2:	0f be       	out	0x3f, r0	; 63
    38b4:	cd bf       	out	0x3d, r28	; 61
    38b6:	cf 91       	pop	r28
    38b8:	df 91       	pop	r29
    38ba:	1f 91       	pop	r17
    38bc:	0f 91       	pop	r16
    38be:	ff 90       	pop	r15
    38c0:	ef 90       	pop	r14
    38c2:	08 95       	ret

000038c4 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    38c4:	ef 92       	push	r14
    38c6:	ff 92       	push	r15
    38c8:	0f 93       	push	r16
    38ca:	1f 93       	push	r17
    38cc:	df 93       	push	r29
    38ce:	cf 93       	push	r28
    38d0:	cd b7       	in	r28, 0x3d	; 61
    38d2:	de b7       	in	r29, 0x3e	; 62
    38d4:	28 97       	sbiw	r28, 0x08	; 8
    38d6:	0f b6       	in	r0, 0x3f	; 63
    38d8:	f8 94       	cli
    38da:	de bf       	out	0x3e, r29	; 62
    38dc:	0f be       	out	0x3f, r0	; 63
    38de:	cd bf       	out	0x3d, r28	; 61
    38e0:	9e 83       	std	Y+6, r25	; 0x06
    38e2:	8d 83       	std	Y+5, r24	; 0x05
    38e4:	78 87       	std	Y+8, r23	; 0x08
    38e6:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    38e8:	8d 81       	ldd	r24, Y+5	; 0x05
    38ea:	9e 81       	ldd	r25, Y+6	; 0x06
    38ec:	9c 83       	std	Y+4, r25	; 0x04
    38ee:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    38f0:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    38f2:	eb 81       	ldd	r30, Y+3	; 0x03
    38f4:	fc 81       	ldd	r31, Y+4	; 0x04
    38f6:	82 85       	ldd	r24, Z+10	; 0x0a
    38f8:	93 85       	ldd	r25, Z+11	; 0x0b
    38fa:	00 97       	sbiw	r24, 0x00	; 0
    38fc:	b9 f0       	breq	.+46     	; 0x392c <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    38fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3900:	fc 81       	ldd	r31, Y+4	; 0x04
    3902:	82 85       	ldd	r24, Z+10	; 0x0a
    3904:	93 85       	ldd	r25, Z+11	; 0x0b
    3906:	ef 81       	ldd	r30, Y+7	; 0x07
    3908:	f8 85       	ldd	r31, Y+8	; 0x08
    390a:	40 e0       	ldi	r20, 0x00	; 0
    390c:	50 e0       	ldi	r21, 0x00	; 0
    390e:	60 e0       	ldi	r22, 0x00	; 0
    3910:	70 e0       	ldi	r23, 0x00	; 0
    3912:	20 e0       	ldi	r18, 0x00	; 0
    3914:	00 e0       	ldi	r16, 0x00	; 0
    3916:	10 e0       	ldi	r17, 0x00	; 0
    3918:	7f 01       	movw	r14, r30
    391a:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    391e:	eb 81       	ldd	r30, Y+3	; 0x03
    3920:	fc 81       	ldd	r31, Y+4	; 0x04
    3922:	13 86       	std	Z+11, r1	; 0x0b
    3924:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    3926:	81 e0       	ldi	r24, 0x01	; 1
    3928:	8a 83       	std	Y+2, r24	; 0x02
    392a:	01 c0       	rjmp	.+2      	; 0x392e <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    392c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    392e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3930:	28 96       	adiw	r28, 0x08	; 8
    3932:	0f b6       	in	r0, 0x3f	; 63
    3934:	f8 94       	cli
    3936:	de bf       	out	0x3e, r29	; 62
    3938:	0f be       	out	0x3f, r0	; 63
    393a:	cd bf       	out	0x3d, r28	; 61
    393c:	cf 91       	pop	r28
    393e:	df 91       	pop	r29
    3940:	1f 91       	pop	r17
    3942:	0f 91       	pop	r16
    3944:	ff 90       	pop	r15
    3946:	ef 90       	pop	r14
    3948:	08 95       	ret

0000394a <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    394a:	df 93       	push	r29
    394c:	cf 93       	push	r28
    394e:	cd b7       	in	r28, 0x3d	; 61
    3950:	de b7       	in	r29, 0x3e	; 62
    3952:	2e 97       	sbiw	r28, 0x0e	; 14
    3954:	0f b6       	in	r0, 0x3f	; 63
    3956:	f8 94       	cli
    3958:	de bf       	out	0x3e, r29	; 62
    395a:	0f be       	out	0x3f, r0	; 63
    395c:	cd bf       	out	0x3d, r28	; 61
    395e:	9e 83       	std	Y+6, r25	; 0x06
    3960:	8d 83       	std	Y+5, r24	; 0x05
    3962:	78 87       	std	Y+8, r23	; 0x08
    3964:	6f 83       	std	Y+7, r22	; 0x07
    3966:	5a 87       	std	Y+10, r21	; 0x0a
    3968:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    396a:	ed 81       	ldd	r30, Y+5	; 0x05
    396c:	fe 81       	ldd	r31, Y+6	; 0x06
    396e:	82 81       	ldd	r24, Z+2	; 0x02
    3970:	93 81       	ldd	r25, Z+3	; 0x03
    3972:	9c 83       	std	Y+4, r25	; 0x04
    3974:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3976:	ed 81       	ldd	r30, Y+5	; 0x05
    3978:	fe 81       	ldd	r31, Y+6	; 0x06
    397a:	24 81       	ldd	r18, Z+4	; 0x04
    397c:	35 81       	ldd	r19, Z+5	; 0x05
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	9c 81       	ldd	r25, Y+4	; 0x04
    3982:	a9 01       	movw	r20, r18
    3984:	48 1b       	sub	r20, r24
    3986:	59 0b       	sbc	r21, r25
    3988:	ca 01       	movw	r24, r20
    398a:	29 85       	ldd	r18, Y+9	; 0x09
    398c:	3a 85       	ldd	r19, Y+10	; 0x0a
    398e:	3e 87       	std	Y+14, r19	; 0x0e
    3990:	2d 87       	std	Y+13, r18	; 0x0d
    3992:	9c 87       	std	Y+12, r25	; 0x0c
    3994:	8b 87       	std	Y+11, r24	; 0x0b
    3996:	4b 85       	ldd	r20, Y+11	; 0x0b
    3998:	5c 85       	ldd	r21, Y+12	; 0x0c
    399a:	8d 85       	ldd	r24, Y+13	; 0x0d
    399c:	9e 85       	ldd	r25, Y+14	; 0x0e
    399e:	84 17       	cp	r24, r20
    39a0:	95 07       	cpc	r25, r21
    39a2:	20 f4       	brcc	.+8      	; 0x39ac <prvWriteBytesToBuffer+0x62>
    39a4:	2d 85       	ldd	r18, Y+13	; 0x0d
    39a6:	3e 85       	ldd	r19, Y+14	; 0x0e
    39a8:	3c 87       	std	Y+12, r19	; 0x0c
    39aa:	2b 87       	std	Y+11, r18	; 0x0b
    39ac:	4b 85       	ldd	r20, Y+11	; 0x0b
    39ae:	5c 85       	ldd	r21, Y+12	; 0x0c
    39b0:	5a 83       	std	Y+2, r21	; 0x02
    39b2:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    39b4:	ed 81       	ldd	r30, Y+5	; 0x05
    39b6:	fe 81       	ldd	r31, Y+6	; 0x06
    39b8:	24 85       	ldd	r18, Z+12	; 0x0c
    39ba:	35 85       	ldd	r19, Z+13	; 0x0d
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	9c 81       	ldd	r25, Y+4	; 0x04
    39c0:	82 0f       	add	r24, r18
    39c2:	93 1f       	adc	r25, r19
    39c4:	2f 81       	ldd	r18, Y+7	; 0x07
    39c6:	38 85       	ldd	r19, Y+8	; 0x08
    39c8:	49 81       	ldd	r20, Y+1	; 0x01
    39ca:	5a 81       	ldd	r21, Y+2	; 0x02
    39cc:	b9 01       	movw	r22, r18
    39ce:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    39d2:	29 85       	ldd	r18, Y+9	; 0x09
    39d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    39d6:	89 81       	ldd	r24, Y+1	; 0x01
    39d8:	9a 81       	ldd	r25, Y+2	; 0x02
    39da:	82 17       	cp	r24, r18
    39dc:	93 07       	cpc	r25, r19
    39de:	b0 f4       	brcc	.+44     	; 0x3a0c <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    39e0:	ed 81       	ldd	r30, Y+5	; 0x05
    39e2:	fe 81       	ldd	r31, Y+6	; 0x06
    39e4:	64 85       	ldd	r22, Z+12	; 0x0c
    39e6:	75 85       	ldd	r23, Z+13	; 0x0d
    39e8:	2f 81       	ldd	r18, Y+7	; 0x07
    39ea:	38 85       	ldd	r19, Y+8	; 0x08
    39ec:	89 81       	ldd	r24, Y+1	; 0x01
    39ee:	9a 81       	ldd	r25, Y+2	; 0x02
    39f0:	a9 01       	movw	r20, r18
    39f2:	48 0f       	add	r20, r24
    39f4:	59 1f       	adc	r21, r25
    39f6:	29 85       	ldd	r18, Y+9	; 0x09
    39f8:	3a 85       	ldd	r19, Y+10	; 0x0a
    39fa:	89 81       	ldd	r24, Y+1	; 0x01
    39fc:	9a 81       	ldd	r25, Y+2	; 0x02
    39fe:	28 1b       	sub	r18, r24
    3a00:	39 0b       	sbc	r19, r25
    3a02:	cb 01       	movw	r24, r22
    3a04:	ba 01       	movw	r22, r20
    3a06:	a9 01       	movw	r20, r18
    3a08:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3a0c:	2b 81       	ldd	r18, Y+3	; 0x03
    3a0e:	3c 81       	ldd	r19, Y+4	; 0x04
    3a10:	89 85       	ldd	r24, Y+9	; 0x09
    3a12:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a14:	82 0f       	add	r24, r18
    3a16:	93 1f       	adc	r25, r19
    3a18:	9c 83       	std	Y+4, r25	; 0x04
    3a1a:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    3a1c:	ed 81       	ldd	r30, Y+5	; 0x05
    3a1e:	fe 81       	ldd	r31, Y+6	; 0x06
    3a20:	24 81       	ldd	r18, Z+4	; 0x04
    3a22:	35 81       	ldd	r19, Z+5	; 0x05
    3a24:	8b 81       	ldd	r24, Y+3	; 0x03
    3a26:	9c 81       	ldd	r25, Y+4	; 0x04
    3a28:	82 17       	cp	r24, r18
    3a2a:	93 07       	cpc	r25, r19
    3a2c:	50 f0       	brcs	.+20     	; 0x3a42 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3a2e:	ed 81       	ldd	r30, Y+5	; 0x05
    3a30:	fe 81       	ldd	r31, Y+6	; 0x06
    3a32:	24 81       	ldd	r18, Z+4	; 0x04
    3a34:	35 81       	ldd	r19, Z+5	; 0x05
    3a36:	8b 81       	ldd	r24, Y+3	; 0x03
    3a38:	9c 81       	ldd	r25, Y+4	; 0x04
    3a3a:	82 1b       	sub	r24, r18
    3a3c:	93 0b       	sbc	r25, r19
    3a3e:	9c 83       	std	Y+4, r25	; 0x04
    3a40:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3a42:	ed 81       	ldd	r30, Y+5	; 0x05
    3a44:	fe 81       	ldd	r31, Y+6	; 0x06
    3a46:	8b 81       	ldd	r24, Y+3	; 0x03
    3a48:	9c 81       	ldd	r25, Y+4	; 0x04
    3a4a:	93 83       	std	Z+3, r25	; 0x03
    3a4c:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3a4e:	89 85       	ldd	r24, Y+9	; 0x09
    3a50:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3a52:	2e 96       	adiw	r28, 0x0e	; 14
    3a54:	0f b6       	in	r0, 0x3f	; 63
    3a56:	f8 94       	cli
    3a58:	de bf       	out	0x3e, r29	; 62
    3a5a:	0f be       	out	0x3f, r0	; 63
    3a5c:	cd bf       	out	0x3d, r28	; 61
    3a5e:	cf 91       	pop	r28
    3a60:	df 91       	pop	r29
    3a62:	08 95       	ret

00003a64 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3a64:	df 93       	push	r29
    3a66:	cf 93       	push	r28
    3a68:	cd b7       	in	r28, 0x3d	; 61
    3a6a:	de b7       	in	r29, 0x3e	; 62
    3a6c:	66 97       	sbiw	r28, 0x16	; 22
    3a6e:	0f b6       	in	r0, 0x3f	; 63
    3a70:	f8 94       	cli
    3a72:	de bf       	out	0x3e, r29	; 62
    3a74:	0f be       	out	0x3f, r0	; 63
    3a76:	cd bf       	out	0x3d, r28	; 61
    3a78:	98 87       	std	Y+8, r25	; 0x08
    3a7a:	8f 83       	std	Y+7, r24	; 0x07
    3a7c:	7a 87       	std	Y+10, r23	; 0x0a
    3a7e:	69 87       	std	Y+9, r22	; 0x09
    3a80:	5c 87       	std	Y+12, r21	; 0x0c
    3a82:	4b 87       	std	Y+11, r20	; 0x0b
    3a84:	3e 87       	std	Y+14, r19	; 0x0e
    3a86:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3a88:	2d 85       	ldd	r18, Y+13	; 0x0d
    3a8a:	3e 85       	ldd	r19, Y+14	; 0x0e
    3a8c:	3a 8b       	std	Y+18, r19	; 0x12
    3a8e:	29 8b       	std	Y+17, r18	; 0x11
    3a90:	4b 85       	ldd	r20, Y+11	; 0x0b
    3a92:	5c 85       	ldd	r21, Y+12	; 0x0c
    3a94:	58 8b       	std	Y+16, r21	; 0x10
    3a96:	4f 87       	std	Y+15, r20	; 0x0f
    3a98:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a9a:	98 89       	ldd	r25, Y+16	; 0x10
    3a9c:	29 89       	ldd	r18, Y+17	; 0x11
    3a9e:	3a 89       	ldd	r19, Y+18	; 0x12
    3aa0:	28 17       	cp	r18, r24
    3aa2:	39 07       	cpc	r19, r25
    3aa4:	20 f4       	brcc	.+8      	; 0x3aae <prvReadBytesFromBuffer+0x4a>
    3aa6:	49 89       	ldd	r20, Y+17	; 0x11
    3aa8:	5a 89       	ldd	r21, Y+18	; 0x12
    3aaa:	58 8b       	std	Y+16, r21	; 0x10
    3aac:	4f 87       	std	Y+15, r20	; 0x0f
    3aae:	8f 85       	ldd	r24, Y+15	; 0x0f
    3ab0:	98 89       	ldd	r25, Y+16	; 0x10
    3ab2:	9e 83       	std	Y+6, r25	; 0x06
    3ab4:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3ab6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ab8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aba:	00 97       	sbiw	r24, 0x00	; 0
    3abc:	09 f4       	brne	.+2      	; 0x3ac0 <prvReadBytesFromBuffer+0x5c>
    3abe:	74 c0       	rjmp	.+232    	; 0x3ba8 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3ac0:	ef 81       	ldd	r30, Y+7	; 0x07
    3ac2:	f8 85       	ldd	r31, Y+8	; 0x08
    3ac4:	80 81       	ld	r24, Z
    3ac6:	91 81       	ldd	r25, Z+1	; 0x01
    3ac8:	9a 83       	std	Y+2, r25	; 0x02
    3aca:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3acc:	ef 81       	ldd	r30, Y+7	; 0x07
    3ace:	f8 85       	ldd	r31, Y+8	; 0x08
    3ad0:	24 81       	ldd	r18, Z+4	; 0x04
    3ad2:	35 81       	ldd	r19, Z+5	; 0x05
    3ad4:	89 81       	ldd	r24, Y+1	; 0x01
    3ad6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad8:	a9 01       	movw	r20, r18
    3ada:	48 1b       	sub	r20, r24
    3adc:	59 0b       	sbc	r21, r25
    3ade:	ca 01       	movw	r24, r20
    3ae0:	2d 81       	ldd	r18, Y+5	; 0x05
    3ae2:	3e 81       	ldd	r19, Y+6	; 0x06
    3ae4:	3e 8b       	std	Y+22, r19	; 0x16
    3ae6:	2d 8b       	std	Y+21, r18	; 0x15
    3ae8:	9c 8b       	std	Y+20, r25	; 0x14
    3aea:	8b 8b       	std	Y+19, r24	; 0x13
    3aec:	4b 89       	ldd	r20, Y+19	; 0x13
    3aee:	5c 89       	ldd	r21, Y+20	; 0x14
    3af0:	8d 89       	ldd	r24, Y+21	; 0x15
    3af2:	9e 89       	ldd	r25, Y+22	; 0x16
    3af4:	84 17       	cp	r24, r20
    3af6:	95 07       	cpc	r25, r21
    3af8:	20 f4       	brcc	.+8      	; 0x3b02 <prvReadBytesFromBuffer+0x9e>
    3afa:	2d 89       	ldd	r18, Y+21	; 0x15
    3afc:	3e 89       	ldd	r19, Y+22	; 0x16
    3afe:	3c 8b       	std	Y+20, r19	; 0x14
    3b00:	2b 8b       	std	Y+19, r18	; 0x13
    3b02:	4b 89       	ldd	r20, Y+19	; 0x13
    3b04:	5c 89       	ldd	r21, Y+20	; 0x14
    3b06:	5c 83       	std	Y+4, r21	; 0x04
    3b08:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3b0a:	ef 81       	ldd	r30, Y+7	; 0x07
    3b0c:	f8 85       	ldd	r31, Y+8	; 0x08
    3b0e:	24 85       	ldd	r18, Z+12	; 0x0c
    3b10:	35 85       	ldd	r19, Z+13	; 0x0d
    3b12:	89 81       	ldd	r24, Y+1	; 0x01
    3b14:	9a 81       	ldd	r25, Y+2	; 0x02
    3b16:	a9 01       	movw	r20, r18
    3b18:	48 0f       	add	r20, r24
    3b1a:	59 1f       	adc	r21, r25
    3b1c:	89 85       	ldd	r24, Y+9	; 0x09
    3b1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b20:	2b 81       	ldd	r18, Y+3	; 0x03
    3b22:	3c 81       	ldd	r19, Y+4	; 0x04
    3b24:	ba 01       	movw	r22, r20
    3b26:	a9 01       	movw	r20, r18
    3b28:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3b2c:	2d 81       	ldd	r18, Y+5	; 0x05
    3b2e:	3e 81       	ldd	r19, Y+6	; 0x06
    3b30:	8b 81       	ldd	r24, Y+3	; 0x03
    3b32:	9c 81       	ldd	r25, Y+4	; 0x04
    3b34:	82 17       	cp	r24, r18
    3b36:	93 07       	cpc	r25, r19
    3b38:	b0 f4       	brcc	.+44     	; 0x3b66 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3b3a:	29 85       	ldd	r18, Y+9	; 0x09
    3b3c:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b40:	9c 81       	ldd	r25, Y+4	; 0x04
    3b42:	b9 01       	movw	r22, r18
    3b44:	68 0f       	add	r22, r24
    3b46:	79 1f       	adc	r23, r25
    3b48:	ef 81       	ldd	r30, Y+7	; 0x07
    3b4a:	f8 85       	ldd	r31, Y+8	; 0x08
    3b4c:	44 85       	ldd	r20, Z+12	; 0x0c
    3b4e:	55 85       	ldd	r21, Z+13	; 0x0d
    3b50:	2d 81       	ldd	r18, Y+5	; 0x05
    3b52:	3e 81       	ldd	r19, Y+6	; 0x06
    3b54:	8b 81       	ldd	r24, Y+3	; 0x03
    3b56:	9c 81       	ldd	r25, Y+4	; 0x04
    3b58:	28 1b       	sub	r18, r24
    3b5a:	39 0b       	sbc	r19, r25
    3b5c:	cb 01       	movw	r24, r22
    3b5e:	ba 01       	movw	r22, r20
    3b60:	a9 01       	movw	r20, r18
    3b62:	0e 94 32 2d 	call	0x5a64	; 0x5a64 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3b66:	29 81       	ldd	r18, Y+1	; 0x01
    3b68:	3a 81       	ldd	r19, Y+2	; 0x02
    3b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    3b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    3b6e:	82 0f       	add	r24, r18
    3b70:	93 1f       	adc	r25, r19
    3b72:	9a 83       	std	Y+2, r25	; 0x02
    3b74:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3b76:	ef 81       	ldd	r30, Y+7	; 0x07
    3b78:	f8 85       	ldd	r31, Y+8	; 0x08
    3b7a:	24 81       	ldd	r18, Z+4	; 0x04
    3b7c:	35 81       	ldd	r19, Z+5	; 0x05
    3b7e:	89 81       	ldd	r24, Y+1	; 0x01
    3b80:	9a 81       	ldd	r25, Y+2	; 0x02
    3b82:	82 17       	cp	r24, r18
    3b84:	93 07       	cpc	r25, r19
    3b86:	50 f0       	brcs	.+20     	; 0x3b9c <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3b88:	ef 81       	ldd	r30, Y+7	; 0x07
    3b8a:	f8 85       	ldd	r31, Y+8	; 0x08
    3b8c:	24 81       	ldd	r18, Z+4	; 0x04
    3b8e:	35 81       	ldd	r19, Z+5	; 0x05
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	9a 81       	ldd	r25, Y+2	; 0x02
    3b94:	82 1b       	sub	r24, r18
    3b96:	93 0b       	sbc	r25, r19
    3b98:	9a 83       	std	Y+2, r25	; 0x02
    3b9a:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3b9c:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9e:	f8 85       	ldd	r31, Y+8	; 0x08
    3ba0:	89 81       	ldd	r24, Y+1	; 0x01
    3ba2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba4:	91 83       	std	Z+1, r25	; 0x01
    3ba6:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3ba8:	8d 81       	ldd	r24, Y+5	; 0x05
    3baa:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3bac:	66 96       	adiw	r28, 0x16	; 22
    3bae:	0f b6       	in	r0, 0x3f	; 63
    3bb0:	f8 94       	cli
    3bb2:	de bf       	out	0x3e, r29	; 62
    3bb4:	0f be       	out	0x3f, r0	; 63
    3bb6:	cd bf       	out	0x3d, r28	; 61
    3bb8:	cf 91       	pop	r28
    3bba:	df 91       	pop	r29
    3bbc:	08 95       	ret

00003bbe <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3bbe:	df 93       	push	r29
    3bc0:	cf 93       	push	r28
    3bc2:	00 d0       	rcall	.+0      	; 0x3bc4 <prvBytesInBuffer+0x6>
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <prvBytesInBuffer+0x8>
    3bc6:	cd b7       	in	r28, 0x3d	; 61
    3bc8:	de b7       	in	r29, 0x3e	; 62
    3bca:	9c 83       	std	Y+4, r25	; 0x04
    3bcc:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3bce:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd2:	24 81       	ldd	r18, Z+4	; 0x04
    3bd4:	35 81       	ldd	r19, Z+5	; 0x05
    3bd6:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd8:	fc 81       	ldd	r31, Y+4	; 0x04
    3bda:	82 81       	ldd	r24, Z+2	; 0x02
    3bdc:	93 81       	ldd	r25, Z+3	; 0x03
    3bde:	82 0f       	add	r24, r18
    3be0:	93 1f       	adc	r25, r19
    3be2:	9a 83       	std	Y+2, r25	; 0x02
    3be4:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3be6:	eb 81       	ldd	r30, Y+3	; 0x03
    3be8:	fc 81       	ldd	r31, Y+4	; 0x04
    3bea:	20 81       	ld	r18, Z
    3bec:	31 81       	ldd	r19, Z+1	; 0x01
    3bee:	89 81       	ldd	r24, Y+1	; 0x01
    3bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf2:	82 1b       	sub	r24, r18
    3bf4:	93 0b       	sbc	r25, r19
    3bf6:	9a 83       	std	Y+2, r25	; 0x02
    3bf8:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bfe:	24 81       	ldd	r18, Z+4	; 0x04
    3c00:	35 81       	ldd	r19, Z+5	; 0x05
    3c02:	89 81       	ldd	r24, Y+1	; 0x01
    3c04:	9a 81       	ldd	r25, Y+2	; 0x02
    3c06:	82 17       	cp	r24, r18
    3c08:	93 07       	cpc	r25, r19
    3c0a:	50 f0       	brcs	.+20     	; 0x3c20 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c10:	24 81       	ldd	r18, Z+4	; 0x04
    3c12:	35 81       	ldd	r19, Z+5	; 0x05
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	82 1b       	sub	r24, r18
    3c1a:	93 0b       	sbc	r25, r19
    3c1c:	9a 83       	std	Y+2, r25	; 0x02
    3c1e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3c20:	89 81       	ldd	r24, Y+1	; 0x01
    3c22:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c24:	0f 90       	pop	r0
    3c26:	0f 90       	pop	r0
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3c32:	0f 93       	push	r16
    3c34:	df 93       	push	r29
    3c36:	cf 93       	push	r28
    3c38:	cd b7       	in	r28, 0x3d	; 61
    3c3a:	de b7       	in	r29, 0x3e	; 62
    3c3c:	29 97       	sbiw	r28, 0x09	; 9
    3c3e:	0f b6       	in	r0, 0x3f	; 63
    3c40:	f8 94       	cli
    3c42:	de bf       	out	0x3e, r29	; 62
    3c44:	0f be       	out	0x3f, r0	; 63
    3c46:	cd bf       	out	0x3d, r28	; 61
    3c48:	9a 83       	std	Y+2, r25	; 0x02
    3c4a:	89 83       	std	Y+1, r24	; 0x01
    3c4c:	7c 83       	std	Y+4, r23	; 0x04
    3c4e:	6b 83       	std	Y+3, r22	; 0x03
    3c50:	5e 83       	std	Y+6, r21	; 0x06
    3c52:	4d 83       	std	Y+5, r20	; 0x05
    3c54:	38 87       	std	Y+8, r19	; 0x08
    3c56:	2f 83       	std	Y+7, r18	; 0x07
    3c58:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
    3c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5e:	60 e0       	ldi	r22, 0x00	; 0
    3c60:	70 e0       	ldi	r23, 0x00	; 0
    3c62:	4f e0       	ldi	r20, 0x0F	; 15
    3c64:	50 e0       	ldi	r21, 0x00	; 0
    3c66:	0e 94 3b 2d 	call	0x5a76	; 0x5a76 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c70:	9c 81       	ldd	r25, Y+4	; 0x04
    3c72:	95 87       	std	Z+13, r25	; 0x0d
    3c74:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3c76:	e9 81       	ldd	r30, Y+1	; 0x01
    3c78:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7a:	8d 81       	ldd	r24, Y+5	; 0x05
    3c7c:	9e 81       	ldd	r25, Y+6	; 0x06
    3c7e:	95 83       	std	Z+5, r25	; 0x05
    3c80:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3c82:	e9 81       	ldd	r30, Y+1	; 0x01
    3c84:	fa 81       	ldd	r31, Y+2	; 0x02
    3c86:	8f 81       	ldd	r24, Y+7	; 0x07
    3c88:	98 85       	ldd	r25, Y+8	; 0x08
    3c8a:	97 83       	std	Z+7, r25	; 0x07
    3c8c:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c90:	fa 81       	ldd	r31, Y+2	; 0x02
    3c92:	89 85       	ldd	r24, Y+9	; 0x09
    3c94:	86 87       	std	Z+14, r24	; 0x0e
}
    3c96:	29 96       	adiw	r28, 0x09	; 9
    3c98:	0f b6       	in	r0, 0x3f	; 63
    3c9a:	f8 94       	cli
    3c9c:	de bf       	out	0x3e, r29	; 62
    3c9e:	0f be       	out	0x3f, r0	; 63
    3ca0:	cd bf       	out	0x3d, r28	; 61
    3ca2:	cf 91       	pop	r28
    3ca4:	df 91       	pop	r29
    3ca6:	0f 91       	pop	r16
    3ca8:	08 95       	ret

00003caa <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3caa:	8f 92       	push	r8
    3cac:	9f 92       	push	r9
    3cae:	af 92       	push	r10
    3cb0:	bf 92       	push	r11
    3cb2:	cf 92       	push	r12
    3cb4:	df 92       	push	r13
    3cb6:	ef 92       	push	r14
    3cb8:	ff 92       	push	r15
    3cba:	0f 93       	push	r16
    3cbc:	1f 93       	push	r17
    3cbe:	df 93       	push	r29
    3cc0:	cf 93       	push	r28
    3cc2:	cd b7       	in	r28, 0x3d	; 61
    3cc4:	de b7       	in	r29, 0x3e	; 62
    3cc6:	60 97       	sbiw	r28, 0x10	; 16
    3cc8:	0f b6       	in	r0, 0x3f	; 63
    3cca:	f8 94       	cli
    3ccc:	de bf       	out	0x3e, r29	; 62
    3cce:	0f be       	out	0x3f, r0	; 63
    3cd0:	cd bf       	out	0x3d, r28	; 61
    3cd2:	9f 83       	std	Y+7, r25	; 0x07
    3cd4:	8e 83       	std	Y+6, r24	; 0x06
    3cd6:	79 87       	std	Y+9, r23	; 0x09
    3cd8:	68 87       	std	Y+8, r22	; 0x08
    3cda:	5b 87       	std	Y+11, r21	; 0x0b
    3cdc:	4a 87       	std	Y+10, r20	; 0x0a
    3cde:	3d 87       	std	Y+13, r19	; 0x0d
    3ce0:	2c 87       	std	Y+12, r18	; 0x0c
    3ce2:	0e 87       	std	Y+14, r16	; 0x0e
    3ce4:	f8 8a       	std	Y+16, r15	; 0x10
    3ce6:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3ce8:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cea:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cec:	0e 94 c9 08 	call	0x1192	; 0x1192 <pvPortMalloc>
    3cf0:	9a 83       	std	Y+2, r25	; 0x02
    3cf2:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3cf4:	89 81       	ldd	r24, Y+1	; 0x01
    3cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf8:	00 97       	sbiw	r24, 0x00	; 0
    3cfa:	b1 f0       	breq	.+44     	; 0x3d28 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3cfc:	84 e3       	ldi	r24, 0x34	; 52
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	0e 94 c9 08 	call	0x1192	; 0x1192 <pvPortMalloc>
    3d04:	9d 83       	std	Y+5, r25	; 0x05
    3d06:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3d08:	8c 81       	ldd	r24, Y+4	; 0x04
    3d0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d0c:	00 97       	sbiw	r24, 0x00	; 0
    3d0e:	39 f0       	breq	.+14     	; 0x3d1e <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3d10:	ec 81       	ldd	r30, Y+4	; 0x04
    3d12:	fd 81       	ldd	r31, Y+5	; 0x05
    3d14:	89 81       	ldd	r24, Y+1	; 0x01
    3d16:	9a 81       	ldd	r25, Y+2	; 0x02
    3d18:	90 8f       	std	Z+24, r25	; 0x18
    3d1a:	87 8b       	std	Z+23, r24	; 0x17
    3d1c:	07 c0       	rjmp	.+14     	; 0x3d2c <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3d1e:	89 81       	ldd	r24, Y+1	; 0x01
    3d20:	9a 81       	ldd	r25, Y+2	; 0x02
    3d22:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
    3d26:	02 c0       	rjmp	.+4      	; 0x3d2c <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3d28:	1d 82       	std	Y+5, r1	; 0x05
    3d2a:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3d2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d30:	00 97       	sbiw	r24, 0x00	; 0
    3d32:	e9 f0       	breq	.+58     	; 0x3d6e <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3d34:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d36:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d38:	9c 01       	movw	r18, r24
    3d3a:	40 e0       	ldi	r20, 0x00	; 0
    3d3c:	50 e0       	ldi	r21, 0x00	; 0
    3d3e:	8e 81       	ldd	r24, Y+6	; 0x06
    3d40:	9f 81       	ldd	r25, Y+7	; 0x07
    3d42:	68 85       	ldd	r22, Y+8	; 0x08
    3d44:	79 85       	ldd	r23, Y+9	; 0x09
    3d46:	ec 85       	ldd	r30, Y+12	; 0x0c
    3d48:	fd 85       	ldd	r31, Y+13	; 0x0d
    3d4a:	af 85       	ldd	r26, Y+15	; 0x0f
    3d4c:	b8 89       	ldd	r27, Y+16	; 0x10
    3d4e:	ac 80       	ldd	r10, Y+4	; 0x04
    3d50:	bd 80       	ldd	r11, Y+5	; 0x05
    3d52:	8f 01       	movw	r16, r30
    3d54:	ee 84       	ldd	r14, Y+14	; 0x0e
    3d56:	6d 01       	movw	r12, r26
    3d58:	88 24       	eor	r8, r8
    3d5a:	99 24       	eor	r9, r9
    3d5c:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3d60:	8c 81       	ldd	r24, Y+4	; 0x04
    3d62:	9d 81       	ldd	r25, Y+5	; 0x05
    3d64:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3d68:	81 e0       	ldi	r24, 0x01	; 1
    3d6a:	8b 83       	std	Y+3, r24	; 0x03
    3d6c:	02 c0       	rjmp	.+4      	; 0x3d72 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3d6e:	8f ef       	ldi	r24, 0xFF	; 255
    3d70:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3d72:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3d74:	60 96       	adiw	r28, 0x10	; 16
    3d76:	0f b6       	in	r0, 0x3f	; 63
    3d78:	f8 94       	cli
    3d7a:	de bf       	out	0x3e, r29	; 62
    3d7c:	0f be       	out	0x3f, r0	; 63
    3d7e:	cd bf       	out	0x3d, r28	; 61
    3d80:	cf 91       	pop	r28
    3d82:	df 91       	pop	r29
    3d84:	1f 91       	pop	r17
    3d86:	0f 91       	pop	r16
    3d88:	ff 90       	pop	r15
    3d8a:	ef 90       	pop	r14
    3d8c:	df 90       	pop	r13
    3d8e:	cf 90       	pop	r12
    3d90:	bf 90       	pop	r11
    3d92:	af 90       	pop	r10
    3d94:	9f 90       	pop	r9
    3d96:	8f 90       	pop	r8
    3d98:	08 95       	ret

00003d9a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3d9a:	8f 92       	push	r8
    3d9c:	9f 92       	push	r9
    3d9e:	af 92       	push	r10
    3da0:	bf 92       	push	r11
    3da2:	cf 92       	push	r12
    3da4:	df 92       	push	r13
    3da6:	ef 92       	push	r14
    3da8:	0f 93       	push	r16
    3daa:	1f 93       	push	r17
    3dac:	df 93       	push	r29
    3dae:	cf 93       	push	r28
    3db0:	cd b7       	in	r28, 0x3d	; 61
    3db2:	de b7       	in	r29, 0x3e	; 62
    3db4:	64 97       	sbiw	r28, 0x14	; 20
    3db6:	0f b6       	in	r0, 0x3f	; 63
    3db8:	f8 94       	cli
    3dba:	de bf       	out	0x3e, r29	; 62
    3dbc:	0f be       	out	0x3f, r0	; 63
    3dbe:	cd bf       	out	0x3d, r28	; 61
    3dc0:	9d 83       	std	Y+5, r25	; 0x05
    3dc2:	8c 83       	std	Y+4, r24	; 0x04
    3dc4:	7f 83       	std	Y+7, r23	; 0x07
    3dc6:	6e 83       	std	Y+6, r22	; 0x06
    3dc8:	28 87       	std	Y+8, r18	; 0x08
    3dca:	39 87       	std	Y+9, r19	; 0x09
    3dcc:	4a 87       	std	Y+10, r20	; 0x0a
    3dce:	5b 87       	std	Y+11, r21	; 0x0b
    3dd0:	1d 87       	std	Y+13, r17	; 0x0d
    3dd2:	0c 87       	std	Y+12, r16	; 0x0c
    3dd4:	ee 86       	std	Y+14, r14	; 0x0e
    3dd6:	d8 8a       	std	Y+16, r13	; 0x10
    3dd8:	cf 86       	std	Y+15, r12	; 0x0f
    3dda:	ba 8a       	std	Y+18, r11	; 0x12
    3ddc:	a9 8a       	std	Y+17, r10	; 0x11
    3dde:	9c 8a       	std	Y+20, r9	; 0x14
    3de0:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3de2:	e9 89       	ldd	r30, Y+17	; 0x11
    3de4:	fa 89       	ldd	r31, Y+18	; 0x12
    3de6:	27 89       	ldd	r18, Z+23	; 0x17
    3de8:	30 8d       	ldd	r19, Z+24	; 0x18
    3dea:	88 85       	ldd	r24, Y+8	; 0x08
    3dec:	99 85       	ldd	r25, Y+9	; 0x09
    3dee:	01 97       	sbiw	r24, 0x01	; 1
    3df0:	82 0f       	add	r24, r18
    3df2:	93 1f       	adc	r25, r19
    3df4:	9b 83       	std	Y+3, r25	; 0x03
    3df6:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3df8:	8e 81       	ldd	r24, Y+6	; 0x06
    3dfa:	9f 81       	ldd	r25, Y+7	; 0x07
    3dfc:	00 97       	sbiw	r24, 0x00	; 0
    3dfe:	51 f1       	breq	.+84     	; 0x3e54 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3e00:	19 82       	std	Y+1, r1	; 0x01
    3e02:	21 c0       	rjmp	.+66     	; 0x3e46 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3e04:	89 81       	ldd	r24, Y+1	; 0x01
    3e06:	48 2f       	mov	r20, r24
    3e08:	50 e0       	ldi	r21, 0x00	; 0
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
    3e0c:	28 2f       	mov	r18, r24
    3e0e:	30 e0       	ldi	r19, 0x00	; 0
    3e10:	8e 81       	ldd	r24, Y+6	; 0x06
    3e12:	9f 81       	ldd	r25, Y+7	; 0x07
    3e14:	fc 01       	movw	r30, r24
    3e16:	e2 0f       	add	r30, r18
    3e18:	f3 1f       	adc	r31, r19
    3e1a:	20 81       	ld	r18, Z
    3e1c:	89 89       	ldd	r24, Y+17	; 0x11
    3e1e:	9a 89       	ldd	r25, Y+18	; 0x12
    3e20:	84 0f       	add	r24, r20
    3e22:	95 1f       	adc	r25, r21
    3e24:	fc 01       	movw	r30, r24
    3e26:	79 96       	adiw	r30, 0x19	; 25
    3e28:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3e2a:	89 81       	ldd	r24, Y+1	; 0x01
    3e2c:	28 2f       	mov	r18, r24
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	8e 81       	ldd	r24, Y+6	; 0x06
    3e32:	9f 81       	ldd	r25, Y+7	; 0x07
    3e34:	fc 01       	movw	r30, r24
    3e36:	e2 0f       	add	r30, r18
    3e38:	f3 1f       	adc	r31, r19
    3e3a:	80 81       	ld	r24, Z
    3e3c:	88 23       	and	r24, r24
    3e3e:	31 f0       	breq	.+12     	; 0x3e4c <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	8f 5f       	subi	r24, 0xFF	; 255
    3e44:	89 83       	std	Y+1, r24	; 0x01
    3e46:	89 81       	ldd	r24, Y+1	; 0x01
    3e48:	84 31       	cpi	r24, 0x14	; 20
    3e4a:	e0 f2       	brcs	.-72     	; 0x3e04 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3e4c:	e9 89       	ldd	r30, Y+17	; 0x11
    3e4e:	fa 89       	ldd	r31, Y+18	; 0x12
    3e50:	14 a6       	std	Z+44, r1	; 0x2c
    3e52:	03 c0       	rjmp	.+6      	; 0x3e5a <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3e54:	e9 89       	ldd	r30, Y+17	; 0x11
    3e56:	fa 89       	ldd	r31, Y+18	; 0x12
    3e58:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3e5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e5c:	87 30       	cpi	r24, 0x07	; 7
    3e5e:	10 f0       	brcs	.+4      	; 0x3e64 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3e60:	86 e0       	ldi	r24, 0x06	; 6
    3e62:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3e64:	e9 89       	ldd	r30, Y+17	; 0x11
    3e66:	fa 89       	ldd	r31, Y+18	; 0x12
    3e68:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e6a:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    3e6c:	e9 89       	ldd	r30, Y+17	; 0x11
    3e6e:	fa 89       	ldd	r31, Y+18	; 0x12
    3e70:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e72:	85 a7       	std	Z+45, r24	; 0x2d
		pxNewTCB->uxMutexesHeld = 0;
    3e74:	e9 89       	ldd	r30, Y+17	; 0x11
    3e76:	fa 89       	ldd	r31, Y+18	; 0x12
    3e78:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3e7a:	89 89       	ldd	r24, Y+17	; 0x11
    3e7c:	9a 89       	ldd	r25, Y+18	; 0x12
    3e7e:	02 96       	adiw	r24, 0x02	; 2
    3e80:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3e84:	89 89       	ldd	r24, Y+17	; 0x11
    3e86:	9a 89       	ldd	r25, Y+18	; 0x12
    3e88:	0c 96       	adiw	r24, 0x0c	; 12
    3e8a:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3e8e:	e9 89       	ldd	r30, Y+17	; 0x11
    3e90:	fa 89       	ldd	r31, Y+18	; 0x12
    3e92:	89 89       	ldd	r24, Y+17	; 0x11
    3e94:	9a 89       	ldd	r25, Y+18	; 0x12
    3e96:	91 87       	std	Z+9, r25	; 0x09
    3e98:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e9a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e9c:	28 2f       	mov	r18, r24
    3e9e:	30 e0       	ldi	r19, 0x00	; 0
    3ea0:	87 e0       	ldi	r24, 0x07	; 7
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
    3ea4:	82 1b       	sub	r24, r18
    3ea6:	93 0b       	sbc	r25, r19
    3ea8:	e9 89       	ldd	r30, Y+17	; 0x11
    3eaa:	fa 89       	ldd	r31, Y+18	; 0x12
    3eac:	95 87       	std	Z+13, r25	; 0x0d
    3eae:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3eb0:	e9 89       	ldd	r30, Y+17	; 0x11
    3eb2:	fa 89       	ldd	r31, Y+18	; 0x12
    3eb4:	89 89       	ldd	r24, Y+17	; 0x11
    3eb6:	9a 89       	ldd	r25, Y+18	; 0x12
    3eb8:	93 8b       	std	Z+19, r25	; 0x13
    3eba:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3ebc:	e9 89       	ldd	r30, Y+17	; 0x11
    3ebe:	fa 89       	ldd	r31, Y+18	; 0x12
    3ec0:	17 a6       	std	Z+47, r1	; 0x2f
    3ec2:	10 aa       	std	Z+48, r1	; 0x30
    3ec4:	11 aa       	std	Z+49, r1	; 0x31
    3ec6:	12 aa       	std	Z+50, r1	; 0x32
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3ec8:	e9 89       	ldd	r30, Y+17	; 0x11
    3eca:	fa 89       	ldd	r31, Y+18	; 0x12
    3ecc:	13 aa       	std	Z+51, r1	; 0x33
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3ece:	8a 81       	ldd	r24, Y+2	; 0x02
    3ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ed2:	2c 81       	ldd	r18, Y+4	; 0x04
    3ed4:	3d 81       	ldd	r19, Y+5	; 0x05
    3ed6:	4c 85       	ldd	r20, Y+12	; 0x0c
    3ed8:	5d 85       	ldd	r21, Y+13	; 0x0d
    3eda:	b9 01       	movw	r22, r18
    3edc:	0e 94 21 0c 	call	0x1842	; 0x1842 <pxPortInitialiseStack>
    3ee0:	e9 89       	ldd	r30, Y+17	; 0x11
    3ee2:	fa 89       	ldd	r31, Y+18	; 0x12
    3ee4:	91 83       	std	Z+1, r25	; 0x01
    3ee6:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3ee8:	8f 85       	ldd	r24, Y+15	; 0x0f
    3eea:	98 89       	ldd	r25, Y+16	; 0x10
    3eec:	00 97       	sbiw	r24, 0x00	; 0
    3eee:	31 f0       	breq	.+12     	; 0x3efc <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3ef0:	ef 85       	ldd	r30, Y+15	; 0x0f
    3ef2:	f8 89       	ldd	r31, Y+16	; 0x10
    3ef4:	89 89       	ldd	r24, Y+17	; 0x11
    3ef6:	9a 89       	ldd	r25, Y+18	; 0x12
    3ef8:	91 83       	std	Z+1, r25	; 0x01
    3efa:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3efc:	64 96       	adiw	r28, 0x14	; 20
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	f8 94       	cli
    3f02:	de bf       	out	0x3e, r29	; 62
    3f04:	0f be       	out	0x3f, r0	; 63
    3f06:	cd bf       	out	0x3d, r28	; 61
    3f08:	cf 91       	pop	r28
    3f0a:	df 91       	pop	r29
    3f0c:	1f 91       	pop	r17
    3f0e:	0f 91       	pop	r16
    3f10:	ef 90       	pop	r14
    3f12:	df 90       	pop	r13
    3f14:	cf 90       	pop	r12
    3f16:	bf 90       	pop	r11
    3f18:	af 90       	pop	r10
    3f1a:	9f 90       	pop	r9
    3f1c:	8f 90       	pop	r8
    3f1e:	08 95       	ret

00003f20 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3f20:	df 93       	push	r29
    3f22:	cf 93       	push	r28
    3f24:	00 d0       	rcall	.+0      	; 0x3f26 <prvAddNewTaskToReadyList+0x6>
    3f26:	cd b7       	in	r28, 0x3d	; 61
    3f28:	de b7       	in	r29, 0x3e	; 62
    3f2a:	9a 83       	std	Y+2, r25	; 0x02
    3f2c:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3f2e:	0f b6       	in	r0, 0x3f	; 63
    3f30:	f8 94       	cli
    3f32:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3f34:	80 91 c3 06 	lds	r24, 0x06C3
    3f38:	8f 5f       	subi	r24, 0xFF	; 255
    3f3a:	80 93 c3 06 	sts	0x06C3, r24
		if( pxCurrentTCB == NULL )
    3f3e:	80 91 c0 06 	lds	r24, 0x06C0
    3f42:	90 91 c1 06 	lds	r25, 0x06C1
    3f46:	00 97       	sbiw	r24, 0x00	; 0
    3f48:	69 f4       	brne	.+26     	; 0x3f64 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3f4a:	89 81       	ldd	r24, Y+1	; 0x01
    3f4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f4e:	90 93 c1 06 	sts	0x06C1, r25
    3f52:	80 93 c0 06 	sts	0x06C0, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3f56:	80 91 c3 06 	lds	r24, 0x06C3
    3f5a:	81 30       	cpi	r24, 0x01	; 1
    3f5c:	b9 f4       	brne	.+46     	; 0x3f8c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3f5e:	0e 94 67 26 	call	0x4cce	; 0x4cce <prvInitialiseTaskLists>
    3f62:	14 c0       	rjmp	.+40     	; 0x3f8c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3f64:	80 91 c7 06 	lds	r24, 0x06C7
    3f68:	88 23       	and	r24, r24
    3f6a:	81 f4       	brne	.+32     	; 0x3f8c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3f6c:	e0 91 c0 06 	lds	r30, 0x06C0
    3f70:	f0 91 c1 06 	lds	r31, 0x06C1
    3f74:	96 89       	ldd	r25, Z+22	; 0x16
    3f76:	e9 81       	ldd	r30, Y+1	; 0x01
    3f78:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7a:	86 89       	ldd	r24, Z+22	; 0x16
    3f7c:	89 17       	cp	r24, r25
    3f7e:	30 f0       	brcs	.+12     	; 0x3f8c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3f80:	89 81       	ldd	r24, Y+1	; 0x01
    3f82:	9a 81       	ldd	r25, Y+2	; 0x02
    3f84:	90 93 c1 06 	sts	0x06C1, r25
    3f88:	80 93 c0 06 	sts	0x06C0, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3f8c:	80 91 cb 06 	lds	r24, 0x06CB
    3f90:	8f 5f       	subi	r24, 0xFF	; 255
    3f92:	80 93 cb 06 	sts	0x06CB, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3f96:	e9 81       	ldd	r30, Y+1	; 0x01
    3f98:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9a:	96 89       	ldd	r25, Z+22	; 0x16
    3f9c:	80 91 c6 06 	lds	r24, 0x06C6
    3fa0:	89 17       	cp	r24, r25
    3fa2:	28 f4       	brcc	.+10     	; 0x3fae <prvAddNewTaskToReadyList+0x8e>
    3fa4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa8:	86 89       	ldd	r24, Z+22	; 0x16
    3faa:	80 93 c6 06 	sts	0x06C6, r24
    3fae:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb2:	86 89       	ldd	r24, Z+22	; 0x16
    3fb4:	28 2f       	mov	r18, r24
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
    3fb8:	c9 01       	movw	r24, r18
    3fba:	88 0f       	add	r24, r24
    3fbc:	99 1f       	adc	r25, r25
    3fbe:	88 0f       	add	r24, r24
    3fc0:	99 1f       	adc	r25, r25
    3fc2:	88 0f       	add	r24, r24
    3fc4:	99 1f       	adc	r25, r25
    3fc6:	82 0f       	add	r24, r18
    3fc8:	93 1f       	adc	r25, r19
    3fca:	ac 01       	movw	r20, r24
    3fcc:	4f 52       	subi	r20, 0x2F	; 47
    3fce:	59 4f       	sbci	r21, 0xF9	; 249
    3fd0:	89 81       	ldd	r24, Y+1	; 0x01
    3fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd4:	9c 01       	movw	r18, r24
    3fd6:	2e 5f       	subi	r18, 0xFE	; 254
    3fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    3fda:	ca 01       	movw	r24, r20
    3fdc:	b9 01       	movw	r22, r18
    3fde:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3fe2:	0f 90       	pop	r0
    3fe4:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3fe6:	80 91 c7 06 	lds	r24, 0x06C7
    3fea:	88 23       	and	r24, r24
    3fec:	61 f0       	breq	.+24     	; 0x4006 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3fee:	e0 91 c0 06 	lds	r30, 0x06C0
    3ff2:	f0 91 c1 06 	lds	r31, 0x06C1
    3ff6:	96 89       	ldd	r25, Z+22	; 0x16
    3ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffc:	86 89       	ldd	r24, Z+22	; 0x16
    3ffe:	98 17       	cp	r25, r24
    4000:	10 f4       	brcc	.+4      	; 0x4006 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4002:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4006:	0f 90       	pop	r0
    4008:	0f 90       	pop	r0
    400a:	cf 91       	pop	r28
    400c:	df 91       	pop	r29
    400e:	08 95       	ret

00004010 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4010:	df 93       	push	r29
    4012:	cf 93       	push	r28
    4014:	00 d0       	rcall	.+0      	; 0x4016 <vTaskDelete+0x6>
    4016:	00 d0       	rcall	.+0      	; 0x4018 <vTaskDelete+0x8>
    4018:	00 d0       	rcall	.+0      	; 0x401a <vTaskDelete+0xa>
    401a:	cd b7       	in	r28, 0x3d	; 61
    401c:	de b7       	in	r29, 0x3e	; 62
    401e:	9c 83       	std	Y+4, r25	; 0x04
    4020:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4022:	0f b6       	in	r0, 0x3f	; 63
    4024:	f8 94       	cli
    4026:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4028:	8b 81       	ldd	r24, Y+3	; 0x03
    402a:	9c 81       	ldd	r25, Y+4	; 0x04
    402c:	00 97       	sbiw	r24, 0x00	; 0
    402e:	39 f4       	brne	.+14     	; 0x403e <vTaskDelete+0x2e>
    4030:	80 91 c0 06 	lds	r24, 0x06C0
    4034:	90 91 c1 06 	lds	r25, 0x06C1
    4038:	9e 83       	std	Y+6, r25	; 0x06
    403a:	8d 83       	std	Y+5, r24	; 0x05
    403c:	04 c0       	rjmp	.+8      	; 0x4046 <vTaskDelete+0x36>
    403e:	8b 81       	ldd	r24, Y+3	; 0x03
    4040:	9c 81       	ldd	r25, Y+4	; 0x04
    4042:	9e 83       	std	Y+6, r25	; 0x06
    4044:	8d 83       	std	Y+5, r24	; 0x05
    4046:	8d 81       	ldd	r24, Y+5	; 0x05
    4048:	9e 81       	ldd	r25, Y+6	; 0x06
    404a:	9a 83       	std	Y+2, r25	; 0x02
    404c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	9a 81       	ldd	r25, Y+2	; 0x02
    4052:	02 96       	adiw	r24, 0x02	; 2
    4054:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4058:	e9 81       	ldd	r30, Y+1	; 0x01
    405a:	fa 81       	ldd	r31, Y+2	; 0x02
    405c:	84 89       	ldd	r24, Z+20	; 0x14
    405e:	95 89       	ldd	r25, Z+21	; 0x15
    4060:	00 97       	sbiw	r24, 0x00	; 0
    4062:	29 f0       	breq	.+10     	; 0x406e <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4064:	89 81       	ldd	r24, Y+1	; 0x01
    4066:	9a 81       	ldd	r25, Y+2	; 0x02
    4068:	0c 96       	adiw	r24, 0x0c	; 12
    406a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    406e:	80 91 cb 06 	lds	r24, 0x06CB
    4072:	8f 5f       	subi	r24, 0xFF	; 255
    4074:	80 93 cb 06 	sts	0x06CB, r24

			if( pxTCB == pxCurrentTCB )
    4078:	20 91 c0 06 	lds	r18, 0x06C0
    407c:	30 91 c1 06 	lds	r19, 0x06C1
    4080:	89 81       	ldd	r24, Y+1	; 0x01
    4082:	9a 81       	ldd	r25, Y+2	; 0x02
    4084:	82 17       	cp	r24, r18
    4086:	93 07       	cpc	r25, r19
    4088:	81 f4       	brne	.+32     	; 0x40aa <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    408a:	89 81       	ldd	r24, Y+1	; 0x01
    408c:	9a 81       	ldd	r25, Y+2	; 0x02
    408e:	9c 01       	movw	r18, r24
    4090:	2e 5f       	subi	r18, 0xFE	; 254
    4092:	3f 4f       	sbci	r19, 0xFF	; 255
    4094:	8f e2       	ldi	r24, 0x2F	; 47
    4096:	97 e0       	ldi	r25, 0x07	; 7
    4098:	b9 01       	movw	r22, r18
    409a:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    409e:	80 91 c2 06 	lds	r24, 0x06C2
    40a2:	8f 5f       	subi	r24, 0xFF	; 255
    40a4:	80 93 c2 06 	sts	0x06C2, r24
    40a8:	0b c0       	rjmp	.+22     	; 0x40c0 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    40aa:	80 91 c3 06 	lds	r24, 0x06C3
    40ae:	81 50       	subi	r24, 0x01	; 1
    40b0:	80 93 c3 06 	sts	0x06C3, r24
				prvDeleteTCB( pxTCB );
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
    40b6:	9a 81       	ldd	r25, Y+2	; 0x02
    40b8:	0e 94 d7 26 	call	0x4dae	; 0x4dae <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    40bc:	0e 94 ed 26 	call	0x4dda	; 0x4dda <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    40c0:	0f 90       	pop	r0
    40c2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    40c4:	80 91 c7 06 	lds	r24, 0x06C7
    40c8:	88 23       	and	r24, r24
    40ca:	59 f0       	breq	.+22     	; 0x40e2 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    40cc:	20 91 c0 06 	lds	r18, 0x06C0
    40d0:	30 91 c1 06 	lds	r19, 0x06C1
    40d4:	89 81       	ldd	r24, Y+1	; 0x01
    40d6:	9a 81       	ldd	r25, Y+2	; 0x02
    40d8:	82 17       	cp	r24, r18
    40da:	93 07       	cpc	r25, r19
    40dc:	11 f4       	brne	.+4      	; 0x40e2 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    40de:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    40e2:	26 96       	adiw	r28, 0x06	; 6
    40e4:	0f b6       	in	r0, 0x3f	; 63
    40e6:	f8 94       	cli
    40e8:	de bf       	out	0x3e, r29	; 62
    40ea:	0f be       	out	0x3f, r0	; 63
    40ec:	cd bf       	out	0x3d, r28	; 61
    40ee:	cf 91       	pop	r28
    40f0:	df 91       	pop	r29
    40f2:	08 95       	ret

000040f4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    40f4:	df 93       	push	r29
    40f6:	cf 93       	push	r28
    40f8:	00 d0       	rcall	.+0      	; 0x40fa <vTaskDelay+0x6>
    40fa:	0f 92       	push	r0
    40fc:	cd b7       	in	r28, 0x3d	; 61
    40fe:	de b7       	in	r29, 0x3e	; 62
    4100:	9b 83       	std	Y+3, r25	; 0x03
    4102:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4104:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4106:	8a 81       	ldd	r24, Y+2	; 0x02
    4108:	9b 81       	ldd	r25, Y+3	; 0x03
    410a:	00 97       	sbiw	r24, 0x00	; 0
    410c:	51 f0       	breq	.+20     	; 0x4122 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    410e:	0e 94 47 22 	call	0x448e	; 0x448e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4112:	8a 81       	ldd	r24, Y+2	; 0x02
    4114:	9b 81       	ldd	r25, Y+3	; 0x03
    4116:	60 e0       	ldi	r22, 0x00	; 0
    4118:	0e 94 b6 2c 	call	0x596c	; 0x596c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    411c:	0e 94 53 22 	call	0x44a6	; 0x44a6 <xTaskResumeAll>
    4120:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4122:	89 81       	ldd	r24, Y+1	; 0x01
    4124:	88 23       	and	r24, r24
    4126:	11 f4       	brne	.+4      	; 0x412c <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    4128:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    412c:	0f 90       	pop	r0
    412e:	0f 90       	pop	r0
    4130:	0f 90       	pop	r0
    4132:	cf 91       	pop	r28
    4134:	df 91       	pop	r29
    4136:	08 95       	ret

00004138 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    4138:	df 93       	push	r29
    413a:	cf 93       	push	r28
    413c:	00 d0       	rcall	.+0      	; 0x413e <vTaskSuspend+0x6>
    413e:	00 d0       	rcall	.+0      	; 0x4140 <vTaskSuspend+0x8>
    4140:	00 d0       	rcall	.+0      	; 0x4142 <vTaskSuspend+0xa>
    4142:	cd b7       	in	r28, 0x3d	; 61
    4144:	de b7       	in	r29, 0x3e	; 62
    4146:	9c 83       	std	Y+4, r25	; 0x04
    4148:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    414a:	0f b6       	in	r0, 0x3f	; 63
    414c:	f8 94       	cli
    414e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    4150:	8b 81       	ldd	r24, Y+3	; 0x03
    4152:	9c 81       	ldd	r25, Y+4	; 0x04
    4154:	00 97       	sbiw	r24, 0x00	; 0
    4156:	39 f4       	brne	.+14     	; 0x4166 <vTaskSuspend+0x2e>
    4158:	80 91 c0 06 	lds	r24, 0x06C0
    415c:	90 91 c1 06 	lds	r25, 0x06C1
    4160:	9e 83       	std	Y+6, r25	; 0x06
    4162:	8d 83       	std	Y+5, r24	; 0x05
    4164:	04 c0       	rjmp	.+8      	; 0x416e <vTaskSuspend+0x36>
    4166:	8b 81       	ldd	r24, Y+3	; 0x03
    4168:	9c 81       	ldd	r25, Y+4	; 0x04
    416a:	9e 83       	std	Y+6, r25	; 0x06
    416c:	8d 83       	std	Y+5, r24	; 0x05
    416e:	8d 81       	ldd	r24, Y+5	; 0x05
    4170:	9e 81       	ldd	r25, Y+6	; 0x06
    4172:	9a 83       	std	Y+2, r25	; 0x02
    4174:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4176:	89 81       	ldd	r24, Y+1	; 0x01
    4178:	9a 81       	ldd	r25, Y+2	; 0x02
    417a:	02 96       	adiw	r24, 0x02	; 2
    417c:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4180:	e9 81       	ldd	r30, Y+1	; 0x01
    4182:	fa 81       	ldd	r31, Y+2	; 0x02
    4184:	84 89       	ldd	r24, Z+20	; 0x14
    4186:	95 89       	ldd	r25, Z+21	; 0x15
    4188:	00 97       	sbiw	r24, 0x00	; 0
    418a:	29 f0       	breq	.+10     	; 0x4196 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    418c:	89 81       	ldd	r24, Y+1	; 0x01
    418e:	9a 81       	ldd	r25, Y+2	; 0x02
    4190:	0c 96       	adiw	r24, 0x0c	; 12
    4192:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4196:	89 81       	ldd	r24, Y+1	; 0x01
    4198:	9a 81       	ldd	r25, Y+2	; 0x02
    419a:	9c 01       	movw	r18, r24
    419c:	2e 5f       	subi	r18, 0xFE	; 254
    419e:	3f 4f       	sbci	r19, 0xFF	; 255
    41a0:	88 e3       	ldi	r24, 0x38	; 56
    41a2:	97 e0       	ldi	r25, 0x07	; 7
    41a4:	b9 01       	movw	r22, r18
    41a6:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    41aa:	e9 81       	ldd	r30, Y+1	; 0x01
    41ac:	fa 81       	ldd	r31, Y+2	; 0x02
    41ae:	83 a9       	ldd	r24, Z+51	; 0x33
    41b0:	81 30       	cpi	r24, 0x01	; 1
    41b2:	19 f4       	brne	.+6      	; 0x41ba <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    41b4:	e9 81       	ldd	r30, Y+1	; 0x01
    41b6:	fa 81       	ldd	r31, Y+2	; 0x02
    41b8:	13 aa       	std	Z+51, r1	; 0x33
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    41ba:	0f 90       	pop	r0
    41bc:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    41be:	80 91 c7 06 	lds	r24, 0x06C7
    41c2:	88 23       	and	r24, r24
    41c4:	39 f0       	breq	.+14     	; 0x41d4 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    41c6:	0f b6       	in	r0, 0x3f	; 63
    41c8:	f8 94       	cli
    41ca:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    41cc:	0e 94 ed 26 	call	0x4dda	; 0x4dda <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    41d0:	0f 90       	pop	r0
    41d2:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    41d4:	20 91 c0 06 	lds	r18, 0x06C0
    41d8:	30 91 c1 06 	lds	r19, 0x06C1
    41dc:	89 81       	ldd	r24, Y+1	; 0x01
    41de:	9a 81       	ldd	r25, Y+2	; 0x02
    41e0:	82 17       	cp	r24, r18
    41e2:	93 07       	cpc	r25, r19
    41e4:	a1 f4       	brne	.+40     	; 0x420e <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    41e6:	80 91 c7 06 	lds	r24, 0x06C7
    41ea:	88 23       	and	r24, r24
    41ec:	19 f0       	breq	.+6      	; 0x41f4 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    41ee:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
    41f2:	0d c0       	rjmp	.+26     	; 0x420e <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    41f4:	90 91 38 07 	lds	r25, 0x0738
    41f8:	80 91 c3 06 	lds	r24, 0x06C3
    41fc:	98 17       	cp	r25, r24
    41fe:	29 f4       	brne	.+10     	; 0x420a <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4200:	10 92 c1 06 	sts	0x06C1, r1
    4204:	10 92 c0 06 	sts	0x06C0, r1
    4208:	02 c0       	rjmp	.+4      	; 0x420e <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    420a:	0e 94 28 24 	call	0x4850	; 0x4850 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    420e:	26 96       	adiw	r28, 0x06	; 6
    4210:	0f b6       	in	r0, 0x3f	; 63
    4212:	f8 94       	cli
    4214:	de bf       	out	0x3e, r29	; 62
    4216:	0f be       	out	0x3f, r0	; 63
    4218:	cd bf       	out	0x3d, r28	; 61
    421a:	cf 91       	pop	r28
    421c:	df 91       	pop	r29
    421e:	08 95       	ret

00004220 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    4220:	df 93       	push	r29
    4222:	cf 93       	push	r28
    4224:	00 d0       	rcall	.+0      	; 0x4226 <prvTaskIsTaskSuspended+0x6>
    4226:	00 d0       	rcall	.+0      	; 0x4228 <prvTaskIsTaskSuspended+0x8>
    4228:	0f 92       	push	r0
    422a:	cd b7       	in	r28, 0x3d	; 61
    422c:	de b7       	in	r29, 0x3e	; 62
    422e:	9d 83       	std	Y+5, r25	; 0x05
    4230:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    4232:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    4234:	8c 81       	ldd	r24, Y+4	; 0x04
    4236:	9d 81       	ldd	r25, Y+5	; 0x05
    4238:	9a 83       	std	Y+2, r25	; 0x02
    423a:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    423c:	e9 81       	ldd	r30, Y+1	; 0x01
    423e:	fa 81       	ldd	r31, Y+2	; 0x02
    4240:	82 85       	ldd	r24, Z+10	; 0x0a
    4242:	93 85       	ldd	r25, Z+11	; 0x0b
    4244:	27 e0       	ldi	r18, 0x07	; 7
    4246:	88 33       	cpi	r24, 0x38	; 56
    4248:	92 07       	cpc	r25, r18
    424a:	81 f4       	brne	.+32     	; 0x426c <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    424c:	e9 81       	ldd	r30, Y+1	; 0x01
    424e:	fa 81       	ldd	r31, Y+2	; 0x02
    4250:	84 89       	ldd	r24, Z+20	; 0x14
    4252:	95 89       	ldd	r25, Z+21	; 0x15
    4254:	27 e0       	ldi	r18, 0x07	; 7
    4256:	86 32       	cpi	r24, 0x26	; 38
    4258:	92 07       	cpc	r25, r18
    425a:	41 f0       	breq	.+16     	; 0x426c <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    425c:	e9 81       	ldd	r30, Y+1	; 0x01
    425e:	fa 81       	ldd	r31, Y+2	; 0x02
    4260:	84 89       	ldd	r24, Z+20	; 0x14
    4262:	95 89       	ldd	r25, Z+21	; 0x15
    4264:	00 97       	sbiw	r24, 0x00	; 0
    4266:	11 f4       	brne	.+4      	; 0x426c <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4268:	81 e0       	ldi	r24, 0x01	; 1
    426a:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    426c:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    426e:	0f 90       	pop	r0
    4270:	0f 90       	pop	r0
    4272:	0f 90       	pop	r0
    4274:	0f 90       	pop	r0
    4276:	0f 90       	pop	r0
    4278:	cf 91       	pop	r28
    427a:	df 91       	pop	r29
    427c:	08 95       	ret

0000427e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    427e:	df 93       	push	r29
    4280:	cf 93       	push	r28
    4282:	00 d0       	rcall	.+0      	; 0x4284 <vTaskResume+0x6>
    4284:	00 d0       	rcall	.+0      	; 0x4286 <vTaskResume+0x8>
    4286:	cd b7       	in	r28, 0x3d	; 61
    4288:	de b7       	in	r29, 0x3e	; 62
    428a:	9c 83       	std	Y+4, r25	; 0x04
    428c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    428e:	8b 81       	ldd	r24, Y+3	; 0x03
    4290:	9c 81       	ldd	r25, Y+4	; 0x04
    4292:	9a 83       	std	Y+2, r25	; 0x02
    4294:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4296:	20 91 c0 06 	lds	r18, 0x06C0
    429a:	30 91 c1 06 	lds	r19, 0x06C1
    429e:	89 81       	ldd	r24, Y+1	; 0x01
    42a0:	9a 81       	ldd	r25, Y+2	; 0x02
    42a2:	82 17       	cp	r24, r18
    42a4:	93 07       	cpc	r25, r19
    42a6:	09 f4       	brne	.+2      	; 0x42aa <vTaskResume+0x2c>
    42a8:	47 c0       	rjmp	.+142    	; 0x4338 <vTaskResume+0xba>
    42aa:	89 81       	ldd	r24, Y+1	; 0x01
    42ac:	9a 81       	ldd	r25, Y+2	; 0x02
    42ae:	00 97       	sbiw	r24, 0x00	; 0
    42b0:	09 f4       	brne	.+2      	; 0x42b4 <vTaskResume+0x36>
    42b2:	42 c0       	rjmp	.+132    	; 0x4338 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    42b4:	0f b6       	in	r0, 0x3f	; 63
    42b6:	f8 94       	cli
    42b8:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    42ba:	89 81       	ldd	r24, Y+1	; 0x01
    42bc:	9a 81       	ldd	r25, Y+2	; 0x02
    42be:	0e 94 10 21 	call	0x4220	; 0x4220 <prvTaskIsTaskSuspended>
    42c2:	88 23       	and	r24, r24
    42c4:	b9 f1       	breq	.+110    	; 0x4334 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    42c6:	89 81       	ldd	r24, Y+1	; 0x01
    42c8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ca:	02 96       	adiw	r24, 0x02	; 2
    42cc:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    42d0:	e9 81       	ldd	r30, Y+1	; 0x01
    42d2:	fa 81       	ldd	r31, Y+2	; 0x02
    42d4:	96 89       	ldd	r25, Z+22	; 0x16
    42d6:	80 91 c6 06 	lds	r24, 0x06C6
    42da:	89 17       	cp	r24, r25
    42dc:	28 f4       	brcc	.+10     	; 0x42e8 <vTaskResume+0x6a>
    42de:	e9 81       	ldd	r30, Y+1	; 0x01
    42e0:	fa 81       	ldd	r31, Y+2	; 0x02
    42e2:	86 89       	ldd	r24, Z+22	; 0x16
    42e4:	80 93 c6 06 	sts	0x06C6, r24
    42e8:	e9 81       	ldd	r30, Y+1	; 0x01
    42ea:	fa 81       	ldd	r31, Y+2	; 0x02
    42ec:	86 89       	ldd	r24, Z+22	; 0x16
    42ee:	28 2f       	mov	r18, r24
    42f0:	30 e0       	ldi	r19, 0x00	; 0
    42f2:	c9 01       	movw	r24, r18
    42f4:	88 0f       	add	r24, r24
    42f6:	99 1f       	adc	r25, r25
    42f8:	88 0f       	add	r24, r24
    42fa:	99 1f       	adc	r25, r25
    42fc:	88 0f       	add	r24, r24
    42fe:	99 1f       	adc	r25, r25
    4300:	82 0f       	add	r24, r18
    4302:	93 1f       	adc	r25, r19
    4304:	ac 01       	movw	r20, r24
    4306:	4f 52       	subi	r20, 0x2F	; 47
    4308:	59 4f       	sbci	r21, 0xF9	; 249
    430a:	89 81       	ldd	r24, Y+1	; 0x01
    430c:	9a 81       	ldd	r25, Y+2	; 0x02
    430e:	9c 01       	movw	r18, r24
    4310:	2e 5f       	subi	r18, 0xFE	; 254
    4312:	3f 4f       	sbci	r19, 0xFF	; 255
    4314:	ca 01       	movw	r24, r20
    4316:	b9 01       	movw	r22, r18
    4318:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    431c:	e9 81       	ldd	r30, Y+1	; 0x01
    431e:	fa 81       	ldd	r31, Y+2	; 0x02
    4320:	96 89       	ldd	r25, Z+22	; 0x16
    4322:	e0 91 c0 06 	lds	r30, 0x06C0
    4326:	f0 91 c1 06 	lds	r31, 0x06C1
    432a:	86 89       	ldd	r24, Z+22	; 0x16
    432c:	98 17       	cp	r25, r24
    432e:	10 f0       	brcs	.+4      	; 0x4334 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4330:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4334:	0f 90       	pop	r0
    4336:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4338:	0f 90       	pop	r0
    433a:	0f 90       	pop	r0
    433c:	0f 90       	pop	r0
    433e:	0f 90       	pop	r0
    4340:	cf 91       	pop	r28
    4342:	df 91       	pop	r29
    4344:	08 95       	ret

00004346 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    4346:	df 93       	push	r29
    4348:	cf 93       	push	r28
    434a:	00 d0       	rcall	.+0      	; 0x434c <xTaskResumeFromISR+0x6>
    434c:	00 d0       	rcall	.+0      	; 0x434e <xTaskResumeFromISR+0x8>
    434e:	00 d0       	rcall	.+0      	; 0x4350 <xTaskResumeFromISR+0xa>
    4350:	cd b7       	in	r28, 0x3d	; 61
    4352:	de b7       	in	r29, 0x3e	; 62
    4354:	9e 83       	std	Y+6, r25	; 0x06
    4356:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4358:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    435a:	8d 81       	ldd	r24, Y+5	; 0x05
    435c:	9e 81       	ldd	r25, Y+6	; 0x06
    435e:	9b 83       	std	Y+3, r25	; 0x03
    4360:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4362:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4364:	8a 81       	ldd	r24, Y+2	; 0x02
    4366:	9b 81       	ldd	r25, Y+3	; 0x03
    4368:	0e 94 10 21 	call	0x4220	; 0x4220 <prvTaskIsTaskSuspended>
    436c:	88 23       	and	r24, r24
    436e:	09 f4       	brne	.+2      	; 0x4372 <xTaskResumeFromISR+0x2c>
    4370:	46 c0       	rjmp	.+140    	; 0x43fe <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4372:	80 91 d0 06 	lds	r24, 0x06D0
    4376:	88 23       	and	r24, r24
    4378:	c1 f5       	brne	.+112    	; 0x43ea <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    437a:	ea 81       	ldd	r30, Y+2	; 0x02
    437c:	fb 81       	ldd	r31, Y+3	; 0x03
    437e:	96 89       	ldd	r25, Z+22	; 0x16
    4380:	e0 91 c0 06 	lds	r30, 0x06C0
    4384:	f0 91 c1 06 	lds	r31, 0x06C1
    4388:	86 89       	ldd	r24, Z+22	; 0x16
    438a:	98 17       	cp	r25, r24
    438c:	10 f0       	brcs	.+4      	; 0x4392 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    438e:	81 e0       	ldi	r24, 0x01	; 1
    4390:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4392:	8a 81       	ldd	r24, Y+2	; 0x02
    4394:	9b 81       	ldd	r25, Y+3	; 0x03
    4396:	02 96       	adiw	r24, 0x02	; 2
    4398:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    439c:	ea 81       	ldd	r30, Y+2	; 0x02
    439e:	fb 81       	ldd	r31, Y+3	; 0x03
    43a0:	96 89       	ldd	r25, Z+22	; 0x16
    43a2:	80 91 c6 06 	lds	r24, 0x06C6
    43a6:	89 17       	cp	r24, r25
    43a8:	28 f4       	brcc	.+10     	; 0x43b4 <xTaskResumeFromISR+0x6e>
    43aa:	ea 81       	ldd	r30, Y+2	; 0x02
    43ac:	fb 81       	ldd	r31, Y+3	; 0x03
    43ae:	86 89       	ldd	r24, Z+22	; 0x16
    43b0:	80 93 c6 06 	sts	0x06C6, r24
    43b4:	ea 81       	ldd	r30, Y+2	; 0x02
    43b6:	fb 81       	ldd	r31, Y+3	; 0x03
    43b8:	86 89       	ldd	r24, Z+22	; 0x16
    43ba:	28 2f       	mov	r18, r24
    43bc:	30 e0       	ldi	r19, 0x00	; 0
    43be:	c9 01       	movw	r24, r18
    43c0:	88 0f       	add	r24, r24
    43c2:	99 1f       	adc	r25, r25
    43c4:	88 0f       	add	r24, r24
    43c6:	99 1f       	adc	r25, r25
    43c8:	88 0f       	add	r24, r24
    43ca:	99 1f       	adc	r25, r25
    43cc:	82 0f       	add	r24, r18
    43ce:	93 1f       	adc	r25, r19
    43d0:	ac 01       	movw	r20, r24
    43d2:	4f 52       	subi	r20, 0x2F	; 47
    43d4:	59 4f       	sbci	r21, 0xF9	; 249
    43d6:	8a 81       	ldd	r24, Y+2	; 0x02
    43d8:	9b 81       	ldd	r25, Y+3	; 0x03
    43da:	9c 01       	movw	r18, r24
    43dc:	2e 5f       	subi	r18, 0xFE	; 254
    43de:	3f 4f       	sbci	r19, 0xFF	; 255
    43e0:	ca 01       	movw	r24, r20
    43e2:	b9 01       	movw	r22, r18
    43e4:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    43e8:	0a c0       	rjmp	.+20     	; 0x43fe <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    43ea:	8a 81       	ldd	r24, Y+2	; 0x02
    43ec:	9b 81       	ldd	r25, Y+3	; 0x03
    43ee:	9c 01       	movw	r18, r24
    43f0:	24 5f       	subi	r18, 0xF4	; 244
    43f2:	3f 4f       	sbci	r19, 0xFF	; 255
    43f4:	86 e2       	ldi	r24, 0x26	; 38
    43f6:	97 e0       	ldi	r25, 0x07	; 7
    43f8:	b9 01       	movw	r22, r18
    43fa:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    43fe:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4400:	26 96       	adiw	r28, 0x06	; 6
    4402:	0f b6       	in	r0, 0x3f	; 63
    4404:	f8 94       	cli
    4406:	de bf       	out	0x3e, r29	; 62
    4408:	0f be       	out	0x3f, r0	; 63
    440a:	cd bf       	out	0x3d, r28	; 61
    440c:	cf 91       	pop	r28
    440e:	df 91       	pop	r29
    4410:	08 95       	ret

00004412 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4412:	ef 92       	push	r14
    4414:	ff 92       	push	r15
    4416:	0f 93       	push	r16
    4418:	df 93       	push	r29
    441a:	cf 93       	push	r28
    441c:	0f 92       	push	r0
    441e:	cd b7       	in	r28, 0x3d	; 61
    4420:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4422:	8d e5       	ldi	r24, 0x5D	; 93
    4424:	96 e2       	ldi	r25, 0x26	; 38
    4426:	23 ed       	ldi	r18, 0xD3	; 211
    4428:	30 e0       	ldi	r19, 0x00	; 0
    442a:	ee ec       	ldi	r30, 0xCE	; 206
    442c:	f6 e0       	ldi	r31, 0x06	; 6
    442e:	b9 01       	movw	r22, r18
    4430:	46 e9       	ldi	r20, 0x96	; 150
    4432:	50 e0       	ldi	r21, 0x00	; 0
    4434:	20 e0       	ldi	r18, 0x00	; 0
    4436:	30 e0       	ldi	r19, 0x00	; 0
    4438:	00 e0       	ldi	r16, 0x00	; 0
    443a:	7f 01       	movw	r14, r30
    443c:	0e 94 55 1e 	call	0x3caa	; 0x3caa <xTaskCreate>
    4440:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4442:	89 81       	ldd	r24, Y+1	; 0x01
    4444:	81 30       	cpi	r24, 0x01	; 1
    4446:	81 f4       	brne	.+32     	; 0x4468 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4448:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    444a:	8f ef       	ldi	r24, 0xFF	; 255
    444c:	9f ef       	ldi	r25, 0xFF	; 255
    444e:	90 93 cd 06 	sts	0x06CD, r25
    4452:	80 93 cc 06 	sts	0x06CC, r24
		xSchedulerRunning = pdTRUE;
    4456:	81 e0       	ldi	r24, 0x01	; 1
    4458:	80 93 c7 06 	sts	0x06C7, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    445c:	10 92 c5 06 	sts	0x06C5, r1
    4460:	10 92 c4 06 	sts	0x06C4, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4464:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4468:	0f 90       	pop	r0
    446a:	cf 91       	pop	r28
    446c:	df 91       	pop	r29
    446e:	0f 91       	pop	r16
    4470:	ff 90       	pop	r15
    4472:	ef 90       	pop	r14
    4474:	08 95       	ret

00004476 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4476:	df 93       	push	r29
    4478:	cf 93       	push	r28
    447a:	cd b7       	in	r28, 0x3d	; 61
    447c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    447e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4480:	10 92 c7 06 	sts	0x06C7, r1
	vPortEndScheduler();
    4484:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <vPortEndScheduler>
}
    4488:	cf 91       	pop	r28
    448a:	df 91       	pop	r29
    448c:	08 95       	ret

0000448e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    448e:	df 93       	push	r29
    4490:	cf 93       	push	r28
    4492:	cd b7       	in	r28, 0x3d	; 61
    4494:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4496:	80 91 d0 06 	lds	r24, 0x06D0
    449a:	8f 5f       	subi	r24, 0xFF	; 255
    449c:	80 93 d0 06 	sts	0x06D0, r24
}
    44a0:	cf 91       	pop	r28
    44a2:	df 91       	pop	r29
    44a4:	08 95       	ret

000044a6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    44a6:	df 93       	push	r29
    44a8:	cf 93       	push	r28
    44aa:	00 d0       	rcall	.+0      	; 0x44ac <xTaskResumeAll+0x6>
    44ac:	00 d0       	rcall	.+0      	; 0x44ae <xTaskResumeAll+0x8>
    44ae:	cd b7       	in	r28, 0x3d	; 61
    44b0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    44b2:	1c 82       	std	Y+4, r1	; 0x04
    44b4:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    44b6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    44b8:	0f b6       	in	r0, 0x3f	; 63
    44ba:	f8 94       	cli
    44bc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    44be:	80 91 d0 06 	lds	r24, 0x06D0
    44c2:	81 50       	subi	r24, 0x01	; 1
    44c4:	80 93 d0 06 	sts	0x06D0, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    44c8:	80 91 d0 06 	lds	r24, 0x06D0
    44cc:	88 23       	and	r24, r24
    44ce:	09 f0       	breq	.+2      	; 0x44d2 <xTaskResumeAll+0x2c>
    44d0:	73 c0       	rjmp	.+230    	; 0x45b8 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    44d2:	80 91 c3 06 	lds	r24, 0x06C3
    44d6:	88 23       	and	r24, r24
    44d8:	09 f4       	brne	.+2      	; 0x44dc <xTaskResumeAll+0x36>
    44da:	6e c0       	rjmp	.+220    	; 0x45b8 <xTaskResumeAll+0x112>
    44dc:	45 c0       	rjmp	.+138    	; 0x4568 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44de:	e0 91 2b 07 	lds	r30, 0x072B
    44e2:	f0 91 2c 07 	lds	r31, 0x072C
    44e6:	86 81       	ldd	r24, Z+6	; 0x06
    44e8:	97 81       	ldd	r25, Z+7	; 0x07
    44ea:	9c 83       	std	Y+4, r25	; 0x04
    44ec:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44ee:	8b 81       	ldd	r24, Y+3	; 0x03
    44f0:	9c 81       	ldd	r25, Y+4	; 0x04
    44f2:	0c 96       	adiw	r24, 0x0c	; 12
    44f4:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44f8:	8b 81       	ldd	r24, Y+3	; 0x03
    44fa:	9c 81       	ldd	r25, Y+4	; 0x04
    44fc:	02 96       	adiw	r24, 0x02	; 2
    44fe:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4502:	eb 81       	ldd	r30, Y+3	; 0x03
    4504:	fc 81       	ldd	r31, Y+4	; 0x04
    4506:	96 89       	ldd	r25, Z+22	; 0x16
    4508:	80 91 c6 06 	lds	r24, 0x06C6
    450c:	89 17       	cp	r24, r25
    450e:	28 f4       	brcc	.+10     	; 0x451a <xTaskResumeAll+0x74>
    4510:	eb 81       	ldd	r30, Y+3	; 0x03
    4512:	fc 81       	ldd	r31, Y+4	; 0x04
    4514:	86 89       	ldd	r24, Z+22	; 0x16
    4516:	80 93 c6 06 	sts	0x06C6, r24
    451a:	eb 81       	ldd	r30, Y+3	; 0x03
    451c:	fc 81       	ldd	r31, Y+4	; 0x04
    451e:	86 89       	ldd	r24, Z+22	; 0x16
    4520:	28 2f       	mov	r18, r24
    4522:	30 e0       	ldi	r19, 0x00	; 0
    4524:	c9 01       	movw	r24, r18
    4526:	88 0f       	add	r24, r24
    4528:	99 1f       	adc	r25, r25
    452a:	88 0f       	add	r24, r24
    452c:	99 1f       	adc	r25, r25
    452e:	88 0f       	add	r24, r24
    4530:	99 1f       	adc	r25, r25
    4532:	82 0f       	add	r24, r18
    4534:	93 1f       	adc	r25, r19
    4536:	ac 01       	movw	r20, r24
    4538:	4f 52       	subi	r20, 0x2F	; 47
    453a:	59 4f       	sbci	r21, 0xF9	; 249
    453c:	8b 81       	ldd	r24, Y+3	; 0x03
    453e:	9c 81       	ldd	r25, Y+4	; 0x04
    4540:	9c 01       	movw	r18, r24
    4542:	2e 5f       	subi	r18, 0xFE	; 254
    4544:	3f 4f       	sbci	r19, 0xFF	; 255
    4546:	ca 01       	movw	r24, r20
    4548:	b9 01       	movw	r22, r18
    454a:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    454e:	eb 81       	ldd	r30, Y+3	; 0x03
    4550:	fc 81       	ldd	r31, Y+4	; 0x04
    4552:	96 89       	ldd	r25, Z+22	; 0x16
    4554:	e0 91 c0 06 	lds	r30, 0x06C0
    4558:	f0 91 c1 06 	lds	r31, 0x06C1
    455c:	86 89       	ldd	r24, Z+22	; 0x16
    455e:	98 17       	cp	r25, r24
    4560:	18 f0       	brcs	.+6      	; 0x4568 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    4562:	81 e0       	ldi	r24, 0x01	; 1
    4564:	80 93 c9 06 	sts	0x06C9, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4568:	80 91 26 07 	lds	r24, 0x0726
    456c:	88 23       	and	r24, r24
    456e:	09 f0       	breq	.+2      	; 0x4572 <xTaskResumeAll+0xcc>
    4570:	b6 cf       	rjmp	.-148    	; 0x44de <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4572:	8b 81       	ldd	r24, Y+3	; 0x03
    4574:	9c 81       	ldd	r25, Y+4	; 0x04
    4576:	00 97       	sbiw	r24, 0x00	; 0
    4578:	11 f0       	breq	.+4      	; 0x457e <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    457a:	0e 94 ed 26 	call	0x4dda	; 0x4dda <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    457e:	80 91 c8 06 	lds	r24, 0x06C8
    4582:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4584:	89 81       	ldd	r24, Y+1	; 0x01
    4586:	88 23       	and	r24, r24
    4588:	79 f0       	breq	.+30     	; 0x45a8 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    458a:	0e 94 43 23 	call	0x4686	; 0x4686 <xTaskIncrementTick>
    458e:	88 23       	and	r24, r24
    4590:	19 f0       	breq	.+6      	; 0x4598 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4592:	81 e0       	ldi	r24, 0x01	; 1
    4594:	80 93 c9 06 	sts	0x06C9, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4598:	89 81       	ldd	r24, Y+1	; 0x01
    459a:	81 50       	subi	r24, 0x01	; 1
    459c:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    459e:	89 81       	ldd	r24, Y+1	; 0x01
    45a0:	88 23       	and	r24, r24
    45a2:	99 f7       	brne	.-26     	; 0x458a <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    45a4:	10 92 c8 06 	sts	0x06C8, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    45a8:	80 91 c9 06 	lds	r24, 0x06C9
    45ac:	88 23       	and	r24, r24
    45ae:	21 f0       	breq	.+8      	; 0x45b8 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    45b0:	81 e0       	ldi	r24, 0x01	; 1
    45b2:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    45b4:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    45b8:	0f 90       	pop	r0
    45ba:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    45bc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    45be:	0f 90       	pop	r0
    45c0:	0f 90       	pop	r0
    45c2:	0f 90       	pop	r0
    45c4:	0f 90       	pop	r0
    45c6:	cf 91       	pop	r28
    45c8:	df 91       	pop	r29
    45ca:	08 95       	ret

000045cc <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    45cc:	df 93       	push	r29
    45ce:	cf 93       	push	r28
    45d0:	00 d0       	rcall	.+0      	; 0x45d2 <xTaskGetTickCount+0x6>
    45d2:	cd b7       	in	r28, 0x3d	; 61
    45d4:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    45d6:	0f b6       	in	r0, 0x3f	; 63
    45d8:	f8 94       	cli
    45da:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    45dc:	80 91 c4 06 	lds	r24, 0x06C4
    45e0:	90 91 c5 06 	lds	r25, 0x06C5
    45e4:	9a 83       	std	Y+2, r25	; 0x02
    45e6:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    45e8:	0f 90       	pop	r0
    45ea:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    45ec:	89 81       	ldd	r24, Y+1	; 0x01
    45ee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    45f0:	0f 90       	pop	r0
    45f2:	0f 90       	pop	r0
    45f4:	cf 91       	pop	r28
    45f6:	df 91       	pop	r29
    45f8:	08 95       	ret

000045fa <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    45fa:	df 93       	push	r29
    45fc:	cf 93       	push	r28
    45fe:	00 d0       	rcall	.+0      	; 0x4600 <xTaskGetTickCountFromISR+0x6>
    4600:	0f 92       	push	r0
    4602:	cd b7       	in	r28, 0x3d	; 61
    4604:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4606:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4608:	80 91 c4 06 	lds	r24, 0x06C4
    460c:	90 91 c5 06 	lds	r25, 0x06C5
    4610:	9b 83       	std	Y+3, r25	; 0x03
    4612:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4614:	8a 81       	ldd	r24, Y+2	; 0x02
    4616:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4618:	0f 90       	pop	r0
    461a:	0f 90       	pop	r0
    461c:	0f 90       	pop	r0
    461e:	cf 91       	pop	r28
    4620:	df 91       	pop	r29
    4622:	08 95       	ret

00004624 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4624:	df 93       	push	r29
    4626:	cf 93       	push	r28
    4628:	cd b7       	in	r28, 0x3d	; 61
    462a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    462c:	80 91 c3 06 	lds	r24, 0x06C3
}
    4630:	cf 91       	pop	r28
    4632:	df 91       	pop	r29
    4634:	08 95       	ret

00004636 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4636:	df 93       	push	r29
    4638:	cf 93       	push	r28
    463a:	00 d0       	rcall	.+0      	; 0x463c <pcTaskGetName+0x6>
    463c:	00 d0       	rcall	.+0      	; 0x463e <pcTaskGetName+0x8>
    463e:	00 d0       	rcall	.+0      	; 0x4640 <pcTaskGetName+0xa>
    4640:	cd b7       	in	r28, 0x3d	; 61
    4642:	de b7       	in	r29, 0x3e	; 62
    4644:	9c 83       	std	Y+4, r25	; 0x04
    4646:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4648:	8b 81       	ldd	r24, Y+3	; 0x03
    464a:	9c 81       	ldd	r25, Y+4	; 0x04
    464c:	00 97       	sbiw	r24, 0x00	; 0
    464e:	39 f4       	brne	.+14     	; 0x465e <pcTaskGetName+0x28>
    4650:	80 91 c0 06 	lds	r24, 0x06C0
    4654:	90 91 c1 06 	lds	r25, 0x06C1
    4658:	9e 83       	std	Y+6, r25	; 0x06
    465a:	8d 83       	std	Y+5, r24	; 0x05
    465c:	04 c0       	rjmp	.+8      	; 0x4666 <pcTaskGetName+0x30>
    465e:	8b 81       	ldd	r24, Y+3	; 0x03
    4660:	9c 81       	ldd	r25, Y+4	; 0x04
    4662:	9e 83       	std	Y+6, r25	; 0x06
    4664:	8d 83       	std	Y+5, r24	; 0x05
    4666:	8d 81       	ldd	r24, Y+5	; 0x05
    4668:	9e 81       	ldd	r25, Y+6	; 0x06
    466a:	9a 83       	std	Y+2, r25	; 0x02
    466c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    466e:	89 81       	ldd	r24, Y+1	; 0x01
    4670:	9a 81       	ldd	r25, Y+2	; 0x02
    4672:	49 96       	adiw	r24, 0x19	; 25
}
    4674:	26 96       	adiw	r28, 0x06	; 6
    4676:	0f b6       	in	r0, 0x3f	; 63
    4678:	f8 94       	cli
    467a:	de bf       	out	0x3e, r29	; 62
    467c:	0f be       	out	0x3f, r0	; 63
    467e:	cd bf       	out	0x3d, r28	; 61
    4680:	cf 91       	pop	r28
    4682:	df 91       	pop	r29
    4684:	08 95       	ret

00004686 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4686:	df 93       	push	r29
    4688:	cf 93       	push	r28
    468a:	cd b7       	in	r28, 0x3d	; 61
    468c:	de b7       	in	r29, 0x3e	; 62
    468e:	29 97       	sbiw	r28, 0x09	; 9
    4690:	0f b6       	in	r0, 0x3f	; 63
    4692:	f8 94       	cli
    4694:	de bf       	out	0x3e, r29	; 62
    4696:	0f be       	out	0x3f, r0	; 63
    4698:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    469a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    469c:	80 91 d0 06 	lds	r24, 0x06D0
    46a0:	88 23       	and	r24, r24
    46a2:	09 f0       	breq	.+2      	; 0x46a6 <xTaskIncrementTick+0x20>
    46a4:	c0 c0       	rjmp	.+384    	; 0x4826 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    46a6:	80 91 c4 06 	lds	r24, 0x06C4
    46aa:	90 91 c5 06 	lds	r25, 0x06C5
    46ae:	01 96       	adiw	r24, 0x01	; 1
    46b0:	9c 83       	std	Y+4, r25	; 0x04
    46b2:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    46b4:	8b 81       	ldd	r24, Y+3	; 0x03
    46b6:	9c 81       	ldd	r25, Y+4	; 0x04
    46b8:	90 93 c5 06 	sts	0x06C5, r25
    46bc:	80 93 c4 06 	sts	0x06C4, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    46c0:	8b 81       	ldd	r24, Y+3	; 0x03
    46c2:	9c 81       	ldd	r25, Y+4	; 0x04
    46c4:	00 97       	sbiw	r24, 0x00	; 0
    46c6:	d9 f4       	brne	.+54     	; 0x46fe <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    46c8:	80 91 22 07 	lds	r24, 0x0722
    46cc:	90 91 23 07 	lds	r25, 0x0723
    46d0:	9a 83       	std	Y+2, r25	; 0x02
    46d2:	89 83       	std	Y+1, r24	; 0x01
    46d4:	80 91 24 07 	lds	r24, 0x0724
    46d8:	90 91 25 07 	lds	r25, 0x0725
    46dc:	90 93 23 07 	sts	0x0723, r25
    46e0:	80 93 22 07 	sts	0x0722, r24
    46e4:	89 81       	ldd	r24, Y+1	; 0x01
    46e6:	9a 81       	ldd	r25, Y+2	; 0x02
    46e8:	90 93 25 07 	sts	0x0725, r25
    46ec:	80 93 24 07 	sts	0x0724, r24
    46f0:	80 91 ca 06 	lds	r24, 0x06CA
    46f4:	8f 5f       	subi	r24, 0xFF	; 255
    46f6:	80 93 ca 06 	sts	0x06CA, r24
    46fa:	0e 94 ed 26 	call	0x4dda	; 0x4dda <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    46fe:	20 91 cc 06 	lds	r18, 0x06CC
    4702:	30 91 cd 06 	lds	r19, 0x06CD
    4706:	8b 81       	ldd	r24, Y+3	; 0x03
    4708:	9c 81       	ldd	r25, Y+4	; 0x04
    470a:	82 17       	cp	r24, r18
    470c:	93 07       	cpc	r25, r19
    470e:	08 f4       	brcc	.+2      	; 0x4712 <xTaskIncrementTick+0x8c>
    4710:	71 c0       	rjmp	.+226    	; 0x47f4 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4712:	e0 91 22 07 	lds	r30, 0x0722
    4716:	f0 91 23 07 	lds	r31, 0x0723
    471a:	80 81       	ld	r24, Z
    471c:	88 23       	and	r24, r24
    471e:	39 f4       	brne	.+14     	; 0x472e <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4720:	8f ef       	ldi	r24, 0xFF	; 255
    4722:	9f ef       	ldi	r25, 0xFF	; 255
    4724:	90 93 cd 06 	sts	0x06CD, r25
    4728:	80 93 cc 06 	sts	0x06CC, r24
    472c:	63 c0       	rjmp	.+198    	; 0x47f4 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    472e:	e0 91 22 07 	lds	r30, 0x0722
    4732:	f0 91 23 07 	lds	r31, 0x0723
    4736:	05 80       	ldd	r0, Z+5	; 0x05
    4738:	f6 81       	ldd	r31, Z+6	; 0x06
    473a:	e0 2d       	mov	r30, r0
    473c:	86 81       	ldd	r24, Z+6	; 0x06
    473e:	97 81       	ldd	r25, Z+7	; 0x07
    4740:	99 87       	std	Y+9, r25	; 0x09
    4742:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4744:	e8 85       	ldd	r30, Y+8	; 0x08
    4746:	f9 85       	ldd	r31, Y+9	; 0x09
    4748:	82 81       	ldd	r24, Z+2	; 0x02
    474a:	93 81       	ldd	r25, Z+3	; 0x03
    474c:	9f 83       	std	Y+7, r25	; 0x07
    474e:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    4750:	2b 81       	ldd	r18, Y+3	; 0x03
    4752:	3c 81       	ldd	r19, Y+4	; 0x04
    4754:	8e 81       	ldd	r24, Y+6	; 0x06
    4756:	9f 81       	ldd	r25, Y+7	; 0x07
    4758:	28 17       	cp	r18, r24
    475a:	39 07       	cpc	r19, r25
    475c:	38 f4       	brcc	.+14     	; 0x476c <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    475e:	8e 81       	ldd	r24, Y+6	; 0x06
    4760:	9f 81       	ldd	r25, Y+7	; 0x07
    4762:	90 93 cd 06 	sts	0x06CD, r25
    4766:	80 93 cc 06 	sts	0x06CC, r24
    476a:	44 c0       	rjmp	.+136    	; 0x47f4 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    476c:	88 85       	ldd	r24, Y+8	; 0x08
    476e:	99 85       	ldd	r25, Y+9	; 0x09
    4770:	02 96       	adiw	r24, 0x02	; 2
    4772:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4776:	e8 85       	ldd	r30, Y+8	; 0x08
    4778:	f9 85       	ldd	r31, Y+9	; 0x09
    477a:	84 89       	ldd	r24, Z+20	; 0x14
    477c:	95 89       	ldd	r25, Z+21	; 0x15
    477e:	00 97       	sbiw	r24, 0x00	; 0
    4780:	29 f0       	breq	.+10     	; 0x478c <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4782:	88 85       	ldd	r24, Y+8	; 0x08
    4784:	99 85       	ldd	r25, Y+9	; 0x09
    4786:	0c 96       	adiw	r24, 0x0c	; 12
    4788:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    478c:	e8 85       	ldd	r30, Y+8	; 0x08
    478e:	f9 85       	ldd	r31, Y+9	; 0x09
    4790:	96 89       	ldd	r25, Z+22	; 0x16
    4792:	80 91 c6 06 	lds	r24, 0x06C6
    4796:	89 17       	cp	r24, r25
    4798:	28 f4       	brcc	.+10     	; 0x47a4 <xTaskIncrementTick+0x11e>
    479a:	e8 85       	ldd	r30, Y+8	; 0x08
    479c:	f9 85       	ldd	r31, Y+9	; 0x09
    479e:	86 89       	ldd	r24, Z+22	; 0x16
    47a0:	80 93 c6 06 	sts	0x06C6, r24
    47a4:	e8 85       	ldd	r30, Y+8	; 0x08
    47a6:	f9 85       	ldd	r31, Y+9	; 0x09
    47a8:	86 89       	ldd	r24, Z+22	; 0x16
    47aa:	28 2f       	mov	r18, r24
    47ac:	30 e0       	ldi	r19, 0x00	; 0
    47ae:	c9 01       	movw	r24, r18
    47b0:	88 0f       	add	r24, r24
    47b2:	99 1f       	adc	r25, r25
    47b4:	88 0f       	add	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	88 0f       	add	r24, r24
    47ba:	99 1f       	adc	r25, r25
    47bc:	82 0f       	add	r24, r18
    47be:	93 1f       	adc	r25, r19
    47c0:	ac 01       	movw	r20, r24
    47c2:	4f 52       	subi	r20, 0x2F	; 47
    47c4:	59 4f       	sbci	r21, 0xF9	; 249
    47c6:	88 85       	ldd	r24, Y+8	; 0x08
    47c8:	99 85       	ldd	r25, Y+9	; 0x09
    47ca:	9c 01       	movw	r18, r24
    47cc:	2e 5f       	subi	r18, 0xFE	; 254
    47ce:	3f 4f       	sbci	r19, 0xFF	; 255
    47d0:	ca 01       	movw	r24, r20
    47d2:	b9 01       	movw	r22, r18
    47d4:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    47d8:	e8 85       	ldd	r30, Y+8	; 0x08
    47da:	f9 85       	ldd	r31, Y+9	; 0x09
    47dc:	96 89       	ldd	r25, Z+22	; 0x16
    47de:	e0 91 c0 06 	lds	r30, 0x06C0
    47e2:	f0 91 c1 06 	lds	r31, 0x06C1
    47e6:	86 89       	ldd	r24, Z+22	; 0x16
    47e8:	98 17       	cp	r25, r24
    47ea:	08 f4       	brcc	.+2      	; 0x47ee <xTaskIncrementTick+0x168>
    47ec:	92 cf       	rjmp	.-220    	; 0x4712 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    47ee:	81 e0       	ldi	r24, 0x01	; 1
    47f0:	8d 83       	std	Y+5, r24	; 0x05
    47f2:	8f cf       	rjmp	.-226    	; 0x4712 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    47f4:	e0 91 c0 06 	lds	r30, 0x06C0
    47f8:	f0 91 c1 06 	lds	r31, 0x06C1
    47fc:	86 89       	ldd	r24, Z+22	; 0x16
    47fe:	28 2f       	mov	r18, r24
    4800:	30 e0       	ldi	r19, 0x00	; 0
    4802:	c9 01       	movw	r24, r18
    4804:	88 0f       	add	r24, r24
    4806:	99 1f       	adc	r25, r25
    4808:	88 0f       	add	r24, r24
    480a:	99 1f       	adc	r25, r25
    480c:	88 0f       	add	r24, r24
    480e:	99 1f       	adc	r25, r25
    4810:	82 0f       	add	r24, r18
    4812:	93 1f       	adc	r25, r19
    4814:	fc 01       	movw	r30, r24
    4816:	ef 52       	subi	r30, 0x2F	; 47
    4818:	f9 4f       	sbci	r31, 0xF9	; 249
    481a:	80 81       	ld	r24, Z
    481c:	82 30       	cpi	r24, 0x02	; 2
    481e:	40 f0       	brcs	.+16     	; 0x4830 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    4820:	81 e0       	ldi	r24, 0x01	; 1
    4822:	8d 83       	std	Y+5, r24	; 0x05
    4824:	05 c0       	rjmp	.+10     	; 0x4830 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4826:	80 91 c8 06 	lds	r24, 0x06C8
    482a:	8f 5f       	subi	r24, 0xFF	; 255
    482c:	80 93 c8 06 	sts	0x06C8, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4830:	80 91 c9 06 	lds	r24, 0x06C9
    4834:	88 23       	and	r24, r24
    4836:	11 f0       	breq	.+4      	; 0x483c <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    4838:	81 e0       	ldi	r24, 0x01	; 1
    483a:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    483c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    483e:	29 96       	adiw	r28, 0x09	; 9
    4840:	0f b6       	in	r0, 0x3f	; 63
    4842:	f8 94       	cli
    4844:	de bf       	out	0x3e, r29	; 62
    4846:	0f be       	out	0x3f, r0	; 63
    4848:	cd bf       	out	0x3d, r28	; 61
    484a:	cf 91       	pop	r28
    484c:	df 91       	pop	r29
    484e:	08 95       	ret

00004850 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4850:	df 93       	push	r29
    4852:	cf 93       	push	r28
    4854:	00 d0       	rcall	.+0      	; 0x4856 <vTaskSwitchContext+0x6>
    4856:	0f 92       	push	r0
    4858:	cd b7       	in	r28, 0x3d	; 61
    485a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    485c:	80 91 d0 06 	lds	r24, 0x06D0
    4860:	88 23       	and	r24, r24
    4862:	21 f0       	breq	.+8      	; 0x486c <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4864:	81 e0       	ldi	r24, 0x01	; 1
    4866:	80 93 c9 06 	sts	0x06C9, r24
    486a:	59 c0       	rjmp	.+178    	; 0x491e <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    486c:	10 92 c9 06 	sts	0x06C9, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4870:	80 91 c6 06 	lds	r24, 0x06C6
    4874:	8b 83       	std	Y+3, r24	; 0x03
    4876:	03 c0       	rjmp	.+6      	; 0x487e <vTaskSwitchContext+0x2e>
    4878:	8b 81       	ldd	r24, Y+3	; 0x03
    487a:	81 50       	subi	r24, 0x01	; 1
    487c:	8b 83       	std	Y+3, r24	; 0x03
    487e:	8b 81       	ldd	r24, Y+3	; 0x03
    4880:	28 2f       	mov	r18, r24
    4882:	30 e0       	ldi	r19, 0x00	; 0
    4884:	c9 01       	movw	r24, r18
    4886:	88 0f       	add	r24, r24
    4888:	99 1f       	adc	r25, r25
    488a:	88 0f       	add	r24, r24
    488c:	99 1f       	adc	r25, r25
    488e:	88 0f       	add	r24, r24
    4890:	99 1f       	adc	r25, r25
    4892:	82 0f       	add	r24, r18
    4894:	93 1f       	adc	r25, r19
    4896:	fc 01       	movw	r30, r24
    4898:	ef 52       	subi	r30, 0x2F	; 47
    489a:	f9 4f       	sbci	r31, 0xF9	; 249
    489c:	80 81       	ld	r24, Z
    489e:	88 23       	and	r24, r24
    48a0:	59 f3       	breq	.-42     	; 0x4878 <vTaskSwitchContext+0x28>
    48a2:	8b 81       	ldd	r24, Y+3	; 0x03
    48a4:	28 2f       	mov	r18, r24
    48a6:	30 e0       	ldi	r19, 0x00	; 0
    48a8:	c9 01       	movw	r24, r18
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	88 0f       	add	r24, r24
    48b0:	99 1f       	adc	r25, r25
    48b2:	88 0f       	add	r24, r24
    48b4:	99 1f       	adc	r25, r25
    48b6:	82 0f       	add	r24, r18
    48b8:	93 1f       	adc	r25, r19
    48ba:	8f 52       	subi	r24, 0x2F	; 47
    48bc:	99 4f       	sbci	r25, 0xF9	; 249
    48be:	9a 83       	std	Y+2, r25	; 0x02
    48c0:	89 83       	std	Y+1, r24	; 0x01
    48c2:	e9 81       	ldd	r30, Y+1	; 0x01
    48c4:	fa 81       	ldd	r31, Y+2	; 0x02
    48c6:	01 80       	ldd	r0, Z+1	; 0x01
    48c8:	f2 81       	ldd	r31, Z+2	; 0x02
    48ca:	e0 2d       	mov	r30, r0
    48cc:	82 81       	ldd	r24, Z+2	; 0x02
    48ce:	93 81       	ldd	r25, Z+3	; 0x03
    48d0:	e9 81       	ldd	r30, Y+1	; 0x01
    48d2:	fa 81       	ldd	r31, Y+2	; 0x02
    48d4:	92 83       	std	Z+2, r25	; 0x02
    48d6:	81 83       	std	Z+1, r24	; 0x01
    48d8:	e9 81       	ldd	r30, Y+1	; 0x01
    48da:	fa 81       	ldd	r31, Y+2	; 0x02
    48dc:	21 81       	ldd	r18, Z+1	; 0x01
    48de:	32 81       	ldd	r19, Z+2	; 0x02
    48e0:	89 81       	ldd	r24, Y+1	; 0x01
    48e2:	9a 81       	ldd	r25, Y+2	; 0x02
    48e4:	03 96       	adiw	r24, 0x03	; 3
    48e6:	28 17       	cp	r18, r24
    48e8:	39 07       	cpc	r19, r25
    48ea:	59 f4       	brne	.+22     	; 0x4902 <vTaskSwitchContext+0xb2>
    48ec:	e9 81       	ldd	r30, Y+1	; 0x01
    48ee:	fa 81       	ldd	r31, Y+2	; 0x02
    48f0:	01 80       	ldd	r0, Z+1	; 0x01
    48f2:	f2 81       	ldd	r31, Z+2	; 0x02
    48f4:	e0 2d       	mov	r30, r0
    48f6:	82 81       	ldd	r24, Z+2	; 0x02
    48f8:	93 81       	ldd	r25, Z+3	; 0x03
    48fa:	e9 81       	ldd	r30, Y+1	; 0x01
    48fc:	fa 81       	ldd	r31, Y+2	; 0x02
    48fe:	92 83       	std	Z+2, r25	; 0x02
    4900:	81 83       	std	Z+1, r24	; 0x01
    4902:	e9 81       	ldd	r30, Y+1	; 0x01
    4904:	fa 81       	ldd	r31, Y+2	; 0x02
    4906:	01 80       	ldd	r0, Z+1	; 0x01
    4908:	f2 81       	ldd	r31, Z+2	; 0x02
    490a:	e0 2d       	mov	r30, r0
    490c:	86 81       	ldd	r24, Z+6	; 0x06
    490e:	97 81       	ldd	r25, Z+7	; 0x07
    4910:	90 93 c1 06 	sts	0x06C1, r25
    4914:	80 93 c0 06 	sts	0x06C0, r24
    4918:	8b 81       	ldd	r24, Y+3	; 0x03
    491a:	80 93 c6 06 	sts	0x06C6, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    491e:	0f 90       	pop	r0
    4920:	0f 90       	pop	r0
    4922:	0f 90       	pop	r0
    4924:	cf 91       	pop	r28
    4926:	df 91       	pop	r29
    4928:	08 95       	ret

0000492a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    492a:	df 93       	push	r29
    492c:	cf 93       	push	r28
    492e:	00 d0       	rcall	.+0      	; 0x4930 <vTaskPlaceOnEventList+0x6>
    4930:	00 d0       	rcall	.+0      	; 0x4932 <vTaskPlaceOnEventList+0x8>
    4932:	cd b7       	in	r28, 0x3d	; 61
    4934:	de b7       	in	r29, 0x3e	; 62
    4936:	9a 83       	std	Y+2, r25	; 0x02
    4938:	89 83       	std	Y+1, r24	; 0x01
    493a:	7c 83       	std	Y+4, r23	; 0x04
    493c:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    493e:	80 91 c0 06 	lds	r24, 0x06C0
    4942:	90 91 c1 06 	lds	r25, 0x06C1
    4946:	9c 01       	movw	r18, r24
    4948:	24 5f       	subi	r18, 0xF4	; 244
    494a:	3f 4f       	sbci	r19, 0xFF	; 255
    494c:	89 81       	ldd	r24, Y+1	; 0x01
    494e:	9a 81       	ldd	r25, Y+2	; 0x02
    4950:	b9 01       	movw	r22, r18
    4952:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4956:	8b 81       	ldd	r24, Y+3	; 0x03
    4958:	9c 81       	ldd	r25, Y+4	; 0x04
    495a:	61 e0       	ldi	r22, 0x01	; 1
    495c:	0e 94 b6 2c 	call	0x596c	; 0x596c <prvAddCurrentTaskToDelayedList>
}
    4960:	0f 90       	pop	r0
    4962:	0f 90       	pop	r0
    4964:	0f 90       	pop	r0
    4966:	0f 90       	pop	r0
    4968:	cf 91       	pop	r28
    496a:	df 91       	pop	r29
    496c:	08 95       	ret

0000496e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    496e:	df 93       	push	r29
    4970:	cf 93       	push	r28
    4972:	00 d0       	rcall	.+0      	; 0x4974 <vTaskPlaceOnUnorderedEventList+0x6>
    4974:	00 d0       	rcall	.+0      	; 0x4976 <vTaskPlaceOnUnorderedEventList+0x8>
    4976:	00 d0       	rcall	.+0      	; 0x4978 <vTaskPlaceOnUnorderedEventList+0xa>
    4978:	cd b7       	in	r28, 0x3d	; 61
    497a:	de b7       	in	r29, 0x3e	; 62
    497c:	9a 83       	std	Y+2, r25	; 0x02
    497e:	89 83       	std	Y+1, r24	; 0x01
    4980:	7c 83       	std	Y+4, r23	; 0x04
    4982:	6b 83       	std	Y+3, r22	; 0x03
    4984:	5e 83       	std	Y+6, r21	; 0x06
    4986:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4988:	e0 91 c0 06 	lds	r30, 0x06C0
    498c:	f0 91 c1 06 	lds	r31, 0x06C1
    4990:	8b 81       	ldd	r24, Y+3	; 0x03
    4992:	9c 81       	ldd	r25, Y+4	; 0x04
    4994:	90 68       	ori	r25, 0x80	; 128
    4996:	95 87       	std	Z+13, r25	; 0x0d
    4998:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    499a:	80 91 c0 06 	lds	r24, 0x06C0
    499e:	90 91 c1 06 	lds	r25, 0x06C1
    49a2:	9c 01       	movw	r18, r24
    49a4:	24 5f       	subi	r18, 0xF4	; 244
    49a6:	3f 4f       	sbci	r19, 0xFF	; 255
    49a8:	89 81       	ldd	r24, Y+1	; 0x01
    49aa:	9a 81       	ldd	r25, Y+2	; 0x02
    49ac:	b9 01       	movw	r22, r18
    49ae:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    49b2:	8d 81       	ldd	r24, Y+5	; 0x05
    49b4:	9e 81       	ldd	r25, Y+6	; 0x06
    49b6:	61 e0       	ldi	r22, 0x01	; 1
    49b8:	0e 94 b6 2c 	call	0x596c	; 0x596c <prvAddCurrentTaskToDelayedList>
}
    49bc:	26 96       	adiw	r28, 0x06	; 6
    49be:	0f b6       	in	r0, 0x3f	; 63
    49c0:	f8 94       	cli
    49c2:	de bf       	out	0x3e, r29	; 62
    49c4:	0f be       	out	0x3f, r0	; 63
    49c6:	cd bf       	out	0x3d, r28	; 61
    49c8:	cf 91       	pop	r28
    49ca:	df 91       	pop	r29
    49cc:	08 95       	ret

000049ce <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    49ce:	df 93       	push	r29
    49d0:	cf 93       	push	r28
    49d2:	00 d0       	rcall	.+0      	; 0x49d4 <xTaskRemoveFromEventList+0x6>
    49d4:	00 d0       	rcall	.+0      	; 0x49d6 <xTaskRemoveFromEventList+0x8>
    49d6:	0f 92       	push	r0
    49d8:	cd b7       	in	r28, 0x3d	; 61
    49da:	de b7       	in	r29, 0x3e	; 62
    49dc:	9d 83       	std	Y+5, r25	; 0x05
    49de:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49e0:	ec 81       	ldd	r30, Y+4	; 0x04
    49e2:	fd 81       	ldd	r31, Y+5	; 0x05
    49e4:	05 80       	ldd	r0, Z+5	; 0x05
    49e6:	f6 81       	ldd	r31, Z+6	; 0x06
    49e8:	e0 2d       	mov	r30, r0
    49ea:	86 81       	ldd	r24, Z+6	; 0x06
    49ec:	97 81       	ldd	r25, Z+7	; 0x07
    49ee:	9b 83       	std	Y+3, r25	; 0x03
    49f0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    49f2:	8a 81       	ldd	r24, Y+2	; 0x02
    49f4:	9b 81       	ldd	r25, Y+3	; 0x03
    49f6:	0c 96       	adiw	r24, 0x0c	; 12
    49f8:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49fc:	80 91 d0 06 	lds	r24, 0x06D0
    4a00:	88 23       	and	r24, r24
    4a02:	61 f5       	brne	.+88     	; 0x4a5c <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4a04:	8a 81       	ldd	r24, Y+2	; 0x02
    4a06:	9b 81       	ldd	r25, Y+3	; 0x03
    4a08:	02 96       	adiw	r24, 0x02	; 2
    4a0a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4a0e:	ea 81       	ldd	r30, Y+2	; 0x02
    4a10:	fb 81       	ldd	r31, Y+3	; 0x03
    4a12:	96 89       	ldd	r25, Z+22	; 0x16
    4a14:	80 91 c6 06 	lds	r24, 0x06C6
    4a18:	89 17       	cp	r24, r25
    4a1a:	28 f4       	brcc	.+10     	; 0x4a26 <xTaskRemoveFromEventList+0x58>
    4a1c:	ea 81       	ldd	r30, Y+2	; 0x02
    4a1e:	fb 81       	ldd	r31, Y+3	; 0x03
    4a20:	86 89       	ldd	r24, Z+22	; 0x16
    4a22:	80 93 c6 06 	sts	0x06C6, r24
    4a26:	ea 81       	ldd	r30, Y+2	; 0x02
    4a28:	fb 81       	ldd	r31, Y+3	; 0x03
    4a2a:	86 89       	ldd	r24, Z+22	; 0x16
    4a2c:	28 2f       	mov	r18, r24
    4a2e:	30 e0       	ldi	r19, 0x00	; 0
    4a30:	c9 01       	movw	r24, r18
    4a32:	88 0f       	add	r24, r24
    4a34:	99 1f       	adc	r25, r25
    4a36:	88 0f       	add	r24, r24
    4a38:	99 1f       	adc	r25, r25
    4a3a:	88 0f       	add	r24, r24
    4a3c:	99 1f       	adc	r25, r25
    4a3e:	82 0f       	add	r24, r18
    4a40:	93 1f       	adc	r25, r19
    4a42:	ac 01       	movw	r20, r24
    4a44:	4f 52       	subi	r20, 0x2F	; 47
    4a46:	59 4f       	sbci	r21, 0xF9	; 249
    4a48:	8a 81       	ldd	r24, Y+2	; 0x02
    4a4a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a4c:	9c 01       	movw	r18, r24
    4a4e:	2e 5f       	subi	r18, 0xFE	; 254
    4a50:	3f 4f       	sbci	r19, 0xFF	; 255
    4a52:	ca 01       	movw	r24, r20
    4a54:	b9 01       	movw	r22, r18
    4a56:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    4a5a:	0a c0       	rjmp	.+20     	; 0x4a70 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a60:	9c 01       	movw	r18, r24
    4a62:	24 5f       	subi	r18, 0xF4	; 244
    4a64:	3f 4f       	sbci	r19, 0xFF	; 255
    4a66:	86 e2       	ldi	r24, 0x26	; 38
    4a68:	97 e0       	ldi	r25, 0x07	; 7
    4a6a:	b9 01       	movw	r22, r18
    4a6c:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a70:	ea 81       	ldd	r30, Y+2	; 0x02
    4a72:	fb 81       	ldd	r31, Y+3	; 0x03
    4a74:	96 89       	ldd	r25, Z+22	; 0x16
    4a76:	e0 91 c0 06 	lds	r30, 0x06C0
    4a7a:	f0 91 c1 06 	lds	r31, 0x06C1
    4a7e:	86 89       	ldd	r24, Z+22	; 0x16
    4a80:	89 17       	cp	r24, r25
    4a82:	30 f4       	brcc	.+12     	; 0x4a90 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4a84:	81 e0       	ldi	r24, 0x01	; 1
    4a86:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4a88:	81 e0       	ldi	r24, 0x01	; 1
    4a8a:	80 93 c9 06 	sts	0x06C9, r24
    4a8e:	01 c0       	rjmp	.+2      	; 0x4a92 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4a90:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4a92:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a94:	0f 90       	pop	r0
    4a96:	0f 90       	pop	r0
    4a98:	0f 90       	pop	r0
    4a9a:	0f 90       	pop	r0
    4a9c:	0f 90       	pop	r0
    4a9e:	cf 91       	pop	r28
    4aa0:	df 91       	pop	r29
    4aa2:	08 95       	ret

00004aa4 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4aa4:	df 93       	push	r29
    4aa6:	cf 93       	push	r28
    4aa8:	00 d0       	rcall	.+0      	; 0x4aaa <vTaskRemoveFromUnorderedEventList+0x6>
    4aaa:	00 d0       	rcall	.+0      	; 0x4aac <vTaskRemoveFromUnorderedEventList+0x8>
    4aac:	00 d0       	rcall	.+0      	; 0x4aae <vTaskRemoveFromUnorderedEventList+0xa>
    4aae:	cd b7       	in	r28, 0x3d	; 61
    4ab0:	de b7       	in	r29, 0x3e	; 62
    4ab2:	9c 83       	std	Y+4, r25	; 0x04
    4ab4:	8b 83       	std	Y+3, r24	; 0x03
    4ab6:	7e 83       	std	Y+6, r23	; 0x06
    4ab8:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4aba:	8d 81       	ldd	r24, Y+5	; 0x05
    4abc:	9e 81       	ldd	r25, Y+6	; 0x06
    4abe:	90 68       	ori	r25, 0x80	; 128
    4ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ac4:	91 83       	std	Z+1, r25	; 0x01
    4ac6:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    4aca:	fc 81       	ldd	r31, Y+4	; 0x04
    4acc:	86 81       	ldd	r24, Z+6	; 0x06
    4ace:	97 81       	ldd	r25, Z+7	; 0x07
    4ad0:	9a 83       	std	Y+2, r25	; 0x02
    4ad2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad8:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4adc:	89 81       	ldd	r24, Y+1	; 0x01
    4ade:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae0:	02 96       	adiw	r24, 0x02	; 2
    4ae2:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aea:	96 89       	ldd	r25, Z+22	; 0x16
    4aec:	80 91 c6 06 	lds	r24, 0x06C6
    4af0:	89 17       	cp	r24, r25
    4af2:	28 f4       	brcc	.+10     	; 0x4afe <vTaskRemoveFromUnorderedEventList+0x5a>
    4af4:	e9 81       	ldd	r30, Y+1	; 0x01
    4af6:	fa 81       	ldd	r31, Y+2	; 0x02
    4af8:	86 89       	ldd	r24, Z+22	; 0x16
    4afa:	80 93 c6 06 	sts	0x06C6, r24
    4afe:	e9 81       	ldd	r30, Y+1	; 0x01
    4b00:	fa 81       	ldd	r31, Y+2	; 0x02
    4b02:	86 89       	ldd	r24, Z+22	; 0x16
    4b04:	28 2f       	mov	r18, r24
    4b06:	30 e0       	ldi	r19, 0x00	; 0
    4b08:	c9 01       	movw	r24, r18
    4b0a:	88 0f       	add	r24, r24
    4b0c:	99 1f       	adc	r25, r25
    4b0e:	88 0f       	add	r24, r24
    4b10:	99 1f       	adc	r25, r25
    4b12:	88 0f       	add	r24, r24
    4b14:	99 1f       	adc	r25, r25
    4b16:	82 0f       	add	r24, r18
    4b18:	93 1f       	adc	r25, r19
    4b1a:	ac 01       	movw	r20, r24
    4b1c:	4f 52       	subi	r20, 0x2F	; 47
    4b1e:	59 4f       	sbci	r21, 0xF9	; 249
    4b20:	89 81       	ldd	r24, Y+1	; 0x01
    4b22:	9a 81       	ldd	r25, Y+2	; 0x02
    4b24:	9c 01       	movw	r18, r24
    4b26:	2e 5f       	subi	r18, 0xFE	; 254
    4b28:	3f 4f       	sbci	r19, 0xFF	; 255
    4b2a:	ca 01       	movw	r24, r20
    4b2c:	b9 01       	movw	r22, r18
    4b2e:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b32:	e9 81       	ldd	r30, Y+1	; 0x01
    4b34:	fa 81       	ldd	r31, Y+2	; 0x02
    4b36:	96 89       	ldd	r25, Z+22	; 0x16
    4b38:	e0 91 c0 06 	lds	r30, 0x06C0
    4b3c:	f0 91 c1 06 	lds	r31, 0x06C1
    4b40:	86 89       	ldd	r24, Z+22	; 0x16
    4b42:	89 17       	cp	r24, r25
    4b44:	18 f4       	brcc	.+6      	; 0x4b4c <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4b46:	81 e0       	ldi	r24, 0x01	; 1
    4b48:	80 93 c9 06 	sts	0x06C9, r24
	}
}
    4b4c:	26 96       	adiw	r28, 0x06	; 6
    4b4e:	0f b6       	in	r0, 0x3f	; 63
    4b50:	f8 94       	cli
    4b52:	de bf       	out	0x3e, r29	; 62
    4b54:	0f be       	out	0x3f, r0	; 63
    4b56:	cd bf       	out	0x3d, r28	; 61
    4b58:	cf 91       	pop	r28
    4b5a:	df 91       	pop	r29
    4b5c:	08 95       	ret

00004b5e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b5e:	df 93       	push	r29
    4b60:	cf 93       	push	r28
    4b62:	00 d0       	rcall	.+0      	; 0x4b64 <vTaskSetTimeOutState+0x6>
    4b64:	cd b7       	in	r28, 0x3d	; 61
    4b66:	de b7       	in	r29, 0x3e	; 62
    4b68:	9a 83       	std	Y+2, r25	; 0x02
    4b6a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b72:	80 91 ca 06 	lds	r24, 0x06CA
    4b76:	e9 81       	ldd	r30, Y+1	; 0x01
    4b78:	fa 81       	ldd	r31, Y+2	; 0x02
    4b7a:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4b7c:	80 91 c4 06 	lds	r24, 0x06C4
    4b80:	90 91 c5 06 	lds	r25, 0x06C5
    4b84:	e9 81       	ldd	r30, Y+1	; 0x01
    4b86:	fa 81       	ldd	r31, Y+2	; 0x02
    4b88:	92 83       	std	Z+2, r25	; 0x02
    4b8a:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4b8c:	0f 90       	pop	r0
    4b8e:	0f be       	out	0x3f, r0	; 63
}
    4b90:	0f 90       	pop	r0
    4b92:	0f 90       	pop	r0
    4b94:	cf 91       	pop	r28
    4b96:	df 91       	pop	r29
    4b98:	08 95       	ret

00004b9a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4b9a:	df 93       	push	r29
    4b9c:	cf 93       	push	r28
    4b9e:	00 d0       	rcall	.+0      	; 0x4ba0 <vTaskInternalSetTimeOutState+0x6>
    4ba0:	cd b7       	in	r28, 0x3d	; 61
    4ba2:	de b7       	in	r29, 0x3e	; 62
    4ba4:	9a 83       	std	Y+2, r25	; 0x02
    4ba6:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4ba8:	80 91 ca 06 	lds	r24, 0x06CA
    4bac:	e9 81       	ldd	r30, Y+1	; 0x01
    4bae:	fa 81       	ldd	r31, Y+2	; 0x02
    4bb0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4bb2:	80 91 c4 06 	lds	r24, 0x06C4
    4bb6:	90 91 c5 06 	lds	r25, 0x06C5
    4bba:	e9 81       	ldd	r30, Y+1	; 0x01
    4bbc:	fa 81       	ldd	r31, Y+2	; 0x02
    4bbe:	92 83       	std	Z+2, r25	; 0x02
    4bc0:	81 83       	std	Z+1, r24	; 0x01
}
    4bc2:	0f 90       	pop	r0
    4bc4:	0f 90       	pop	r0
    4bc6:	cf 91       	pop	r28
    4bc8:	df 91       	pop	r29
    4bca:	08 95       	ret

00004bcc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4bcc:	df 93       	push	r29
    4bce:	cf 93       	push	r28
    4bd0:	cd b7       	in	r28, 0x3d	; 61
    4bd2:	de b7       	in	r29, 0x3e	; 62
    4bd4:	29 97       	sbiw	r28, 0x09	; 9
    4bd6:	0f b6       	in	r0, 0x3f	; 63
    4bd8:	f8 94       	cli
    4bda:	de bf       	out	0x3e, r29	; 62
    4bdc:	0f be       	out	0x3f, r0	; 63
    4bde:	cd bf       	out	0x3d, r28	; 61
    4be0:	9f 83       	std	Y+7, r25	; 0x07
    4be2:	8e 83       	std	Y+6, r24	; 0x06
    4be4:	79 87       	std	Y+9, r23	; 0x09
    4be6:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4be8:	0f b6       	in	r0, 0x3f	; 63
    4bea:	f8 94       	cli
    4bec:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4bee:	80 91 c4 06 	lds	r24, 0x06C4
    4bf2:	90 91 c5 06 	lds	r25, 0x06C5
    4bf6:	9c 83       	std	Y+4, r25	; 0x04
    4bf8:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4bfa:	ee 81       	ldd	r30, Y+6	; 0x06
    4bfc:	ff 81       	ldd	r31, Y+7	; 0x07
    4bfe:	21 81       	ldd	r18, Z+1	; 0x01
    4c00:	32 81       	ldd	r19, Z+2	; 0x02
    4c02:	8b 81       	ldd	r24, Y+3	; 0x03
    4c04:	9c 81       	ldd	r25, Y+4	; 0x04
    4c06:	82 1b       	sub	r24, r18
    4c08:	93 0b       	sbc	r25, r19
    4c0a:	9a 83       	std	Y+2, r25	; 0x02
    4c0c:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4c0e:	e8 85       	ldd	r30, Y+8	; 0x08
    4c10:	f9 85       	ldd	r31, Y+9	; 0x09
    4c12:	80 81       	ld	r24, Z
    4c14:	91 81       	ldd	r25, Z+1	; 0x01
    4c16:	2f ef       	ldi	r18, 0xFF	; 255
    4c18:	8f 3f       	cpi	r24, 0xFF	; 255
    4c1a:	92 07       	cpc	r25, r18
    4c1c:	11 f4       	brne	.+4      	; 0x4c22 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4c1e:	1d 82       	std	Y+5, r1	; 0x05
    4c20:	36 c0       	rjmp	.+108    	; 0x4c8e <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4c22:	ee 81       	ldd	r30, Y+6	; 0x06
    4c24:	ff 81       	ldd	r31, Y+7	; 0x07
    4c26:	90 81       	ld	r25, Z
    4c28:	80 91 ca 06 	lds	r24, 0x06CA
    4c2c:	98 17       	cp	r25, r24
    4c2e:	61 f0       	breq	.+24     	; 0x4c48 <xTaskCheckForTimeOut+0x7c>
    4c30:	ee 81       	ldd	r30, Y+6	; 0x06
    4c32:	ff 81       	ldd	r31, Y+7	; 0x07
    4c34:	21 81       	ldd	r18, Z+1	; 0x01
    4c36:	32 81       	ldd	r19, Z+2	; 0x02
    4c38:	8b 81       	ldd	r24, Y+3	; 0x03
    4c3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4c3c:	82 17       	cp	r24, r18
    4c3e:	93 07       	cpc	r25, r19
    4c40:	18 f0       	brcs	.+6      	; 0x4c48 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4c42:	81 e0       	ldi	r24, 0x01	; 1
    4c44:	8d 83       	std	Y+5, r24	; 0x05
    4c46:	23 c0       	rjmp	.+70     	; 0x4c8e <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4c48:	e8 85       	ldd	r30, Y+8	; 0x08
    4c4a:	f9 85       	ldd	r31, Y+9	; 0x09
    4c4c:	20 81       	ld	r18, Z
    4c4e:	31 81       	ldd	r19, Z+1	; 0x01
    4c50:	89 81       	ldd	r24, Y+1	; 0x01
    4c52:	9a 81       	ldd	r25, Y+2	; 0x02
    4c54:	82 17       	cp	r24, r18
    4c56:	93 07       	cpc	r25, r19
    4c58:	a0 f4       	brcc	.+40     	; 0x4c82 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4c5a:	e8 85       	ldd	r30, Y+8	; 0x08
    4c5c:	f9 85       	ldd	r31, Y+9	; 0x09
    4c5e:	20 81       	ld	r18, Z
    4c60:	31 81       	ldd	r19, Z+1	; 0x01
    4c62:	89 81       	ldd	r24, Y+1	; 0x01
    4c64:	9a 81       	ldd	r25, Y+2	; 0x02
    4c66:	a9 01       	movw	r20, r18
    4c68:	48 1b       	sub	r20, r24
    4c6a:	59 0b       	sbc	r21, r25
    4c6c:	ca 01       	movw	r24, r20
    4c6e:	e8 85       	ldd	r30, Y+8	; 0x08
    4c70:	f9 85       	ldd	r31, Y+9	; 0x09
    4c72:	91 83       	std	Z+1, r25	; 0x01
    4c74:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4c76:	8e 81       	ldd	r24, Y+6	; 0x06
    4c78:	9f 81       	ldd	r25, Y+7	; 0x07
    4c7a:	0e 94 cd 25 	call	0x4b9a	; 0x4b9a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4c7e:	1d 82       	std	Y+5, r1	; 0x05
    4c80:	06 c0       	rjmp	.+12     	; 0x4c8e <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4c82:	e8 85       	ldd	r30, Y+8	; 0x08
    4c84:	f9 85       	ldd	r31, Y+9	; 0x09
    4c86:	11 82       	std	Z+1, r1	; 0x01
    4c88:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4c8a:	81 e0       	ldi	r24, 0x01	; 1
    4c8c:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4c8e:	0f 90       	pop	r0
    4c90:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4c92:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c94:	29 96       	adiw	r28, 0x09	; 9
    4c96:	0f b6       	in	r0, 0x3f	; 63
    4c98:	f8 94       	cli
    4c9a:	de bf       	out	0x3e, r29	; 62
    4c9c:	0f be       	out	0x3f, r0	; 63
    4c9e:	cd bf       	out	0x3d, r28	; 61
    4ca0:	cf 91       	pop	r28
    4ca2:	df 91       	pop	r29
    4ca4:	08 95       	ret

00004ca6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4ca6:	df 93       	push	r29
    4ca8:	cf 93       	push	r28
    4caa:	cd b7       	in	r28, 0x3d	; 61
    4cac:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4cae:	81 e0       	ldi	r24, 0x01	; 1
    4cb0:	80 93 c9 06 	sts	0x06C9, r24
}
    4cb4:	cf 91       	pop	r28
    4cb6:	df 91       	pop	r29
    4cb8:	08 95       	ret

00004cba <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4cba:	df 93       	push	r29
    4cbc:	cf 93       	push	r28
    4cbe:	00 d0       	rcall	.+0      	; 0x4cc0 <prvIdleTask+0x6>
    4cc0:	cd b7       	in	r28, 0x3d	; 61
    4cc2:	de b7       	in	r29, 0x3e	; 62
    4cc4:	9a 83       	std	Y+2, r25	; 0x02
    4cc6:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4cc8:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <prvCheckTasksWaitingTermination>
    4ccc:	fd cf       	rjmp	.-6      	; 0x4cc8 <prvIdleTask+0xe>

00004cce <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4cce:	df 93       	push	r29
    4cd0:	cf 93       	push	r28
    4cd2:	0f 92       	push	r0
    4cd4:	cd b7       	in	r28, 0x3d	; 61
    4cd6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cd8:	19 82       	std	Y+1, r1	; 0x01
    4cda:	13 c0       	rjmp	.+38     	; 0x4d02 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	28 2f       	mov	r18, r24
    4ce0:	30 e0       	ldi	r19, 0x00	; 0
    4ce2:	c9 01       	movw	r24, r18
    4ce4:	88 0f       	add	r24, r24
    4ce6:	99 1f       	adc	r25, r25
    4ce8:	88 0f       	add	r24, r24
    4cea:	99 1f       	adc	r25, r25
    4cec:	88 0f       	add	r24, r24
    4cee:	99 1f       	adc	r25, r25
    4cf0:	82 0f       	add	r24, r18
    4cf2:	93 1f       	adc	r25, r19
    4cf4:	8f 52       	subi	r24, 0x2F	; 47
    4cf6:	99 4f       	sbci	r25, 0xF9	; 249
    4cf8:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4cfc:	89 81       	ldd	r24, Y+1	; 0x01
    4cfe:	8f 5f       	subi	r24, 0xFF	; 255
    4d00:	89 83       	std	Y+1, r24	; 0x01
    4d02:	89 81       	ldd	r24, Y+1	; 0x01
    4d04:	87 30       	cpi	r24, 0x07	; 7
    4d06:	50 f3       	brcs	.-44     	; 0x4cdc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4d08:	80 e1       	ldi	r24, 0x10	; 16
    4d0a:	97 e0       	ldi	r25, 0x07	; 7
    4d0c:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4d10:	89 e1       	ldi	r24, 0x19	; 25
    4d12:	97 e0       	ldi	r25, 0x07	; 7
    4d14:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4d18:	86 e2       	ldi	r24, 0x26	; 38
    4d1a:	97 e0       	ldi	r25, 0x07	; 7
    4d1c:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4d20:	8f e2       	ldi	r24, 0x2F	; 47
    4d22:	97 e0       	ldi	r25, 0x07	; 7
    4d24:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4d28:	88 e3       	ldi	r24, 0x38	; 56
    4d2a:	97 e0       	ldi	r25, 0x07	; 7
    4d2c:	0e 94 ce 0a 	call	0x159c	; 0x159c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4d30:	80 e1       	ldi	r24, 0x10	; 16
    4d32:	97 e0       	ldi	r25, 0x07	; 7
    4d34:	90 93 23 07 	sts	0x0723, r25
    4d38:	80 93 22 07 	sts	0x0722, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4d3c:	89 e1       	ldi	r24, 0x19	; 25
    4d3e:	97 e0       	ldi	r25, 0x07	; 7
    4d40:	90 93 25 07 	sts	0x0725, r25
    4d44:	80 93 24 07 	sts	0x0724, r24
}
    4d48:	0f 90       	pop	r0
    4d4a:	cf 91       	pop	r28
    4d4c:	df 91       	pop	r29
    4d4e:	08 95       	ret

00004d50 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4d50:	df 93       	push	r29
    4d52:	cf 93       	push	r28
    4d54:	00 d0       	rcall	.+0      	; 0x4d56 <prvCheckTasksWaitingTermination+0x6>
    4d56:	cd b7       	in	r28, 0x3d	; 61
    4d58:	de b7       	in	r29, 0x3e	; 62
    4d5a:	20 c0       	rjmp	.+64     	; 0x4d9c <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4d5c:	0f b6       	in	r0, 0x3f	; 63
    4d5e:	f8 94       	cli
    4d60:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d62:	e0 91 34 07 	lds	r30, 0x0734
    4d66:	f0 91 35 07 	lds	r31, 0x0735
    4d6a:	86 81       	ldd	r24, Z+6	; 0x06
    4d6c:	97 81       	ldd	r25, Z+7	; 0x07
    4d6e:	9a 83       	std	Y+2, r25	; 0x02
    4d70:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4d72:	89 81       	ldd	r24, Y+1	; 0x01
    4d74:	9a 81       	ldd	r25, Y+2	; 0x02
    4d76:	02 96       	adiw	r24, 0x02	; 2
    4d78:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4d7c:	80 91 c3 06 	lds	r24, 0x06C3
    4d80:	81 50       	subi	r24, 0x01	; 1
    4d82:	80 93 c3 06 	sts	0x06C3, r24
				--uxDeletedTasksWaitingCleanUp;
    4d86:	80 91 c2 06 	lds	r24, 0x06C2
    4d8a:	81 50       	subi	r24, 0x01	; 1
    4d8c:	80 93 c2 06 	sts	0x06C2, r24
			}
			taskEXIT_CRITICAL();
    4d90:	0f 90       	pop	r0
    4d92:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4d94:	89 81       	ldd	r24, Y+1	; 0x01
    4d96:	9a 81       	ldd	r25, Y+2	; 0x02
    4d98:	0e 94 d7 26 	call	0x4dae	; 0x4dae <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4d9c:	80 91 c2 06 	lds	r24, 0x06C2
    4da0:	88 23       	and	r24, r24
    4da2:	e1 f6       	brne	.-72     	; 0x4d5c <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4da4:	0f 90       	pop	r0
    4da6:	0f 90       	pop	r0
    4da8:	cf 91       	pop	r28
    4daa:	df 91       	pop	r29
    4dac:	08 95       	ret

00004dae <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4dae:	df 93       	push	r29
    4db0:	cf 93       	push	r28
    4db2:	00 d0       	rcall	.+0      	; 0x4db4 <prvDeleteTCB+0x6>
    4db4:	cd b7       	in	r28, 0x3d	; 61
    4db6:	de b7       	in	r29, 0x3e	; 62
    4db8:	9a 83       	std	Y+2, r25	; 0x02
    4dba:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    4dc0:	87 89       	ldd	r24, Z+23	; 0x17
    4dc2:	90 8d       	ldd	r25, Z+24	; 0x18
    4dc4:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
			vPortFree( pxTCB );
    4dc8:	89 81       	ldd	r24, Y+1	; 0x01
    4dca:	9a 81       	ldd	r25, Y+2	; 0x02
    4dcc:	0e 94 1f 09 	call	0x123e	; 0x123e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4dd0:	0f 90       	pop	r0
    4dd2:	0f 90       	pop	r0
    4dd4:	cf 91       	pop	r28
    4dd6:	df 91       	pop	r29
    4dd8:	08 95       	ret

00004dda <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4dda:	df 93       	push	r29
    4ddc:	cf 93       	push	r28
    4dde:	00 d0       	rcall	.+0      	; 0x4de0 <prvResetNextTaskUnblockTime+0x6>
    4de0:	cd b7       	in	r28, 0x3d	; 61
    4de2:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4de4:	e0 91 22 07 	lds	r30, 0x0722
    4de8:	f0 91 23 07 	lds	r31, 0x0723
    4dec:	80 81       	ld	r24, Z
    4dee:	88 23       	and	r24, r24
    4df0:	39 f4       	brne	.+14     	; 0x4e00 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4df2:	8f ef       	ldi	r24, 0xFF	; 255
    4df4:	9f ef       	ldi	r25, 0xFF	; 255
    4df6:	90 93 cd 06 	sts	0x06CD, r25
    4dfa:	80 93 cc 06 	sts	0x06CC, r24
    4dfe:	13 c0       	rjmp	.+38     	; 0x4e26 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4e00:	e0 91 22 07 	lds	r30, 0x0722
    4e04:	f0 91 23 07 	lds	r31, 0x0723
    4e08:	05 80       	ldd	r0, Z+5	; 0x05
    4e0a:	f6 81       	ldd	r31, Z+6	; 0x06
    4e0c:	e0 2d       	mov	r30, r0
    4e0e:	86 81       	ldd	r24, Z+6	; 0x06
    4e10:	97 81       	ldd	r25, Z+7	; 0x07
    4e12:	9a 83       	std	Y+2, r25	; 0x02
    4e14:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4e16:	e9 81       	ldd	r30, Y+1	; 0x01
    4e18:	fa 81       	ldd	r31, Y+2	; 0x02
    4e1a:	82 81       	ldd	r24, Z+2	; 0x02
    4e1c:	93 81       	ldd	r25, Z+3	; 0x03
    4e1e:	90 93 cd 06 	sts	0x06CD, r25
    4e22:	80 93 cc 06 	sts	0x06CC, r24
	}
}
    4e26:	0f 90       	pop	r0
    4e28:	0f 90       	pop	r0
    4e2a:	cf 91       	pop	r28
    4e2c:	df 91       	pop	r29
    4e2e:	08 95       	ret

00004e30 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4e30:	df 93       	push	r29
    4e32:	cf 93       	push	r28
    4e34:	00 d0       	rcall	.+0      	; 0x4e36 <xTaskGetCurrentTaskHandle+0x6>
    4e36:	cd b7       	in	r28, 0x3d	; 61
    4e38:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4e3a:	80 91 c0 06 	lds	r24, 0x06C0
    4e3e:	90 91 c1 06 	lds	r25, 0x06C1
    4e42:	9a 83       	std	Y+2, r25	; 0x02
    4e44:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4e46:	89 81       	ldd	r24, Y+1	; 0x01
    4e48:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4e4a:	0f 90       	pop	r0
    4e4c:	0f 90       	pop	r0
    4e4e:	cf 91       	pop	r28
    4e50:	df 91       	pop	r29
    4e52:	08 95       	ret

00004e54 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4e54:	df 93       	push	r29
    4e56:	cf 93       	push	r28
    4e58:	00 d0       	rcall	.+0      	; 0x4e5a <xTaskPriorityInherit+0x6>
    4e5a:	00 d0       	rcall	.+0      	; 0x4e5c <xTaskPriorityInherit+0x8>
    4e5c:	0f 92       	push	r0
    4e5e:	cd b7       	in	r28, 0x3d	; 61
    4e60:	de b7       	in	r29, 0x3e	; 62
    4e62:	9d 83       	std	Y+5, r25	; 0x05
    4e64:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    4e66:	8c 81       	ldd	r24, Y+4	; 0x04
    4e68:	9d 81       	ldd	r25, Y+5	; 0x05
    4e6a:	9b 83       	std	Y+3, r25	; 0x03
    4e6c:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4e6e:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    4e70:	8c 81       	ldd	r24, Y+4	; 0x04
    4e72:	9d 81       	ldd	r25, Y+5	; 0x05
    4e74:	00 97       	sbiw	r24, 0x00	; 0
    4e76:	09 f4       	brne	.+2      	; 0x4e7a <xTaskPriorityInherit+0x26>
    4e78:	82 c0       	rjmp	.+260    	; 0x4f7e <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    4e7a:	ea 81       	ldd	r30, Y+2	; 0x02
    4e7c:	fb 81       	ldd	r31, Y+3	; 0x03
    4e7e:	96 89       	ldd	r25, Z+22	; 0x16
    4e80:	e0 91 c0 06 	lds	r30, 0x06C0
    4e84:	f0 91 c1 06 	lds	r31, 0x06C1
    4e88:	86 89       	ldd	r24, Z+22	; 0x16
    4e8a:	98 17       	cp	r25, r24
    4e8c:	08 f0       	brcs	.+2      	; 0x4e90 <xTaskPriorityInherit+0x3c>
    4e8e:	6b c0       	rjmp	.+214    	; 0x4f66 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4e90:	ea 81       	ldd	r30, Y+2	; 0x02
    4e92:	fb 81       	ldd	r31, Y+3	; 0x03
    4e94:	84 85       	ldd	r24, Z+12	; 0x0c
    4e96:	95 85       	ldd	r25, Z+13	; 0x0d
    4e98:	99 23       	and	r25, r25
    4e9a:	7c f0       	brlt	.+30     	; 0x4eba <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4e9c:	e0 91 c0 06 	lds	r30, 0x06C0
    4ea0:	f0 91 c1 06 	lds	r31, 0x06C1
    4ea4:	86 89       	ldd	r24, Z+22	; 0x16
    4ea6:	28 2f       	mov	r18, r24
    4ea8:	30 e0       	ldi	r19, 0x00	; 0
    4eaa:	87 e0       	ldi	r24, 0x07	; 7
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	82 1b       	sub	r24, r18
    4eb0:	93 0b       	sbc	r25, r19
    4eb2:	ea 81       	ldd	r30, Y+2	; 0x02
    4eb4:	fb 81       	ldd	r31, Y+3	; 0x03
    4eb6:	95 87       	std	Z+13, r25	; 0x0d
    4eb8:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    4eba:	ea 81       	ldd	r30, Y+2	; 0x02
    4ebc:	fb 81       	ldd	r31, Y+3	; 0x03
    4ebe:	42 85       	ldd	r20, Z+10	; 0x0a
    4ec0:	53 85       	ldd	r21, Z+11	; 0x0b
    4ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    4ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    4ec6:	86 89       	ldd	r24, Z+22	; 0x16
    4ec8:	28 2f       	mov	r18, r24
    4eca:	30 e0       	ldi	r19, 0x00	; 0
    4ecc:	c9 01       	movw	r24, r18
    4ece:	88 0f       	add	r24, r24
    4ed0:	99 1f       	adc	r25, r25
    4ed2:	88 0f       	add	r24, r24
    4ed4:	99 1f       	adc	r25, r25
    4ed6:	88 0f       	add	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	82 0f       	add	r24, r18
    4edc:	93 1f       	adc	r25, r19
    4ede:	8f 52       	subi	r24, 0x2F	; 47
    4ee0:	99 4f       	sbci	r25, 0xF9	; 249
    4ee2:	48 17       	cp	r20, r24
    4ee4:	59 07       	cpc	r21, r25
    4ee6:	a1 f5       	brne	.+104    	; 0x4f50 <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eea:	9b 81       	ldd	r25, Y+3	; 0x03
    4eec:	02 96       	adiw	r24, 0x02	; 2
    4eee:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4ef2:	e0 91 c0 06 	lds	r30, 0x06C0
    4ef6:	f0 91 c1 06 	lds	r31, 0x06C1
    4efa:	86 89       	ldd	r24, Z+22	; 0x16
    4efc:	ea 81       	ldd	r30, Y+2	; 0x02
    4efe:	fb 81       	ldd	r31, Y+3	; 0x03
    4f00:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    4f02:	ea 81       	ldd	r30, Y+2	; 0x02
    4f04:	fb 81       	ldd	r31, Y+3	; 0x03
    4f06:	96 89       	ldd	r25, Z+22	; 0x16
    4f08:	80 91 c6 06 	lds	r24, 0x06C6
    4f0c:	89 17       	cp	r24, r25
    4f0e:	28 f4       	brcc	.+10     	; 0x4f1a <xTaskPriorityInherit+0xc6>
    4f10:	ea 81       	ldd	r30, Y+2	; 0x02
    4f12:	fb 81       	ldd	r31, Y+3	; 0x03
    4f14:	86 89       	ldd	r24, Z+22	; 0x16
    4f16:	80 93 c6 06 	sts	0x06C6, r24
    4f1a:	ea 81       	ldd	r30, Y+2	; 0x02
    4f1c:	fb 81       	ldd	r31, Y+3	; 0x03
    4f1e:	86 89       	ldd	r24, Z+22	; 0x16
    4f20:	28 2f       	mov	r18, r24
    4f22:	30 e0       	ldi	r19, 0x00	; 0
    4f24:	c9 01       	movw	r24, r18
    4f26:	88 0f       	add	r24, r24
    4f28:	99 1f       	adc	r25, r25
    4f2a:	88 0f       	add	r24, r24
    4f2c:	99 1f       	adc	r25, r25
    4f2e:	88 0f       	add	r24, r24
    4f30:	99 1f       	adc	r25, r25
    4f32:	82 0f       	add	r24, r18
    4f34:	93 1f       	adc	r25, r19
    4f36:	ac 01       	movw	r20, r24
    4f38:	4f 52       	subi	r20, 0x2F	; 47
    4f3a:	59 4f       	sbci	r21, 0xF9	; 249
    4f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f40:	9c 01       	movw	r18, r24
    4f42:	2e 5f       	subi	r18, 0xFE	; 254
    4f44:	3f 4f       	sbci	r19, 0xFF	; 255
    4f46:	ca 01       	movw	r24, r20
    4f48:	b9 01       	movw	r22, r18
    4f4a:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    4f4e:	08 c0       	rjmp	.+16     	; 0x4f60 <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4f50:	e0 91 c0 06 	lds	r30, 0x06C0
    4f54:	f0 91 c1 06 	lds	r31, 0x06C1
    4f58:	86 89       	ldd	r24, Z+22	; 0x16
    4f5a:	ea 81       	ldd	r30, Y+2	; 0x02
    4f5c:	fb 81       	ldd	r31, Y+3	; 0x03
    4f5e:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    4f60:	81 e0       	ldi	r24, 0x01	; 1
    4f62:	89 83       	std	Y+1, r24	; 0x01
    4f64:	0c c0       	rjmp	.+24     	; 0x4f7e <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    4f66:	ea 81       	ldd	r30, Y+2	; 0x02
    4f68:	fb 81       	ldd	r31, Y+3	; 0x03
    4f6a:	95 a5       	ldd	r25, Z+45	; 0x2d
    4f6c:	e0 91 c0 06 	lds	r30, 0x06C0
    4f70:	f0 91 c1 06 	lds	r31, 0x06C1
    4f74:	86 89       	ldd	r24, Z+22	; 0x16
    4f76:	98 17       	cp	r25, r24
    4f78:	10 f4       	brcc	.+4      	; 0x4f7e <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    4f7a:	81 e0       	ldi	r24, 0x01	; 1
    4f7c:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4f7e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4f80:	0f 90       	pop	r0
    4f82:	0f 90       	pop	r0
    4f84:	0f 90       	pop	r0
    4f86:	0f 90       	pop	r0
    4f88:	0f 90       	pop	r0
    4f8a:	cf 91       	pop	r28
    4f8c:	df 91       	pop	r29
    4f8e:	08 95       	ret

00004f90 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4f90:	df 93       	push	r29
    4f92:	cf 93       	push	r28
    4f94:	00 d0       	rcall	.+0      	; 0x4f96 <xTaskPriorityDisinherit+0x6>
    4f96:	00 d0       	rcall	.+0      	; 0x4f98 <xTaskPriorityDisinherit+0x8>
    4f98:	0f 92       	push	r0
    4f9a:	cd b7       	in	r28, 0x3d	; 61
    4f9c:	de b7       	in	r29, 0x3e	; 62
    4f9e:	9d 83       	std	Y+5, r25	; 0x05
    4fa0:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    4fa2:	8c 81       	ldd	r24, Y+4	; 0x04
    4fa4:	9d 81       	ldd	r25, Y+5	; 0x05
    4fa6:	9b 83       	std	Y+3, r25	; 0x03
    4fa8:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4faa:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4fac:	8c 81       	ldd	r24, Y+4	; 0x04
    4fae:	9d 81       	ldd	r25, Y+5	; 0x05
    4fb0:	00 97       	sbiw	r24, 0x00	; 0
    4fb2:	09 f4       	brne	.+2      	; 0x4fb6 <xTaskPriorityDisinherit+0x26>
    4fb4:	56 c0       	rjmp	.+172    	; 0x5062 <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4fb6:	ea 81       	ldd	r30, Y+2	; 0x02
    4fb8:	fb 81       	ldd	r31, Y+3	; 0x03
    4fba:	86 a5       	ldd	r24, Z+46	; 0x2e
    4fbc:	81 50       	subi	r24, 0x01	; 1
    4fbe:	ea 81       	ldd	r30, Y+2	; 0x02
    4fc0:	fb 81       	ldd	r31, Y+3	; 0x03
    4fc2:	86 a7       	std	Z+46, r24	; 0x2e

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4fc4:	ea 81       	ldd	r30, Y+2	; 0x02
    4fc6:	fb 81       	ldd	r31, Y+3	; 0x03
    4fc8:	96 89       	ldd	r25, Z+22	; 0x16
    4fca:	ea 81       	ldd	r30, Y+2	; 0x02
    4fcc:	fb 81       	ldd	r31, Y+3	; 0x03
    4fce:	85 a5       	ldd	r24, Z+45	; 0x2d
    4fd0:	98 17       	cp	r25, r24
    4fd2:	09 f4       	brne	.+2      	; 0x4fd6 <xTaskPriorityDisinherit+0x46>
    4fd4:	46 c0       	rjmp	.+140    	; 0x5062 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4fd6:	ea 81       	ldd	r30, Y+2	; 0x02
    4fd8:	fb 81       	ldd	r31, Y+3	; 0x03
    4fda:	86 a5       	ldd	r24, Z+46	; 0x2e
    4fdc:	88 23       	and	r24, r24
    4fde:	09 f0       	breq	.+2      	; 0x4fe2 <xTaskPriorityDisinherit+0x52>
    4fe0:	40 c0       	rjmp	.+128    	; 0x5062 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    4fe4:	9b 81       	ldd	r25, Y+3	; 0x03
    4fe6:	02 96       	adiw	r24, 0x02	; 2
    4fe8:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4fec:	ea 81       	ldd	r30, Y+2	; 0x02
    4fee:	fb 81       	ldd	r31, Y+3	; 0x03
    4ff0:	85 a5       	ldd	r24, Z+45	; 0x2d
    4ff2:	ea 81       	ldd	r30, Y+2	; 0x02
    4ff4:	fb 81       	ldd	r31, Y+3	; 0x03
    4ff6:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ff8:	ea 81       	ldd	r30, Y+2	; 0x02
    4ffa:	fb 81       	ldd	r31, Y+3	; 0x03
    4ffc:	86 89       	ldd	r24, Z+22	; 0x16
    4ffe:	28 2f       	mov	r18, r24
    5000:	30 e0       	ldi	r19, 0x00	; 0
    5002:	87 e0       	ldi	r24, 0x07	; 7
    5004:	90 e0       	ldi	r25, 0x00	; 0
    5006:	82 1b       	sub	r24, r18
    5008:	93 0b       	sbc	r25, r19
    500a:	ea 81       	ldd	r30, Y+2	; 0x02
    500c:	fb 81       	ldd	r31, Y+3	; 0x03
    500e:	95 87       	std	Z+13, r25	; 0x0d
    5010:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    5012:	ea 81       	ldd	r30, Y+2	; 0x02
    5014:	fb 81       	ldd	r31, Y+3	; 0x03
    5016:	96 89       	ldd	r25, Z+22	; 0x16
    5018:	80 91 c6 06 	lds	r24, 0x06C6
    501c:	89 17       	cp	r24, r25
    501e:	28 f4       	brcc	.+10     	; 0x502a <xTaskPriorityDisinherit+0x9a>
    5020:	ea 81       	ldd	r30, Y+2	; 0x02
    5022:	fb 81       	ldd	r31, Y+3	; 0x03
    5024:	86 89       	ldd	r24, Z+22	; 0x16
    5026:	80 93 c6 06 	sts	0x06C6, r24
    502a:	ea 81       	ldd	r30, Y+2	; 0x02
    502c:	fb 81       	ldd	r31, Y+3	; 0x03
    502e:	86 89       	ldd	r24, Z+22	; 0x16
    5030:	28 2f       	mov	r18, r24
    5032:	30 e0       	ldi	r19, 0x00	; 0
    5034:	c9 01       	movw	r24, r18
    5036:	88 0f       	add	r24, r24
    5038:	99 1f       	adc	r25, r25
    503a:	88 0f       	add	r24, r24
    503c:	99 1f       	adc	r25, r25
    503e:	88 0f       	add	r24, r24
    5040:	99 1f       	adc	r25, r25
    5042:	82 0f       	add	r24, r18
    5044:	93 1f       	adc	r25, r19
    5046:	ac 01       	movw	r20, r24
    5048:	4f 52       	subi	r20, 0x2F	; 47
    504a:	59 4f       	sbci	r21, 0xF9	; 249
    504c:	8a 81       	ldd	r24, Y+2	; 0x02
    504e:	9b 81       	ldd	r25, Y+3	; 0x03
    5050:	9c 01       	movw	r18, r24
    5052:	2e 5f       	subi	r18, 0xFE	; 254
    5054:	3f 4f       	sbci	r19, 0xFF	; 255
    5056:	ca 01       	movw	r24, r20
    5058:	b9 01       	movw	r22, r18
    505a:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    505e:	81 e0       	ldi	r24, 0x01	; 1
    5060:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5062:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5064:	0f 90       	pop	r0
    5066:	0f 90       	pop	r0
    5068:	0f 90       	pop	r0
    506a:	0f 90       	pop	r0
    506c:	0f 90       	pop	r0
    506e:	cf 91       	pop	r28
    5070:	df 91       	pop	r29
    5072:	08 95       	ret

00005074 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5074:	df 93       	push	r29
    5076:	cf 93       	push	r28
    5078:	cd b7       	in	r28, 0x3d	; 61
    507a:	de b7       	in	r29, 0x3e	; 62
    507c:	28 97       	sbiw	r28, 0x08	; 8
    507e:	0f b6       	in	r0, 0x3f	; 63
    5080:	f8 94       	cli
    5082:	de bf       	out	0x3e, r29	; 62
    5084:	0f be       	out	0x3f, r0	; 63
    5086:	cd bf       	out	0x3d, r28	; 61
    5088:	9f 83       	std	Y+7, r25	; 0x07
    508a:	8e 83       	std	Y+6, r24	; 0x06
    508c:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    508e:	8e 81       	ldd	r24, Y+6	; 0x06
    5090:	9f 81       	ldd	r25, Y+7	; 0x07
    5092:	9d 83       	std	Y+5, r25	; 0x05
    5094:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    5096:	81 e0       	ldi	r24, 0x01	; 1
    5098:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    509a:	8e 81       	ldd	r24, Y+6	; 0x06
    509c:	9f 81       	ldd	r25, Y+7	; 0x07
    509e:	00 97       	sbiw	r24, 0x00	; 0
    50a0:	09 f4       	brne	.+2      	; 0x50a4 <vTaskPriorityDisinheritAfterTimeout+0x30>
    50a2:	74 c0       	rjmp	.+232    	; 0x518c <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    50a4:	ec 81       	ldd	r30, Y+4	; 0x04
    50a6:	fd 81       	ldd	r31, Y+5	; 0x05
    50a8:	95 a5       	ldd	r25, Z+45	; 0x2d
    50aa:	88 85       	ldd	r24, Y+8	; 0x08
    50ac:	98 17       	cp	r25, r24
    50ae:	18 f4       	brcc	.+6      	; 0x50b6 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    50b0:	88 85       	ldd	r24, Y+8	; 0x08
    50b2:	8a 83       	std	Y+2, r24	; 0x02
    50b4:	04 c0       	rjmp	.+8      	; 0x50be <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    50b6:	ec 81       	ldd	r30, Y+4	; 0x04
    50b8:	fd 81       	ldd	r31, Y+5	; 0x05
    50ba:	85 a5       	ldd	r24, Z+45	; 0x2d
    50bc:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    50be:	ec 81       	ldd	r30, Y+4	; 0x04
    50c0:	fd 81       	ldd	r31, Y+5	; 0x05
    50c2:	96 89       	ldd	r25, Z+22	; 0x16
    50c4:	8a 81       	ldd	r24, Y+2	; 0x02
    50c6:	98 17       	cp	r25, r24
    50c8:	09 f4       	brne	.+2      	; 0x50cc <vTaskPriorityDisinheritAfterTimeout+0x58>
    50ca:	60 c0       	rjmp	.+192    	; 0x518c <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    50cc:	ec 81       	ldd	r30, Y+4	; 0x04
    50ce:	fd 81       	ldd	r31, Y+5	; 0x05
    50d0:	96 a5       	ldd	r25, Z+46	; 0x2e
    50d2:	89 81       	ldd	r24, Y+1	; 0x01
    50d4:	98 17       	cp	r25, r24
    50d6:	09 f0       	breq	.+2      	; 0x50da <vTaskPriorityDisinheritAfterTimeout+0x66>
    50d8:	59 c0       	rjmp	.+178    	; 0x518c <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    50da:	ec 81       	ldd	r30, Y+4	; 0x04
    50dc:	fd 81       	ldd	r31, Y+5	; 0x05
    50de:	86 89       	ldd	r24, Z+22	; 0x16
    50e0:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    50e2:	ec 81       	ldd	r30, Y+4	; 0x04
    50e4:	fd 81       	ldd	r31, Y+5	; 0x05
    50e6:	8a 81       	ldd	r24, Y+2	; 0x02
    50e8:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    50ea:	ec 81       	ldd	r30, Y+4	; 0x04
    50ec:	fd 81       	ldd	r31, Y+5	; 0x05
    50ee:	84 85       	ldd	r24, Z+12	; 0x0c
    50f0:	95 85       	ldd	r25, Z+13	; 0x0d
    50f2:	99 23       	and	r25, r25
    50f4:	5c f0       	brlt	.+22     	; 0x510c <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    50f6:	8a 81       	ldd	r24, Y+2	; 0x02
    50f8:	28 2f       	mov	r18, r24
    50fa:	30 e0       	ldi	r19, 0x00	; 0
    50fc:	87 e0       	ldi	r24, 0x07	; 7
    50fe:	90 e0       	ldi	r25, 0x00	; 0
    5100:	82 1b       	sub	r24, r18
    5102:	93 0b       	sbc	r25, r19
    5104:	ec 81       	ldd	r30, Y+4	; 0x04
    5106:	fd 81       	ldd	r31, Y+5	; 0x05
    5108:	95 87       	std	Z+13, r25	; 0x0d
    510a:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    510c:	ec 81       	ldd	r30, Y+4	; 0x04
    510e:	fd 81       	ldd	r31, Y+5	; 0x05
    5110:	42 85       	ldd	r20, Z+10	; 0x0a
    5112:	53 85       	ldd	r21, Z+11	; 0x0b
    5114:	8b 81       	ldd	r24, Y+3	; 0x03
    5116:	28 2f       	mov	r18, r24
    5118:	30 e0       	ldi	r19, 0x00	; 0
    511a:	c9 01       	movw	r24, r18
    511c:	88 0f       	add	r24, r24
    511e:	99 1f       	adc	r25, r25
    5120:	88 0f       	add	r24, r24
    5122:	99 1f       	adc	r25, r25
    5124:	88 0f       	add	r24, r24
    5126:	99 1f       	adc	r25, r25
    5128:	82 0f       	add	r24, r18
    512a:	93 1f       	adc	r25, r19
    512c:	8f 52       	subi	r24, 0x2F	; 47
    512e:	99 4f       	sbci	r25, 0xF9	; 249
    5130:	48 17       	cp	r20, r24
    5132:	59 07       	cpc	r21, r25
    5134:	59 f5       	brne	.+86     	; 0x518c <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5136:	8c 81       	ldd	r24, Y+4	; 0x04
    5138:	9d 81       	ldd	r25, Y+5	; 0x05
    513a:	02 96       	adiw	r24, 0x02	; 2
    513c:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    5140:	ec 81       	ldd	r30, Y+4	; 0x04
    5142:	fd 81       	ldd	r31, Y+5	; 0x05
    5144:	96 89       	ldd	r25, Z+22	; 0x16
    5146:	80 91 c6 06 	lds	r24, 0x06C6
    514a:	89 17       	cp	r24, r25
    514c:	28 f4       	brcc	.+10     	; 0x5158 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    514e:	ec 81       	ldd	r30, Y+4	; 0x04
    5150:	fd 81       	ldd	r31, Y+5	; 0x05
    5152:	86 89       	ldd	r24, Z+22	; 0x16
    5154:	80 93 c6 06 	sts	0x06C6, r24
    5158:	ec 81       	ldd	r30, Y+4	; 0x04
    515a:	fd 81       	ldd	r31, Y+5	; 0x05
    515c:	86 89       	ldd	r24, Z+22	; 0x16
    515e:	28 2f       	mov	r18, r24
    5160:	30 e0       	ldi	r19, 0x00	; 0
    5162:	c9 01       	movw	r24, r18
    5164:	88 0f       	add	r24, r24
    5166:	99 1f       	adc	r25, r25
    5168:	88 0f       	add	r24, r24
    516a:	99 1f       	adc	r25, r25
    516c:	88 0f       	add	r24, r24
    516e:	99 1f       	adc	r25, r25
    5170:	82 0f       	add	r24, r18
    5172:	93 1f       	adc	r25, r19
    5174:	ac 01       	movw	r20, r24
    5176:	4f 52       	subi	r20, 0x2F	; 47
    5178:	59 4f       	sbci	r21, 0xF9	; 249
    517a:	8c 81       	ldd	r24, Y+4	; 0x04
    517c:	9d 81       	ldd	r25, Y+5	; 0x05
    517e:	9c 01       	movw	r18, r24
    5180:	2e 5f       	subi	r18, 0xFE	; 254
    5182:	3f 4f       	sbci	r19, 0xFF	; 255
    5184:	ca 01       	movw	r24, r20
    5186:	b9 01       	movw	r22, r18
    5188:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    518c:	28 96       	adiw	r28, 0x08	; 8
    518e:	0f b6       	in	r0, 0x3f	; 63
    5190:	f8 94       	cli
    5192:	de bf       	out	0x3e, r29	; 62
    5194:	0f be       	out	0x3f, r0	; 63
    5196:	cd bf       	out	0x3d, r28	; 61
    5198:	cf 91       	pop	r28
    519a:	df 91       	pop	r29
    519c:	08 95       	ret

0000519e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    519e:	df 93       	push	r29
    51a0:	cf 93       	push	r28
    51a2:	00 d0       	rcall	.+0      	; 0x51a4 <uxTaskResetEventItemValue+0x6>
    51a4:	cd b7       	in	r28, 0x3d	; 61
    51a6:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    51a8:	e0 91 c0 06 	lds	r30, 0x06C0
    51ac:	f0 91 c1 06 	lds	r31, 0x06C1
    51b0:	84 85       	ldd	r24, Z+12	; 0x0c
    51b2:	95 85       	ldd	r25, Z+13	; 0x0d
    51b4:	9a 83       	std	Y+2, r25	; 0x02
    51b6:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    51b8:	a0 91 c0 06 	lds	r26, 0x06C0
    51bc:	b0 91 c1 06 	lds	r27, 0x06C1
    51c0:	e0 91 c0 06 	lds	r30, 0x06C0
    51c4:	f0 91 c1 06 	lds	r31, 0x06C1
    51c8:	86 89       	ldd	r24, Z+22	; 0x16
    51ca:	28 2f       	mov	r18, r24
    51cc:	30 e0       	ldi	r19, 0x00	; 0
    51ce:	87 e0       	ldi	r24, 0x07	; 7
    51d0:	90 e0       	ldi	r25, 0x00	; 0
    51d2:	82 1b       	sub	r24, r18
    51d4:	93 0b       	sbc	r25, r19
    51d6:	1d 96       	adiw	r26, 0x0d	; 13
    51d8:	9c 93       	st	X, r25
    51da:	8e 93       	st	-X, r24
    51dc:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    51de:	89 81       	ldd	r24, Y+1	; 0x01
    51e0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    51e2:	0f 90       	pop	r0
    51e4:	0f 90       	pop	r0
    51e6:	cf 91       	pop	r28
    51e8:	df 91       	pop	r29
    51ea:	08 95       	ret

000051ec <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    51ec:	df 93       	push	r29
    51ee:	cf 93       	push	r28
    51f0:	cd b7       	in	r28, 0x3d	; 61
    51f2:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    51f4:	80 91 c0 06 	lds	r24, 0x06C0
    51f8:	90 91 c1 06 	lds	r25, 0x06C1
    51fc:	00 97       	sbiw	r24, 0x00	; 0
    51fe:	39 f0       	breq	.+14     	; 0x520e <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5200:	e0 91 c0 06 	lds	r30, 0x06C0
    5204:	f0 91 c1 06 	lds	r31, 0x06C1
    5208:	86 a5       	ldd	r24, Z+46	; 0x2e
    520a:	8f 5f       	subi	r24, 0xFF	; 255
    520c:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    520e:	80 91 c0 06 	lds	r24, 0x06C0
    5212:	90 91 c1 06 	lds	r25, 0x06C1
	}
    5216:	cf 91       	pop	r28
    5218:	df 91       	pop	r29
    521a:	08 95       	ret

0000521c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    521c:	df 93       	push	r29
    521e:	cf 93       	push	r28
    5220:	cd b7       	in	r28, 0x3d	; 61
    5222:	de b7       	in	r29, 0x3e	; 62
    5224:	27 97       	sbiw	r28, 0x07	; 7
    5226:	0f b6       	in	r0, 0x3f	; 63
    5228:	f8 94       	cli
    522a:	de bf       	out	0x3e, r29	; 62
    522c:	0f be       	out	0x3f, r0	; 63
    522e:	cd bf       	out	0x3d, r28	; 61
    5230:	8d 83       	std	Y+5, r24	; 0x05
    5232:	7f 83       	std	Y+7, r23	; 0x07
    5234:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5236:	0f b6       	in	r0, 0x3f	; 63
    5238:	f8 94       	cli
    523a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    523c:	e0 91 c0 06 	lds	r30, 0x06C0
    5240:	f0 91 c1 06 	lds	r31, 0x06C1
    5244:	87 a5       	ldd	r24, Z+47	; 0x2f
    5246:	90 a9       	ldd	r25, Z+48	; 0x30
    5248:	a1 a9       	ldd	r26, Z+49	; 0x31
    524a:	b2 a9       	ldd	r27, Z+50	; 0x32
    524c:	00 97       	sbiw	r24, 0x00	; 0
    524e:	a1 05       	cpc	r26, r1
    5250:	b1 05       	cpc	r27, r1
    5252:	89 f4       	brne	.+34     	; 0x5276 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5254:	e0 91 c0 06 	lds	r30, 0x06C0
    5258:	f0 91 c1 06 	lds	r31, 0x06C1
    525c:	81 e0       	ldi	r24, 0x01	; 1
    525e:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    5260:	8e 81       	ldd	r24, Y+6	; 0x06
    5262:	9f 81       	ldd	r25, Y+7	; 0x07
    5264:	00 97       	sbiw	r24, 0x00	; 0
    5266:	39 f0       	breq	.+14     	; 0x5276 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5268:	8e 81       	ldd	r24, Y+6	; 0x06
    526a:	9f 81       	ldd	r25, Y+7	; 0x07
    526c:	61 e0       	ldi	r22, 0x01	; 1
    526e:	0e 94 b6 2c 	call	0x596c	; 0x596c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5272:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5276:	0f 90       	pop	r0
    5278:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    527a:	0f b6       	in	r0, 0x3f	; 63
    527c:	f8 94       	cli
    527e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5280:	e0 91 c0 06 	lds	r30, 0x06C0
    5284:	f0 91 c1 06 	lds	r31, 0x06C1
    5288:	87 a5       	ldd	r24, Z+47	; 0x2f
    528a:	90 a9       	ldd	r25, Z+48	; 0x30
    528c:	a1 a9       	ldd	r26, Z+49	; 0x31
    528e:	b2 a9       	ldd	r27, Z+50	; 0x32
    5290:	89 83       	std	Y+1, r24	; 0x01
    5292:	9a 83       	std	Y+2, r25	; 0x02
    5294:	ab 83       	std	Y+3, r26	; 0x03
    5296:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5298:	89 81       	ldd	r24, Y+1	; 0x01
    529a:	9a 81       	ldd	r25, Y+2	; 0x02
    529c:	ab 81       	ldd	r26, Y+3	; 0x03
    529e:	bc 81       	ldd	r27, Y+4	; 0x04
    52a0:	00 97       	sbiw	r24, 0x00	; 0
    52a2:	a1 05       	cpc	r26, r1
    52a4:	b1 05       	cpc	r27, r1
    52a6:	d9 f0       	breq	.+54     	; 0x52de <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    52a8:	8d 81       	ldd	r24, Y+5	; 0x05
    52aa:	88 23       	and	r24, r24
    52ac:	49 f0       	breq	.+18     	; 0x52c0 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    52ae:	e0 91 c0 06 	lds	r30, 0x06C0
    52b2:	f0 91 c1 06 	lds	r31, 0x06C1
    52b6:	17 a6       	std	Z+47, r1	; 0x2f
    52b8:	10 aa       	std	Z+48, r1	; 0x30
    52ba:	11 aa       	std	Z+49, r1	; 0x31
    52bc:	12 aa       	std	Z+50, r1	; 0x32
    52be:	0f c0       	rjmp	.+30     	; 0x52de <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    52c0:	e0 91 c0 06 	lds	r30, 0x06C0
    52c4:	f0 91 c1 06 	lds	r31, 0x06C1
    52c8:	89 81       	ldd	r24, Y+1	; 0x01
    52ca:	9a 81       	ldd	r25, Y+2	; 0x02
    52cc:	ab 81       	ldd	r26, Y+3	; 0x03
    52ce:	bc 81       	ldd	r27, Y+4	; 0x04
    52d0:	01 97       	sbiw	r24, 0x01	; 1
    52d2:	a1 09       	sbc	r26, r1
    52d4:	b1 09       	sbc	r27, r1
    52d6:	87 a7       	std	Z+47, r24	; 0x2f
    52d8:	90 ab       	std	Z+48, r25	; 0x30
    52da:	a1 ab       	std	Z+49, r26	; 0x31
    52dc:	b2 ab       	std	Z+50, r27	; 0x32
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    52de:	e0 91 c0 06 	lds	r30, 0x06C0
    52e2:	f0 91 c1 06 	lds	r31, 0x06C1
    52e6:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    52e8:	0f 90       	pop	r0
    52ea:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    52ec:	89 81       	ldd	r24, Y+1	; 0x01
    52ee:	9a 81       	ldd	r25, Y+2	; 0x02
    52f0:	ab 81       	ldd	r26, Y+3	; 0x03
    52f2:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    52f4:	bc 01       	movw	r22, r24
    52f6:	cd 01       	movw	r24, r26
    52f8:	27 96       	adiw	r28, 0x07	; 7
    52fa:	0f b6       	in	r0, 0x3f	; 63
    52fc:	f8 94       	cli
    52fe:	de bf       	out	0x3e, r29	; 62
    5300:	0f be       	out	0x3f, r0	; 63
    5302:	cd bf       	out	0x3d, r28	; 61
    5304:	cf 91       	pop	r28
    5306:	df 91       	pop	r29
    5308:	08 95       	ret

0000530a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    530a:	ef 92       	push	r14
    530c:	ff 92       	push	r15
    530e:	0f 93       	push	r16
    5310:	1f 93       	push	r17
    5312:	df 93       	push	r29
    5314:	cf 93       	push	r28
    5316:	cd b7       	in	r28, 0x3d	; 61
    5318:	de b7       	in	r29, 0x3e	; 62
    531a:	2d 97       	sbiw	r28, 0x0d	; 13
    531c:	0f b6       	in	r0, 0x3f	; 63
    531e:	f8 94       	cli
    5320:	de bf       	out	0x3e, r29	; 62
    5322:	0f be       	out	0x3f, r0	; 63
    5324:	cd bf       	out	0x3d, r28	; 61
    5326:	6a 83       	std	Y+2, r22	; 0x02
    5328:	7b 83       	std	Y+3, r23	; 0x03
    532a:	8c 83       	std	Y+4, r24	; 0x04
    532c:	9d 83       	std	Y+5, r25	; 0x05
    532e:	2e 83       	std	Y+6, r18	; 0x06
    5330:	3f 83       	std	Y+7, r19	; 0x07
    5332:	48 87       	std	Y+8, r20	; 0x08
    5334:	59 87       	std	Y+9, r21	; 0x09
    5336:	1b 87       	std	Y+11, r17	; 0x0b
    5338:	0a 87       	std	Y+10, r16	; 0x0a
    533a:	fd 86       	std	Y+13, r15	; 0x0d
    533c:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    533e:	0f b6       	in	r0, 0x3f	; 63
    5340:	f8 94       	cli
    5342:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5344:	e0 91 c0 06 	lds	r30, 0x06C0
    5348:	f0 91 c1 06 	lds	r31, 0x06C1
    534c:	83 a9       	ldd	r24, Z+51	; 0x33
    534e:	82 30       	cpi	r24, 0x02	; 2
    5350:	49 f1       	breq	.+82     	; 0x53a4 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5352:	e0 91 c0 06 	lds	r30, 0x06C0
    5356:	f0 91 c1 06 	lds	r31, 0x06C1
    535a:	27 a5       	ldd	r18, Z+47	; 0x2f
    535c:	30 a9       	ldd	r19, Z+48	; 0x30
    535e:	41 a9       	ldd	r20, Z+49	; 0x31
    5360:	52 a9       	ldd	r21, Z+50	; 0x32
    5362:	8a 81       	ldd	r24, Y+2	; 0x02
    5364:	9b 81       	ldd	r25, Y+3	; 0x03
    5366:	ac 81       	ldd	r26, Y+4	; 0x04
    5368:	bd 81       	ldd	r27, Y+5	; 0x05
    536a:	80 95       	com	r24
    536c:	90 95       	com	r25
    536e:	a0 95       	com	r26
    5370:	b0 95       	com	r27
    5372:	82 23       	and	r24, r18
    5374:	93 23       	and	r25, r19
    5376:	a4 23       	and	r26, r20
    5378:	b5 23       	and	r27, r21
    537a:	87 a7       	std	Z+47, r24	; 0x2f
    537c:	90 ab       	std	Z+48, r25	; 0x30
    537e:	a1 ab       	std	Z+49, r26	; 0x31
    5380:	b2 ab       	std	Z+50, r27	; 0x32

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5382:	e0 91 c0 06 	lds	r30, 0x06C0
    5386:	f0 91 c1 06 	lds	r31, 0x06C1
    538a:	81 e0       	ldi	r24, 0x01	; 1
    538c:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    538e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5390:	9d 85       	ldd	r25, Y+13	; 0x0d
    5392:	00 97       	sbiw	r24, 0x00	; 0
    5394:	39 f0       	breq	.+14     	; 0x53a4 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5396:	8c 85       	ldd	r24, Y+12	; 0x0c
    5398:	9d 85       	ldd	r25, Y+13	; 0x0d
    539a:	61 e0       	ldi	r22, 0x01	; 1
    539c:	0e 94 b6 2c 	call	0x596c	; 0x596c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    53a0:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    53a4:	0f 90       	pop	r0
    53a6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    53a8:	0f b6       	in	r0, 0x3f	; 63
    53aa:	f8 94       	cli
    53ac:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    53ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    53b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    53b2:	00 97       	sbiw	r24, 0x00	; 0
    53b4:	71 f0       	breq	.+28     	; 0x53d2 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    53b6:	e0 91 c0 06 	lds	r30, 0x06C0
    53ba:	f0 91 c1 06 	lds	r31, 0x06C1
    53be:	87 a5       	ldd	r24, Z+47	; 0x2f
    53c0:	90 a9       	ldd	r25, Z+48	; 0x30
    53c2:	a1 a9       	ldd	r26, Z+49	; 0x31
    53c4:	b2 a9       	ldd	r27, Z+50	; 0x32
    53c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    53c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    53ca:	80 83       	st	Z, r24
    53cc:	91 83       	std	Z+1, r25	; 0x01
    53ce:	a2 83       	std	Z+2, r26	; 0x02
    53d0:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    53d2:	e0 91 c0 06 	lds	r30, 0x06C0
    53d6:	f0 91 c1 06 	lds	r31, 0x06C1
    53da:	83 a9       	ldd	r24, Z+51	; 0x33
    53dc:	82 30       	cpi	r24, 0x02	; 2
    53de:	11 f0       	breq	.+4      	; 0x53e4 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    53e0:	19 82       	std	Y+1, r1	; 0x01
    53e2:	1a c0       	rjmp	.+52     	; 0x5418 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    53e4:	e0 91 c0 06 	lds	r30, 0x06C0
    53e8:	f0 91 c1 06 	lds	r31, 0x06C1
    53ec:	27 a5       	ldd	r18, Z+47	; 0x2f
    53ee:	30 a9       	ldd	r19, Z+48	; 0x30
    53f0:	41 a9       	ldd	r20, Z+49	; 0x31
    53f2:	52 a9       	ldd	r21, Z+50	; 0x32
    53f4:	8e 81       	ldd	r24, Y+6	; 0x06
    53f6:	9f 81       	ldd	r25, Y+7	; 0x07
    53f8:	a8 85       	ldd	r26, Y+8	; 0x08
    53fa:	b9 85       	ldd	r27, Y+9	; 0x09
    53fc:	80 95       	com	r24
    53fe:	90 95       	com	r25
    5400:	a0 95       	com	r26
    5402:	b0 95       	com	r27
    5404:	82 23       	and	r24, r18
    5406:	93 23       	and	r25, r19
    5408:	a4 23       	and	r26, r20
    540a:	b5 23       	and	r27, r21
    540c:	87 a7       	std	Z+47, r24	; 0x2f
    540e:	90 ab       	std	Z+48, r25	; 0x30
    5410:	a1 ab       	std	Z+49, r26	; 0x31
    5412:	b2 ab       	std	Z+50, r27	; 0x32
				xReturn = pdTRUE;
    5414:	81 e0       	ldi	r24, 0x01	; 1
    5416:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5418:	e0 91 c0 06 	lds	r30, 0x06C0
    541c:	f0 91 c1 06 	lds	r31, 0x06C1
    5420:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    5422:	0f 90       	pop	r0
    5424:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5426:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5428:	2d 96       	adiw	r28, 0x0d	; 13
    542a:	0f b6       	in	r0, 0x3f	; 63
    542c:	f8 94       	cli
    542e:	de bf       	out	0x3e, r29	; 62
    5430:	0f be       	out	0x3f, r0	; 63
    5432:	cd bf       	out	0x3d, r28	; 61
    5434:	cf 91       	pop	r28
    5436:	df 91       	pop	r29
    5438:	1f 91       	pop	r17
    543a:	0f 91       	pop	r16
    543c:	ff 90       	pop	r15
    543e:	ef 90       	pop	r14
    5440:	08 95       	ret

00005442 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5442:	0f 93       	push	r16
    5444:	1f 93       	push	r17
    5446:	df 93       	push	r29
    5448:	cf 93       	push	r28
    544a:	cd b7       	in	r28, 0x3d	; 61
    544c:	de b7       	in	r29, 0x3e	; 62
    544e:	2f 97       	sbiw	r28, 0x0f	; 15
    5450:	0f b6       	in	r0, 0x3f	; 63
    5452:	f8 94       	cli
    5454:	de bf       	out	0x3e, r29	; 62
    5456:	0f be       	out	0x3f, r0	; 63
    5458:	cd bf       	out	0x3d, r28	; 61
    545a:	9e 83       	std	Y+6, r25	; 0x06
    545c:	8d 83       	std	Y+5, r24	; 0x05
    545e:	4f 83       	std	Y+7, r20	; 0x07
    5460:	58 87       	std	Y+8, r21	; 0x08
    5462:	69 87       	std	Y+9, r22	; 0x09
    5464:	7a 87       	std	Y+10, r23	; 0x0a
    5466:	2b 87       	std	Y+11, r18	; 0x0b
    5468:	1d 87       	std	Y+13, r17	; 0x0d
    546a:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    546c:	81 e0       	ldi	r24, 0x01	; 1
    546e:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5470:	8d 81       	ldd	r24, Y+5	; 0x05
    5472:	9e 81       	ldd	r25, Y+6	; 0x06
    5474:	9c 83       	std	Y+4, r25	; 0x04
    5476:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5478:	0f b6       	in	r0, 0x3f	; 63
    547a:	f8 94       	cli
    547c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    547e:	8c 85       	ldd	r24, Y+12	; 0x0c
    5480:	9d 85       	ldd	r25, Y+13	; 0x0d
    5482:	00 97       	sbiw	r24, 0x00	; 0
    5484:	61 f0       	breq	.+24     	; 0x549e <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5486:	eb 81       	ldd	r30, Y+3	; 0x03
    5488:	fc 81       	ldd	r31, Y+4	; 0x04
    548a:	87 a5       	ldd	r24, Z+47	; 0x2f
    548c:	90 a9       	ldd	r25, Z+48	; 0x30
    548e:	a1 a9       	ldd	r26, Z+49	; 0x31
    5490:	b2 a9       	ldd	r27, Z+50	; 0x32
    5492:	ec 85       	ldd	r30, Y+12	; 0x0c
    5494:	fd 85       	ldd	r31, Y+13	; 0x0d
    5496:	80 83       	st	Z, r24
    5498:	91 83       	std	Z+1, r25	; 0x01
    549a:	a2 83       	std	Z+2, r26	; 0x02
    549c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    549e:	eb 81       	ldd	r30, Y+3	; 0x03
    54a0:	fc 81       	ldd	r31, Y+4	; 0x04
    54a2:	83 a9       	ldd	r24, Z+51	; 0x33
    54a4:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    54a6:	eb 81       	ldd	r30, Y+3	; 0x03
    54a8:	fc 81       	ldd	r31, Y+4	; 0x04
    54aa:	82 e0       	ldi	r24, 0x02	; 2
    54ac:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    54ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    54b0:	28 2f       	mov	r18, r24
    54b2:	30 e0       	ldi	r19, 0x00	; 0
    54b4:	3f 87       	std	Y+15, r19	; 0x0f
    54b6:	2e 87       	std	Y+14, r18	; 0x0e
    54b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    54ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    54bc:	82 30       	cpi	r24, 0x02	; 2
    54be:	91 05       	cpc	r25, r1
    54c0:	59 f1       	breq	.+86     	; 0x5518 <xTaskGenericNotify+0xd6>
    54c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    54c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    54c6:	23 30       	cpi	r18, 0x03	; 3
    54c8:	31 05       	cpc	r19, r1
    54ca:	34 f4       	brge	.+12     	; 0x54d8 <xTaskGenericNotify+0x96>
    54cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    54ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    54d0:	81 30       	cpi	r24, 0x01	; 1
    54d2:	91 05       	cpc	r25, r1
    54d4:	61 f0       	breq	.+24     	; 0x54ee <xTaskGenericNotify+0xac>
    54d6:	4a c0       	rjmp	.+148    	; 0x556c <xTaskGenericNotify+0x12a>
    54d8:	2e 85       	ldd	r18, Y+14	; 0x0e
    54da:	3f 85       	ldd	r19, Y+15	; 0x0f
    54dc:	23 30       	cpi	r18, 0x03	; 3
    54de:	31 05       	cpc	r19, r1
    54e0:	59 f1       	breq	.+86     	; 0x5538 <xTaskGenericNotify+0xf6>
    54e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    54e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    54e6:	84 30       	cpi	r24, 0x04	; 4
    54e8:	91 05       	cpc	r25, r1
    54ea:	89 f1       	breq	.+98     	; 0x554e <xTaskGenericNotify+0x10c>
    54ec:	3f c0       	rjmp	.+126    	; 0x556c <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    54ee:	eb 81       	ldd	r30, Y+3	; 0x03
    54f0:	fc 81       	ldd	r31, Y+4	; 0x04
    54f2:	27 a5       	ldd	r18, Z+47	; 0x2f
    54f4:	30 a9       	ldd	r19, Z+48	; 0x30
    54f6:	41 a9       	ldd	r20, Z+49	; 0x31
    54f8:	52 a9       	ldd	r21, Z+50	; 0x32
    54fa:	8f 81       	ldd	r24, Y+7	; 0x07
    54fc:	98 85       	ldd	r25, Y+8	; 0x08
    54fe:	a9 85       	ldd	r26, Y+9	; 0x09
    5500:	ba 85       	ldd	r27, Y+10	; 0x0a
    5502:	82 2b       	or	r24, r18
    5504:	93 2b       	or	r25, r19
    5506:	a4 2b       	or	r26, r20
    5508:	b5 2b       	or	r27, r21
    550a:	eb 81       	ldd	r30, Y+3	; 0x03
    550c:	fc 81       	ldd	r31, Y+4	; 0x04
    550e:	87 a7       	std	Z+47, r24	; 0x2f
    5510:	90 ab       	std	Z+48, r25	; 0x30
    5512:	a1 ab       	std	Z+49, r26	; 0x31
    5514:	b2 ab       	std	Z+50, r27	; 0x32
    5516:	2a c0       	rjmp	.+84     	; 0x556c <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5518:	eb 81       	ldd	r30, Y+3	; 0x03
    551a:	fc 81       	ldd	r31, Y+4	; 0x04
    551c:	87 a5       	ldd	r24, Z+47	; 0x2f
    551e:	90 a9       	ldd	r25, Z+48	; 0x30
    5520:	a1 a9       	ldd	r26, Z+49	; 0x31
    5522:	b2 a9       	ldd	r27, Z+50	; 0x32
    5524:	01 96       	adiw	r24, 0x01	; 1
    5526:	a1 1d       	adc	r26, r1
    5528:	b1 1d       	adc	r27, r1
    552a:	eb 81       	ldd	r30, Y+3	; 0x03
    552c:	fc 81       	ldd	r31, Y+4	; 0x04
    552e:	87 a7       	std	Z+47, r24	; 0x2f
    5530:	90 ab       	std	Z+48, r25	; 0x30
    5532:	a1 ab       	std	Z+49, r26	; 0x31
    5534:	b2 ab       	std	Z+50, r27	; 0x32
    5536:	1a c0       	rjmp	.+52     	; 0x556c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5538:	eb 81       	ldd	r30, Y+3	; 0x03
    553a:	fc 81       	ldd	r31, Y+4	; 0x04
    553c:	8f 81       	ldd	r24, Y+7	; 0x07
    553e:	98 85       	ldd	r25, Y+8	; 0x08
    5540:	a9 85       	ldd	r26, Y+9	; 0x09
    5542:	ba 85       	ldd	r27, Y+10	; 0x0a
    5544:	87 a7       	std	Z+47, r24	; 0x2f
    5546:	90 ab       	std	Z+48, r25	; 0x30
    5548:	a1 ab       	std	Z+49, r26	; 0x31
    554a:	b2 ab       	std	Z+50, r27	; 0x32
    554c:	0f c0       	rjmp	.+30     	; 0x556c <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    554e:	89 81       	ldd	r24, Y+1	; 0x01
    5550:	82 30       	cpi	r24, 0x02	; 2
    5552:	59 f0       	breq	.+22     	; 0x556a <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5554:	eb 81       	ldd	r30, Y+3	; 0x03
    5556:	fc 81       	ldd	r31, Y+4	; 0x04
    5558:	8f 81       	ldd	r24, Y+7	; 0x07
    555a:	98 85       	ldd	r25, Y+8	; 0x08
    555c:	a9 85       	ldd	r26, Y+9	; 0x09
    555e:	ba 85       	ldd	r27, Y+10	; 0x0a
    5560:	87 a7       	std	Z+47, r24	; 0x2f
    5562:	90 ab       	std	Z+48, r25	; 0x30
    5564:	a1 ab       	std	Z+49, r26	; 0x31
    5566:	b2 ab       	std	Z+50, r27	; 0x32
    5568:	01 c0       	rjmp	.+2      	; 0x556c <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    556a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    556c:	89 81       	ldd	r24, Y+1	; 0x01
    556e:	81 30       	cpi	r24, 0x01	; 1
    5570:	b9 f5       	brne	.+110    	; 0x55e0 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5572:	8b 81       	ldd	r24, Y+3	; 0x03
    5574:	9c 81       	ldd	r25, Y+4	; 0x04
    5576:	02 96       	adiw	r24, 0x02	; 2
    5578:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    557c:	eb 81       	ldd	r30, Y+3	; 0x03
    557e:	fc 81       	ldd	r31, Y+4	; 0x04
    5580:	96 89       	ldd	r25, Z+22	; 0x16
    5582:	80 91 c6 06 	lds	r24, 0x06C6
    5586:	89 17       	cp	r24, r25
    5588:	28 f4       	brcc	.+10     	; 0x5594 <xTaskGenericNotify+0x152>
    558a:	eb 81       	ldd	r30, Y+3	; 0x03
    558c:	fc 81       	ldd	r31, Y+4	; 0x04
    558e:	86 89       	ldd	r24, Z+22	; 0x16
    5590:	80 93 c6 06 	sts	0x06C6, r24
    5594:	eb 81       	ldd	r30, Y+3	; 0x03
    5596:	fc 81       	ldd	r31, Y+4	; 0x04
    5598:	86 89       	ldd	r24, Z+22	; 0x16
    559a:	28 2f       	mov	r18, r24
    559c:	30 e0       	ldi	r19, 0x00	; 0
    559e:	c9 01       	movw	r24, r18
    55a0:	88 0f       	add	r24, r24
    55a2:	99 1f       	adc	r25, r25
    55a4:	88 0f       	add	r24, r24
    55a6:	99 1f       	adc	r25, r25
    55a8:	88 0f       	add	r24, r24
    55aa:	99 1f       	adc	r25, r25
    55ac:	82 0f       	add	r24, r18
    55ae:	93 1f       	adc	r25, r19
    55b0:	ac 01       	movw	r20, r24
    55b2:	4f 52       	subi	r20, 0x2F	; 47
    55b4:	59 4f       	sbci	r21, 0xF9	; 249
    55b6:	8b 81       	ldd	r24, Y+3	; 0x03
    55b8:	9c 81       	ldd	r25, Y+4	; 0x04
    55ba:	9c 01       	movw	r18, r24
    55bc:	2e 5f       	subi	r18, 0xFE	; 254
    55be:	3f 4f       	sbci	r19, 0xFF	; 255
    55c0:	ca 01       	movw	r24, r20
    55c2:	b9 01       	movw	r22, r18
    55c4:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    55c8:	eb 81       	ldd	r30, Y+3	; 0x03
    55ca:	fc 81       	ldd	r31, Y+4	; 0x04
    55cc:	96 89       	ldd	r25, Z+22	; 0x16
    55ce:	e0 91 c0 06 	lds	r30, 0x06C0
    55d2:	f0 91 c1 06 	lds	r31, 0x06C1
    55d6:	86 89       	ldd	r24, Z+22	; 0x16
    55d8:	89 17       	cp	r24, r25
    55da:	10 f4       	brcc	.+4      	; 0x55e0 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    55dc:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    55e0:	0f 90       	pop	r0
    55e2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    55e4:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    55e6:	2f 96       	adiw	r28, 0x0f	; 15
    55e8:	0f b6       	in	r0, 0x3f	; 63
    55ea:	f8 94       	cli
    55ec:	de bf       	out	0x3e, r29	; 62
    55ee:	0f be       	out	0x3f, r0	; 63
    55f0:	cd bf       	out	0x3d, r28	; 61
    55f2:	cf 91       	pop	r28
    55f4:	df 91       	pop	r29
    55f6:	1f 91       	pop	r17
    55f8:	0f 91       	pop	r16
    55fa:	08 95       	ret

000055fc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    55fc:	ef 92       	push	r14
    55fe:	ff 92       	push	r15
    5600:	0f 93       	push	r16
    5602:	1f 93       	push	r17
    5604:	df 93       	push	r29
    5606:	cf 93       	push	r28
    5608:	cd b7       	in	r28, 0x3d	; 61
    560a:	de b7       	in	r29, 0x3e	; 62
    560c:	62 97       	sbiw	r28, 0x12	; 18
    560e:	0f b6       	in	r0, 0x3f	; 63
    5610:	f8 94       	cli
    5612:	de bf       	out	0x3e, r29	; 62
    5614:	0f be       	out	0x3f, r0	; 63
    5616:	cd bf       	out	0x3d, r28	; 61
    5618:	9f 83       	std	Y+7, r25	; 0x07
    561a:	8e 83       	std	Y+6, r24	; 0x06
    561c:	48 87       	std	Y+8, r20	; 0x08
    561e:	59 87       	std	Y+9, r21	; 0x09
    5620:	6a 87       	std	Y+10, r22	; 0x0a
    5622:	7b 87       	std	Y+11, r23	; 0x0b
    5624:	2c 87       	std	Y+12, r18	; 0x0c
    5626:	1e 87       	std	Y+14, r17	; 0x0e
    5628:	0d 87       	std	Y+13, r16	; 0x0d
    562a:	f8 8a       	std	Y+16, r15	; 0x10
    562c:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    562e:	81 e0       	ldi	r24, 0x01	; 1
    5630:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5632:	8e 81       	ldd	r24, Y+6	; 0x06
    5634:	9f 81       	ldd	r25, Y+7	; 0x07
    5636:	9d 83       	std	Y+5, r25	; 0x05
    5638:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    563a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    563c:	8d 85       	ldd	r24, Y+13	; 0x0d
    563e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5640:	00 97       	sbiw	r24, 0x00	; 0
    5642:	61 f0       	breq	.+24     	; 0x565c <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5644:	ec 81       	ldd	r30, Y+4	; 0x04
    5646:	fd 81       	ldd	r31, Y+5	; 0x05
    5648:	87 a5       	ldd	r24, Z+47	; 0x2f
    564a:	90 a9       	ldd	r25, Z+48	; 0x30
    564c:	a1 a9       	ldd	r26, Z+49	; 0x31
    564e:	b2 a9       	ldd	r27, Z+50	; 0x32
    5650:	ed 85       	ldd	r30, Y+13	; 0x0d
    5652:	fe 85       	ldd	r31, Y+14	; 0x0e
    5654:	80 83       	st	Z, r24
    5656:	91 83       	std	Z+1, r25	; 0x01
    5658:	a2 83       	std	Z+2, r26	; 0x02
    565a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    565c:	ec 81       	ldd	r30, Y+4	; 0x04
    565e:	fd 81       	ldd	r31, Y+5	; 0x05
    5660:	83 a9       	ldd	r24, Z+51	; 0x33
    5662:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5664:	ec 81       	ldd	r30, Y+4	; 0x04
    5666:	fd 81       	ldd	r31, Y+5	; 0x05
    5668:	82 e0       	ldi	r24, 0x02	; 2
    566a:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    566c:	8c 85       	ldd	r24, Y+12	; 0x0c
    566e:	28 2f       	mov	r18, r24
    5670:	30 e0       	ldi	r19, 0x00	; 0
    5672:	3a 8b       	std	Y+18, r19	; 0x12
    5674:	29 8b       	std	Y+17, r18	; 0x11
    5676:	89 89       	ldd	r24, Y+17	; 0x11
    5678:	9a 89       	ldd	r25, Y+18	; 0x12
    567a:	82 30       	cpi	r24, 0x02	; 2
    567c:	91 05       	cpc	r25, r1
    567e:	59 f1       	breq	.+86     	; 0x56d6 <xTaskGenericNotifyFromISR+0xda>
    5680:	29 89       	ldd	r18, Y+17	; 0x11
    5682:	3a 89       	ldd	r19, Y+18	; 0x12
    5684:	23 30       	cpi	r18, 0x03	; 3
    5686:	31 05       	cpc	r19, r1
    5688:	34 f4       	brge	.+12     	; 0x5696 <xTaskGenericNotifyFromISR+0x9a>
    568a:	89 89       	ldd	r24, Y+17	; 0x11
    568c:	9a 89       	ldd	r25, Y+18	; 0x12
    568e:	81 30       	cpi	r24, 0x01	; 1
    5690:	91 05       	cpc	r25, r1
    5692:	61 f0       	breq	.+24     	; 0x56ac <xTaskGenericNotifyFromISR+0xb0>
    5694:	4a c0       	rjmp	.+148    	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
    5696:	29 89       	ldd	r18, Y+17	; 0x11
    5698:	3a 89       	ldd	r19, Y+18	; 0x12
    569a:	23 30       	cpi	r18, 0x03	; 3
    569c:	31 05       	cpc	r19, r1
    569e:	59 f1       	breq	.+86     	; 0x56f6 <xTaskGenericNotifyFromISR+0xfa>
    56a0:	89 89       	ldd	r24, Y+17	; 0x11
    56a2:	9a 89       	ldd	r25, Y+18	; 0x12
    56a4:	84 30       	cpi	r24, 0x04	; 4
    56a6:	91 05       	cpc	r25, r1
    56a8:	89 f1       	breq	.+98     	; 0x570c <xTaskGenericNotifyFromISR+0x110>
    56aa:	3f c0       	rjmp	.+126    	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    56ac:	ec 81       	ldd	r30, Y+4	; 0x04
    56ae:	fd 81       	ldd	r31, Y+5	; 0x05
    56b0:	27 a5       	ldd	r18, Z+47	; 0x2f
    56b2:	30 a9       	ldd	r19, Z+48	; 0x30
    56b4:	41 a9       	ldd	r20, Z+49	; 0x31
    56b6:	52 a9       	ldd	r21, Z+50	; 0x32
    56b8:	88 85       	ldd	r24, Y+8	; 0x08
    56ba:	99 85       	ldd	r25, Y+9	; 0x09
    56bc:	aa 85       	ldd	r26, Y+10	; 0x0a
    56be:	bb 85       	ldd	r27, Y+11	; 0x0b
    56c0:	82 2b       	or	r24, r18
    56c2:	93 2b       	or	r25, r19
    56c4:	a4 2b       	or	r26, r20
    56c6:	b5 2b       	or	r27, r21
    56c8:	ec 81       	ldd	r30, Y+4	; 0x04
    56ca:	fd 81       	ldd	r31, Y+5	; 0x05
    56cc:	87 a7       	std	Z+47, r24	; 0x2f
    56ce:	90 ab       	std	Z+48, r25	; 0x30
    56d0:	a1 ab       	std	Z+49, r26	; 0x31
    56d2:	b2 ab       	std	Z+50, r27	; 0x32
    56d4:	2a c0       	rjmp	.+84     	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    56d6:	ec 81       	ldd	r30, Y+4	; 0x04
    56d8:	fd 81       	ldd	r31, Y+5	; 0x05
    56da:	87 a5       	ldd	r24, Z+47	; 0x2f
    56dc:	90 a9       	ldd	r25, Z+48	; 0x30
    56de:	a1 a9       	ldd	r26, Z+49	; 0x31
    56e0:	b2 a9       	ldd	r27, Z+50	; 0x32
    56e2:	01 96       	adiw	r24, 0x01	; 1
    56e4:	a1 1d       	adc	r26, r1
    56e6:	b1 1d       	adc	r27, r1
    56e8:	ec 81       	ldd	r30, Y+4	; 0x04
    56ea:	fd 81       	ldd	r31, Y+5	; 0x05
    56ec:	87 a7       	std	Z+47, r24	; 0x2f
    56ee:	90 ab       	std	Z+48, r25	; 0x30
    56f0:	a1 ab       	std	Z+49, r26	; 0x31
    56f2:	b2 ab       	std	Z+50, r27	; 0x32
    56f4:	1a c0       	rjmp	.+52     	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    56f6:	ec 81       	ldd	r30, Y+4	; 0x04
    56f8:	fd 81       	ldd	r31, Y+5	; 0x05
    56fa:	88 85       	ldd	r24, Y+8	; 0x08
    56fc:	99 85       	ldd	r25, Y+9	; 0x09
    56fe:	aa 85       	ldd	r26, Y+10	; 0x0a
    5700:	bb 85       	ldd	r27, Y+11	; 0x0b
    5702:	87 a7       	std	Z+47, r24	; 0x2f
    5704:	90 ab       	std	Z+48, r25	; 0x30
    5706:	a1 ab       	std	Z+49, r26	; 0x31
    5708:	b2 ab       	std	Z+50, r27	; 0x32
    570a:	0f c0       	rjmp	.+30     	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    570c:	8b 81       	ldd	r24, Y+3	; 0x03
    570e:	82 30       	cpi	r24, 0x02	; 2
    5710:	59 f0       	breq	.+22     	; 0x5728 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5712:	ec 81       	ldd	r30, Y+4	; 0x04
    5714:	fd 81       	ldd	r31, Y+5	; 0x05
    5716:	88 85       	ldd	r24, Y+8	; 0x08
    5718:	99 85       	ldd	r25, Y+9	; 0x09
    571a:	aa 85       	ldd	r26, Y+10	; 0x0a
    571c:	bb 85       	ldd	r27, Y+11	; 0x0b
    571e:	87 a7       	std	Z+47, r24	; 0x2f
    5720:	90 ab       	std	Z+48, r25	; 0x30
    5722:	a1 ab       	std	Z+49, r26	; 0x31
    5724:	b2 ab       	std	Z+50, r27	; 0x32
    5726:	01 c0       	rjmp	.+2      	; 0x572a <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5728:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    572a:	8b 81       	ldd	r24, Y+3	; 0x03
    572c:	81 30       	cpi	r24, 0x01	; 1
    572e:	09 f0       	breq	.+2      	; 0x5732 <xTaskGenericNotifyFromISR+0x136>
    5730:	4f c0       	rjmp	.+158    	; 0x57d0 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5732:	80 91 d0 06 	lds	r24, 0x06D0
    5736:	88 23       	and	r24, r24
    5738:	61 f5       	brne	.+88     	; 0x5792 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    573a:	8c 81       	ldd	r24, Y+4	; 0x04
    573c:	9d 81       	ldd	r25, Y+5	; 0x05
    573e:	02 96       	adiw	r24, 0x02	; 2
    5740:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5744:	ec 81       	ldd	r30, Y+4	; 0x04
    5746:	fd 81       	ldd	r31, Y+5	; 0x05
    5748:	96 89       	ldd	r25, Z+22	; 0x16
    574a:	80 91 c6 06 	lds	r24, 0x06C6
    574e:	89 17       	cp	r24, r25
    5750:	28 f4       	brcc	.+10     	; 0x575c <xTaskGenericNotifyFromISR+0x160>
    5752:	ec 81       	ldd	r30, Y+4	; 0x04
    5754:	fd 81       	ldd	r31, Y+5	; 0x05
    5756:	86 89       	ldd	r24, Z+22	; 0x16
    5758:	80 93 c6 06 	sts	0x06C6, r24
    575c:	ec 81       	ldd	r30, Y+4	; 0x04
    575e:	fd 81       	ldd	r31, Y+5	; 0x05
    5760:	86 89       	ldd	r24, Z+22	; 0x16
    5762:	28 2f       	mov	r18, r24
    5764:	30 e0       	ldi	r19, 0x00	; 0
    5766:	c9 01       	movw	r24, r18
    5768:	88 0f       	add	r24, r24
    576a:	99 1f       	adc	r25, r25
    576c:	88 0f       	add	r24, r24
    576e:	99 1f       	adc	r25, r25
    5770:	88 0f       	add	r24, r24
    5772:	99 1f       	adc	r25, r25
    5774:	82 0f       	add	r24, r18
    5776:	93 1f       	adc	r25, r19
    5778:	ac 01       	movw	r20, r24
    577a:	4f 52       	subi	r20, 0x2F	; 47
    577c:	59 4f       	sbci	r21, 0xF9	; 249
    577e:	8c 81       	ldd	r24, Y+4	; 0x04
    5780:	9d 81       	ldd	r25, Y+5	; 0x05
    5782:	9c 01       	movw	r18, r24
    5784:	2e 5f       	subi	r18, 0xFE	; 254
    5786:	3f 4f       	sbci	r19, 0xFF	; 255
    5788:	ca 01       	movw	r24, r20
    578a:	b9 01       	movw	r22, r18
    578c:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    5790:	0a c0       	rjmp	.+20     	; 0x57a6 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5792:	8c 81       	ldd	r24, Y+4	; 0x04
    5794:	9d 81       	ldd	r25, Y+5	; 0x05
    5796:	9c 01       	movw	r18, r24
    5798:	24 5f       	subi	r18, 0xF4	; 244
    579a:	3f 4f       	sbci	r19, 0xFF	; 255
    579c:	86 e2       	ldi	r24, 0x26	; 38
    579e:	97 e0       	ldi	r25, 0x07	; 7
    57a0:	b9 01       	movw	r22, r18
    57a2:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    57a6:	ec 81       	ldd	r30, Y+4	; 0x04
    57a8:	fd 81       	ldd	r31, Y+5	; 0x05
    57aa:	96 89       	ldd	r25, Z+22	; 0x16
    57ac:	e0 91 c0 06 	lds	r30, 0x06C0
    57b0:	f0 91 c1 06 	lds	r31, 0x06C1
    57b4:	86 89       	ldd	r24, Z+22	; 0x16
    57b6:	89 17       	cp	r24, r25
    57b8:	58 f4       	brcc	.+22     	; 0x57d0 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    57ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    57bc:	98 89       	ldd	r25, Y+16	; 0x10
    57be:	00 97       	sbiw	r24, 0x00	; 0
    57c0:	21 f0       	breq	.+8      	; 0x57ca <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    57c2:	ef 85       	ldd	r30, Y+15	; 0x0f
    57c4:	f8 89       	ldd	r31, Y+16	; 0x10
    57c6:	81 e0       	ldi	r24, 0x01	; 1
    57c8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    57ca:	81 e0       	ldi	r24, 0x01	; 1
    57cc:	80 93 c9 06 	sts	0x06C9, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    57d0:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    57d2:	62 96       	adiw	r28, 0x12	; 18
    57d4:	0f b6       	in	r0, 0x3f	; 63
    57d6:	f8 94       	cli
    57d8:	de bf       	out	0x3e, r29	; 62
    57da:	0f be       	out	0x3f, r0	; 63
    57dc:	cd bf       	out	0x3d, r28	; 61
    57de:	cf 91       	pop	r28
    57e0:	df 91       	pop	r29
    57e2:	1f 91       	pop	r17
    57e4:	0f 91       	pop	r16
    57e6:	ff 90       	pop	r15
    57e8:	ef 90       	pop	r14
    57ea:	08 95       	ret

000057ec <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    57ec:	df 93       	push	r29
    57ee:	cf 93       	push	r28
    57f0:	cd b7       	in	r28, 0x3d	; 61
    57f2:	de b7       	in	r29, 0x3e	; 62
    57f4:	28 97       	sbiw	r28, 0x08	; 8
    57f6:	0f b6       	in	r0, 0x3f	; 63
    57f8:	f8 94       	cli
    57fa:	de bf       	out	0x3e, r29	; 62
    57fc:	0f be       	out	0x3f, r0	; 63
    57fe:	cd bf       	out	0x3d, r28	; 61
    5800:	9e 83       	std	Y+6, r25	; 0x06
    5802:	8d 83       	std	Y+5, r24	; 0x05
    5804:	78 87       	std	Y+8, r23	; 0x08
    5806:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5808:	8d 81       	ldd	r24, Y+5	; 0x05
    580a:	9e 81       	ldd	r25, Y+6	; 0x06
    580c:	9c 83       	std	Y+4, r25	; 0x04
    580e:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5810:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5812:	eb 81       	ldd	r30, Y+3	; 0x03
    5814:	fc 81       	ldd	r31, Y+4	; 0x04
    5816:	83 a9       	ldd	r24, Z+51	; 0x33
    5818:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    581a:	eb 81       	ldd	r30, Y+3	; 0x03
    581c:	fc 81       	ldd	r31, Y+4	; 0x04
    581e:	82 e0       	ldi	r24, 0x02	; 2
    5820:	83 ab       	std	Z+51, r24	; 0x33

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5822:	eb 81       	ldd	r30, Y+3	; 0x03
    5824:	fc 81       	ldd	r31, Y+4	; 0x04
    5826:	87 a5       	ldd	r24, Z+47	; 0x2f
    5828:	90 a9       	ldd	r25, Z+48	; 0x30
    582a:	a1 a9       	ldd	r26, Z+49	; 0x31
    582c:	b2 a9       	ldd	r27, Z+50	; 0x32
    582e:	01 96       	adiw	r24, 0x01	; 1
    5830:	a1 1d       	adc	r26, r1
    5832:	b1 1d       	adc	r27, r1
    5834:	eb 81       	ldd	r30, Y+3	; 0x03
    5836:	fc 81       	ldd	r31, Y+4	; 0x04
    5838:	87 a7       	std	Z+47, r24	; 0x2f
    583a:	90 ab       	std	Z+48, r25	; 0x30
    583c:	a1 ab       	std	Z+49, r26	; 0x31
    583e:	b2 ab       	std	Z+50, r27	; 0x32

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5840:	8a 81       	ldd	r24, Y+2	; 0x02
    5842:	81 30       	cpi	r24, 0x01	; 1
    5844:	09 f0       	breq	.+2      	; 0x5848 <vTaskNotifyGiveFromISR+0x5c>
    5846:	4f c0       	rjmp	.+158    	; 0x58e6 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5848:	80 91 d0 06 	lds	r24, 0x06D0
    584c:	88 23       	and	r24, r24
    584e:	61 f5       	brne	.+88     	; 0x58a8 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5850:	8b 81       	ldd	r24, Y+3	; 0x03
    5852:	9c 81       	ldd	r25, Y+4	; 0x04
    5854:	02 96       	adiw	r24, 0x02	; 2
    5856:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    585a:	eb 81       	ldd	r30, Y+3	; 0x03
    585c:	fc 81       	ldd	r31, Y+4	; 0x04
    585e:	96 89       	ldd	r25, Z+22	; 0x16
    5860:	80 91 c6 06 	lds	r24, 0x06C6
    5864:	89 17       	cp	r24, r25
    5866:	28 f4       	brcc	.+10     	; 0x5872 <vTaskNotifyGiveFromISR+0x86>
    5868:	eb 81       	ldd	r30, Y+3	; 0x03
    586a:	fc 81       	ldd	r31, Y+4	; 0x04
    586c:	86 89       	ldd	r24, Z+22	; 0x16
    586e:	80 93 c6 06 	sts	0x06C6, r24
    5872:	eb 81       	ldd	r30, Y+3	; 0x03
    5874:	fc 81       	ldd	r31, Y+4	; 0x04
    5876:	86 89       	ldd	r24, Z+22	; 0x16
    5878:	28 2f       	mov	r18, r24
    587a:	30 e0       	ldi	r19, 0x00	; 0
    587c:	c9 01       	movw	r24, r18
    587e:	88 0f       	add	r24, r24
    5880:	99 1f       	adc	r25, r25
    5882:	88 0f       	add	r24, r24
    5884:	99 1f       	adc	r25, r25
    5886:	88 0f       	add	r24, r24
    5888:	99 1f       	adc	r25, r25
    588a:	82 0f       	add	r24, r18
    588c:	93 1f       	adc	r25, r19
    588e:	ac 01       	movw	r20, r24
    5890:	4f 52       	subi	r20, 0x2F	; 47
    5892:	59 4f       	sbci	r21, 0xF9	; 249
    5894:	8b 81       	ldd	r24, Y+3	; 0x03
    5896:	9c 81       	ldd	r25, Y+4	; 0x04
    5898:	9c 01       	movw	r18, r24
    589a:	2e 5f       	subi	r18, 0xFE	; 254
    589c:	3f 4f       	sbci	r19, 0xFF	; 255
    589e:	ca 01       	movw	r24, r20
    58a0:	b9 01       	movw	r22, r18
    58a2:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    58a6:	0a c0       	rjmp	.+20     	; 0x58bc <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    58a8:	8b 81       	ldd	r24, Y+3	; 0x03
    58aa:	9c 81       	ldd	r25, Y+4	; 0x04
    58ac:	9c 01       	movw	r18, r24
    58ae:	24 5f       	subi	r18, 0xF4	; 244
    58b0:	3f 4f       	sbci	r19, 0xFF	; 255
    58b2:	86 e2       	ldi	r24, 0x26	; 38
    58b4:	97 e0       	ldi	r25, 0x07	; 7
    58b6:	b9 01       	movw	r22, r18
    58b8:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    58bc:	eb 81       	ldd	r30, Y+3	; 0x03
    58be:	fc 81       	ldd	r31, Y+4	; 0x04
    58c0:	96 89       	ldd	r25, Z+22	; 0x16
    58c2:	e0 91 c0 06 	lds	r30, 0x06C0
    58c6:	f0 91 c1 06 	lds	r31, 0x06C1
    58ca:	86 89       	ldd	r24, Z+22	; 0x16
    58cc:	89 17       	cp	r24, r25
    58ce:	58 f4       	brcc	.+22     	; 0x58e6 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    58d0:	8f 81       	ldd	r24, Y+7	; 0x07
    58d2:	98 85       	ldd	r25, Y+8	; 0x08
    58d4:	00 97       	sbiw	r24, 0x00	; 0
    58d6:	21 f0       	breq	.+8      	; 0x58e0 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    58d8:	ef 81       	ldd	r30, Y+7	; 0x07
    58da:	f8 85       	ldd	r31, Y+8	; 0x08
    58dc:	81 e0       	ldi	r24, 0x01	; 1
    58de:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    58e0:	81 e0       	ldi	r24, 0x01	; 1
    58e2:	80 93 c9 06 	sts	0x06C9, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    58e6:	28 96       	adiw	r28, 0x08	; 8
    58e8:	0f b6       	in	r0, 0x3f	; 63
    58ea:	f8 94       	cli
    58ec:	de bf       	out	0x3e, r29	; 62
    58ee:	0f be       	out	0x3f, r0	; 63
    58f0:	cd bf       	out	0x3d, r28	; 61
    58f2:	cf 91       	pop	r28
    58f4:	df 91       	pop	r29
    58f6:	08 95       	ret

000058f8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    58f8:	df 93       	push	r29
    58fa:	cf 93       	push	r28
    58fc:	cd b7       	in	r28, 0x3d	; 61
    58fe:	de b7       	in	r29, 0x3e	; 62
    5900:	27 97       	sbiw	r28, 0x07	; 7
    5902:	0f b6       	in	r0, 0x3f	; 63
    5904:	f8 94       	cli
    5906:	de bf       	out	0x3e, r29	; 62
    5908:	0f be       	out	0x3f, r0	; 63
    590a:	cd bf       	out	0x3d, r28	; 61
    590c:	9d 83       	std	Y+5, r25	; 0x05
    590e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5910:	8c 81       	ldd	r24, Y+4	; 0x04
    5912:	9d 81       	ldd	r25, Y+5	; 0x05
    5914:	00 97       	sbiw	r24, 0x00	; 0
    5916:	39 f4       	brne	.+14     	; 0x5926 <xTaskNotifyStateClear+0x2e>
    5918:	80 91 c0 06 	lds	r24, 0x06C0
    591c:	90 91 c1 06 	lds	r25, 0x06C1
    5920:	9f 83       	std	Y+7, r25	; 0x07
    5922:	8e 83       	std	Y+6, r24	; 0x06
    5924:	04 c0       	rjmp	.+8      	; 0x592e <xTaskNotifyStateClear+0x36>
    5926:	8c 81       	ldd	r24, Y+4	; 0x04
    5928:	9d 81       	ldd	r25, Y+5	; 0x05
    592a:	9f 83       	std	Y+7, r25	; 0x07
    592c:	8e 83       	std	Y+6, r24	; 0x06
    592e:	8e 81       	ldd	r24, Y+6	; 0x06
    5930:	9f 81       	ldd	r25, Y+7	; 0x07
    5932:	9b 83       	std	Y+3, r25	; 0x03
    5934:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5936:	0f b6       	in	r0, 0x3f	; 63
    5938:	f8 94       	cli
    593a:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    593c:	ea 81       	ldd	r30, Y+2	; 0x02
    593e:	fb 81       	ldd	r31, Y+3	; 0x03
    5940:	83 a9       	ldd	r24, Z+51	; 0x33
    5942:	82 30       	cpi	r24, 0x02	; 2
    5944:	31 f4       	brne	.+12     	; 0x5952 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5946:	ea 81       	ldd	r30, Y+2	; 0x02
    5948:	fb 81       	ldd	r31, Y+3	; 0x03
    594a:	13 aa       	std	Z+51, r1	; 0x33
				xReturn = pdPASS;
    594c:	81 e0       	ldi	r24, 0x01	; 1
    594e:	89 83       	std	Y+1, r24	; 0x01
    5950:	01 c0       	rjmp	.+2      	; 0x5954 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5952:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5954:	0f 90       	pop	r0
    5956:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5958:	89 81       	ldd	r24, Y+1	; 0x01
	}
    595a:	27 96       	adiw	r28, 0x07	; 7
    595c:	0f b6       	in	r0, 0x3f	; 63
    595e:	f8 94       	cli
    5960:	de bf       	out	0x3e, r29	; 62
    5962:	0f be       	out	0x3f, r0	; 63
    5964:	cd bf       	out	0x3d, r28	; 61
    5966:	cf 91       	pop	r28
    5968:	df 91       	pop	r29
    596a:	08 95       	ret

0000596c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    596c:	df 93       	push	r29
    596e:	cf 93       	push	r28
    5970:	cd b7       	in	r28, 0x3d	; 61
    5972:	de b7       	in	r29, 0x3e	; 62
    5974:	27 97       	sbiw	r28, 0x07	; 7
    5976:	0f b6       	in	r0, 0x3f	; 63
    5978:	f8 94       	cli
    597a:	de bf       	out	0x3e, r29	; 62
    597c:	0f be       	out	0x3f, r0	; 63
    597e:	cd bf       	out	0x3d, r28	; 61
    5980:	9e 83       	std	Y+6, r25	; 0x06
    5982:	8d 83       	std	Y+5, r24	; 0x05
    5984:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5986:	80 91 c4 06 	lds	r24, 0x06C4
    598a:	90 91 c5 06 	lds	r25, 0x06C5
    598e:	9a 83       	std	Y+2, r25	; 0x02
    5990:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5992:	80 91 c0 06 	lds	r24, 0x06C0
    5996:	90 91 c1 06 	lds	r25, 0x06C1
    599a:	02 96       	adiw	r24, 0x02	; 2
    599c:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    59a0:	8d 81       	ldd	r24, Y+5	; 0x05
    59a2:	9e 81       	ldd	r25, Y+6	; 0x06
    59a4:	2f ef       	ldi	r18, 0xFF	; 255
    59a6:	8f 3f       	cpi	r24, 0xFF	; 255
    59a8:	92 07       	cpc	r25, r18
    59aa:	81 f4       	brne	.+32     	; 0x59cc <prvAddCurrentTaskToDelayedList+0x60>
    59ac:	8f 81       	ldd	r24, Y+7	; 0x07
    59ae:	88 23       	and	r24, r24
    59b0:	69 f0       	breq	.+26     	; 0x59cc <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    59b2:	80 91 c0 06 	lds	r24, 0x06C0
    59b6:	90 91 c1 06 	lds	r25, 0x06C1
    59ba:	9c 01       	movw	r18, r24
    59bc:	2e 5f       	subi	r18, 0xFE	; 254
    59be:	3f 4f       	sbci	r19, 0xFF	; 255
    59c0:	88 e3       	ldi	r24, 0x38	; 56
    59c2:	97 e0       	ldi	r25, 0x07	; 7
    59c4:	b9 01       	movw	r22, r18
    59c6:	0e 94 08 0b 	call	0x1610	; 0x1610 <vListInsertEnd>
    59ca:	43 c0       	rjmp	.+134    	; 0x5a52 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    59cc:	29 81       	ldd	r18, Y+1	; 0x01
    59ce:	3a 81       	ldd	r19, Y+2	; 0x02
    59d0:	8d 81       	ldd	r24, Y+5	; 0x05
    59d2:	9e 81       	ldd	r25, Y+6	; 0x06
    59d4:	82 0f       	add	r24, r18
    59d6:	93 1f       	adc	r25, r19
    59d8:	9c 83       	std	Y+4, r25	; 0x04
    59da:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    59dc:	e0 91 c0 06 	lds	r30, 0x06C0
    59e0:	f0 91 c1 06 	lds	r31, 0x06C1
    59e4:	8b 81       	ldd	r24, Y+3	; 0x03
    59e6:	9c 81       	ldd	r25, Y+4	; 0x04
    59e8:	93 83       	std	Z+3, r25	; 0x03
    59ea:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    59ec:	2b 81       	ldd	r18, Y+3	; 0x03
    59ee:	3c 81       	ldd	r19, Y+4	; 0x04
    59f0:	89 81       	ldd	r24, Y+1	; 0x01
    59f2:	9a 81       	ldd	r25, Y+2	; 0x02
    59f4:	28 17       	cp	r18, r24
    59f6:	39 07       	cpc	r19, r25
    59f8:	70 f4       	brcc	.+28     	; 0x5a16 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    59fa:	80 91 24 07 	lds	r24, 0x0724
    59fe:	90 91 25 07 	lds	r25, 0x0725
    5a02:	20 91 c0 06 	lds	r18, 0x06C0
    5a06:	30 91 c1 06 	lds	r19, 0x06C1
    5a0a:	2e 5f       	subi	r18, 0xFE	; 254
    5a0c:	3f 4f       	sbci	r19, 0xFF	; 255
    5a0e:	b9 01       	movw	r22, r18
    5a10:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInsert>
    5a14:	1e c0       	rjmp	.+60     	; 0x5a52 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5a16:	40 91 22 07 	lds	r20, 0x0722
    5a1a:	50 91 23 07 	lds	r21, 0x0723
    5a1e:	80 91 c0 06 	lds	r24, 0x06C0
    5a22:	90 91 c1 06 	lds	r25, 0x06C1
    5a26:	9c 01       	movw	r18, r24
    5a28:	2e 5f       	subi	r18, 0xFE	; 254
    5a2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a2c:	ca 01       	movw	r24, r20
    5a2e:	b9 01       	movw	r22, r18
    5a30:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5a34:	20 91 cc 06 	lds	r18, 0x06CC
    5a38:	30 91 cd 06 	lds	r19, 0x06CD
    5a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a40:	82 17       	cp	r24, r18
    5a42:	93 07       	cpc	r25, r19
    5a44:	30 f4       	brcc	.+12     	; 0x5a52 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5a46:	8b 81       	ldd	r24, Y+3	; 0x03
    5a48:	9c 81       	ldd	r25, Y+4	; 0x04
    5a4a:	90 93 cd 06 	sts	0x06CD, r25
    5a4e:	80 93 cc 06 	sts	0x06CC, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5a52:	27 96       	adiw	r28, 0x07	; 7
    5a54:	0f b6       	in	r0, 0x3f	; 63
    5a56:	f8 94       	cli
    5a58:	de bf       	out	0x3e, r29	; 62
    5a5a:	0f be       	out	0x3f, r0	; 63
    5a5c:	cd bf       	out	0x3d, r28	; 61
    5a5e:	cf 91       	pop	r28
    5a60:	df 91       	pop	r29
    5a62:	08 95       	ret

00005a64 <memcpy>:
    5a64:	fb 01       	movw	r30, r22
    5a66:	dc 01       	movw	r26, r24
    5a68:	02 c0       	rjmp	.+4      	; 0x5a6e <memcpy+0xa>
    5a6a:	01 90       	ld	r0, Z+
    5a6c:	0d 92       	st	X+, r0
    5a6e:	41 50       	subi	r20, 0x01	; 1
    5a70:	50 40       	sbci	r21, 0x00	; 0
    5a72:	d8 f7       	brcc	.-10     	; 0x5a6a <memcpy+0x6>
    5a74:	08 95       	ret

00005a76 <memset>:
    5a76:	dc 01       	movw	r26, r24
    5a78:	01 c0       	rjmp	.+2      	; 0x5a7c <memset+0x6>
    5a7a:	6d 93       	st	X+, r22
    5a7c:	41 50       	subi	r20, 0x01	; 1
    5a7e:	50 40       	sbci	r21, 0x00	; 0
    5a80:	e0 f7       	brcc	.-8      	; 0x5a7a <memset+0x4>
    5a82:	08 95       	ret

00005a84 <_exit>:
    5a84:	f8 94       	cli

00005a86 <__stop_program>:
    5a86:	ff cf       	rjmp	.-2      	; 0x5a86 <__stop_program>
