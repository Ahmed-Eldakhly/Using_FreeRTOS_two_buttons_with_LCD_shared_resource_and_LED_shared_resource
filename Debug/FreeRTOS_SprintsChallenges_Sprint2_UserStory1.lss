
FreeRTOS_SprintsChallenges_Sprint2_UserStory1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000053a2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000060  00800060  000053a2  00005436  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  008000c0  008000c0  00005496  2**0
                  ALLOC
  3 .stab         00008cc4  00000000  00000000  00005498  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000491e  00000000  00000000  0000e15c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ed 0d 	jmp	0x1bda	; 0x1bda <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ea       	ldi	r30, 0xA2	; 162
      68:	f3 e5       	ldi	r31, 0x53	; 83
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3c       	cpi	r26, 0xC0	; 192
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 ec       	ldi	r26, 0xC0	; 192
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 31       	cpi	r26, 0x17	; 23
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <main>
      8a:	0c 94 cf 29 	jmp	0x539e	; 0x539e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 0)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	88 23       	and	r24, r24
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 0)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	88 23       	and	r24, r24
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	MessageQueue_PushButton= xQueueCreate( 3 , sizeof(uint8));
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 76 0e 	call	0x1cec	; 0x1cec <xQueueGenericCreate>
     5a4:	90 93 c5 00 	sts	0x00C5, r25
     5a8:	80 93 c4 00 	sts	0x00C4, r24
	MessageQueue_Hello= xQueueCreate( 3 , sizeof(uint8));
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 76 0e 	call	0x1cec	; 0x1cec <xQueueGenericCreate>
     5b6:	90 93 c7 00 	sts	0x00C7, r25
     5ba:	80 93 c6 00 	sts	0x00C6, r24

	/*Create 3 Tasks*/
	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     5be:	86 e2       	ldi	r24, 0x26	; 38
     5c0:	93 e0       	ldi	r25, 0x03	; 3
     5c2:	20 e6       	ldi	r18, 0x60	; 96
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	e0 ec       	ldi	r30, 0xC0	; 192
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	b9 01       	movw	r22, r18
     5cc:	46 e9       	ldi	r20, 0x96	; 150
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	05 e0       	ldi	r16, 0x05	; 5
     5d6:	7f 01       	movw	r14, r30
     5d8:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(PushButton_Task  , "PushButton_Task" , configMINIMAL_STACK_SIZE ,
     5dc:	88 e3       	ldi	r24, 0x38	; 56
     5de:	93 e0       	ldi	r25, 0x03	; 3
     5e0:	2a e6       	ldi	r18, 0x6A	; 106
     5e2:	30 e0       	ldi	r19, 0x00	; 0
     5e4:	b9 01       	movw	r22, r18
     5e6:	46 e9       	ldi	r20, 0x96	; 150
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	03 e0       	ldi	r16, 0x03	; 3
     5f0:	ee 24       	eor	r14, r14
     5f2:	ff 24       	eor	r15, r15
     5f4:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     5f8:	82 ea       	ldi	r24, 0xA2	; 162
     5fa:	93 e0       	ldi	r25, 0x03	; 3
     5fc:	2a e7       	ldi	r18, 0x7A	; 122
     5fe:	30 e0       	ldi	r19, 0x00	; 0
     600:	b9 01       	movw	r22, r18
     602:	46 e9       	ldi	r20, 0x96	; 150
     604:	50 e0       	ldi	r21, 0x00	; 0
     606:	20 e0       	ldi	r18, 0x00	; 0
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	01 e0       	ldi	r16, 0x01	; 1
     60c:	ee 24       	eor	r14, r14
     60e:	ff 24       	eor	r15, r15
     610:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(SendHallo_Task  , "SendHallo_Task" , configMINIMAL_STACK_SIZE ,
     614:	83 e6       	ldi	r24, 0x63	; 99
     616:	94 e0       	ldi	r25, 0x04	; 4
     618:	23 e8       	ldi	r18, 0x83	; 131
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	b9 01       	movw	r22, r18
     61e:	46 e9       	ldi	r20, 0x96	; 150
     620:	50 e0       	ldi	r21, 0x00	; 0
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	02 e0       	ldi	r16, 0x02	; 2
     628:	ee 24       	eor	r14, r14
     62a:	ff 24       	eor	r15, r15
     62c:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     630:	80 91 c2 00 	lds	r24, 0x00C2
     634:	90 91 c3 00 	lds	r25, 0x00C3
     638:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <vTaskSuspend>
}
     63c:	0f 90       	pop	r0
     63e:	0f 90       	pop	r0
     640:	cf 91       	pop	r28
     642:	df 91       	pop	r29
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	08 95       	ret

0000064c <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     64c:	df 93       	push	r29
     64e:	cf 93       	push	r28
     650:	00 d0       	rcall	.+0      	; 0x652 <All_Hardware_Init_Task+0x6>
     652:	cd b7       	in	r28, 0x3d	; 61
     654:	de b7       	in	r29, 0x3e	; 62
     656:	9a 83       	std	Y+2, r25	; 0x02
     658:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		PushButton_Init();
     65a:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     65e:	0e 94 40 08 	call	0x1080	; 0x1080 <LCD_init>
		vTaskSuspend( AllHardwareInit_Flag);
     662:	80 91 c0 00 	lds	r24, 0x00C0
     666:	90 91 c1 00 	lds	r25, 0x00C1
     66a:	0e 94 e6 1e 	call	0x3dcc	; 0x3dcc <vTaskSuspend>
     66e:	f5 cf       	rjmp	.-22     	; 0x65a <All_Hardware_Init_Task+0xe>

00000670 <PushButton_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButton_Task(void * a_Task_ptr)
{
     670:	df 93       	push	r29
     672:	cf 93       	push	r28
     674:	00 d0       	rcall	.+0      	; 0x676 <PushButton_Task+0x6>
     676:	00 d0       	rcall	.+0      	; 0x678 <PushButton_Task+0x8>
     678:	0f 92       	push	r0
     67a:	cd b7       	in	r28, 0x3d	; 61
     67c:	de b7       	in	r29, 0x3e	; 62
     67e:	9d 83       	std	Y+5, r25	; 0x05
     680:	8c 83       	std	Y+4, r24	; 0x04
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     686:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     688:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     68a:	8a 81       	ldd	r24, Y+2	; 0x02
     68c:	88 23       	and	r24, r24
     68e:	79 f4       	brne	.+30     	; 0x6ae <PushButton_Task+0x3e>
     690:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     694:	81 30       	cpi	r24, 0x01	; 1
     696:	59 f4       	brne	.+22     	; 0x6ae <PushButton_Task+0x3e>
		{
			OldPressedValue =  Buttons_getPressedButton();
     698:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     69c:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	8f 5f       	subi	r24, 0xFF	; 255
     6a2:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6a4:	8a e0       	ldi	r24, 0x0A	; 10
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
     6ac:	ee cf       	rjmp	.-36     	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 1)
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	81 30       	cpi	r24, 0x01	; 1
     6b2:	09 f5       	brne	.+66     	; 0x6f6 <PushButton_Task+0x86>
     6b4:	13 c0       	rjmp	.+38     	; 0x6dc <PushButton_Task+0x6c>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				SendData = 1;
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	8b 83       	std	Y+3, r24	; 0x03
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(MessageQueue_PushButton , &SendData , 100);
     6ba:	80 91 c4 00 	lds	r24, 0x00C4
     6be:	90 91 c5 00 	lds	r25, 0x00C5
     6c2:	9e 01       	movw	r18, r28
     6c4:	2d 5f       	subi	r18, 0xFD	; 253
     6c6:	3f 4f       	sbci	r19, 0xFF	; 255
     6c8:	b9 01       	movw	r22, r18
     6ca:	44 e6       	ldi	r20, 0x64	; 100
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <xQueueGenericSend>
				vTaskDelay(100);
     6d4:	84 e6       	ldi	r24, 0x64	; 100
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     6dc:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6e0:	98 2f       	mov	r25, r24
     6e2:	89 81       	ldd	r24, Y+1	; 0x01
     6e4:	98 17       	cp	r25, r24
     6e6:	39 f3       	breq	.-50     	; 0x6b6 <PushButton_Task+0x46>
				SendData = 1;
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(MessageQueue_PushButton , &SendData , 100);
				vTaskDelay(100);
			}
			Debouncing = 2;
     6e8:	82 e0       	ldi	r24, 0x02	; 2
     6ea:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(100);
     6ec:	84 e6       	ldi	r24, 0x64	; 100
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
     6f4:	ca cf       	rjmp	.-108    	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 2)
     6f6:	8a 81       	ldd	r24, Y+2	; 0x02
     6f8:	82 30       	cpi	r24, 0x02	; 2
     6fa:	81 f4       	brne	.+32     	; 0x71c <PushButton_Task+0xac>
		{
			SendData = 0;
     6fc:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(MessageQueue_PushButton , &SendData , 100);
     6fe:	80 91 c4 00 	lds	r24, 0x00C4
     702:	90 91 c5 00 	lds	r25, 0x00C5
     706:	9e 01       	movw	r18, r28
     708:	2d 5f       	subi	r18, 0xFD	; 253
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	b9 01       	movw	r22, r18
     70e:	44 e6       	ldi	r20, 0x64	; 100
     710:	50 e0       	ldi	r21, 0x00	; 0
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <xQueueGenericSend>
			Debouncing = 0;
     718:	1a 82       	std	Y+2, r1	; 0x02
     71a:	b7 cf       	rjmp	.-146    	; 0x68a <PushButton_Task+0x1a>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     71c:	83 e0       	ldi	r24, 0x03	; 3
     71e:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(MessageQueue_PushButton , &SendData , 100);
     720:	80 91 c4 00 	lds	r24, 0x00C4
     724:	90 91 c5 00 	lds	r25, 0x00C5
     728:	9e 01       	movw	r18, r28
     72a:	2d 5f       	subi	r18, 0xFD	; 253
     72c:	3f 4f       	sbci	r19, 0xFF	; 255
     72e:	b9 01       	movw	r22, r18
     730:	44 e6       	ldi	r20, 0x64	; 100
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <xQueueGenericSend>
			vTaskDelay(100);
     73a:	84 e6       	ldi	r24, 0x64	; 100
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
     742:	a3 cf       	rjmp	.-186    	; 0x68a <PushButton_Task+0x1a>

00000744 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     744:	df 93       	push	r29
     746:	cf 93       	push	r28
     748:	cd b7       	in	r28, 0x3d	; 61
     74a:	de b7       	in	r29, 0x3e	; 62
     74c:	af 97       	sbiw	r28, 0x2f	; 47
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	de bf       	out	0x3e, r29	; 62
     754:	0f be       	out	0x3f, r0	; 63
     756:	cd bf       	out	0x3d, r28	; 61
     758:	9d a3       	std	Y+37, r25	; 0x25
     75a:	8c a3       	std	Y+36, r24	; 0x24
	vTaskDelay(100);
     75c:	84 e6       	ldi	r24, 0x64	; 100
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>

	/*received message from Hello Task to display button state on LCD*/
	uint8 HelloTask_Data;

	/*Push Button "Pressed" message*/
	uint8 ButtonPressedString[] = "Over Written!!!!";
     764:	ce 01       	movw	r24, r28
     766:	06 96       	adiw	r24, 0x06	; 6
     768:	9f a3       	std	Y+39, r25	; 0x27
     76a:	8e a3       	std	Y+38, r24	; 0x26
     76c:	e2 e9       	ldi	r30, 0x92	; 146
     76e:	f0 e0       	ldi	r31, 0x00	; 0
     770:	f9 a7       	std	Y+41, r31	; 0x29
     772:	e8 a7       	std	Y+40, r30	; 0x28
     774:	f1 e1       	ldi	r31, 0x11	; 17
     776:	fa a7       	std	Y+42, r31	; 0x2a
     778:	e8 a5       	ldd	r30, Y+40	; 0x28
     77a:	f9 a5       	ldd	r31, Y+41	; 0x29
     77c:	00 80       	ld	r0, Z
     77e:	88 a5       	ldd	r24, Y+40	; 0x28
     780:	99 a5       	ldd	r25, Y+41	; 0x29
     782:	01 96       	adiw	r24, 0x01	; 1
     784:	99 a7       	std	Y+41, r25	; 0x29
     786:	88 a7       	std	Y+40, r24	; 0x28
     788:	ee a1       	ldd	r30, Y+38	; 0x26
     78a:	ff a1       	ldd	r31, Y+39	; 0x27
     78c:	00 82       	st	Z, r0
     78e:	8e a1       	ldd	r24, Y+38	; 0x26
     790:	9f a1       	ldd	r25, Y+39	; 0x27
     792:	01 96       	adiw	r24, 0x01	; 1
     794:	9f a3       	std	Y+39, r25	; 0x27
     796:	8e a3       	std	Y+38, r24	; 0x26
     798:	9a a5       	ldd	r25, Y+42	; 0x2a
     79a:	91 50       	subi	r25, 0x01	; 1
     79c:	9a a7       	std	Y+42, r25	; 0x2a
     79e:	ea a5       	ldd	r30, Y+42	; 0x2a
     7a0:	ee 23       	and	r30, r30
     7a2:	51 f7       	brne	.-44     	; 0x778 <LCD_Task+0x34>

	/*Hello message*/
	uint8 MessageString[] = "Hello LCD !!";
     7a4:	ce 01       	movw	r24, r28
     7a6:	47 96       	adiw	r24, 0x17	; 23
     7a8:	9c a7       	std	Y+44, r25	; 0x2c
     7aa:	8b a7       	std	Y+43, r24	; 0x2b
     7ac:	e3 ea       	ldi	r30, 0xA3	; 163
     7ae:	f0 e0       	ldi	r31, 0x00	; 0
     7b0:	fe a7       	std	Y+46, r31	; 0x2e
     7b2:	ed a7       	std	Y+45, r30	; 0x2d
     7b4:	fd e0       	ldi	r31, 0x0D	; 13
     7b6:	ff a7       	std	Y+47, r31	; 0x2f
     7b8:	ed a5       	ldd	r30, Y+45	; 0x2d
     7ba:	fe a5       	ldd	r31, Y+46	; 0x2e
     7bc:	00 80       	ld	r0, Z
     7be:	8d a5       	ldd	r24, Y+45	; 0x2d
     7c0:	9e a5       	ldd	r25, Y+46	; 0x2e
     7c2:	01 96       	adiw	r24, 0x01	; 1
     7c4:	9e a7       	std	Y+46, r25	; 0x2e
     7c6:	8d a7       	std	Y+45, r24	; 0x2d
     7c8:	eb a5       	ldd	r30, Y+43	; 0x2b
     7ca:	fc a5       	ldd	r31, Y+44	; 0x2c
     7cc:	00 82       	st	Z, r0
     7ce:	8b a5       	ldd	r24, Y+43	; 0x2b
     7d0:	9c a5       	ldd	r25, Y+44	; 0x2c
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	9c a7       	std	Y+44, r25	; 0x2c
     7d6:	8b a7       	std	Y+43, r24	; 0x2b
     7d8:	9f a5       	ldd	r25, Y+47	; 0x2f
     7da:	91 50       	subi	r25, 0x01	; 1
     7dc:	9f a7       	std	Y+47, r25	; 0x2f
     7de:	ef a5       	ldd	r30, Y+47	; 0x2f
     7e0:	ee 23       	and	r30, r30
     7e2:	51 f7       	brne	.-44     	; 0x7b8 <LCD_Task+0x74>

	/*counter to hundle displaying of hello message*/
	uint8 Counter = 0;
     7e4:	1b 82       	std	Y+3, r1	; 0x03

	/*Synchronize between displaying of Push Button task and hello task*/
	uint8 Flag = 0;
     7e6:	1a 82       	std	Y+2, r1	; 0x02
	uint8 Flag2 = 0;
     7e8:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*receive messages fro other tasks by queues*/
		xQueueReceive(MessageQueue_PushButton , &PushButtonTask_Data , 10);
     7ea:	80 91 c4 00 	lds	r24, 0x00C4
     7ee:	90 91 c5 00 	lds	r25, 0x00C5
     7f2:	9e 01       	movw	r18, r28
     7f4:	2c 5f       	subi	r18, 0xFC	; 252
     7f6:	3f 4f       	sbci	r19, 0xFF	; 255
     7f8:	b9 01       	movw	r22, r18
     7fa:	4a e0       	ldi	r20, 0x0A	; 10
     7fc:	50 e0       	ldi	r21, 0x00	; 0
     7fe:	0e 94 57 10 	call	0x20ae	; 0x20ae <xQueueReceive>
		xQueueReceive(MessageQueue_Hello , &HelloTask_Data , 10);
     802:	80 91 c6 00 	lds	r24, 0x00C6
     806:	90 91 c7 00 	lds	r25, 0x00C7
     80a:	9e 01       	movw	r18, r28
     80c:	2b 5f       	subi	r18, 0xFB	; 251
     80e:	3f 4f       	sbci	r19, 0xFF	; 255
     810:	b9 01       	movw	r22, r18
     812:	4a e0       	ldi	r20, 0x0A	; 10
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	0e 94 57 10 	call	0x20ae	; 0x20ae <xQueueReceive>

		/*Increment counter to Display Hello message for specific time*/
		if(Counter != 0)
     81a:	8b 81       	ldd	r24, Y+3	; 0x03
     81c:	88 23       	and	r24, r24
     81e:	19 f0       	breq	.+6      	; 0x826 <LCD_Task+0xe2>
		{
			Counter++;
     820:	8b 81       	ldd	r24, Y+3	; 0x03
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	8b 83       	std	Y+3, r24	; 0x03
		{
			/*Do Nothing*/
		}

		/*check on Push Button Message is received*/
		if(PushButtonTask_Data == 1)
     826:	8c 81       	ldd	r24, Y+4	; 0x04
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	59 f4       	brne	.+22     	; 0x842 <LCD_Task+0xfe>
		{
			LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     82c:	9e 01       	movw	r18, r28
     82e:	2a 5f       	subi	r18, 0xFA	; 250
     830:	3f 4f       	sbci	r19, 0xFF	; 255
     832:	81 e0       	ldi	r24, 0x01	; 1
     834:	60 e0       	ldi	r22, 0x00	; 0
     836:	a9 01       	movw	r20, r18
     838:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
			Flag = 1;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	8a 83       	std	Y+2, r24	; 0x02
     840:	14 c0       	rjmp	.+40     	; 0x86a <__stack+0xb>
		}
		else if(PushButtonTask_Data == 0)
     842:	8c 81       	ldd	r24, Y+4	; 0x04
     844:	88 23       	and	r24, r24
     846:	89 f4       	brne	.+34     	; 0x86a <__stack+0xb>
		{
			Flag = 0;
     848:	1a 82       	std	Y+2, r1	; 0x02
			if(Flag2 == 1)
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	81 30       	cpi	r24, 0x01	; 1
     84e:	59 f4       	brne	.+22     	; 0x866 <__stack+0x7>
			{
				LCD_clearScreen();
     850:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
				LCD_displayStringRowColumn(0 , 0 , MessageString);
     854:	9e 01       	movw	r18, r28
     856:	29 5e       	subi	r18, 0xE9	; 233
     858:	3f 4f       	sbci	r19, 0xFF	; 255
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	60 e0       	ldi	r22, 0x00	; 0
     85e:	a9 01       	movw	r20, r18
     860:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
     864:	02 c0       	rjmp	.+4      	; 0x86a <__stack+0xb>
			}
			else
			{
				LCD_clearScreen();
     866:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
			}
		}

		/*check on Hello Message is received*/
		if(HelloTask_Data == 2)
     86a:	8d 81       	ldd	r24, Y+5	; 0x05
     86c:	82 30       	cpi	r24, 0x02	; 2
     86e:	89 f4       	brne	.+34     	; 0x892 <__stack+0x33>
		{
			LCD_displayStringRowColumn(0 , 0 , MessageString);
     870:	9e 01       	movw	r18, r28
     872:	29 5e       	subi	r18, 0xE9	; 233
     874:	3f 4f       	sbci	r19, 0xFF	; 255
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	a9 01       	movw	r20, r18
     87c:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
			if(Counter == 0)
     880:	8b 81       	ldd	r24, Y+3	; 0x03
     882:	88 23       	and	r24, r24
     884:	19 f4       	brne	.+6      	; 0x88c <__stack+0x2d>
			{
				Counter++;
     886:	8b 81       	ldd	r24, Y+3	; 0x03
     888:	8f 5f       	subi	r24, 0xFF	; 255
     88a:	8b 83       	std	Y+3, r24	; 0x03
			}

			Flag2 = 1;
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	89 83       	std	Y+1, r24	; 0x01
			HelloTask_Data = 0;
     890:	1d 82       	std	Y+5, r1	; 0x05
		{
			/*Do Nothing*/
		}

		/*Reset counter to Display off Hello message for specific time*/
		if(Counter == 10)
     892:	8b 81       	ldd	r24, Y+3	; 0x03
     894:	8a 30       	cpi	r24, 0x0A	; 10
     896:	91 f4       	brne	.+36     	; 0x8bc <__stack+0x5d>
		{
			Counter = 0;
     898:	1b 82       	std	Y+3, r1	; 0x03
			Flag2 = 0;
     89a:	19 82       	std	Y+1, r1	; 0x01
			if(Flag == 1)
     89c:	8a 81       	ldd	r24, Y+2	; 0x02
     89e:	81 30       	cpi	r24, 0x01	; 1
     8a0:	59 f4       	brne	.+22     	; 0x8b8 <__stack+0x59>
			{
				LCD_clearScreen();
     8a2:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
				LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     8a6:	9e 01       	movw	r18, r28
     8a8:	2a 5f       	subi	r18, 0xFA	; 250
     8aa:	3f 4f       	sbci	r19, 0xFF	; 255
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	a9 01       	movw	r20, r18
     8b2:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
     8b6:	02 c0       	rjmp	.+4      	; 0x8bc <__stack+0x5d>
			}
			else
			{
				LCD_clearScreen();
     8b8:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(20);
     8bc:	84 e1       	ldi	r24, 0x14	; 20
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
     8c4:	92 cf       	rjmp	.-220    	; 0x7ea <LCD_Task+0xa6>

000008c6 <SendHallo_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void SendHallo_Task(void * a_Task_ptr)
{
     8c6:	df 93       	push	r29
     8c8:	cf 93       	push	r28
     8ca:	00 d0       	rcall	.+0      	; 0x8cc <SendHallo_Task+0x6>
     8cc:	0f 92       	push	r0
     8ce:	cd b7       	in	r28, 0x3d	; 61
     8d0:	de b7       	in	r29, 0x3e	; 62
     8d2:	9b 83       	std	Y+3, r25	; 0x03
     8d4:	8a 83       	std	Y+2, r24	; 0x02
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 2;
     8d6:	82 e0       	ldi	r24, 0x02	; 2
     8d8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		xQueueSend(MessageQueue_Hello , &SendData , 10);
     8da:	80 91 c6 00 	lds	r24, 0x00C6
     8de:	90 91 c7 00 	lds	r25, 0x00C7
     8e2:	9e 01       	movw	r18, r28
     8e4:	2f 5f       	subi	r18, 0xFF	; 255
     8e6:	3f 4f       	sbci	r19, 0xFF	; 255
     8e8:	b9 01       	movw	r22, r18
     8ea:	4a e0       	ldi	r20, 0x0A	; 10
     8ec:	50 e0       	ldi	r21, 0x00	; 0
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <xQueueGenericSend>
		vTaskDelay(400);
     8f4:	80 e9       	ldi	r24, 0x90	; 144
     8f6:	91 e0       	ldi	r25, 0x01	; 1
     8f8:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
     8fc:	ee cf       	rjmp	.-36     	; 0x8da <SendHallo_Task+0x14>

000008fe <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     8fe:	df 93       	push	r29
     900:	cf 93       	push	r28
     902:	00 d0       	rcall	.+0      	; 0x904 <xEventGroupCreate+0x6>
     904:	cd b7       	in	r28, 0x3d	; 61
     906:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     908:	8b e0       	ldi	r24, 0x0B	; 11
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
     910:	9a 83       	std	Y+2, r25	; 0x02
     912:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     914:	89 81       	ldd	r24, Y+1	; 0x01
     916:	9a 81       	ldd	r25, Y+2	; 0x02
     918:	00 97       	sbiw	r24, 0x00	; 0
     91a:	49 f0       	breq	.+18     	; 0x92e <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     91c:	e9 81       	ldd	r30, Y+1	; 0x01
     91e:	fa 81       	ldd	r31, Y+2	; 0x02
     920:	11 82       	std	Z+1, r1	; 0x01
     922:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	9a 81       	ldd	r25, Y+2	; 0x02
     928:	02 96       	adiw	r24, 0x02	; 2
     92a:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     932:	0f 90       	pop	r0
     934:	0f 90       	pop	r0
     936:	cf 91       	pop	r28
     938:	df 91       	pop	r29
     93a:	08 95       	ret

0000093c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     93c:	df 93       	push	r29
     93e:	cf 93       	push	r28
     940:	cd b7       	in	r28, 0x3d	; 61
     942:	de b7       	in	r29, 0x3e	; 62
     944:	60 97       	sbiw	r28, 0x10	; 16
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	de bf       	out	0x3e, r29	; 62
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	9a 87       	std	Y+10, r25	; 0x0a
     952:	89 87       	std	Y+9, r24	; 0x09
     954:	7c 87       	std	Y+12, r23	; 0x0c
     956:	6b 87       	std	Y+11, r22	; 0x0b
     958:	5e 87       	std	Y+14, r21	; 0x0e
     95a:	4d 87       	std	Y+13, r20	; 0x0d
     95c:	38 8b       	std	Y+16, r19	; 0x10
     95e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     960:	89 85       	ldd	r24, Y+9	; 0x09
     962:	9a 85       	ldd	r25, Y+10	; 0x0a
     964:	9c 83       	std	Y+4, r25	; 0x04
     966:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     968:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     96a:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     96e:	eb 81       	ldd	r30, Y+3	; 0x03
     970:	fc 81       	ldd	r31, Y+4	; 0x04
     972:	80 81       	ld	r24, Z
     974:	91 81       	ldd	r25, Z+1	; 0x01
     976:	98 87       	std	Y+8, r25	; 0x08
     978:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     97a:	89 85       	ldd	r24, Y+9	; 0x09
     97c:	9a 85       	ldd	r25, Y+10	; 0x0a
     97e:	2b 85       	ldd	r18, Y+11	; 0x0b
     980:	3c 85       	ldd	r19, Y+12	; 0x0c
     982:	b9 01       	movw	r22, r18
     984:	0e 94 75 06 	call	0xcea	; 0xcea <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     988:	2f 81       	ldd	r18, Y+7	; 0x07
     98a:	38 85       	ldd	r19, Y+8	; 0x08
     98c:	8b 85       	ldd	r24, Y+11	; 0x0b
     98e:	9c 85       	ldd	r25, Y+12	; 0x0c
     990:	28 2b       	or	r18, r24
     992:	39 2b       	or	r19, r25
     994:	8d 85       	ldd	r24, Y+13	; 0x0d
     996:	9e 85       	ldd	r25, Y+14	; 0x0e
     998:	28 23       	and	r18, r24
     99a:	39 23       	and	r19, r25
     99c:	8d 85       	ldd	r24, Y+13	; 0x0d
     99e:	9e 85       	ldd	r25, Y+14	; 0x0e
     9a0:	28 17       	cp	r18, r24
     9a2:	39 07       	cpc	r19, r25
     9a4:	c9 f4       	brne	.+50     	; 0x9d8 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     9a6:	2f 81       	ldd	r18, Y+7	; 0x07
     9a8:	38 85       	ldd	r19, Y+8	; 0x08
     9aa:	8b 85       	ldd	r24, Y+11	; 0x0b
     9ac:	9c 85       	ldd	r25, Y+12	; 0x0c
     9ae:	82 2b       	or	r24, r18
     9b0:	93 2b       	or	r25, r19
     9b2:	9e 83       	std	Y+6, r25	; 0x06
     9b4:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9b6:	eb 81       	ldd	r30, Y+3	; 0x03
     9b8:	fc 81       	ldd	r31, Y+4	; 0x04
     9ba:	20 81       	ld	r18, Z
     9bc:	31 81       	ldd	r19, Z+1	; 0x01
     9be:	8d 85       	ldd	r24, Y+13	; 0x0d
     9c0:	9e 85       	ldd	r25, Y+14	; 0x0e
     9c2:	80 95       	com	r24
     9c4:	90 95       	com	r25
     9c6:	82 23       	and	r24, r18
     9c8:	93 23       	and	r25, r19
     9ca:	eb 81       	ldd	r30, Y+3	; 0x03
     9cc:	fc 81       	ldd	r31, Y+4	; 0x04
     9ce:	91 83       	std	Z+1, r25	; 0x01
     9d0:	80 83       	st	Z, r24

			xTicksToWait = 0;
     9d2:	18 8a       	std	Y+16, r1	; 0x10
     9d4:	1f 86       	std	Y+15, r1	; 0x0f
     9d6:	1e c0       	rjmp	.+60     	; 0xa14 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     9d8:	8f 85       	ldd	r24, Y+15	; 0x0f
     9da:	98 89       	ldd	r25, Y+16	; 0x10
     9dc:	00 97       	sbiw	r24, 0x00	; 0
     9de:	91 f0       	breq	.+36     	; 0xa04 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     9e0:	8b 81       	ldd	r24, Y+3	; 0x03
     9e2:	9c 81       	ldd	r25, Y+4	; 0x04
     9e4:	bc 01       	movw	r22, r24
     9e6:	6e 5f       	subi	r22, 0xFE	; 254
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	8d 85       	ldd	r24, Y+13	; 0x0d
     9ec:	9e 85       	ldd	r25, Y+14	; 0x0e
     9ee:	9c 01       	movw	r18, r24
     9f0:	35 60       	ori	r19, 0x05	; 5
     9f2:	4f 85       	ldd	r20, Y+15	; 0x0f
     9f4:	58 89       	ldd	r21, Y+16	; 0x10
     9f6:	cb 01       	movw	r24, r22
     9f8:	b9 01       	movw	r22, r18
     9fa:	0e 94 01 23 	call	0x4602	; 0x4602 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     9fe:	1e 82       	std	Y+6, r1	; 0x06
     a00:	1d 82       	std	Y+5, r1	; 0x05
     a02:	08 c0       	rjmp	.+16     	; 0xa14 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	80 81       	ld	r24, Z
     a0a:	91 81       	ldd	r25, Z+1	; 0x01
     a0c:	9e 83       	std	Y+6, r25	; 0x06
     a0e:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a14:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
     a18:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     a1a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a1c:	98 89       	ldd	r25, Y+16	; 0x10
     a1e:	00 97       	sbiw	r24, 0x00	; 0
     a20:	09 f4       	brne	.+2      	; 0xa24 <xEventGroupSync+0xe8>
     a22:	3a c0       	rjmp	.+116    	; 0xa98 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     a24:	8a 81       	ldd	r24, Y+2	; 0x02
     a26:	88 23       	and	r24, r24
     a28:	11 f4       	brne	.+4      	; 0xa2e <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     a2a:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     a2e:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <uxTaskResetEventItemValue>
     a32:	9e 83       	std	Y+6, r25	; 0x06
     a34:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     a36:	8d 81       	ldd	r24, Y+5	; 0x05
     a38:	9e 81       	ldd	r25, Y+6	; 0x06
     a3a:	80 70       	andi	r24, 0x00	; 0
     a3c:	92 70       	andi	r25, 0x02	; 2
     a3e:	00 97       	sbiw	r24, 0x00	; 0
     a40:	31 f5       	brne	.+76     	; 0xa8e <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     a42:	0f b6       	in	r0, 0x3f	; 63
     a44:	f8 94       	cli
     a46:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     a48:	eb 81       	ldd	r30, Y+3	; 0x03
     a4a:	fc 81       	ldd	r31, Y+4	; 0x04
     a4c:	80 81       	ld	r24, Z
     a4e:	91 81       	ldd	r25, Z+1	; 0x01
     a50:	9e 83       	std	Y+6, r25	; 0x06
     a52:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a54:	2d 81       	ldd	r18, Y+5	; 0x05
     a56:	3e 81       	ldd	r19, Y+6	; 0x06
     a58:	8d 85       	ldd	r24, Y+13	; 0x0d
     a5a:	9e 85       	ldd	r25, Y+14	; 0x0e
     a5c:	28 23       	and	r18, r24
     a5e:	39 23       	and	r19, r25
     a60:	8d 85       	ldd	r24, Y+13	; 0x0d
     a62:	9e 85       	ldd	r25, Y+14	; 0x0e
     a64:	28 17       	cp	r18, r24
     a66:	39 07       	cpc	r19, r25
     a68:	71 f4       	brne	.+28     	; 0xa86 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a6a:	eb 81       	ldd	r30, Y+3	; 0x03
     a6c:	fc 81       	ldd	r31, Y+4	; 0x04
     a6e:	20 81       	ld	r18, Z
     a70:	31 81       	ldd	r19, Z+1	; 0x01
     a72:	8d 85       	ldd	r24, Y+13	; 0x0d
     a74:	9e 85       	ldd	r25, Y+14	; 0x0e
     a76:	80 95       	com	r24
     a78:	90 95       	com	r25
     a7a:	82 23       	and	r24, r18
     a7c:	93 23       	and	r25, r19
     a7e:	eb 81       	ldd	r30, Y+3	; 0x03
     a80:	fc 81       	ldd	r31, Y+4	; 0x04
     a82:	91 83       	std	Z+1, r25	; 0x01
     a84:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     a86:	0f 90       	pop	r0
     a88:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a8e:	8d 81       	ldd	r24, Y+5	; 0x05
     a90:	9e 81       	ldd	r25, Y+6	; 0x06
     a92:	90 70       	andi	r25, 0x00	; 0
     a94:	9e 83       	std	Y+6, r25	; 0x06
     a96:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     a98:	8d 81       	ldd	r24, Y+5	; 0x05
     a9a:	9e 81       	ldd	r25, Y+6	; 0x06
}
     a9c:	60 96       	adiw	r28, 0x10	; 16
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	de bf       	out	0x3e, r29	; 62
     aa4:	0f be       	out	0x3f, r0	; 63
     aa6:	cd bf       	out	0x3d, r28	; 61
     aa8:	cf 91       	pop	r28
     aaa:	df 91       	pop	r29
     aac:	08 95       	ret

00000aae <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     aae:	0f 93       	push	r16
     ab0:	1f 93       	push	r17
     ab2:	df 93       	push	r29
     ab4:	cf 93       	push	r28
     ab6:	cd b7       	in	r28, 0x3d	; 61
     ab8:	de b7       	in	r29, 0x3e	; 62
     aba:	63 97       	sbiw	r28, 0x13	; 19
     abc:	0f b6       	in	r0, 0x3f	; 63
     abe:	f8 94       	cli
     ac0:	de bf       	out	0x3e, r29	; 62
     ac2:	0f be       	out	0x3f, r0	; 63
     ac4:	cd bf       	out	0x3d, r28	; 61
     ac6:	9d 87       	std	Y+13, r25	; 0x0d
     ac8:	8c 87       	std	Y+12, r24	; 0x0c
     aca:	7f 87       	std	Y+15, r23	; 0x0f
     acc:	6e 87       	std	Y+14, r22	; 0x0e
     ace:	48 8b       	std	Y+16, r20	; 0x10
     ad0:	29 8b       	std	Y+17, r18	; 0x11
     ad2:	1b 8b       	std	Y+19, r17	; 0x13
     ad4:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     ad6:	8c 85       	ldd	r24, Y+12	; 0x0c
     ad8:	9d 85       	ldd	r25, Y+13	; 0x0d
     ada:	9b 87       	std	Y+11, r25	; 0x0b
     adc:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     ade:	1f 82       	std	Y+7, r1	; 0x07
     ae0:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     ae2:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     ae4:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     ae8:	ea 85       	ldd	r30, Y+10	; 0x0a
     aea:	fb 85       	ldd	r31, Y+11	; 0x0b
     aec:	80 81       	ld	r24, Z
     aee:	91 81       	ldd	r25, Z+1	; 0x01
     af0:	9a 83       	std	Y+2, r25	; 0x02
     af2:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     af4:	89 81       	ldd	r24, Y+1	; 0x01
     af6:	9a 81       	ldd	r25, Y+2	; 0x02
     af8:	2e 85       	ldd	r18, Y+14	; 0x0e
     afa:	3f 85       	ldd	r19, Y+15	; 0x0f
     afc:	b9 01       	movw	r22, r18
     afe:	49 89       	ldd	r20, Y+17	; 0x11
     b00:	0e 94 92 07 	call	0xf24	; 0xf24 <prvTestWaitCondition>
     b04:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     b06:	8d 81       	ldd	r24, Y+5	; 0x05
     b08:	88 23       	and	r24, r24
     b0a:	c1 f0       	breq	.+48     	; 0xb3c <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     b0c:	89 81       	ldd	r24, Y+1	; 0x01
     b0e:	9a 81       	ldd	r25, Y+2	; 0x02
     b10:	99 87       	std	Y+9, r25	; 0x09
     b12:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     b14:	1b 8a       	std	Y+19, r1	; 0x13
     b16:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     b18:	88 89       	ldd	r24, Y+16	; 0x10
     b1a:	88 23       	and	r24, r24
     b1c:	e9 f1       	breq	.+122    	; 0xb98 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b1e:	ea 85       	ldd	r30, Y+10	; 0x0a
     b20:	fb 85       	ldd	r31, Y+11	; 0x0b
     b22:	20 81       	ld	r18, Z
     b24:	31 81       	ldd	r19, Z+1	; 0x01
     b26:	8e 85       	ldd	r24, Y+14	; 0x0e
     b28:	9f 85       	ldd	r25, Y+15	; 0x0f
     b2a:	80 95       	com	r24
     b2c:	90 95       	com	r25
     b2e:	82 23       	and	r24, r18
     b30:	93 23       	and	r25, r19
     b32:	ea 85       	ldd	r30, Y+10	; 0x0a
     b34:	fb 85       	ldd	r31, Y+11	; 0x0b
     b36:	91 83       	std	Z+1, r25	; 0x01
     b38:	80 83       	st	Z, r24
     b3a:	2e c0       	rjmp	.+92     	; 0xb98 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     b3c:	8a 89       	ldd	r24, Y+18	; 0x12
     b3e:	9b 89       	ldd	r25, Y+19	; 0x13
     b40:	00 97       	sbiw	r24, 0x00	; 0
     b42:	39 f4       	brne	.+14     	; 0xb52 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     b44:	89 81       	ldd	r24, Y+1	; 0x01
     b46:	9a 81       	ldd	r25, Y+2	; 0x02
     b48:	99 87       	std	Y+9, r25	; 0x09
     b4a:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	8b 83       	std	Y+3, r24	; 0x03
     b50:	23 c0       	rjmp	.+70     	; 0xb98 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     b52:	88 89       	ldd	r24, Y+16	; 0x10
     b54:	88 23       	and	r24, r24
     b56:	29 f0       	breq	.+10     	; 0xb62 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     b58:	8e 81       	ldd	r24, Y+6	; 0x06
     b5a:	9f 81       	ldd	r25, Y+7	; 0x07
     b5c:	91 60       	ori	r25, 0x01	; 1
     b5e:	9f 83       	std	Y+7, r25	; 0x07
     b60:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     b62:	89 89       	ldd	r24, Y+17	; 0x11
     b64:	88 23       	and	r24, r24
     b66:	29 f0       	breq	.+10     	; 0xb72 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     b68:	8e 81       	ldd	r24, Y+6	; 0x06
     b6a:	9f 81       	ldd	r25, Y+7	; 0x07
     b6c:	94 60       	ori	r25, 0x04	; 4
     b6e:	9f 83       	std	Y+7, r25	; 0x07
     b70:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     b72:	8a 85       	ldd	r24, Y+10	; 0x0a
     b74:	9b 85       	ldd	r25, Y+11	; 0x0b
     b76:	bc 01       	movw	r22, r24
     b78:	6e 5f       	subi	r22, 0xFE	; 254
     b7a:	7f 4f       	sbci	r23, 0xFF	; 255
     b7c:	2e 85       	ldd	r18, Y+14	; 0x0e
     b7e:	3f 85       	ldd	r19, Y+15	; 0x0f
     b80:	8e 81       	ldd	r24, Y+6	; 0x06
     b82:	9f 81       	ldd	r25, Y+7	; 0x07
     b84:	28 2b       	or	r18, r24
     b86:	39 2b       	or	r19, r25
     b88:	4a 89       	ldd	r20, Y+18	; 0x12
     b8a:	5b 89       	ldd	r21, Y+19	; 0x13
     b8c:	cb 01       	movw	r24, r22
     b8e:	b9 01       	movw	r22, r18
     b90:	0e 94 01 23 	call	0x4602	; 0x4602 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     b94:	19 86       	std	Y+9, r1	; 0x09
     b96:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     b98:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
     b9c:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     b9e:	8a 89       	ldd	r24, Y+18	; 0x12
     ba0:	9b 89       	ldd	r25, Y+19	; 0x13
     ba2:	00 97       	sbiw	r24, 0x00	; 0
     ba4:	09 f4       	brne	.+2      	; 0xba8 <xEventGroupWaitBits+0xfa>
     ba6:	3c c0       	rjmp	.+120    	; 0xc20 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     ba8:	8c 81       	ldd	r24, Y+4	; 0x04
     baa:	88 23       	and	r24, r24
     bac:	11 f4       	brne	.+4      	; 0xbb2 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     bae:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     bb2:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <uxTaskResetEventItemValue>
     bb6:	99 87       	std	Y+9, r25	; 0x09
     bb8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     bba:	88 85       	ldd	r24, Y+8	; 0x08
     bbc:	99 85       	ldd	r25, Y+9	; 0x09
     bbe:	80 70       	andi	r24, 0x00	; 0
     bc0:	92 70       	andi	r25, 0x02	; 2
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	41 f5       	brne	.+80     	; 0xc16 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     bcc:	ea 85       	ldd	r30, Y+10	; 0x0a
     bce:	fb 85       	ldd	r31, Y+11	; 0x0b
     bd0:	80 81       	ld	r24, Z
     bd2:	91 81       	ldd	r25, Z+1	; 0x01
     bd4:	99 87       	std	Y+9, r25	; 0x09
     bd6:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     bd8:	88 85       	ldd	r24, Y+8	; 0x08
     bda:	99 85       	ldd	r25, Y+9	; 0x09
     bdc:	2e 85       	ldd	r18, Y+14	; 0x0e
     bde:	3f 85       	ldd	r19, Y+15	; 0x0f
     be0:	b9 01       	movw	r22, r18
     be2:	49 89       	ldd	r20, Y+17	; 0x11
     be4:	0e 94 92 07 	call	0xf24	; 0xf24 <prvTestWaitCondition>
     be8:	88 23       	and	r24, r24
     bea:	89 f0       	breq	.+34     	; 0xc0e <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     bec:	88 89       	ldd	r24, Y+16	; 0x10
     bee:	88 23       	and	r24, r24
     bf0:	71 f0       	breq	.+28     	; 0xc0e <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     bf2:	ea 85       	ldd	r30, Y+10	; 0x0a
     bf4:	fb 85       	ldd	r31, Y+11	; 0x0b
     bf6:	20 81       	ld	r18, Z
     bf8:	31 81       	ldd	r19, Z+1	; 0x01
     bfa:	8e 85       	ldd	r24, Y+14	; 0x0e
     bfc:	9f 85       	ldd	r25, Y+15	; 0x0f
     bfe:	80 95       	com	r24
     c00:	90 95       	com	r25
     c02:	82 23       	and	r24, r18
     c04:	93 23       	and	r25, r19
     c06:	ea 85       	ldd	r30, Y+10	; 0x0a
     c08:	fb 85       	ldd	r31, Y+11	; 0x0b
     c0a:	91 83       	std	Z+1, r25	; 0x01
     c0c:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c16:	88 85       	ldd	r24, Y+8	; 0x08
     c18:	99 85       	ldd	r25, Y+9	; 0x09
     c1a:	90 70       	andi	r25, 0x00	; 0
     c1c:	99 87       	std	Y+9, r25	; 0x09
     c1e:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     c20:	88 85       	ldd	r24, Y+8	; 0x08
     c22:	99 85       	ldd	r25, Y+9	; 0x09
}
     c24:	63 96       	adiw	r28, 0x13	; 19
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	de bf       	out	0x3e, r29	; 62
     c2c:	0f be       	out	0x3f, r0	; 63
     c2e:	cd bf       	out	0x3d, r28	; 61
     c30:	cf 91       	pop	r28
     c32:	df 91       	pop	r29
     c34:	1f 91       	pop	r17
     c36:	0f 91       	pop	r16
     c38:	08 95       	ret

00000c3a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     c3a:	df 93       	push	r29
     c3c:	cf 93       	push	r28
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	28 97       	sbiw	r28, 0x08	; 8
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	f8 94       	cli
     c48:	de bf       	out	0x3e, r29	; 62
     c4a:	0f be       	out	0x3f, r0	; 63
     c4c:	cd bf       	out	0x3d, r28	; 61
     c4e:	9e 83       	std	Y+6, r25	; 0x06
     c50:	8d 83       	std	Y+5, r24	; 0x05
     c52:	78 87       	std	Y+8, r23	; 0x08
     c54:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     c56:	8d 81       	ldd	r24, Y+5	; 0x05
     c58:	9e 81       	ldd	r25, Y+6	; 0x06
     c5a:	9c 83       	std	Y+4, r25	; 0x04
     c5c:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     c64:	eb 81       	ldd	r30, Y+3	; 0x03
     c66:	fc 81       	ldd	r31, Y+4	; 0x04
     c68:	80 81       	ld	r24, Z
     c6a:	91 81       	ldd	r25, Z+1	; 0x01
     c6c:	9a 83       	std	Y+2, r25	; 0x02
     c6e:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     c70:	eb 81       	ldd	r30, Y+3	; 0x03
     c72:	fc 81       	ldd	r31, Y+4	; 0x04
     c74:	20 81       	ld	r18, Z
     c76:	31 81       	ldd	r19, Z+1	; 0x01
     c78:	8f 81       	ldd	r24, Y+7	; 0x07
     c7a:	98 85       	ldd	r25, Y+8	; 0x08
     c7c:	80 95       	com	r24
     c7e:	90 95       	com	r25
     c80:	82 23       	and	r24, r18
     c82:	93 23       	and	r25, r19
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	91 83       	std	Z+1, r25	; 0x01
     c8a:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     c90:	89 81       	ldd	r24, Y+1	; 0x01
     c92:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c94:	28 96       	adiw	r28, 0x08	; 8
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	de bf       	out	0x3e, r29	; 62
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	cd bf       	out	0x3d, r28	; 61
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	08 95       	ret

00000ca6 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
     cae:	27 97       	sbiw	r28, 0x07	; 7
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	9f 83       	std	Y+7, r25	; 0x07
     cbc:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     cbe:	8e 81       	ldd	r24, Y+6	; 0x06
     cc0:	9f 81       	ldd	r25, Y+7	; 0x07
     cc2:	9c 83       	std	Y+4, r25	; 0x04
     cc4:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     cc6:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     cc8:	eb 81       	ldd	r30, Y+3	; 0x03
     cca:	fc 81       	ldd	r31, Y+4	; 0x04
     ccc:	80 81       	ld	r24, Z
     cce:	91 81       	ldd	r25, Z+1	; 0x01
     cd0:	9a 83       	std	Y+2, r25	; 0x02
     cd2:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     cd8:	27 96       	adiw	r28, 0x07	; 7
     cda:	0f b6       	in	r0, 0x3f	; 63
     cdc:	f8 94       	cli
     cde:	de bf       	out	0x3e, r29	; 62
     ce0:	0f be       	out	0x3f, r0	; 63
     ce2:	cd bf       	out	0x3d, r28	; 61
     ce4:	cf 91       	pop	r28
     ce6:	df 91       	pop	r29
     ce8:	08 95       	ret

00000cea <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     cea:	df 93       	push	r29
     cec:	cf 93       	push	r28
     cee:	cd b7       	in	r28, 0x3d	; 61
     cf0:	de b7       	in	r29, 0x3e	; 62
     cf2:	65 97       	sbiw	r28, 0x15	; 21
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	de bf       	out	0x3e, r29	; 62
     cfa:	0f be       	out	0x3f, r0	; 63
     cfc:	cd bf       	out	0x3d, r28	; 61
     cfe:	9b 8b       	std	Y+19, r25	; 0x13
     d00:	8a 8b       	std	Y+18, r24	; 0x12
     d02:	7d 8b       	std	Y+21, r23	; 0x15
     d04:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     d06:	19 86       	std	Y+9, r1	; 0x09
     d08:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     d0a:	8a 89       	ldd	r24, Y+18	; 0x12
     d0c:	9b 89       	ldd	r25, Y+19	; 0x13
     d0e:	9b 83       	std	Y+3, r25	; 0x03
     d10:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     d12:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     d14:	8a 81       	ldd	r24, Y+2	; 0x02
     d16:	9b 81       	ldd	r25, Y+3	; 0x03
     d18:	02 96       	adiw	r24, 0x02	; 2
     d1a:	9b 87       	std	Y+11, r25	; 0x0b
     d1c:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d1e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d20:	9b 85       	ldd	r25, Y+11	; 0x0b
     d22:	03 96       	adiw	r24, 0x03	; 3
     d24:	9d 87       	std	Y+13, r25	; 0x0d
     d26:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     d28:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     d2c:	ea 85       	ldd	r30, Y+10	; 0x0a
     d2e:	fb 85       	ldd	r31, Y+11	; 0x0b
     d30:	85 81       	ldd	r24, Z+5	; 0x05
     d32:	96 81       	ldd	r25, Z+6	; 0x06
     d34:	99 8b       	std	Y+17, r25	; 0x11
     d36:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     d38:	ea 81       	ldd	r30, Y+2	; 0x02
     d3a:	fb 81       	ldd	r31, Y+3	; 0x03
     d3c:	20 81       	ld	r18, Z
     d3e:	31 81       	ldd	r19, Z+1	; 0x01
     d40:	8c 89       	ldd	r24, Y+20	; 0x14
     d42:	9d 89       	ldd	r25, Y+21	; 0x15
     d44:	82 2b       	or	r24, r18
     d46:	93 2b       	or	r25, r19
     d48:	ea 81       	ldd	r30, Y+2	; 0x02
     d4a:	fb 81       	ldd	r31, Y+3	; 0x03
     d4c:	91 83       	std	Z+1, r25	; 0x01
     d4e:	80 83       	st	Z, r24
     d50:	59 c0       	rjmp	.+178    	; 0xe04 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     d52:	e8 89       	ldd	r30, Y+16	; 0x10
     d54:	f9 89       	ldd	r31, Y+17	; 0x11
     d56:	82 81       	ldd	r24, Z+2	; 0x02
     d58:	93 81       	ldd	r25, Z+3	; 0x03
     d5a:	9f 87       	std	Y+15, r25	; 0x0f
     d5c:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     d5e:	e8 89       	ldd	r30, Y+16	; 0x10
     d60:	f9 89       	ldd	r31, Y+17	; 0x11
     d62:	80 81       	ld	r24, Z
     d64:	91 81       	ldd	r25, Z+1	; 0x01
     d66:	9f 83       	std	Y+7, r25	; 0x07
     d68:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     d6a:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	80 70       	andi	r24, 0x00	; 0
     d72:	9d 83       	std	Y+5, r25	; 0x05
     d74:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     d76:	8e 81       	ldd	r24, Y+6	; 0x06
     d78:	9f 81       	ldd	r25, Y+7	; 0x07
     d7a:	90 70       	andi	r25, 0x00	; 0
     d7c:	9f 83       	std	Y+7, r25	; 0x07
     d7e:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     d80:	8c 81       	ldd	r24, Y+4	; 0x04
     d82:	9d 81       	ldd	r25, Y+5	; 0x05
     d84:	80 70       	andi	r24, 0x00	; 0
     d86:	94 70       	andi	r25, 0x04	; 4
     d88:	00 97       	sbiw	r24, 0x00	; 0
     d8a:	69 f4       	brne	.+26     	; 0xda6 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     d8c:	ea 81       	ldd	r30, Y+2	; 0x02
     d8e:	fb 81       	ldd	r31, Y+3	; 0x03
     d90:	20 81       	ld	r18, Z
     d92:	31 81       	ldd	r19, Z+1	; 0x01
     d94:	8e 81       	ldd	r24, Y+6	; 0x06
     d96:	9f 81       	ldd	r25, Y+7	; 0x07
     d98:	82 23       	and	r24, r18
     d9a:	93 23       	and	r25, r19
     d9c:	00 97       	sbiw	r24, 0x00	; 0
     d9e:	91 f0       	breq	.+36     	; 0xdc4 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	89 83       	std	Y+1, r24	; 0x01
     da4:	0f c0       	rjmp	.+30     	; 0xdc4 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     da6:	ea 81       	ldd	r30, Y+2	; 0x02
     da8:	fb 81       	ldd	r31, Y+3	; 0x03
     daa:	20 81       	ld	r18, Z
     dac:	31 81       	ldd	r19, Z+1	; 0x01
     dae:	8e 81       	ldd	r24, Y+6	; 0x06
     db0:	9f 81       	ldd	r25, Y+7	; 0x07
     db2:	28 23       	and	r18, r24
     db4:	39 23       	and	r19, r25
     db6:	8e 81       	ldd	r24, Y+6	; 0x06
     db8:	9f 81       	ldd	r25, Y+7	; 0x07
     dba:	28 17       	cp	r18, r24
     dbc:	39 07       	cpc	r19, r25
     dbe:	11 f4       	brne	.+4      	; 0xdc4 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     dc4:	89 81       	ldd	r24, Y+1	; 0x01
     dc6:	88 23       	and	r24, r24
     dc8:	c9 f0       	breq	.+50     	; 0xdfc <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     dca:	8c 81       	ldd	r24, Y+4	; 0x04
     dcc:	9d 81       	ldd	r25, Y+5	; 0x05
     dce:	80 70       	andi	r24, 0x00	; 0
     dd0:	91 70       	andi	r25, 0x01	; 1
     dd2:	00 97       	sbiw	r24, 0x00	; 0
     dd4:	41 f0       	breq	.+16     	; 0xde6 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     dd6:	88 85       	ldd	r24, Y+8	; 0x08
     dd8:	99 85       	ldd	r25, Y+9	; 0x09
     dda:	2e 81       	ldd	r18, Y+6	; 0x06
     ddc:	3f 81       	ldd	r19, Y+7	; 0x07
     dde:	82 2b       	or	r24, r18
     de0:	93 2b       	or	r25, r19
     de2:	99 87       	std	Y+9, r25	; 0x09
     de4:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     de6:	ea 81       	ldd	r30, Y+2	; 0x02
     de8:	fb 81       	ldd	r31, Y+3	; 0x03
     dea:	80 81       	ld	r24, Z
     dec:	91 81       	ldd	r25, Z+1	; 0x01
     dee:	9c 01       	movw	r18, r24
     df0:	32 60       	ori	r19, 0x02	; 2
     df2:	88 89       	ldd	r24, Y+16	; 0x10
     df4:	99 89       	ldd	r25, Y+17	; 0x11
     df6:	b9 01       	movw	r22, r18
     df8:	0e 94 9c 23 	call	0x4738	; 0x4738 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     dfc:	8e 85       	ldd	r24, Y+14	; 0x0e
     dfe:	9f 85       	ldd	r25, Y+15	; 0x0f
     e00:	99 8b       	std	Y+17, r25	; 0x11
     e02:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     e04:	28 89       	ldd	r18, Y+16	; 0x10
     e06:	39 89       	ldd	r19, Y+17	; 0x11
     e08:	8c 85       	ldd	r24, Y+12	; 0x0c
     e0a:	9d 85       	ldd	r25, Y+13	; 0x0d
     e0c:	28 17       	cp	r18, r24
     e0e:	39 07       	cpc	r19, r25
     e10:	09 f0       	breq	.+2      	; 0xe14 <xEventGroupSetBits+0x12a>
     e12:	9f cf       	rjmp	.-194    	; 0xd52 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     e14:	ea 81       	ldd	r30, Y+2	; 0x02
     e16:	fb 81       	ldd	r31, Y+3	; 0x03
     e18:	20 81       	ld	r18, Z
     e1a:	31 81       	ldd	r19, Z+1	; 0x01
     e1c:	88 85       	ldd	r24, Y+8	; 0x08
     e1e:	99 85       	ldd	r25, Y+9	; 0x09
     e20:	80 95       	com	r24
     e22:	90 95       	com	r25
     e24:	82 23       	and	r24, r18
     e26:	93 23       	and	r25, r19
     e28:	ea 81       	ldd	r30, Y+2	; 0x02
     e2a:	fb 81       	ldd	r31, Y+3	; 0x03
     e2c:	91 83       	std	Z+1, r25	; 0x01
     e2e:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     e30:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     e34:	ea 81       	ldd	r30, Y+2	; 0x02
     e36:	fb 81       	ldd	r31, Y+3	; 0x03
     e38:	80 81       	ld	r24, Z
     e3a:	91 81       	ldd	r25, Z+1	; 0x01
}
     e3c:	65 96       	adiw	r28, 0x15	; 21
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	f8 94       	cli
     e42:	de bf       	out	0x3e, r29	; 62
     e44:	0f be       	out	0x3f, r0	; 63
     e46:	cd bf       	out	0x3d, r28	; 61
     e48:	cf 91       	pop	r28
     e4a:	df 91       	pop	r29
     e4c:	08 95       	ret

00000e4e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     e4e:	df 93       	push	r29
     e50:	cf 93       	push	r28
     e52:	00 d0       	rcall	.+0      	; 0xe54 <vEventGroupDelete+0x6>
     e54:	00 d0       	rcall	.+0      	; 0xe56 <vEventGroupDelete+0x8>
     e56:	00 d0       	rcall	.+0      	; 0xe58 <vEventGroupDelete+0xa>
     e58:	cd b7       	in	r28, 0x3d	; 61
     e5a:	de b7       	in	r29, 0x3e	; 62
     e5c:	9e 83       	std	Y+6, r25	; 0x06
     e5e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     e60:	8d 81       	ldd	r24, Y+5	; 0x05
     e62:	9e 81       	ldd	r25, Y+6	; 0x06
     e64:	9c 83       	std	Y+4, r25	; 0x04
     e66:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     e68:	8b 81       	ldd	r24, Y+3	; 0x03
     e6a:	9c 81       	ldd	r25, Y+4	; 0x04
     e6c:	02 96       	adiw	r24, 0x02	; 2
     e6e:	9a 83       	std	Y+2, r25	; 0x02
     e70:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     e72:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
     e76:	08 c0       	rjmp	.+16     	; 0xe88 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     e78:	e9 81       	ldd	r30, Y+1	; 0x01
     e7a:	fa 81       	ldd	r31, Y+2	; 0x02
     e7c:	85 81       	ldd	r24, Z+5	; 0x05
     e7e:	96 81       	ldd	r25, Z+6	; 0x06
     e80:	60 e0       	ldi	r22, 0x00	; 0
     e82:	72 e0       	ldi	r23, 0x02	; 2
     e84:	0e 94 9c 23 	call	0x4738	; 0x4738 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     e88:	e9 81       	ldd	r30, Y+1	; 0x01
     e8a:	fa 81       	ldd	r31, Y+2	; 0x02
     e8c:	80 81       	ld	r24, Z
     e8e:	88 23       	and	r24, r24
     e90:	99 f7       	brne	.-26     	; 0xe78 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     e92:	8b 81       	ldd	r24, Y+3	; 0x03
     e94:	9c 81       	ldd	r25, Y+4	; 0x04
     e96:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     e9a:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
}
     e9e:	26 96       	adiw	r28, 0x06	; 6
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	de bf       	out	0x3e, r29	; 62
     ea6:	0f be       	out	0x3f, r0	; 63
     ea8:	cd bf       	out	0x3d, r28	; 61
     eaa:	cf 91       	pop	r28
     eac:	df 91       	pop	r29
     eae:	08 95       	ret

00000eb0 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	00 d0       	rcall	.+0      	; 0xeb6 <vEventGroupSetBitsCallback+0x6>
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <vEventGroupSetBitsCallback+0x8>
     eb8:	00 d0       	rcall	.+0      	; 0xeba <vEventGroupSetBitsCallback+0xa>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	9a 83       	std	Y+2, r25	; 0x02
     ec0:	89 83       	std	Y+1, r24	; 0x01
     ec2:	4b 83       	std	Y+3, r20	; 0x03
     ec4:	5c 83       	std	Y+4, r21	; 0x04
     ec6:	6d 83       	std	Y+5, r22	; 0x05
     ec8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	9a 81       	ldd	r25, Y+2	; 0x02
     ece:	2b 81       	ldd	r18, Y+3	; 0x03
     ed0:	3c 81       	ldd	r19, Y+4	; 0x04
     ed2:	b9 01       	movw	r22, r18
     ed4:	0e 94 75 06 	call	0xcea	; 0xcea <xEventGroupSetBits>
}
     ed8:	26 96       	adiw	r28, 0x06	; 6
     eda:	0f b6       	in	r0, 0x3f	; 63
     edc:	f8 94       	cli
     ede:	de bf       	out	0x3e, r29	; 62
     ee0:	0f be       	out	0x3f, r0	; 63
     ee2:	cd bf       	out	0x3d, r28	; 61
     ee4:	cf 91       	pop	r28
     ee6:	df 91       	pop	r29
     ee8:	08 95       	ret

00000eea <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     eea:	df 93       	push	r29
     eec:	cf 93       	push	r28
     eee:	00 d0       	rcall	.+0      	; 0xef0 <vEventGroupClearBitsCallback+0x6>
     ef0:	00 d0       	rcall	.+0      	; 0xef2 <vEventGroupClearBitsCallback+0x8>
     ef2:	00 d0       	rcall	.+0      	; 0xef4 <vEventGroupClearBitsCallback+0xa>
     ef4:	cd b7       	in	r28, 0x3d	; 61
     ef6:	de b7       	in	r29, 0x3e	; 62
     ef8:	9a 83       	std	Y+2, r25	; 0x02
     efa:	89 83       	std	Y+1, r24	; 0x01
     efc:	4b 83       	std	Y+3, r20	; 0x03
     efe:	5c 83       	std	Y+4, r21	; 0x04
     f00:	6d 83       	std	Y+5, r22	; 0x05
     f02:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     f04:	89 81       	ldd	r24, Y+1	; 0x01
     f06:	9a 81       	ldd	r25, Y+2	; 0x02
     f08:	2b 81       	ldd	r18, Y+3	; 0x03
     f0a:	3c 81       	ldd	r19, Y+4	; 0x04
     f0c:	b9 01       	movw	r22, r18
     f0e:	0e 94 1d 06 	call	0xc3a	; 0xc3a <xEventGroupClearBits>
}
     f12:	26 96       	adiw	r28, 0x06	; 6
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	de bf       	out	0x3e, r29	; 62
     f1a:	0f be       	out	0x3f, r0	; 63
     f1c:	cd bf       	out	0x3d, r28	; 61
     f1e:	cf 91       	pop	r28
     f20:	df 91       	pop	r29
     f22:	08 95       	ret

00000f24 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     f24:	df 93       	push	r29
     f26:	cf 93       	push	r28
     f28:	00 d0       	rcall	.+0      	; 0xf2a <prvTestWaitCondition+0x6>
     f2a:	00 d0       	rcall	.+0      	; 0xf2c <prvTestWaitCondition+0x8>
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <prvTestWaitCondition+0xa>
     f2e:	cd b7       	in	r28, 0x3d	; 61
     f30:	de b7       	in	r29, 0x3e	; 62
     f32:	9b 83       	std	Y+3, r25	; 0x03
     f34:	8a 83       	std	Y+2, r24	; 0x02
     f36:	7d 83       	std	Y+5, r23	; 0x05
     f38:	6c 83       	std	Y+4, r22	; 0x04
     f3a:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     f3c:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     f3e:	8e 81       	ldd	r24, Y+6	; 0x06
     f40:	88 23       	and	r24, r24
     f42:	59 f4       	brne	.+22     	; 0xf5a <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     f44:	8a 81       	ldd	r24, Y+2	; 0x02
     f46:	9b 81       	ldd	r25, Y+3	; 0x03
     f48:	2c 81       	ldd	r18, Y+4	; 0x04
     f4a:	3d 81       	ldd	r19, Y+5	; 0x05
     f4c:	82 23       	and	r24, r18
     f4e:	93 23       	and	r25, r19
     f50:	00 97       	sbiw	r24, 0x00	; 0
     f52:	81 f0       	breq	.+32     	; 0xf74 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	0d c0       	rjmp	.+26     	; 0xf74 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     f5a:	2a 81       	ldd	r18, Y+2	; 0x02
     f5c:	3b 81       	ldd	r19, Y+3	; 0x03
     f5e:	8c 81       	ldd	r24, Y+4	; 0x04
     f60:	9d 81       	ldd	r25, Y+5	; 0x05
     f62:	28 23       	and	r18, r24
     f64:	39 23       	and	r19, r25
     f66:	8c 81       	ldd	r24, Y+4	; 0x04
     f68:	9d 81       	ldd	r25, Y+5	; 0x05
     f6a:	28 17       	cp	r18, r24
     f6c:	39 07       	cpc	r19, r25
     f6e:	11 f4       	brne	.+4      	; 0xf74 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     f70:	81 e0       	ldi	r24, 0x01	; 1
     f72:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     f74:	89 81       	ldd	r24, Y+1	; 0x01
}
     f76:	26 96       	adiw	r28, 0x06	; 6
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	de bf       	out	0x3e, r29	; 62
     f7e:	0f be       	out	0x3f, r0	; 63
     f80:	cd bf       	out	0x3d, r28	; 61
     f82:	cf 91       	pop	r28
     f84:	df 91       	pop	r29
     f86:	08 95       	ret

00000f88 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     f88:	df 93       	push	r29
     f8a:	cf 93       	push	r28
     f8c:	00 d0       	rcall	.+0      	; 0xf8e <pvPortMalloc+0x6>
     f8e:	00 d0       	rcall	.+0      	; 0xf90 <pvPortMalloc+0x8>
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	9c 83       	std	Y+4, r25	; 0x04
     f96:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     f98:	1a 82       	std	Y+2, r1	; 0x02
     f9a:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     f9c:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     fa0:	80 91 ca 00 	lds	r24, 0x00CA
     fa4:	90 91 cb 00 	lds	r25, 0x00CB
     fa8:	00 97       	sbiw	r24, 0x00	; 0
     faa:	31 f4       	brne	.+12     	; 0xfb8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     fac:	8d ec       	ldi	r24, 0xCD	; 205
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	90 93 cb 00 	sts	0x00CB, r25
     fb4:	80 93 ca 00 	sts	0x00CA, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     fb8:	80 91 c8 00 	lds	r24, 0x00C8
     fbc:	90 91 c9 00 	lds	r25, 0x00C9
     fc0:	2b 81       	ldd	r18, Y+3	; 0x03
     fc2:	3c 81       	ldd	r19, Y+4	; 0x04
     fc4:	82 0f       	add	r24, r18
     fc6:	93 1f       	adc	r25, r19
     fc8:	25 e0       	ldi	r18, 0x05	; 5
     fca:	8b 3d       	cpi	r24, 0xDB	; 219
     fcc:	92 07       	cpc	r25, r18
     fce:	38 f5       	brcc	.+78     	; 0x101e <pvPortMalloc+0x96>
     fd0:	20 91 c8 00 	lds	r18, 0x00C8
     fd4:	30 91 c9 00 	lds	r19, 0x00C9
     fd8:	8b 81       	ldd	r24, Y+3	; 0x03
     fda:	9c 81       	ldd	r25, Y+4	; 0x04
     fdc:	28 0f       	add	r18, r24
     fde:	39 1f       	adc	r19, r25
     fe0:	80 91 c8 00 	lds	r24, 0x00C8
     fe4:	90 91 c9 00 	lds	r25, 0x00C9
     fe8:	82 17       	cp	r24, r18
     fea:	93 07       	cpc	r25, r19
     fec:	c0 f4       	brcc	.+48     	; 0x101e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     fee:	20 91 ca 00 	lds	r18, 0x00CA
     ff2:	30 91 cb 00 	lds	r19, 0x00CB
     ff6:	80 91 c8 00 	lds	r24, 0x00C8
     ffa:	90 91 c9 00 	lds	r25, 0x00C9
     ffe:	82 0f       	add	r24, r18
    1000:	93 1f       	adc	r25, r19
    1002:	9a 83       	std	Y+2, r25	; 0x02
    1004:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1006:	20 91 c8 00 	lds	r18, 0x00C8
    100a:	30 91 c9 00 	lds	r19, 0x00C9
    100e:	8b 81       	ldd	r24, Y+3	; 0x03
    1010:	9c 81       	ldd	r25, Y+4	; 0x04
    1012:	82 0f       	add	r24, r18
    1014:	93 1f       	adc	r25, r19
    1016:	90 93 c9 00 	sts	0x00C9, r25
    101a:	80 93 c8 00 	sts	0x00C8, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    101e:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1026:	0f 90       	pop	r0
    1028:	0f 90       	pop	r0
    102a:	0f 90       	pop	r0
    102c:	0f 90       	pop	r0
    102e:	cf 91       	pop	r28
    1030:	df 91       	pop	r29
    1032:	08 95       	ret

00001034 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1034:	df 93       	push	r29
    1036:	cf 93       	push	r28
    1038:	00 d0       	rcall	.+0      	; 0x103a <vPortFree+0x6>
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	9a 83       	std	Y+2, r25	; 0x02
    1040:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1042:	0f 90       	pop	r0
    1044:	0f 90       	pop	r0
    1046:	cf 91       	pop	r28
    1048:	df 91       	pop	r29
    104a:	08 95       	ret

0000104c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    104c:	df 93       	push	r29
    104e:	cf 93       	push	r28
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1054:	10 92 c9 00 	sts	0x00C9, r1
    1058:	10 92 c8 00 	sts	0x00C8, r1
}
    105c:	cf 91       	pop	r28
    105e:	df 91       	pop	r29
    1060:	08 95       	ret

00001062 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1062:	df 93       	push	r29
    1064:	cf 93       	push	r28
    1066:	cd b7       	in	r28, 0x3d	; 61
    1068:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    106a:	20 91 c8 00 	lds	r18, 0x00C8
    106e:	30 91 c9 00 	lds	r19, 0x00C9
    1072:	8b ed       	ldi	r24, 0xDB	; 219
    1074:	95 e0       	ldi	r25, 0x05	; 5
    1076:	82 1b       	sub	r24, r18
    1078:	93 0b       	sbc	r25, r19
}
    107a:	cf 91       	pop	r28
    107c:	df 91       	pop	r29
    107e:	08 95       	ret

00001080 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1080:	df 93       	push	r29
    1082:	cf 93       	push	r28
    1084:	cd b7       	in	r28, 0x3d	; 61
    1086:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1088:	aa e3       	ldi	r26, 0x3A	; 58
    108a:	b0 e0       	ldi	r27, 0x00	; 0
    108c:	ea e3       	ldi	r30, 0x3A	; 58
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	80 81       	ld	r24, Z
    1092:	8e 60       	ori	r24, 0x0E	; 14
    1094:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1096:	aa e3       	ldi	r26, 0x3A	; 58
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	ea e3       	ldi	r30, 0x3A	; 58
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	80 81       	ld	r24, Z
    10a0:	80 6f       	ori	r24, 0xF0	; 240
    10a2:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    10a4:	82 e0       	ldi	r24, 0x02	; 2
    10a6:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    10aa:	88 e2       	ldi	r24, 0x28	; 40
    10ac:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    10b0:	8c e0       	ldi	r24, 0x0C	; 12
    10b2:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>

}
    10bc:	cf 91       	pop	r28
    10be:	df 91       	pop	r29
    10c0:	08 95       	ret

000010c2 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    10c2:	df 93       	push	r29
    10c4:	cf 93       	push	r28
    10c6:	0f 92       	push	r0
    10c8:	cd b7       	in	r28, 0x3d	; 61
    10ca:	de b7       	in	r29, 0x3e	; 62
    10cc:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    10ce:	ab e3       	ldi	r26, 0x3B	; 59
    10d0:	b0 e0       	ldi	r27, 0x00	; 0
    10d2:	eb e3       	ldi	r30, 0x3B	; 59
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	80 81       	ld	r24, Z
    10d8:	8d 7f       	andi	r24, 0xFD	; 253
    10da:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    10dc:	ab e3       	ldi	r26, 0x3B	; 59
    10de:	b0 e0       	ldi	r27, 0x00	; 0
    10e0:	eb e3       	ldi	r30, 0x3B	; 59
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	80 81       	ld	r24, Z
    10e6:	8b 7f       	andi	r24, 0xFB	; 251
    10e8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    10f2:	ab e3       	ldi	r26, 0x3B	; 59
    10f4:	b0 e0       	ldi	r27, 0x00	; 0
    10f6:	eb e3       	ldi	r30, 0x3B	; 59
    10f8:	f0 e0       	ldi	r31, 0x00	; 0
    10fa:	80 81       	ld	r24, Z
    10fc:	88 60       	ori	r24, 0x08	; 8
    10fe:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    1108:	ab e3       	ldi	r26, 0x3B	; 59
    110a:	b0 e0       	ldi	r27, 0x00	; 0
    110c:	eb e3       	ldi	r30, 0x3B	; 59
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	98 2f       	mov	r25, r24
    1114:	9f 70       	andi	r25, 0x0F	; 15
    1116:	89 81       	ldd	r24, Y+1	; 0x01
    1118:	80 7f       	andi	r24, 0xF0	; 240
    111a:	89 2b       	or	r24, r25
    111c:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1126:	ab e3       	ldi	r26, 0x3B	; 59
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	eb e3       	ldi	r30, 0x3B	; 59
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	87 7f       	andi	r24, 0xF7	; 247
    1132:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    113c:	ab e3       	ldi	r26, 0x3B	; 59
    113e:	b0 e0       	ldi	r27, 0x00	; 0
    1140:	eb e3       	ldi	r30, 0x3B	; 59
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	88 60       	ori	r24, 0x08	; 8
    1148:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1152:	ab e3       	ldi	r26, 0x3B	; 59
    1154:	b0 e0       	ldi	r27, 0x00	; 0
    1156:	eb e3       	ldi	r30, 0x3B	; 59
    1158:	f0 e0       	ldi	r31, 0x00	; 0
    115a:	80 81       	ld	r24, Z
    115c:	28 2f       	mov	r18, r24
    115e:	2f 70       	andi	r18, 0x0F	; 15
    1160:	89 81       	ldd	r24, Y+1	; 0x01
    1162:	88 2f       	mov	r24, r24
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	82 95       	swap	r24
    1168:	92 95       	swap	r25
    116a:	90 7f       	andi	r25, 0xF0	; 240
    116c:	98 27       	eor	r25, r24
    116e:	80 7f       	andi	r24, 0xF0	; 240
    1170:	98 27       	eor	r25, r24
    1172:	82 2b       	or	r24, r18
    1174:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    117e:	ab e3       	ldi	r26, 0x3B	; 59
    1180:	b0 e0       	ldi	r27, 0x00	; 0
    1182:	eb e3       	ldi	r30, 0x3B	; 59
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	80 81       	ld	r24, Z
    1188:	87 7f       	andi	r24, 0xF7	; 247
    118a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1194:	0f 90       	pop	r0
    1196:	cf 91       	pop	r28
    1198:	df 91       	pop	r29
    119a:	08 95       	ret

0000119c <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    119c:	df 93       	push	r29
    119e:	cf 93       	push	r28
    11a0:	0f 92       	push	r0
    11a2:	cd b7       	in	r28, 0x3d	; 61
    11a4:	de b7       	in	r29, 0x3e	; 62
    11a6:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    11a8:	ab e3       	ldi	r26, 0x3B	; 59
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	eb e3       	ldi	r30, 0x3B	; 59
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	80 81       	ld	r24, Z
    11b2:	82 60       	ori	r24, 0x02	; 2
    11b4:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    11b6:	ab e3       	ldi	r26, 0x3B	; 59
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	eb e3       	ldi	r30, 0x3B	; 59
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	8b 7f       	andi	r24, 0xFB	; 251
    11c2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11cc:	ab e3       	ldi	r26, 0x3B	; 59
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	eb e3       	ldi	r30, 0x3B	; 59
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	80 81       	ld	r24, Z
    11d6:	88 60       	ori	r24, 0x08	; 8
    11d8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    11e2:	ab e3       	ldi	r26, 0x3B	; 59
    11e4:	b0 e0       	ldi	r27, 0x00	; 0
    11e6:	eb e3       	ldi	r30, 0x3B	; 59
    11e8:	f0 e0       	ldi	r31, 0x00	; 0
    11ea:	80 81       	ld	r24, Z
    11ec:	98 2f       	mov	r25, r24
    11ee:	9f 70       	andi	r25, 0x0F	; 15
    11f0:	89 81       	ldd	r24, Y+1	; 0x01
    11f2:	80 7f       	andi	r24, 0xF0	; 240
    11f4:	89 2b       	or	r24, r25
    11f6:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1200:	ab e3       	ldi	r26, 0x3B	; 59
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	eb e3       	ldi	r30, 0x3B	; 59
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	87 7f       	andi	r24, 0xF7	; 247
    120c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1216:	ab e3       	ldi	r26, 0x3B	; 59
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	eb e3       	ldi	r30, 0x3B	; 59
    121c:	f0 e0       	ldi	r31, 0x00	; 0
    121e:	80 81       	ld	r24, Z
    1220:	88 60       	ori	r24, 0x08	; 8
    1222:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    122c:	ab e3       	ldi	r26, 0x3B	; 59
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	eb e3       	ldi	r30, 0x3B	; 59
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	28 2f       	mov	r18, r24
    1238:	2f 70       	andi	r18, 0x0F	; 15
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	88 2f       	mov	r24, r24
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	82 95       	swap	r24
    1242:	92 95       	swap	r25
    1244:	90 7f       	andi	r25, 0xF0	; 240
    1246:	98 27       	eor	r25, r24
    1248:	80 7f       	andi	r24, 0xF0	; 240
    124a:	98 27       	eor	r25, r24
    124c:	82 2b       	or	r24, r18
    124e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1258:	ab e3       	ldi	r26, 0x3B	; 59
    125a:	b0 e0       	ldi	r27, 0x00	; 0
    125c:	eb e3       	ldi	r30, 0x3B	; 59
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	87 7f       	andi	r24, 0xF7	; 247
    1264:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	90 e0       	ldi	r25, 0x00	; 0
    126a:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    126e:	0f 90       	pop	r0
    1270:	cf 91       	pop	r28
    1272:	df 91       	pop	r29
    1274:	08 95       	ret

00001276 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1276:	df 93       	push	r29
    1278:	cf 93       	push	r28
    127a:	00 d0       	rcall	.+0      	; 0x127c <LCD_displayString+0x6>
    127c:	0f 92       	push	r0
    127e:	cd b7       	in	r28, 0x3d	; 61
    1280:	de b7       	in	r29, 0x3e	; 62
    1282:	9b 83       	std	Y+3, r25	; 0x03
    1284:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1286:	19 82       	std	Y+1, r1	; 0x01
    1288:	0e c0       	rjmp	.+28     	; 0x12a6 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	28 2f       	mov	r18, r24
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	8a 81       	ldd	r24, Y+2	; 0x02
    1292:	9b 81       	ldd	r25, Y+3	; 0x03
    1294:	fc 01       	movw	r30, r24
    1296:	e2 0f       	add	r30, r18
    1298:	f3 1f       	adc	r31, r19
    129a:	80 81       	ld	r24, Z
    129c:	0e 94 ce 08 	call	0x119c	; 0x119c <LCD_displayCharacter>
		i++;
    12a0:	89 81       	ldd	r24, Y+1	; 0x01
    12a2:	8f 5f       	subi	r24, 0xFF	; 255
    12a4:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    12a6:	89 81       	ldd	r24, Y+1	; 0x01
    12a8:	28 2f       	mov	r18, r24
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	8a 81       	ldd	r24, Y+2	; 0x02
    12ae:	9b 81       	ldd	r25, Y+3	; 0x03
    12b0:	fc 01       	movw	r30, r24
    12b2:	e2 0f       	add	r30, r18
    12b4:	f3 1f       	adc	r31, r19
    12b6:	80 81       	ld	r24, Z
    12b8:	88 23       	and	r24, r24
    12ba:	39 f7       	brne	.-50     	; 0x128a <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	cf 91       	pop	r28
    12c4:	df 91       	pop	r29
    12c6:	08 95       	ret

000012c8 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    12c8:	df 93       	push	r29
    12ca:	cf 93       	push	r28
    12cc:	00 d0       	rcall	.+0      	; 0x12ce <LCD_goToRowColumn+0x6>
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <LCD_goToRowColumn+0x8>
    12d0:	0f 92       	push	r0
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
    12d6:	8a 83       	std	Y+2, r24	; 0x02
    12d8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    12da:	8a 81       	ldd	r24, Y+2	; 0x02
    12dc:	28 2f       	mov	r18, r24
    12de:	30 e0       	ldi	r19, 0x00	; 0
    12e0:	3d 83       	std	Y+5, r19	; 0x05
    12e2:	2c 83       	std	Y+4, r18	; 0x04
    12e4:	8c 81       	ldd	r24, Y+4	; 0x04
    12e6:	9d 81       	ldd	r25, Y+5	; 0x05
    12e8:	81 30       	cpi	r24, 0x01	; 1
    12ea:	91 05       	cpc	r25, r1
    12ec:	c1 f0       	breq	.+48     	; 0x131e <LCD_goToRowColumn+0x56>
    12ee:	2c 81       	ldd	r18, Y+4	; 0x04
    12f0:	3d 81       	ldd	r19, Y+5	; 0x05
    12f2:	22 30       	cpi	r18, 0x02	; 2
    12f4:	31 05       	cpc	r19, r1
    12f6:	2c f4       	brge	.+10     	; 0x1302 <LCD_goToRowColumn+0x3a>
    12f8:	8c 81       	ldd	r24, Y+4	; 0x04
    12fa:	9d 81       	ldd	r25, Y+5	; 0x05
    12fc:	00 97       	sbiw	r24, 0x00	; 0
    12fe:	61 f0       	breq	.+24     	; 0x1318 <LCD_goToRowColumn+0x50>
    1300:	19 c0       	rjmp	.+50     	; 0x1334 <LCD_goToRowColumn+0x6c>
    1302:	2c 81       	ldd	r18, Y+4	; 0x04
    1304:	3d 81       	ldd	r19, Y+5	; 0x05
    1306:	22 30       	cpi	r18, 0x02	; 2
    1308:	31 05       	cpc	r19, r1
    130a:	69 f0       	breq	.+26     	; 0x1326 <LCD_goToRowColumn+0x5e>
    130c:	8c 81       	ldd	r24, Y+4	; 0x04
    130e:	9d 81       	ldd	r25, Y+5	; 0x05
    1310:	83 30       	cpi	r24, 0x03	; 3
    1312:	91 05       	cpc	r25, r1
    1314:	61 f0       	breq	.+24     	; 0x132e <LCD_goToRowColumn+0x66>
    1316:	0e c0       	rjmp	.+28     	; 0x1334 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    1318:	8b 81       	ldd	r24, Y+3	; 0x03
    131a:	89 83       	std	Y+1, r24	; 0x01
    131c:	0b c0       	rjmp	.+22     	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    131e:	8b 81       	ldd	r24, Y+3	; 0x03
    1320:	80 5c       	subi	r24, 0xC0	; 192
    1322:	89 83       	std	Y+1, r24	; 0x01
    1324:	07 c0       	rjmp	.+14     	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1326:	8b 81       	ldd	r24, Y+3	; 0x03
    1328:	80 5f       	subi	r24, 0xF0	; 240
    132a:	89 83       	std	Y+1, r24	; 0x01
    132c:	03 c0       	rjmp	.+6      	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    132e:	8b 81       	ldd	r24, Y+3	; 0x03
    1330:	80 5b       	subi	r24, 0xB0	; 176
    1332:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    1334:	89 81       	ldd	r24, Y+1	; 0x01
    1336:	80 68       	ori	r24, 0x80	; 128
    1338:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
}
    133c:	0f 90       	pop	r0
    133e:	0f 90       	pop	r0
    1340:	0f 90       	pop	r0
    1342:	0f 90       	pop	r0
    1344:	0f 90       	pop	r0
    1346:	cf 91       	pop	r28
    1348:	df 91       	pop	r29
    134a:	08 95       	ret

0000134c <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    134c:	df 93       	push	r29
    134e:	cf 93       	push	r28
    1350:	00 d0       	rcall	.+0      	; 0x1352 <LCD_displayStringRowColumn+0x6>
    1352:	00 d0       	rcall	.+0      	; 0x1354 <LCD_displayStringRowColumn+0x8>
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	89 83       	std	Y+1, r24	; 0x01
    135a:	6a 83       	std	Y+2, r22	; 0x02
    135c:	5c 83       	std	Y+4, r21	; 0x04
    135e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	6a 81       	ldd	r22, Y+2	; 0x02
    1364:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1368:	8b 81       	ldd	r24, Y+3	; 0x03
    136a:	9c 81       	ldd	r25, Y+4	; 0x04
    136c:	0e 94 3b 09 	call	0x1276	; 0x1276 <LCD_displayString>
}
    1370:	0f 90       	pop	r0
    1372:	0f 90       	pop	r0
    1374:	0f 90       	pop	r0
    1376:	0f 90       	pop	r0
    1378:	cf 91       	pop	r28
    137a:	df 91       	pop	r29
    137c:	08 95       	ret

0000137e <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    137e:	df 93       	push	r29
    1380:	cf 93       	push	r28
    1382:	cd b7       	in	r28, 0x3d	; 61
    1384:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
}
    138c:	cf 91       	pop	r28
    138e:	df 91       	pop	r29
    1390:	08 95       	ret

00001392 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1392:	df 93       	push	r29
    1394:	cf 93       	push	r28
    1396:	00 d0       	rcall	.+0      	; 0x1398 <vListInitialise+0x6>
    1398:	cd b7       	in	r28, 0x3d	; 61
    139a:	de b7       	in	r29, 0x3e	; 62
    139c:	9a 83       	std	Y+2, r25	; 0x02
    139e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13a0:	89 81       	ldd	r24, Y+1	; 0x01
    13a2:	9a 81       	ldd	r25, Y+2	; 0x02
    13a4:	03 96       	adiw	r24, 0x03	; 3
    13a6:	e9 81       	ldd	r30, Y+1	; 0x01
    13a8:	fa 81       	ldd	r31, Y+2	; 0x02
    13aa:	92 83       	std	Z+2, r25	; 0x02
    13ac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    13ae:	e9 81       	ldd	r30, Y+1	; 0x01
    13b0:	fa 81       	ldd	r31, Y+2	; 0x02
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	9f ef       	ldi	r25, 0xFF	; 255
    13b6:	94 83       	std	Z+4, r25	; 0x04
    13b8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13ba:	89 81       	ldd	r24, Y+1	; 0x01
    13bc:	9a 81       	ldd	r25, Y+2	; 0x02
    13be:	03 96       	adiw	r24, 0x03	; 3
    13c0:	e9 81       	ldd	r30, Y+1	; 0x01
    13c2:	fa 81       	ldd	r31, Y+2	; 0x02
    13c4:	96 83       	std	Z+6, r25	; 0x06
    13c6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
    13cc:	03 96       	adiw	r24, 0x03	; 3
    13ce:	e9 81       	ldd	r30, Y+1	; 0x01
    13d0:	fa 81       	ldd	r31, Y+2	; 0x02
    13d2:	90 87       	std	Z+8, r25	; 0x08
    13d4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    13d6:	e9 81       	ldd	r30, Y+1	; 0x01
    13d8:	fa 81       	ldd	r31, Y+2	; 0x02
    13da:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	cf 91       	pop	r28
    13e2:	df 91       	pop	r29
    13e4:	08 95       	ret

000013e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	00 d0       	rcall	.+0      	; 0x13ec <vListInitialiseItem+0x6>
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	9a 83       	std	Y+2, r25	; 0x02
    13f2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    13f4:	e9 81       	ldd	r30, Y+1	; 0x01
    13f6:	fa 81       	ldd	r31, Y+2	; 0x02
    13f8:	11 86       	std	Z+9, r1	; 0x09
    13fa:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	cf 91       	pop	r28
    1402:	df 91       	pop	r29
    1404:	08 95       	ret

00001406 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1406:	df 93       	push	r29
    1408:	cf 93       	push	r28
    140a:	00 d0       	rcall	.+0      	; 0x140c <vListInsertEnd+0x6>
    140c:	00 d0       	rcall	.+0      	; 0x140e <vListInsertEnd+0x8>
    140e:	00 d0       	rcall	.+0      	; 0x1410 <vListInsertEnd+0xa>
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	9c 83       	std	Y+4, r25	; 0x04
    1416:	8b 83       	std	Y+3, r24	; 0x03
    1418:	7e 83       	std	Y+6, r23	; 0x06
    141a:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    141c:	eb 81       	ldd	r30, Y+3	; 0x03
    141e:	fc 81       	ldd	r31, Y+4	; 0x04
    1420:	81 81       	ldd	r24, Z+1	; 0x01
    1422:	92 81       	ldd	r25, Z+2	; 0x02
    1424:	9a 83       	std	Y+2, r25	; 0x02
    1426:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1428:	ed 81       	ldd	r30, Y+5	; 0x05
    142a:	fe 81       	ldd	r31, Y+6	; 0x06
    142c:	89 81       	ldd	r24, Y+1	; 0x01
    142e:	9a 81       	ldd	r25, Y+2	; 0x02
    1430:	93 83       	std	Z+3, r25	; 0x03
    1432:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1434:	e9 81       	ldd	r30, Y+1	; 0x01
    1436:	fa 81       	ldd	r31, Y+2	; 0x02
    1438:	84 81       	ldd	r24, Z+4	; 0x04
    143a:	95 81       	ldd	r25, Z+5	; 0x05
    143c:	ed 81       	ldd	r30, Y+5	; 0x05
    143e:	fe 81       	ldd	r31, Y+6	; 0x06
    1440:	95 83       	std	Z+5, r25	; 0x05
    1442:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1444:	e9 81       	ldd	r30, Y+1	; 0x01
    1446:	fa 81       	ldd	r31, Y+2	; 0x02
    1448:	04 80       	ldd	r0, Z+4	; 0x04
    144a:	f5 81       	ldd	r31, Z+5	; 0x05
    144c:	e0 2d       	mov	r30, r0
    144e:	8d 81       	ldd	r24, Y+5	; 0x05
    1450:	9e 81       	ldd	r25, Y+6	; 0x06
    1452:	93 83       	std	Z+3, r25	; 0x03
    1454:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1456:	e9 81       	ldd	r30, Y+1	; 0x01
    1458:	fa 81       	ldd	r31, Y+2	; 0x02
    145a:	8d 81       	ldd	r24, Y+5	; 0x05
    145c:	9e 81       	ldd	r25, Y+6	; 0x06
    145e:	95 83       	std	Z+5, r25	; 0x05
    1460:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1462:	ed 81       	ldd	r30, Y+5	; 0x05
    1464:	fe 81       	ldd	r31, Y+6	; 0x06
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	9c 81       	ldd	r25, Y+4	; 0x04
    146a:	91 87       	std	Z+9, r25	; 0x09
    146c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    146e:	eb 81       	ldd	r30, Y+3	; 0x03
    1470:	fc 81       	ldd	r31, Y+4	; 0x04
    1472:	80 81       	ld	r24, Z
    1474:	8f 5f       	subi	r24, 0xFF	; 255
    1476:	eb 81       	ldd	r30, Y+3	; 0x03
    1478:	fc 81       	ldd	r31, Y+4	; 0x04
    147a:	80 83       	st	Z, r24
}
    147c:	26 96       	adiw	r28, 0x06	; 6
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	de bf       	out	0x3e, r29	; 62
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	cd bf       	out	0x3d, r28	; 61
    1488:	cf 91       	pop	r28
    148a:	df 91       	pop	r29
    148c:	08 95       	ret

0000148e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    148e:	df 93       	push	r29
    1490:	cf 93       	push	r28
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	28 97       	sbiw	r28, 0x08	; 8
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	9e 83       	std	Y+6, r25	; 0x06
    14a4:	8d 83       	std	Y+5, r24	; 0x05
    14a6:	78 87       	std	Y+8, r23	; 0x08
    14a8:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    14aa:	ef 81       	ldd	r30, Y+7	; 0x07
    14ac:	f8 85       	ldd	r31, Y+8	; 0x08
    14ae:	80 81       	ld	r24, Z
    14b0:	91 81       	ldd	r25, Z+1	; 0x01
    14b2:	9a 83       	std	Y+2, r25	; 0x02
    14b4:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    14b8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ba:	2f ef       	ldi	r18, 0xFF	; 255
    14bc:	8f 3f       	cpi	r24, 0xFF	; 255
    14be:	92 07       	cpc	r25, r18
    14c0:	39 f4       	brne	.+14     	; 0x14d0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14c2:	ed 81       	ldd	r30, Y+5	; 0x05
    14c4:	fe 81       	ldd	r31, Y+6	; 0x06
    14c6:	87 81       	ldd	r24, Z+7	; 0x07
    14c8:	90 85       	ldd	r25, Z+8	; 0x08
    14ca:	9c 83       	std	Y+4, r25	; 0x04
    14cc:	8b 83       	std	Y+3, r24	; 0x03
    14ce:	18 c0       	rjmp	.+48     	; 0x1500 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    14d0:	8d 81       	ldd	r24, Y+5	; 0x05
    14d2:	9e 81       	ldd	r25, Y+6	; 0x06
    14d4:	03 96       	adiw	r24, 0x03	; 3
    14d6:	9c 83       	std	Y+4, r25	; 0x04
    14d8:	8b 83       	std	Y+3, r24	; 0x03
    14da:	06 c0       	rjmp	.+12     	; 0x14e8 <vListInsert+0x5a>
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	82 81       	ldd	r24, Z+2	; 0x02
    14e2:	93 81       	ldd	r25, Z+3	; 0x03
    14e4:	9c 83       	std	Y+4, r25	; 0x04
    14e6:	8b 83       	std	Y+3, r24	; 0x03
    14e8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ea:	fc 81       	ldd	r31, Y+4	; 0x04
    14ec:	02 80       	ldd	r0, Z+2	; 0x02
    14ee:	f3 81       	ldd	r31, Z+3	; 0x03
    14f0:	e0 2d       	mov	r30, r0
    14f2:	20 81       	ld	r18, Z
    14f4:	31 81       	ldd	r19, Z+1	; 0x01
    14f6:	89 81       	ldd	r24, Y+1	; 0x01
    14f8:	9a 81       	ldd	r25, Y+2	; 0x02
    14fa:	82 17       	cp	r24, r18
    14fc:	93 07       	cpc	r25, r19
    14fe:	70 f7       	brcc	.-36     	; 0x14dc <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	82 81       	ldd	r24, Z+2	; 0x02
    1506:	93 81       	ldd	r25, Z+3	; 0x03
    1508:	ef 81       	ldd	r30, Y+7	; 0x07
    150a:	f8 85       	ldd	r31, Y+8	; 0x08
    150c:	93 83       	std	Z+3, r25	; 0x03
    150e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1510:	ef 81       	ldd	r30, Y+7	; 0x07
    1512:	f8 85       	ldd	r31, Y+8	; 0x08
    1514:	02 80       	ldd	r0, Z+2	; 0x02
    1516:	f3 81       	ldd	r31, Z+3	; 0x03
    1518:	e0 2d       	mov	r30, r0
    151a:	8f 81       	ldd	r24, Y+7	; 0x07
    151c:	98 85       	ldd	r25, Y+8	; 0x08
    151e:	95 83       	std	Z+5, r25	; 0x05
    1520:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1522:	ef 81       	ldd	r30, Y+7	; 0x07
    1524:	f8 85       	ldd	r31, Y+8	; 0x08
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	9c 81       	ldd	r25, Y+4	; 0x04
    152a:	95 83       	std	Z+5, r25	; 0x05
    152c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    152e:	eb 81       	ldd	r30, Y+3	; 0x03
    1530:	fc 81       	ldd	r31, Y+4	; 0x04
    1532:	8f 81       	ldd	r24, Y+7	; 0x07
    1534:	98 85       	ldd	r25, Y+8	; 0x08
    1536:	93 83       	std	Z+3, r25	; 0x03
    1538:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    153a:	ef 81       	ldd	r30, Y+7	; 0x07
    153c:	f8 85       	ldd	r31, Y+8	; 0x08
    153e:	8d 81       	ldd	r24, Y+5	; 0x05
    1540:	9e 81       	ldd	r25, Y+6	; 0x06
    1542:	91 87       	std	Z+9, r25	; 0x09
    1544:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1546:	ed 81       	ldd	r30, Y+5	; 0x05
    1548:	fe 81       	ldd	r31, Y+6	; 0x06
    154a:	80 81       	ld	r24, Z
    154c:	8f 5f       	subi	r24, 0xFF	; 255
    154e:	ed 81       	ldd	r30, Y+5	; 0x05
    1550:	fe 81       	ldd	r31, Y+6	; 0x06
    1552:	80 83       	st	Z, r24
}
    1554:	28 96       	adiw	r28, 0x08	; 8
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	de bf       	out	0x3e, r29	; 62
    155c:	0f be       	out	0x3f, r0	; 63
    155e:	cd bf       	out	0x3d, r28	; 61
    1560:	cf 91       	pop	r28
    1562:	df 91       	pop	r29
    1564:	08 95       	ret

00001566 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1566:	df 93       	push	r29
    1568:	cf 93       	push	r28
    156a:	00 d0       	rcall	.+0      	; 0x156c <uxListRemove+0x6>
    156c:	00 d0       	rcall	.+0      	; 0x156e <uxListRemove+0x8>
    156e:	cd b7       	in	r28, 0x3d	; 61
    1570:	de b7       	in	r29, 0x3e	; 62
    1572:	9c 83       	std	Y+4, r25	; 0x04
    1574:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	80 85       	ldd	r24, Z+8	; 0x08
    157c:	91 85       	ldd	r25, Z+9	; 0x09
    157e:	9a 83       	std	Y+2, r25	; 0x02
    1580:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1582:	eb 81       	ldd	r30, Y+3	; 0x03
    1584:	fc 81       	ldd	r31, Y+4	; 0x04
    1586:	a2 81       	ldd	r26, Z+2	; 0x02
    1588:	b3 81       	ldd	r27, Z+3	; 0x03
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	84 81       	ldd	r24, Z+4	; 0x04
    1590:	95 81       	ldd	r25, Z+5	; 0x05
    1592:	15 96       	adiw	r26, 0x05	; 5
    1594:	9c 93       	st	X, r25
    1596:	8e 93       	st	-X, r24
    1598:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    159a:	eb 81       	ldd	r30, Y+3	; 0x03
    159c:	fc 81       	ldd	r31, Y+4	; 0x04
    159e:	a4 81       	ldd	r26, Z+4	; 0x04
    15a0:	b5 81       	ldd	r27, Z+5	; 0x05
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	93 81       	ldd	r25, Z+3	; 0x03
    15aa:	13 96       	adiw	r26, 0x03	; 3
    15ac:	9c 93       	st	X, r25
    15ae:	8e 93       	st	-X, r24
    15b0:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15b2:	e9 81       	ldd	r30, Y+1	; 0x01
    15b4:	fa 81       	ldd	r31, Y+2	; 0x02
    15b6:	21 81       	ldd	r18, Z+1	; 0x01
    15b8:	32 81       	ldd	r19, Z+2	; 0x02
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	9c 81       	ldd	r25, Y+4	; 0x04
    15be:	28 17       	cp	r18, r24
    15c0:	39 07       	cpc	r19, r25
    15c2:	41 f4       	brne	.+16     	; 0x15d4 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	84 81       	ldd	r24, Z+4	; 0x04
    15ca:	95 81       	ldd	r25, Z+5	; 0x05
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	92 83       	std	Z+2, r25	; 0x02
    15d2:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    15d4:	eb 81       	ldd	r30, Y+3	; 0x03
    15d6:	fc 81       	ldd	r31, Y+4	; 0x04
    15d8:	11 86       	std	Z+9, r1	; 0x09
    15da:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    15dc:	e9 81       	ldd	r30, Y+1	; 0x01
    15de:	fa 81       	ldd	r31, Y+2	; 0x02
    15e0:	80 81       	ld	r24, Z
    15e2:	81 50       	subi	r24, 0x01	; 1
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    15ea:	e9 81       	ldd	r30, Y+1	; 0x01
    15ec:	fa 81       	ldd	r31, Y+2	; 0x02
    15ee:	80 81       	ld	r24, Z
}
    15f0:	0f 90       	pop	r0
    15f2:	0f 90       	pop	r0
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	08 95       	ret

000015fe <main>:

#include "UserTasks.h"


void main(void)
{
    15fe:	ef 92       	push	r14
    1600:	ff 92       	push	r15
    1602:	0f 93       	push	r16
    1604:	df 93       	push	r29
    1606:	cf 93       	push	r28
    1608:	cd b7       	in	r28, 0x3d	; 61
    160a:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    160c:	83 ec       	ldi	r24, 0xC3	; 195
    160e:	92 e0       	ldi	r25, 0x02	; 2
    1610:	20 eb       	ldi	r18, 0xB0	; 176
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	e2 ec       	ldi	r30, 0xC2	; 194
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	b9 01       	movw	r22, r18
    161a:	46 e9       	ldi	r20, 0x96	; 150
    161c:	50 e0       	ldi	r21, 0x00	; 0
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	04 e0       	ldi	r16, 0x04	; 4
    1624:	7f 01       	movw	r14, r30
    1626:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , &InitTask_Flag);


	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    162a:	8c e0       	ldi	r24, 0x0C	; 12
    162c:	61 e0       	ldi	r22, 0x01	; 1
    162e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


	vTaskStartScheduler();
    1632:	0e 94 53 20 	call	0x40a6	; 0x40a6 <vTaskStartScheduler>
    1636:	ff cf       	rjmp	.-2      	; 0x1636 <main+0x38>

00001638 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1638:	df 93       	push	r29
    163a:	cf 93       	push	r28
    163c:	cd b7       	in	r28, 0x3d	; 61
    163e:	de b7       	in	r29, 0x3e	; 62
    1640:	28 97       	sbiw	r28, 0x08	; 8
    1642:	0f b6       	in	r0, 0x3f	; 63
    1644:	f8 94       	cli
    1646:	de bf       	out	0x3e, r29	; 62
    1648:	0f be       	out	0x3f, r0	; 63
    164a:	cd bf       	out	0x3d, r28	; 61
    164c:	9c 83       	std	Y+4, r25	; 0x04
    164e:	8b 83       	std	Y+3, r24	; 0x03
    1650:	7e 83       	std	Y+6, r23	; 0x06
    1652:	6d 83       	std	Y+5, r22	; 0x05
    1654:	58 87       	std	Y+8, r21	; 0x08
    1656:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1658:	eb 81       	ldd	r30, Y+3	; 0x03
    165a:	fc 81       	ldd	r31, Y+4	; 0x04
    165c:	81 e1       	ldi	r24, 0x11	; 17
    165e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	01 97       	sbiw	r24, 0x01	; 1
    1666:	9c 83       	std	Y+4, r25	; 0x04
    1668:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	82 e2       	ldi	r24, 0x22	; 34
    1670:	80 83       	st	Z, r24
	pxTopOfStack--;
    1672:	8b 81       	ldd	r24, Y+3	; 0x03
    1674:	9c 81       	ldd	r25, Y+4	; 0x04
    1676:	01 97       	sbiw	r24, 0x01	; 1
    1678:	9c 83       	std	Y+4, r25	; 0x04
    167a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    167c:	eb 81       	ldd	r30, Y+3	; 0x03
    167e:	fc 81       	ldd	r31, Y+4	; 0x04
    1680:	83 e3       	ldi	r24, 0x33	; 51
    1682:	80 83       	st	Z, r24
	pxTopOfStack--;
    1684:	8b 81       	ldd	r24, Y+3	; 0x03
    1686:	9c 81       	ldd	r25, Y+4	; 0x04
    1688:	01 97       	sbiw	r24, 0x01	; 1
    168a:	9c 83       	std	Y+4, r25	; 0x04
    168c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    168e:	8d 81       	ldd	r24, Y+5	; 0x05
    1690:	9e 81       	ldd	r25, Y+6	; 0x06
    1692:	9a 83       	std	Y+2, r25	; 0x02
    1694:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	eb 81       	ldd	r30, Y+3	; 0x03
    169a:	fc 81       	ldd	r31, Y+4	; 0x04
    169c:	80 83       	st	Z, r24
	pxTopOfStack--;
    169e:	8b 81       	ldd	r24, Y+3	; 0x03
    16a0:	9c 81       	ldd	r25, Y+4	; 0x04
    16a2:	01 97       	sbiw	r24, 0x01	; 1
    16a4:	9c 83       	std	Y+4, r25	; 0x04
    16a6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    16a8:	89 81       	ldd	r24, Y+1	; 0x01
    16aa:	9a 81       	ldd	r25, Y+2	; 0x02
    16ac:	89 2f       	mov	r24, r25
    16ae:	99 27       	eor	r25, r25
    16b0:	9a 83       	std	Y+2, r25	; 0x02
    16b2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    16b4:	89 81       	ldd	r24, Y+1	; 0x01
    16b6:	eb 81       	ldd	r30, Y+3	; 0x03
    16b8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    16bc:	8b 81       	ldd	r24, Y+3	; 0x03
    16be:	9c 81       	ldd	r25, Y+4	; 0x04
    16c0:	01 97       	sbiw	r24, 0x01	; 1
    16c2:	9c 83       	std	Y+4, r25	; 0x04
    16c4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    16c6:	eb 81       	ldd	r30, Y+3	; 0x03
    16c8:	fc 81       	ldd	r31, Y+4	; 0x04
    16ca:	10 82       	st	Z, r1
	pxTopOfStack--;
    16cc:	8b 81       	ldd	r24, Y+3	; 0x03
    16ce:	9c 81       	ldd	r25, Y+4	; 0x04
    16d0:	01 97       	sbiw	r24, 0x01	; 1
    16d2:	9c 83       	std	Y+4, r25	; 0x04
    16d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    16d6:	eb 81       	ldd	r30, Y+3	; 0x03
    16d8:	fc 81       	ldd	r31, Y+4	; 0x04
    16da:	80 e8       	ldi	r24, 0x80	; 128
    16dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	9c 81       	ldd	r25, Y+4	; 0x04
    16e2:	01 97       	sbiw	r24, 0x01	; 1
    16e4:	9c 83       	std	Y+4, r25	; 0x04
    16e6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    16e8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ea:	fc 81       	ldd	r31, Y+4	; 0x04
    16ec:	10 82       	st	Z, r1
	pxTopOfStack--;
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	01 97       	sbiw	r24, 0x01	; 1
    16f4:	9c 83       	std	Y+4, r25	; 0x04
    16f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    16f8:	eb 81       	ldd	r30, Y+3	; 0x03
    16fa:	fc 81       	ldd	r31, Y+4	; 0x04
    16fc:	82 e0       	ldi	r24, 0x02	; 2
    16fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1700:	8b 81       	ldd	r24, Y+3	; 0x03
    1702:	9c 81       	ldd	r25, Y+4	; 0x04
    1704:	01 97       	sbiw	r24, 0x01	; 1
    1706:	9c 83       	std	Y+4, r25	; 0x04
    1708:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    170a:	eb 81       	ldd	r30, Y+3	; 0x03
    170c:	fc 81       	ldd	r31, Y+4	; 0x04
    170e:	83 e0       	ldi	r24, 0x03	; 3
    1710:	80 83       	st	Z, r24
	pxTopOfStack--;
    1712:	8b 81       	ldd	r24, Y+3	; 0x03
    1714:	9c 81       	ldd	r25, Y+4	; 0x04
    1716:	01 97       	sbiw	r24, 0x01	; 1
    1718:	9c 83       	std	Y+4, r25	; 0x04
    171a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    171c:	eb 81       	ldd	r30, Y+3	; 0x03
    171e:	fc 81       	ldd	r31, Y+4	; 0x04
    1720:	84 e0       	ldi	r24, 0x04	; 4
    1722:	80 83       	st	Z, r24
	pxTopOfStack--;
    1724:	8b 81       	ldd	r24, Y+3	; 0x03
    1726:	9c 81       	ldd	r25, Y+4	; 0x04
    1728:	01 97       	sbiw	r24, 0x01	; 1
    172a:	9c 83       	std	Y+4, r25	; 0x04
    172c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    172e:	eb 81       	ldd	r30, Y+3	; 0x03
    1730:	fc 81       	ldd	r31, Y+4	; 0x04
    1732:	85 e0       	ldi	r24, 0x05	; 5
    1734:	80 83       	st	Z, r24
	pxTopOfStack--;
    1736:	8b 81       	ldd	r24, Y+3	; 0x03
    1738:	9c 81       	ldd	r25, Y+4	; 0x04
    173a:	01 97       	sbiw	r24, 0x01	; 1
    173c:	9c 83       	std	Y+4, r25	; 0x04
    173e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1740:	eb 81       	ldd	r30, Y+3	; 0x03
    1742:	fc 81       	ldd	r31, Y+4	; 0x04
    1744:	86 e0       	ldi	r24, 0x06	; 6
    1746:	80 83       	st	Z, r24
	pxTopOfStack--;
    1748:	8b 81       	ldd	r24, Y+3	; 0x03
    174a:	9c 81       	ldd	r25, Y+4	; 0x04
    174c:	01 97       	sbiw	r24, 0x01	; 1
    174e:	9c 83       	std	Y+4, r25	; 0x04
    1750:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1752:	eb 81       	ldd	r30, Y+3	; 0x03
    1754:	fc 81       	ldd	r31, Y+4	; 0x04
    1756:	87 e0       	ldi	r24, 0x07	; 7
    1758:	80 83       	st	Z, r24
	pxTopOfStack--;
    175a:	8b 81       	ldd	r24, Y+3	; 0x03
    175c:	9c 81       	ldd	r25, Y+4	; 0x04
    175e:	01 97       	sbiw	r24, 0x01	; 1
    1760:	9c 83       	std	Y+4, r25	; 0x04
    1762:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1764:	eb 81       	ldd	r30, Y+3	; 0x03
    1766:	fc 81       	ldd	r31, Y+4	; 0x04
    1768:	88 e0       	ldi	r24, 0x08	; 8
    176a:	80 83       	st	Z, r24
	pxTopOfStack--;
    176c:	8b 81       	ldd	r24, Y+3	; 0x03
    176e:	9c 81       	ldd	r25, Y+4	; 0x04
    1770:	01 97       	sbiw	r24, 0x01	; 1
    1772:	9c 83       	std	Y+4, r25	; 0x04
    1774:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1776:	eb 81       	ldd	r30, Y+3	; 0x03
    1778:	fc 81       	ldd	r31, Y+4	; 0x04
    177a:	89 e0       	ldi	r24, 0x09	; 9
    177c:	80 83       	st	Z, r24
	pxTopOfStack--;
    177e:	8b 81       	ldd	r24, Y+3	; 0x03
    1780:	9c 81       	ldd	r25, Y+4	; 0x04
    1782:	01 97       	sbiw	r24, 0x01	; 1
    1784:	9c 83       	std	Y+4, r25	; 0x04
    1786:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1788:	eb 81       	ldd	r30, Y+3	; 0x03
    178a:	fc 81       	ldd	r31, Y+4	; 0x04
    178c:	80 e1       	ldi	r24, 0x10	; 16
    178e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1790:	8b 81       	ldd	r24, Y+3	; 0x03
    1792:	9c 81       	ldd	r25, Y+4	; 0x04
    1794:	01 97       	sbiw	r24, 0x01	; 1
    1796:	9c 83       	std	Y+4, r25	; 0x04
    1798:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    179a:	eb 81       	ldd	r30, Y+3	; 0x03
    179c:	fc 81       	ldd	r31, Y+4	; 0x04
    179e:	81 e1       	ldi	r24, 0x11	; 17
    17a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17a2:	8b 81       	ldd	r24, Y+3	; 0x03
    17a4:	9c 81       	ldd	r25, Y+4	; 0x04
    17a6:	01 97       	sbiw	r24, 0x01	; 1
    17a8:	9c 83       	std	Y+4, r25	; 0x04
    17aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    17ac:	eb 81       	ldd	r30, Y+3	; 0x03
    17ae:	fc 81       	ldd	r31, Y+4	; 0x04
    17b0:	82 e1       	ldi	r24, 0x12	; 18
    17b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17b4:	8b 81       	ldd	r24, Y+3	; 0x03
    17b6:	9c 81       	ldd	r25, Y+4	; 0x04
    17b8:	01 97       	sbiw	r24, 0x01	; 1
    17ba:	9c 83       	std	Y+4, r25	; 0x04
    17bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    17be:	eb 81       	ldd	r30, Y+3	; 0x03
    17c0:	fc 81       	ldd	r31, Y+4	; 0x04
    17c2:	83 e1       	ldi	r24, 0x13	; 19
    17c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17c6:	8b 81       	ldd	r24, Y+3	; 0x03
    17c8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ca:	01 97       	sbiw	r24, 0x01	; 1
    17cc:	9c 83       	std	Y+4, r25	; 0x04
    17ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    17d0:	eb 81       	ldd	r30, Y+3	; 0x03
    17d2:	fc 81       	ldd	r31, Y+4	; 0x04
    17d4:	84 e1       	ldi	r24, 0x14	; 20
    17d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d8:	8b 81       	ldd	r24, Y+3	; 0x03
    17da:	9c 81       	ldd	r25, Y+4	; 0x04
    17dc:	01 97       	sbiw	r24, 0x01	; 1
    17de:	9c 83       	std	Y+4, r25	; 0x04
    17e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    17e2:	eb 81       	ldd	r30, Y+3	; 0x03
    17e4:	fc 81       	ldd	r31, Y+4	; 0x04
    17e6:	85 e1       	ldi	r24, 0x15	; 21
    17e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ea:	8b 81       	ldd	r24, Y+3	; 0x03
    17ec:	9c 81       	ldd	r25, Y+4	; 0x04
    17ee:	01 97       	sbiw	r24, 0x01	; 1
    17f0:	9c 83       	std	Y+4, r25	; 0x04
    17f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    17f4:	eb 81       	ldd	r30, Y+3	; 0x03
    17f6:	fc 81       	ldd	r31, Y+4	; 0x04
    17f8:	86 e1       	ldi	r24, 0x16	; 22
    17fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    17fc:	8b 81       	ldd	r24, Y+3	; 0x03
    17fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1800:	01 97       	sbiw	r24, 0x01	; 1
    1802:	9c 83       	std	Y+4, r25	; 0x04
    1804:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1806:	eb 81       	ldd	r30, Y+3	; 0x03
    1808:	fc 81       	ldd	r31, Y+4	; 0x04
    180a:	87 e1       	ldi	r24, 0x17	; 23
    180c:	80 83       	st	Z, r24
	pxTopOfStack--;
    180e:	8b 81       	ldd	r24, Y+3	; 0x03
    1810:	9c 81       	ldd	r25, Y+4	; 0x04
    1812:	01 97       	sbiw	r24, 0x01	; 1
    1814:	9c 83       	std	Y+4, r25	; 0x04
    1816:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1818:	eb 81       	ldd	r30, Y+3	; 0x03
    181a:	fc 81       	ldd	r31, Y+4	; 0x04
    181c:	88 e1       	ldi	r24, 0x18	; 24
    181e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1820:	8b 81       	ldd	r24, Y+3	; 0x03
    1822:	9c 81       	ldd	r25, Y+4	; 0x04
    1824:	01 97       	sbiw	r24, 0x01	; 1
    1826:	9c 83       	std	Y+4, r25	; 0x04
    1828:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    182a:	eb 81       	ldd	r30, Y+3	; 0x03
    182c:	fc 81       	ldd	r31, Y+4	; 0x04
    182e:	89 e1       	ldi	r24, 0x19	; 25
    1830:	80 83       	st	Z, r24
	pxTopOfStack--;
    1832:	8b 81       	ldd	r24, Y+3	; 0x03
    1834:	9c 81       	ldd	r25, Y+4	; 0x04
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	9c 83       	std	Y+4, r25	; 0x04
    183a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    183c:	eb 81       	ldd	r30, Y+3	; 0x03
    183e:	fc 81       	ldd	r31, Y+4	; 0x04
    1840:	80 e2       	ldi	r24, 0x20	; 32
    1842:	80 83       	st	Z, r24
	pxTopOfStack--;
    1844:	8b 81       	ldd	r24, Y+3	; 0x03
    1846:	9c 81       	ldd	r25, Y+4	; 0x04
    1848:	01 97       	sbiw	r24, 0x01	; 1
    184a:	9c 83       	std	Y+4, r25	; 0x04
    184c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    184e:	eb 81       	ldd	r30, Y+3	; 0x03
    1850:	fc 81       	ldd	r31, Y+4	; 0x04
    1852:	81 e2       	ldi	r24, 0x21	; 33
    1854:	80 83       	st	Z, r24
	pxTopOfStack--;
    1856:	8b 81       	ldd	r24, Y+3	; 0x03
    1858:	9c 81       	ldd	r25, Y+4	; 0x04
    185a:	01 97       	sbiw	r24, 0x01	; 1
    185c:	9c 83       	std	Y+4, r25	; 0x04
    185e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1860:	eb 81       	ldd	r30, Y+3	; 0x03
    1862:	fc 81       	ldd	r31, Y+4	; 0x04
    1864:	82 e2       	ldi	r24, 0x22	; 34
    1866:	80 83       	st	Z, r24
	pxTopOfStack--;
    1868:	8b 81       	ldd	r24, Y+3	; 0x03
    186a:	9c 81       	ldd	r25, Y+4	; 0x04
    186c:	01 97       	sbiw	r24, 0x01	; 1
    186e:	9c 83       	std	Y+4, r25	; 0x04
    1870:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1872:	eb 81       	ldd	r30, Y+3	; 0x03
    1874:	fc 81       	ldd	r31, Y+4	; 0x04
    1876:	83 e2       	ldi	r24, 0x23	; 35
    1878:	80 83       	st	Z, r24
	pxTopOfStack--;
    187a:	8b 81       	ldd	r24, Y+3	; 0x03
    187c:	9c 81       	ldd	r25, Y+4	; 0x04
    187e:	01 97       	sbiw	r24, 0x01	; 1
    1880:	9c 83       	std	Y+4, r25	; 0x04
    1882:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1884:	8f 81       	ldd	r24, Y+7	; 0x07
    1886:	98 85       	ldd	r25, Y+8	; 0x08
    1888:	9a 83       	std	Y+2, r25	; 0x02
    188a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    188c:	89 81       	ldd	r24, Y+1	; 0x01
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	80 83       	st	Z, r24
	pxTopOfStack--;
    1894:	8b 81       	ldd	r24, Y+3	; 0x03
    1896:	9c 81       	ldd	r25, Y+4	; 0x04
    1898:	01 97       	sbiw	r24, 0x01	; 1
    189a:	9c 83       	std	Y+4, r25	; 0x04
    189c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    189e:	89 81       	ldd	r24, Y+1	; 0x01
    18a0:	9a 81       	ldd	r25, Y+2	; 0x02
    18a2:	89 2f       	mov	r24, r25
    18a4:	99 27       	eor	r25, r25
    18a6:	9a 83       	std	Y+2, r25	; 0x02
    18a8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    18aa:	89 81       	ldd	r24, Y+1	; 0x01
    18ac:	eb 81       	ldd	r30, Y+3	; 0x03
    18ae:	fc 81       	ldd	r31, Y+4	; 0x04
    18b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    18b2:	8b 81       	ldd	r24, Y+3	; 0x03
    18b4:	9c 81       	ldd	r25, Y+4	; 0x04
    18b6:	01 97       	sbiw	r24, 0x01	; 1
    18b8:	9c 83       	std	Y+4, r25	; 0x04
    18ba:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    18bc:	eb 81       	ldd	r30, Y+3	; 0x03
    18be:	fc 81       	ldd	r31, Y+4	; 0x04
    18c0:	86 e2       	ldi	r24, 0x26	; 38
    18c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    18c4:	8b 81       	ldd	r24, Y+3	; 0x03
    18c6:	9c 81       	ldd	r25, Y+4	; 0x04
    18c8:	01 97       	sbiw	r24, 0x01	; 1
    18ca:	9c 83       	std	Y+4, r25	; 0x04
    18cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    18ce:	eb 81       	ldd	r30, Y+3	; 0x03
    18d0:	fc 81       	ldd	r31, Y+4	; 0x04
    18d2:	87 e2       	ldi	r24, 0x27	; 39
    18d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    18d6:	8b 81       	ldd	r24, Y+3	; 0x03
    18d8:	9c 81       	ldd	r25, Y+4	; 0x04
    18da:	01 97       	sbiw	r24, 0x01	; 1
    18dc:	9c 83       	std	Y+4, r25	; 0x04
    18de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    18e0:	eb 81       	ldd	r30, Y+3	; 0x03
    18e2:	fc 81       	ldd	r31, Y+4	; 0x04
    18e4:	88 e2       	ldi	r24, 0x28	; 40
    18e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18e8:	8b 81       	ldd	r24, Y+3	; 0x03
    18ea:	9c 81       	ldd	r25, Y+4	; 0x04
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	9c 83       	std	Y+4, r25	; 0x04
    18f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    18f2:	eb 81       	ldd	r30, Y+3	; 0x03
    18f4:	fc 81       	ldd	r31, Y+4	; 0x04
    18f6:	89 e2       	ldi	r24, 0x29	; 41
    18f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18fa:	8b 81       	ldd	r24, Y+3	; 0x03
    18fc:	9c 81       	ldd	r25, Y+4	; 0x04
    18fe:	01 97       	sbiw	r24, 0x01	; 1
    1900:	9c 83       	std	Y+4, r25	; 0x04
    1902:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1904:	eb 81       	ldd	r30, Y+3	; 0x03
    1906:	fc 81       	ldd	r31, Y+4	; 0x04
    1908:	80 e3       	ldi	r24, 0x30	; 48
    190a:	80 83       	st	Z, r24
	pxTopOfStack--;
    190c:	8b 81       	ldd	r24, Y+3	; 0x03
    190e:	9c 81       	ldd	r25, Y+4	; 0x04
    1910:	01 97       	sbiw	r24, 0x01	; 1
    1912:	9c 83       	std	Y+4, r25	; 0x04
    1914:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1916:	eb 81       	ldd	r30, Y+3	; 0x03
    1918:	fc 81       	ldd	r31, Y+4	; 0x04
    191a:	81 e3       	ldi	r24, 0x31	; 49
    191c:	80 83       	st	Z, r24
	pxTopOfStack--;
    191e:	8b 81       	ldd	r24, Y+3	; 0x03
    1920:	9c 81       	ldd	r25, Y+4	; 0x04
    1922:	01 97       	sbiw	r24, 0x01	; 1
    1924:	9c 83       	std	Y+4, r25	; 0x04
    1926:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1928:	8b 81       	ldd	r24, Y+3	; 0x03
    192a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    192c:	28 96       	adiw	r28, 0x08	; 8
    192e:	0f b6       	in	r0, 0x3f	; 63
    1930:	f8 94       	cli
    1932:	de bf       	out	0x3e, r29	; 62
    1934:	0f be       	out	0x3f, r0	; 63
    1936:	cd bf       	out	0x3d, r28	; 61
    1938:	cf 91       	pop	r28
    193a:	df 91       	pop	r29
    193c:	08 95       	ret

0000193e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    193e:	df 93       	push	r29
    1940:	cf 93       	push	r28
    1942:	cd b7       	in	r28, 0x3d	; 61
    1944:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1946:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    194a:	a0 91 a8 06 	lds	r26, 0x06A8
    194e:	b0 91 a9 06 	lds	r27, 0x06A9
    1952:	cd 91       	ld	r28, X+
    1954:	cd bf       	out	0x3d, r28	; 61
    1956:	dd 91       	ld	r29, X+
    1958:	de bf       	out	0x3e, r29	; 62
    195a:	ff 91       	pop	r31
    195c:	ef 91       	pop	r30
    195e:	df 91       	pop	r29
    1960:	cf 91       	pop	r28
    1962:	bf 91       	pop	r27
    1964:	af 91       	pop	r26
    1966:	9f 91       	pop	r25
    1968:	8f 91       	pop	r24
    196a:	7f 91       	pop	r23
    196c:	6f 91       	pop	r22
    196e:	5f 91       	pop	r21
    1970:	4f 91       	pop	r20
    1972:	3f 91       	pop	r19
    1974:	2f 91       	pop	r18
    1976:	1f 91       	pop	r17
    1978:	0f 91       	pop	r16
    197a:	ff 90       	pop	r15
    197c:	ef 90       	pop	r14
    197e:	df 90       	pop	r13
    1980:	cf 90       	pop	r12
    1982:	bf 90       	pop	r11
    1984:	af 90       	pop	r10
    1986:	9f 90       	pop	r9
    1988:	8f 90       	pop	r8
    198a:	7f 90       	pop	r7
    198c:	6f 90       	pop	r6
    198e:	5f 90       	pop	r5
    1990:	4f 90       	pop	r4
    1992:	3f 90       	pop	r3
    1994:	2f 90       	pop	r2
    1996:	1f 90       	pop	r1
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63
    199c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    199e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    19a0:	81 e0       	ldi	r24, 0x01	; 1
}
    19a2:	cf 91       	pop	r28
    19a4:	df 91       	pop	r29
    19a6:	08 95       	ret

000019a8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    19a8:	df 93       	push	r29
    19aa:	cf 93       	push	r28
    19ac:	cd b7       	in	r28, 0x3d	; 61
    19ae:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    19b0:	cf 91       	pop	r28
    19b2:	df 91       	pop	r29
    19b4:	08 95       	ret

000019b6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    19b6:	0f 92       	push	r0
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	0f 92       	push	r0
    19be:	1f 92       	push	r1
    19c0:	11 24       	eor	r1, r1
    19c2:	2f 92       	push	r2
    19c4:	3f 92       	push	r3
    19c6:	4f 92       	push	r4
    19c8:	5f 92       	push	r5
    19ca:	6f 92       	push	r6
    19cc:	7f 92       	push	r7
    19ce:	8f 92       	push	r8
    19d0:	9f 92       	push	r9
    19d2:	af 92       	push	r10
    19d4:	bf 92       	push	r11
    19d6:	cf 92       	push	r12
    19d8:	df 92       	push	r13
    19da:	ef 92       	push	r14
    19dc:	ff 92       	push	r15
    19de:	0f 93       	push	r16
    19e0:	1f 93       	push	r17
    19e2:	2f 93       	push	r18
    19e4:	3f 93       	push	r19
    19e6:	4f 93       	push	r20
    19e8:	5f 93       	push	r21
    19ea:	6f 93       	push	r22
    19ec:	7f 93       	push	r23
    19ee:	8f 93       	push	r24
    19f0:	9f 93       	push	r25
    19f2:	af 93       	push	r26
    19f4:	bf 93       	push	r27
    19f6:	cf 93       	push	r28
    19f8:	df 93       	push	r29
    19fa:	ef 93       	push	r30
    19fc:	ff 93       	push	r31
    19fe:	a0 91 a8 06 	lds	r26, 0x06A8
    1a02:	b0 91 a9 06 	lds	r27, 0x06A9
    1a06:	0d b6       	in	r0, 0x3d	; 61
    1a08:	0d 92       	st	X+, r0
    1a0a:	0e b6       	in	r0, 0x3e	; 62
    1a0c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1a0e:	0e 94 72 22 	call	0x44e4	; 0x44e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a12:	a0 91 a8 06 	lds	r26, 0x06A8
    1a16:	b0 91 a9 06 	lds	r27, 0x06A9
    1a1a:	cd 91       	ld	r28, X+
    1a1c:	cd bf       	out	0x3d, r28	; 61
    1a1e:	dd 91       	ld	r29, X+
    1a20:	de bf       	out	0x3e, r29	; 62
    1a22:	ff 91       	pop	r31
    1a24:	ef 91       	pop	r30
    1a26:	df 91       	pop	r29
    1a28:	cf 91       	pop	r28
    1a2a:	bf 91       	pop	r27
    1a2c:	af 91       	pop	r26
    1a2e:	9f 91       	pop	r25
    1a30:	8f 91       	pop	r24
    1a32:	7f 91       	pop	r23
    1a34:	6f 91       	pop	r22
    1a36:	5f 91       	pop	r21
    1a38:	4f 91       	pop	r20
    1a3a:	3f 91       	pop	r19
    1a3c:	2f 91       	pop	r18
    1a3e:	1f 91       	pop	r17
    1a40:	0f 91       	pop	r16
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	df 90       	pop	r13
    1a48:	cf 90       	pop	r12
    1a4a:	bf 90       	pop	r11
    1a4c:	af 90       	pop	r10
    1a4e:	9f 90       	pop	r9
    1a50:	8f 90       	pop	r8
    1a52:	7f 90       	pop	r7
    1a54:	6f 90       	pop	r6
    1a56:	5f 90       	pop	r5
    1a58:	4f 90       	pop	r4
    1a5a:	3f 90       	pop	r3
    1a5c:	2f 90       	pop	r2
    1a5e:	1f 90       	pop	r1
    1a60:	0f 90       	pop	r0
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a66:	08 95       	ret

00001a68 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a68:	0f 92       	push	r0
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
    1a70:	1f 92       	push	r1
    1a72:	11 24       	eor	r1, r1
    1a74:	2f 92       	push	r2
    1a76:	3f 92       	push	r3
    1a78:	4f 92       	push	r4
    1a7a:	5f 92       	push	r5
    1a7c:	6f 92       	push	r6
    1a7e:	7f 92       	push	r7
    1a80:	8f 92       	push	r8
    1a82:	9f 92       	push	r9
    1a84:	af 92       	push	r10
    1a86:	bf 92       	push	r11
    1a88:	cf 92       	push	r12
    1a8a:	df 92       	push	r13
    1a8c:	ef 92       	push	r14
    1a8e:	ff 92       	push	r15
    1a90:	0f 93       	push	r16
    1a92:	1f 93       	push	r17
    1a94:	2f 93       	push	r18
    1a96:	3f 93       	push	r19
    1a98:	4f 93       	push	r20
    1a9a:	5f 93       	push	r21
    1a9c:	6f 93       	push	r22
    1a9e:	7f 93       	push	r23
    1aa0:	8f 93       	push	r24
    1aa2:	9f 93       	push	r25
    1aa4:	af 93       	push	r26
    1aa6:	bf 93       	push	r27
    1aa8:	cf 93       	push	r28
    1aaa:	df 93       	push	r29
    1aac:	ef 93       	push	r30
    1aae:	ff 93       	push	r31
    1ab0:	a0 91 a8 06 	lds	r26, 0x06A8
    1ab4:	b0 91 a9 06 	lds	r27, 0x06A9
    1ab8:	0d b6       	in	r0, 0x3d	; 61
    1aba:	0d 92       	st	X+, r0
    1abc:	0e b6       	in	r0, 0x3e	; 62
    1abe:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1ac0:	0e 94 8d 21 	call	0x431a	; 0x431a <xTaskIncrementTick>
    1ac4:	88 23       	and	r24, r24
    1ac6:	11 f0       	breq	.+4      	; 0x1acc <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1ac8:	0e 94 72 22 	call	0x44e4	; 0x44e4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1acc:	a0 91 a8 06 	lds	r26, 0x06A8
    1ad0:	b0 91 a9 06 	lds	r27, 0x06A9
    1ad4:	cd 91       	ld	r28, X+
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	dd 91       	ld	r29, X+
    1ada:	de bf       	out	0x3e, r29	; 62
    1adc:	ff 91       	pop	r31
    1ade:	ef 91       	pop	r30
    1ae0:	df 91       	pop	r29
    1ae2:	cf 91       	pop	r28
    1ae4:	bf 91       	pop	r27
    1ae6:	af 91       	pop	r26
    1ae8:	9f 91       	pop	r25
    1aea:	8f 91       	pop	r24
    1aec:	7f 91       	pop	r23
    1aee:	6f 91       	pop	r22
    1af0:	5f 91       	pop	r21
    1af2:	4f 91       	pop	r20
    1af4:	3f 91       	pop	r19
    1af6:	2f 91       	pop	r18
    1af8:	1f 91       	pop	r17
    1afa:	0f 91       	pop	r16
    1afc:	ff 90       	pop	r15
    1afe:	ef 90       	pop	r14
    1b00:	df 90       	pop	r13
    1b02:	cf 90       	pop	r12
    1b04:	bf 90       	pop	r11
    1b06:	af 90       	pop	r10
    1b08:	9f 90       	pop	r9
    1b0a:	8f 90       	pop	r8
    1b0c:	7f 90       	pop	r7
    1b0e:	6f 90       	pop	r6
    1b10:	5f 90       	pop	r5
    1b12:	4f 90       	pop	r4
    1b14:	3f 90       	pop	r3
    1b16:	2f 90       	pop	r2
    1b18:	1f 90       	pop	r1
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63
    1b1e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b20:	08 95       	ret

00001b22 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <prvSetupTimerInterrupt+0x6>
    1b28:	00 d0       	rcall	.+0      	; 0x1b2a <prvSetupTimerInterrupt+0x8>
    1b2a:	00 d0       	rcall	.+0      	; 0x1b2c <prvSetupTimerInterrupt+0xa>
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1b30:	80 e4       	ldi	r24, 0x40	; 64
    1b32:	9f e1       	ldi	r25, 0x1F	; 31
    1b34:	a0 e0       	ldi	r26, 0x00	; 0
    1b36:	b0 e0       	ldi	r27, 0x00	; 0
    1b38:	8b 83       	std	Y+3, r24	; 0x03
    1b3a:	9c 83       	std	Y+4, r25	; 0x04
    1b3c:	ad 83       	std	Y+5, r26	; 0x05
    1b3e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	9c 81       	ldd	r25, Y+4	; 0x04
    1b44:	ad 81       	ldd	r26, Y+5	; 0x05
    1b46:	be 81       	ldd	r27, Y+6	; 0x06
    1b48:	68 94       	set
    1b4a:	15 f8       	bld	r1, 5
    1b4c:	b6 95       	lsr	r27
    1b4e:	a7 95       	ror	r26
    1b50:	97 95       	ror	r25
    1b52:	87 95       	ror	r24
    1b54:	16 94       	lsr	r1
    1b56:	d1 f7       	brne	.-12     	; 0x1b4c <prvSetupTimerInterrupt+0x2a>
    1b58:	8b 83       	std	Y+3, r24	; 0x03
    1b5a:	9c 83       	std	Y+4, r25	; 0x04
    1b5c:	ad 83       	std	Y+5, r26	; 0x05
    1b5e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1b60:	8b 81       	ldd	r24, Y+3	; 0x03
    1b62:	9c 81       	ldd	r25, Y+4	; 0x04
    1b64:	ad 81       	ldd	r26, Y+5	; 0x05
    1b66:	be 81       	ldd	r27, Y+6	; 0x06
    1b68:	01 97       	sbiw	r24, 0x01	; 1
    1b6a:	a1 09       	sbc	r26, r1
    1b6c:	b1 09       	sbc	r27, r1
    1b6e:	8b 83       	std	Y+3, r24	; 0x03
    1b70:	9c 83       	std	Y+4, r25	; 0x04
    1b72:	ad 83       	std	Y+5, r26	; 0x05
    1b74:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1b76:	8b 81       	ldd	r24, Y+3	; 0x03
    1b78:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b7e:	ad 81       	ldd	r26, Y+5	; 0x05
    1b80:	be 81       	ldd	r27, Y+6	; 0x06
    1b82:	89 2f       	mov	r24, r25
    1b84:	9a 2f       	mov	r25, r26
    1b86:	ab 2f       	mov	r26, r27
    1b88:	bb 27       	eor	r27, r27
    1b8a:	8b 83       	std	Y+3, r24	; 0x03
    1b8c:	9c 83       	std	Y+4, r25	; 0x04
    1b8e:	ad 83       	std	Y+5, r26	; 0x05
    1b90:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1b92:	8b 81       	ldd	r24, Y+3	; 0x03
    1b94:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1b96:	eb e4       	ldi	r30, 0x4B	; 75
    1b98:	f0 e0       	ldi	r31, 0x00	; 0
    1b9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b9c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1b9e:	ea e4       	ldi	r30, 0x4A	; 74
    1ba0:	f0 e0       	ldi	r31, 0x00	; 0
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1ba6:	8b e0       	ldi	r24, 0x0B	; 11
    1ba8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1baa:	ee e4       	ldi	r30, 0x4E	; 78
    1bac:	f0 e0       	ldi	r31, 0x00	; 0
    1bae:	89 81       	ldd	r24, Y+1	; 0x01
    1bb0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1bb2:	e9 e5       	ldi	r30, 0x59	; 89
    1bb4:	f0 e0       	ldi	r31, 0x00	; 0
    1bb6:	80 81       	ld	r24, Z
    1bb8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1bba:	89 81       	ldd	r24, Y+1	; 0x01
    1bbc:	80 61       	ori	r24, 0x10	; 16
    1bbe:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1bc0:	e9 e5       	ldi	r30, 0x59	; 89
    1bc2:	f0 e0       	ldi	r31, 0x00	; 0
    1bc4:	89 81       	ldd	r24, Y+1	; 0x01
    1bc6:	80 83       	st	Z, r24
}
    1bc8:	26 96       	adiw	r28, 0x06	; 6
    1bca:	0f b6       	in	r0, 0x3f	; 63
    1bcc:	f8 94       	cli
    1bce:	de bf       	out	0x3e, r29	; 62
    1bd0:	0f be       	out	0x3f, r0	; 63
    1bd2:	cd bf       	out	0x3d, r28	; 61
    1bd4:	cf 91       	pop	r28
    1bd6:	df 91       	pop	r29
    1bd8:	08 95       	ret

00001bda <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1bda:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1bde:	18 95       	reti

00001be0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1be0:	df 93       	push	r29
    1be2:	cf 93       	push	r28
    1be4:	00 d0       	rcall	.+0      	; 0x1be6 <xQueueGenericReset+0x6>
    1be6:	00 d0       	rcall	.+0      	; 0x1be8 <xQueueGenericReset+0x8>
    1be8:	0f 92       	push	r0
    1bea:	cd b7       	in	r28, 0x3d	; 61
    1bec:	de b7       	in	r29, 0x3e	; 62
    1bee:	9c 83       	std	Y+4, r25	; 0x04
    1bf0:	8b 83       	std	Y+3, r24	; 0x03
    1bf2:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf8:	9a 83       	std	Y+2, r25	; 0x02
    1bfa:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1bfc:	0f b6       	in	r0, 0x3f	; 63
    1bfe:	f8 94       	cli
    1c00:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1c02:	e9 81       	ldd	r30, Y+1	; 0x01
    1c04:	fa 81       	ldd	r31, Y+2	; 0x02
    1c06:	40 81       	ld	r20, Z
    1c08:	51 81       	ldd	r21, Z+1	; 0x01
    1c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c10:	28 2f       	mov	r18, r24
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	e9 81       	ldd	r30, Y+1	; 0x01
    1c16:	fa 81       	ldd	r31, Y+2	; 0x02
    1c18:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c1a:	88 2f       	mov	r24, r24
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	bc 01       	movw	r22, r24
    1c20:	26 9f       	mul	r18, r22
    1c22:	c0 01       	movw	r24, r0
    1c24:	27 9f       	mul	r18, r23
    1c26:	90 0d       	add	r25, r0
    1c28:	36 9f       	mul	r19, r22
    1c2a:	90 0d       	add	r25, r0
    1c2c:	11 24       	eor	r1, r1
    1c2e:	84 0f       	add	r24, r20
    1c30:	95 1f       	adc	r25, r21
    1c32:	e9 81       	ldd	r30, Y+1	; 0x01
    1c34:	fa 81       	ldd	r31, Y+2	; 0x02
    1c36:	95 83       	std	Z+5, r25	; 0x05
    1c38:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c3e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1c40:	e9 81       	ldd	r30, Y+1	; 0x01
    1c42:	fa 81       	ldd	r31, Y+2	; 0x02
    1c44:	80 81       	ld	r24, Z
    1c46:	91 81       	ldd	r25, Z+1	; 0x01
    1c48:	e9 81       	ldd	r30, Y+1	; 0x01
    1c4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c4c:	93 83       	std	Z+3, r25	; 0x03
    1c4e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	40 81       	ld	r20, Z
    1c56:	51 81       	ldd	r21, Z+1	; 0x01
    1c58:	e9 81       	ldd	r30, Y+1	; 0x01
    1c5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c5c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c5e:	88 2f       	mov	r24, r24
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	9c 01       	movw	r18, r24
    1c64:	21 50       	subi	r18, 0x01	; 1
    1c66:	30 40       	sbci	r19, 0x00	; 0
    1c68:	e9 81       	ldd	r30, Y+1	; 0x01
    1c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c6e:	88 2f       	mov	r24, r24
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	bc 01       	movw	r22, r24
    1c74:	26 9f       	mul	r18, r22
    1c76:	c0 01       	movw	r24, r0
    1c78:	27 9f       	mul	r18, r23
    1c7a:	90 0d       	add	r25, r0
    1c7c:	36 9f       	mul	r19, r22
    1c7e:	90 0d       	add	r25, r0
    1c80:	11 24       	eor	r1, r1
    1c82:	84 0f       	add	r24, r20
    1c84:	95 1f       	adc	r25, r21
    1c86:	e9 81       	ldd	r30, Y+1	; 0x01
    1c88:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8a:	97 83       	std	Z+7, r25	; 0x07
    1c8c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c90:	fa 81       	ldd	r31, Y+2	; 0x02
    1c92:	8f ef       	ldi	r24, 0xFF	; 255
    1c94:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1c96:	e9 81       	ldd	r30, Y+1	; 0x01
    1c98:	fa 81       	ldd	r31, Y+2	; 0x02
    1c9a:	8f ef       	ldi	r24, 0xFF	; 255
    1c9c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1c9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca0:	88 23       	and	r24, r24
    1ca2:	79 f4       	brne	.+30     	; 0x1cc2 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca8:	80 85       	ldd	r24, Z+8	; 0x08
    1caa:	88 23       	and	r24, r24
    1cac:	a1 f0       	breq	.+40     	; 0x1cd6 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cae:	89 81       	ldd	r24, Y+1	; 0x01
    1cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb2:	08 96       	adiw	r24, 0x08	; 8
    1cb4:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    1cb8:	88 23       	and	r24, r24
    1cba:	69 f0       	breq	.+26     	; 0x1cd6 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1cbc:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    1cc0:	0a c0       	rjmp	.+20     	; 0x1cd6 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1cc2:	89 81       	ldd	r24, Y+1	; 0x01
    1cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc6:	08 96       	adiw	r24, 0x08	; 8
    1cc8:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1ccc:	89 81       	ldd	r24, Y+1	; 0x01
    1cce:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd0:	41 96       	adiw	r24, 0x11	; 17
    1cd2:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1cd6:	0f 90       	pop	r0
    1cd8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1cda:	81 e0       	ldi	r24, 0x01	; 1
}
    1cdc:	0f 90       	pop	r0
    1cde:	0f 90       	pop	r0
    1ce0:	0f 90       	pop	r0
    1ce2:	0f 90       	pop	r0
    1ce4:	0f 90       	pop	r0
    1ce6:	cf 91       	pop	r28
    1ce8:	df 91       	pop	r29
    1cea:	08 95       	ret

00001cec <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1cec:	0f 93       	push	r16
    1cee:	1f 93       	push	r17
    1cf0:	df 93       	push	r29
    1cf2:	cf 93       	push	r28
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
    1cf8:	29 97       	sbiw	r28, 0x09	; 9
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	de bf       	out	0x3e, r29	; 62
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	8f 83       	std	Y+7, r24	; 0x07
    1d06:	68 87       	std	Y+8, r22	; 0x08
    1d08:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1d0a:	88 85       	ldd	r24, Y+8	; 0x08
    1d0c:	88 23       	and	r24, r24
    1d0e:	19 f4       	brne	.+6      	; 0x1d16 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1d10:	1c 82       	std	Y+4, r1	; 0x04
    1d12:	1b 82       	std	Y+3, r1	; 0x03
    1d14:	10 c0       	rjmp	.+32     	; 0x1d36 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d16:	8f 81       	ldd	r24, Y+7	; 0x07
    1d18:	28 2f       	mov	r18, r24
    1d1a:	30 e0       	ldi	r19, 0x00	; 0
    1d1c:	88 85       	ldd	r24, Y+8	; 0x08
    1d1e:	88 2f       	mov	r24, r24
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	ac 01       	movw	r20, r24
    1d24:	24 9f       	mul	r18, r20
    1d26:	c0 01       	movw	r24, r0
    1d28:	25 9f       	mul	r18, r21
    1d2a:	90 0d       	add	r25, r0
    1d2c:	34 9f       	mul	r19, r20
    1d2e:	90 0d       	add	r25, r0
    1d30:	11 24       	eor	r1, r1
    1d32:	9c 83       	std	Y+4, r25	; 0x04
    1d34:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1d36:	8b 81       	ldd	r24, Y+3	; 0x03
    1d38:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3a:	4f 96       	adiw	r24, 0x1f	; 31
    1d3c:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    1d40:	9e 83       	std	Y+6, r25	; 0x06
    1d42:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1d44:	8d 81       	ldd	r24, Y+5	; 0x05
    1d46:	9e 81       	ldd	r25, Y+6	; 0x06
    1d48:	00 97       	sbiw	r24, 0x00	; 0
    1d4a:	a1 f0       	breq	.+40     	; 0x1d74 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1d4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d50:	9a 83       	std	Y+2, r25	; 0x02
    1d52:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	9a 81       	ldd	r25, Y+2	; 0x02
    1d58:	4f 96       	adiw	r24, 0x1f	; 31
    1d5a:	9a 83       	std	Y+2, r25	; 0x02
    1d5c:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1d5e:	29 81       	ldd	r18, Y+1	; 0x01
    1d60:	3a 81       	ldd	r19, Y+2	; 0x02
    1d62:	ed 81       	ldd	r30, Y+5	; 0x05
    1d64:	fe 81       	ldd	r31, Y+6	; 0x06
    1d66:	8f 81       	ldd	r24, Y+7	; 0x07
    1d68:	68 85       	ldd	r22, Y+8	; 0x08
    1d6a:	a9 01       	movw	r20, r18
    1d6c:	29 85       	ldd	r18, Y+9	; 0x09
    1d6e:	8f 01       	movw	r16, r30
    1d70:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1d74:	8d 81       	ldd	r24, Y+5	; 0x05
    1d76:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1d78:	29 96       	adiw	r28, 0x09	; 9
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	de bf       	out	0x3e, r29	; 62
    1d80:	0f be       	out	0x3f, r0	; 63
    1d82:	cd bf       	out	0x3d, r28	; 61
    1d84:	cf 91       	pop	r28
    1d86:	df 91       	pop	r29
    1d88:	1f 91       	pop	r17
    1d8a:	0f 91       	pop	r16
    1d8c:	08 95       	ret

00001d8e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1d8e:	0f 93       	push	r16
    1d90:	1f 93       	push	r17
    1d92:	df 93       	push	r29
    1d94:	cf 93       	push	r28
    1d96:	cd b7       	in	r28, 0x3d	; 61
    1d98:	de b7       	in	r29, 0x3e	; 62
    1d9a:	27 97       	sbiw	r28, 0x07	; 7
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	cd bf       	out	0x3d, r28	; 61
    1da6:	89 83       	std	Y+1, r24	; 0x01
    1da8:	6a 83       	std	Y+2, r22	; 0x02
    1daa:	5c 83       	std	Y+4, r21	; 0x04
    1dac:	4b 83       	std	Y+3, r20	; 0x03
    1dae:	2d 83       	std	Y+5, r18	; 0x05
    1db0:	1f 83       	std	Y+7, r17	; 0x07
    1db2:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1db4:	8a 81       	ldd	r24, Y+2	; 0x02
    1db6:	88 23       	and	r24, r24
    1db8:	39 f4       	brne	.+14     	; 0x1dc8 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1dba:	8e 81       	ldd	r24, Y+6	; 0x06
    1dbc:	9f 81       	ldd	r25, Y+7	; 0x07
    1dbe:	ee 81       	ldd	r30, Y+6	; 0x06
    1dc0:	ff 81       	ldd	r31, Y+7	; 0x07
    1dc2:	91 83       	std	Z+1, r25	; 0x01
    1dc4:	80 83       	st	Z, r24
    1dc6:	06 c0       	rjmp	.+12     	; 0x1dd4 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	ee 81       	ldd	r30, Y+6	; 0x06
    1dce:	ff 81       	ldd	r31, Y+7	; 0x07
    1dd0:	91 83       	std	Z+1, r25	; 0x01
    1dd2:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1dd4:	ee 81       	ldd	r30, Y+6	; 0x06
    1dd6:	ff 81       	ldd	r31, Y+7	; 0x07
    1dd8:	89 81       	ldd	r24, Y+1	; 0x01
    1dda:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1ddc:	ee 81       	ldd	r30, Y+6	; 0x06
    1dde:	ff 81       	ldd	r31, Y+7	; 0x07
    1de0:	8a 81       	ldd	r24, Y+2	; 0x02
    1de2:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1de4:	8e 81       	ldd	r24, Y+6	; 0x06
    1de6:	9f 81       	ldd	r25, Y+7	; 0x07
    1de8:	61 e0       	ldi	r22, 0x01	; 1
    1dea:	0e 94 f0 0d 	call	0x1be0	; 0x1be0 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1dee:	27 96       	adiw	r28, 0x07	; 7
    1df0:	0f b6       	in	r0, 0x3f	; 63
    1df2:	f8 94       	cli
    1df4:	de bf       	out	0x3e, r29	; 62
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	cd bf       	out	0x3d, r28	; 61
    1dfa:	cf 91       	pop	r28
    1dfc:	df 91       	pop	r29
    1dfe:	1f 91       	pop	r17
    1e00:	0f 91       	pop	r16
    1e02:	08 95       	ret

00001e04 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1e04:	df 93       	push	r29
    1e06:	cf 93       	push	r28
    1e08:	cd b7       	in	r28, 0x3d	; 61
    1e0a:	de b7       	in	r29, 0x3e	; 62
    1e0c:	2f 97       	sbiw	r28, 0x0f	; 15
    1e0e:	0f b6       	in	r0, 0x3f	; 63
    1e10:	f8 94       	cli
    1e12:	de bf       	out	0x3e, r29	; 62
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	cd bf       	out	0x3d, r28	; 61
    1e18:	99 87       	std	Y+9, r25	; 0x09
    1e1a:	88 87       	std	Y+8, r24	; 0x08
    1e1c:	7b 87       	std	Y+11, r23	; 0x0b
    1e1e:	6a 87       	std	Y+10, r22	; 0x0a
    1e20:	5d 87       	std	Y+13, r21	; 0x0d
    1e22:	4c 87       	std	Y+12, r20	; 0x0c
    1e24:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1e26:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1e28:	88 85       	ldd	r24, Y+8	; 0x08
    1e2a:	99 85       	ldd	r25, Y+9	; 0x09
    1e2c:	9a 83       	std	Y+2, r25	; 0x02
    1e2e:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e30:	0f b6       	in	r0, 0x3f	; 63
    1e32:	f8 94       	cli
    1e34:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1e36:	e9 81       	ldd	r30, Y+1	; 0x01
    1e38:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e40:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e42:	98 17       	cp	r25, r24
    1e44:	18 f0       	brcs	.+6      	; 0x1e4c <xQueueGenericSend+0x48>
    1e46:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e48:	82 30       	cpi	r24, 0x02	; 2
    1e4a:	11 f5       	brne	.+68     	; 0x1e90 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e4c:	89 81       	ldd	r24, Y+1	; 0x01
    1e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e50:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e52:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e54:	b9 01       	movw	r22, r18
    1e56:	4e 85       	ldd	r20, Y+14	; 0x0e
    1e58:	0e 94 54 13 	call	0x26a8	; 0x26a8 <prvCopyDataToQueue>
    1e5c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e60:	fa 81       	ldd	r31, Y+2	; 0x02
    1e62:	81 89       	ldd	r24, Z+17	; 0x11
    1e64:	88 23       	and	r24, r24
    1e66:	51 f0       	breq	.+20     	; 0x1e7c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e68:	89 81       	ldd	r24, Y+1	; 0x01
    1e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6c:	41 96       	adiw	r24, 0x11	; 17
    1e6e:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    1e72:	88 23       	and	r24, r24
    1e74:	41 f0       	breq	.+16     	; 0x1e86 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1e76:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    1e7a:	05 c0       	rjmp	.+10     	; 0x1e86 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7e:	88 23       	and	r24, r24
    1e80:	11 f0       	breq	.+4      	; 0x1e86 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1e82:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	8f 87       	std	Y+15, r24	; 0x0f
    1e8e:	5c c0       	rjmp	.+184    	; 0x1f48 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e90:	8c 85       	ldd	r24, Y+12	; 0x0c
    1e92:	9d 85       	ldd	r25, Y+13	; 0x0d
    1e94:	00 97       	sbiw	r24, 0x00	; 0
    1e96:	21 f4       	brne	.+8      	; 0x1ea0 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1e9c:	1f 86       	std	Y+15, r1	; 0x0f
    1e9e:	54 c0       	rjmp	.+168    	; 0x1f48 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ea0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ea2:	88 23       	and	r24, r24
    1ea4:	31 f4       	brne	.+12     	; 0x1eb2 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1ea6:	ce 01       	movw	r24, r28
    1ea8:	05 96       	adiw	r24, 0x05	; 5
    1eaa:	0e 94 17 24 	call	0x482e	; 0x482e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1eb6:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1eba:	0f b6       	in	r0, 0x3f	; 63
    1ebc:	f8 94       	cli
    1ebe:	0f 92       	push	r0
    1ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ec6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec8:	19 f4       	brne	.+6      	; 0x1ed0 <xQueueGenericSend+0xcc>
    1eca:	e9 81       	ldd	r30, Y+1	; 0x01
    1ecc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ece:	15 8e       	std	Z+29, r1	; 0x1d
    1ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ed6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ed8:	19 f4       	brne	.+6      	; 0x1ee0 <xQueueGenericSend+0xdc>
    1eda:	e9 81       	ldd	r30, Y+1	; 0x01
    1edc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ede:	16 8e       	std	Z+30, r1	; 0x1e
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ee4:	ce 01       	movw	r24, r28
    1ee6:	05 96       	adiw	r24, 0x05	; 5
    1ee8:	9e 01       	movw	r18, r28
    1eea:	24 5f       	subi	r18, 0xF4	; 244
    1eec:	3f 4f       	sbci	r19, 0xFF	; 255
    1eee:	b9 01       	movw	r22, r18
    1ef0:	0e 94 30 24 	call	0x4860	; 0x4860 <xTaskCheckForTimeOut>
    1ef4:	88 23       	and	r24, r24
    1ef6:	09 f5       	brne	.+66     	; 0x1f3a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ef8:	89 81       	ldd	r24, Y+1	; 0x01
    1efa:	9a 81       	ldd	r25, Y+2	; 0x02
    1efc:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <prvIsQueueFull>
    1f00:	88 23       	and	r24, r24
    1f02:	a1 f0       	breq	.+40     	; 0x1f2c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1f04:	89 81       	ldd	r24, Y+1	; 0x01
    1f06:	9a 81       	ldd	r25, Y+2	; 0x02
    1f08:	08 96       	adiw	r24, 0x08	; 8
    1f0a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f0c:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f0e:	b9 01       	movw	r22, r18
    1f10:	0e 94 df 22 	call	0x45be	; 0x45be <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	9a 81       	ldd	r25, Y+2	; 0x02
    1f18:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1f1c:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    1f20:	88 23       	and	r24, r24
    1f22:	09 f0       	breq	.+2      	; 0x1f26 <xQueueGenericSend+0x122>
    1f24:	85 cf       	rjmp	.-246    	; 0x1e30 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1f26:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    1f2a:	82 cf       	rjmp	.-252    	; 0x1e30 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
    1f2e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f30:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f34:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    1f38:	7b cf       	rjmp	.-266    	; 0x1e30 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1f3a:	89 81       	ldd	r24, Y+1	; 0x01
    1f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3e:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f42:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1f46:	1f 86       	std	Y+15, r1	; 0x0f
    1f48:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1f4a:	2f 96       	adiw	r28, 0x0f	; 15
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	de bf       	out	0x3e, r29	; 62
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	cd bf       	out	0x3d, r28	; 61
    1f56:	cf 91       	pop	r28
    1f58:	df 91       	pop	r29
    1f5a:	08 95       	ret

00001f5c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1f5c:	df 93       	push	r29
    1f5e:	cf 93       	push	r28
    1f60:	cd b7       	in	r28, 0x3d	; 61
    1f62:	de b7       	in	r29, 0x3e	; 62
    1f64:	2c 97       	sbiw	r28, 0x0c	; 12
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	de bf       	out	0x3e, r29	; 62
    1f6c:	0f be       	out	0x3f, r0	; 63
    1f6e:	cd bf       	out	0x3d, r28	; 61
    1f70:	9f 83       	std	Y+7, r25	; 0x07
    1f72:	8e 83       	std	Y+6, r24	; 0x06
    1f74:	79 87       	std	Y+9, r23	; 0x09
    1f76:	68 87       	std	Y+8, r22	; 0x08
    1f78:	5b 87       	std	Y+11, r21	; 0x0b
    1f7a:	4a 87       	std	Y+10, r20	; 0x0a
    1f7c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1f7e:	8e 81       	ldd	r24, Y+6	; 0x06
    1f80:	9f 81       	ldd	r25, Y+7	; 0x07
    1f82:	9b 83       	std	Y+3, r25	; 0x03
    1f84:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f86:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f88:	ea 81       	ldd	r30, Y+2	; 0x02
    1f8a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f8e:	ea 81       	ldd	r30, Y+2	; 0x02
    1f90:	fb 81       	ldd	r31, Y+3	; 0x03
    1f92:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f94:	98 17       	cp	r25, r24
    1f96:	18 f0       	brcs	.+6      	; 0x1f9e <xQueueGenericSendFromISR+0x42>
    1f98:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f9a:	82 30       	cpi	r24, 0x02	; 2
    1f9c:	61 f5       	brne	.+88     	; 0x1ff6 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1f9e:	ea 81       	ldd	r30, Y+2	; 0x02
    1fa0:	fb 81       	ldd	r31, Y+3	; 0x03
    1fa2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fa4:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1fa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1faa:	28 85       	ldd	r18, Y+8	; 0x08
    1fac:	39 85       	ldd	r19, Y+9	; 0x09
    1fae:	b9 01       	movw	r22, r18
    1fb0:	4c 85       	ldd	r20, Y+12	; 0x0c
    1fb2:	0e 94 54 13 	call	0x26a8	; 0x26a8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
    1fb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fba:	a9 f4       	brne	.+42     	; 0x1fe6 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc0:	81 89       	ldd	r24, Z+17	; 0x11
    1fc2:	88 23       	and	r24, r24
    1fc4:	a9 f0       	breq	.+42     	; 0x1ff0 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fca:	41 96       	adiw	r24, 0x11	; 17
    1fcc:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    1fd0:	88 23       	and	r24, r24
    1fd2:	71 f0       	breq	.+28     	; 0x1ff0 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1fd4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fd6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fd8:	00 97       	sbiw	r24, 0x00	; 0
    1fda:	51 f0       	breq	.+20     	; 0x1ff0 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1fdc:	ea 85       	ldd	r30, Y+10	; 0x0a
    1fde:	fb 85       	ldd	r31, Y+11	; 0x0b
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	80 83       	st	Z, r24
    1fe4:	05 c0       	rjmp	.+10     	; 0x1ff0 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	8f 5f       	subi	r24, 0xFF	; 255
    1fea:	ea 81       	ldd	r30, Y+2	; 0x02
    1fec:	fb 81       	ldd	r31, Y+3	; 0x03
    1fee:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1ff0:	81 e0       	ldi	r24, 0x01	; 1
    1ff2:	8d 83       	std	Y+5, r24	; 0x05
    1ff4:	01 c0       	rjmp	.+2      	; 0x1ff8 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ff6:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ff8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1ffa:	2c 96       	adiw	r28, 0x0c	; 12
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	de bf       	out	0x3e, r29	; 62
    2002:	0f be       	out	0x3f, r0	; 63
    2004:	cd bf       	out	0x3d, r28	; 61
    2006:	cf 91       	pop	r28
    2008:	df 91       	pop	r29
    200a:	08 95       	ret

0000200c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    200c:	df 93       	push	r29
    200e:	cf 93       	push	r28
    2010:	cd b7       	in	r28, 0x3d	; 61
    2012:	de b7       	in	r29, 0x3e	; 62
    2014:	2a 97       	sbiw	r28, 0x0a	; 10
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	f8 94       	cli
    201a:	de bf       	out	0x3e, r29	; 62
    201c:	0f be       	out	0x3f, r0	; 63
    201e:	cd bf       	out	0x3d, r28	; 61
    2020:	98 87       	std	Y+8, r25	; 0x08
    2022:	8f 83       	std	Y+7, r24	; 0x07
    2024:	7a 87       	std	Y+10, r23	; 0x0a
    2026:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2028:	8f 81       	ldd	r24, Y+7	; 0x07
    202a:	98 85       	ldd	r25, Y+8	; 0x08
    202c:	9c 83       	std	Y+4, r25	; 0x04
    202e:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2030:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2032:	eb 81       	ldd	r30, Y+3	; 0x03
    2034:	fc 81       	ldd	r31, Y+4	; 0x04
    2036:	82 8d       	ldd	r24, Z+26	; 0x1a
    2038:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    203a:	eb 81       	ldd	r30, Y+3	; 0x03
    203c:	fc 81       	ldd	r31, Y+4	; 0x04
    203e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2040:	8a 81       	ldd	r24, Y+2	; 0x02
    2042:	89 17       	cp	r24, r25
    2044:	48 f5       	brcc	.+82     	; 0x2098 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2046:	eb 81       	ldd	r30, Y+3	; 0x03
    2048:	fc 81       	ldd	r31, Y+4	; 0x04
    204a:	86 8d       	ldd	r24, Z+30	; 0x1e
    204c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    204e:	8a 81       	ldd	r24, Y+2	; 0x02
    2050:	8f 5f       	subi	r24, 0xFF	; 255
    2052:	eb 81       	ldd	r30, Y+3	; 0x03
    2054:	fc 81       	ldd	r31, Y+4	; 0x04
    2056:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2058:	89 81       	ldd	r24, Y+1	; 0x01
    205a:	8f 3f       	cpi	r24, 0xFF	; 255
    205c:	a9 f4       	brne	.+42     	; 0x2088 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    205e:	eb 81       	ldd	r30, Y+3	; 0x03
    2060:	fc 81       	ldd	r31, Y+4	; 0x04
    2062:	81 89       	ldd	r24, Z+17	; 0x11
    2064:	88 23       	and	r24, r24
    2066:	a9 f0       	breq	.+42     	; 0x2092 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2068:	8b 81       	ldd	r24, Y+3	; 0x03
    206a:	9c 81       	ldd	r25, Y+4	; 0x04
    206c:	41 96       	adiw	r24, 0x11	; 17
    206e:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    2072:	88 23       	and	r24, r24
    2074:	71 f0       	breq	.+28     	; 0x2092 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2076:	89 85       	ldd	r24, Y+9	; 0x09
    2078:	9a 85       	ldd	r25, Y+10	; 0x0a
    207a:	00 97       	sbiw	r24, 0x00	; 0
    207c:	51 f0       	breq	.+20     	; 0x2092 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    207e:	e9 85       	ldd	r30, Y+9	; 0x09
    2080:	fa 85       	ldd	r31, Y+10	; 0x0a
    2082:	81 e0       	ldi	r24, 0x01	; 1
    2084:	80 83       	st	Z, r24
    2086:	05 c0       	rjmp	.+10     	; 0x2092 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2088:	89 81       	ldd	r24, Y+1	; 0x01
    208a:	8f 5f       	subi	r24, 0xFF	; 255
    208c:	eb 81       	ldd	r30, Y+3	; 0x03
    208e:	fc 81       	ldd	r31, Y+4	; 0x04
    2090:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	8e 83       	std	Y+6, r24	; 0x06
    2096:	01 c0       	rjmp	.+2      	; 0x209a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2098:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    209a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    209c:	2a 96       	adiw	r28, 0x0a	; 10
    209e:	0f b6       	in	r0, 0x3f	; 63
    20a0:	f8 94       	cli
    20a2:	de bf       	out	0x3e, r29	; 62
    20a4:	0f be       	out	0x3f, r0	; 63
    20a6:	cd bf       	out	0x3d, r28	; 61
    20a8:	cf 91       	pop	r28
    20aa:	df 91       	pop	r29
    20ac:	08 95       	ret

000020ae <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    20ae:	df 93       	push	r29
    20b0:	cf 93       	push	r28
    20b2:	cd b7       	in	r28, 0x3d	; 61
    20b4:	de b7       	in	r29, 0x3e	; 62
    20b6:	2e 97       	sbiw	r28, 0x0e	; 14
    20b8:	0f b6       	in	r0, 0x3f	; 63
    20ba:	f8 94       	cli
    20bc:	de bf       	out	0x3e, r29	; 62
    20be:	0f be       	out	0x3f, r0	; 63
    20c0:	cd bf       	out	0x3d, r28	; 61
    20c2:	99 87       	std	Y+9, r25	; 0x09
    20c4:	88 87       	std	Y+8, r24	; 0x08
    20c6:	7b 87       	std	Y+11, r23	; 0x0b
    20c8:	6a 87       	std	Y+10, r22	; 0x0a
    20ca:	5d 87       	std	Y+13, r21	; 0x0d
    20cc:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    20ce:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    20d0:	88 85       	ldd	r24, Y+8	; 0x08
    20d2:	99 85       	ldd	r25, Y+9	; 0x09
    20d4:	9b 83       	std	Y+3, r25	; 0x03
    20d6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20d8:	0f b6       	in	r0, 0x3f	; 63
    20da:	f8 94       	cli
    20dc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20de:	ea 81       	ldd	r30, Y+2	; 0x02
    20e0:	fb 81       	ldd	r31, Y+3	; 0x03
    20e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    20e6:	89 81       	ldd	r24, Y+1	; 0x01
    20e8:	88 23       	and	r24, r24
    20ea:	f9 f0       	breq	.+62     	; 0x212a <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    20ec:	8a 81       	ldd	r24, Y+2	; 0x02
    20ee:	9b 81       	ldd	r25, Y+3	; 0x03
    20f0:	2a 85       	ldd	r18, Y+10	; 0x0a
    20f2:	3b 85       	ldd	r19, Y+11	; 0x0b
    20f4:	b9 01       	movw	r22, r18
    20f6:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    20fa:	89 81       	ldd	r24, Y+1	; 0x01
    20fc:	81 50       	subi	r24, 0x01	; 1
    20fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2100:	fb 81       	ldd	r31, Y+3	; 0x03
    2102:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2104:	ea 81       	ldd	r30, Y+2	; 0x02
    2106:	fb 81       	ldd	r31, Y+3	; 0x03
    2108:	80 85       	ldd	r24, Z+8	; 0x08
    210a:	88 23       	and	r24, r24
    210c:	49 f0       	breq	.+18     	; 0x2120 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    210e:	8a 81       	ldd	r24, Y+2	; 0x02
    2110:	9b 81       	ldd	r25, Y+3	; 0x03
    2112:	08 96       	adiw	r24, 0x08	; 8
    2114:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    2118:	88 23       	and	r24, r24
    211a:	11 f0       	breq	.+4      	; 0x2120 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    211c:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	8e 87       	std	Y+14, r24	; 0x0e
    2128:	63 c0       	rjmp	.+198    	; 0x21f0 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    212a:	8c 85       	ldd	r24, Y+12	; 0x0c
    212c:	9d 85       	ldd	r25, Y+13	; 0x0d
    212e:	00 97       	sbiw	r24, 0x00	; 0
    2130:	21 f4       	brne	.+8      	; 0x213a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2132:	0f 90       	pop	r0
    2134:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2136:	1e 86       	std	Y+14, r1	; 0x0e
    2138:	5b c0       	rjmp	.+182    	; 0x21f0 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    213a:	8c 81       	ldd	r24, Y+4	; 0x04
    213c:	88 23       	and	r24, r24
    213e:	31 f4       	brne	.+12     	; 0x214c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2140:	ce 01       	movw	r24, r28
    2142:	05 96       	adiw	r24, 0x05	; 5
    2144:	0e 94 17 24 	call	0x482e	; 0x482e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2148:	81 e0       	ldi	r24, 0x01	; 1
    214a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    214c:	0f 90       	pop	r0
    214e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2150:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2154:	0f b6       	in	r0, 0x3f	; 63
    2156:	f8 94       	cli
    2158:	0f 92       	push	r0
    215a:	ea 81       	ldd	r30, Y+2	; 0x02
    215c:	fb 81       	ldd	r31, Y+3	; 0x03
    215e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2160:	8f 3f       	cpi	r24, 0xFF	; 255
    2162:	19 f4       	brne	.+6      	; 0x216a <xQueueReceive+0xbc>
    2164:	ea 81       	ldd	r30, Y+2	; 0x02
    2166:	fb 81       	ldd	r31, Y+3	; 0x03
    2168:	15 8e       	std	Z+29, r1	; 0x1d
    216a:	ea 81       	ldd	r30, Y+2	; 0x02
    216c:	fb 81       	ldd	r31, Y+3	; 0x03
    216e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2170:	8f 3f       	cpi	r24, 0xFF	; 255
    2172:	19 f4       	brne	.+6      	; 0x217a <xQueueReceive+0xcc>
    2174:	ea 81       	ldd	r30, Y+2	; 0x02
    2176:	fb 81       	ldd	r31, Y+3	; 0x03
    2178:	16 8e       	std	Z+30, r1	; 0x1e
    217a:	0f 90       	pop	r0
    217c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    217e:	ce 01       	movw	r24, r28
    2180:	05 96       	adiw	r24, 0x05	; 5
    2182:	9e 01       	movw	r18, r28
    2184:	24 5f       	subi	r18, 0xF4	; 244
    2186:	3f 4f       	sbci	r19, 0xFF	; 255
    2188:	b9 01       	movw	r22, r18
    218a:	0e 94 30 24 	call	0x4860	; 0x4860 <xTaskCheckForTimeOut>
    218e:	88 23       	and	r24, r24
    2190:	09 f5       	brne	.+66     	; 0x21d4 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2192:	8a 81       	ldd	r24, Y+2	; 0x02
    2194:	9b 81       	ldd	r25, Y+3	; 0x03
    2196:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    219a:	88 23       	and	r24, r24
    219c:	a1 f0       	breq	.+40     	; 0x21c6 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    219e:	8a 81       	ldd	r24, Y+2	; 0x02
    21a0:	9b 81       	ldd	r25, Y+3	; 0x03
    21a2:	41 96       	adiw	r24, 0x11	; 17
    21a4:	2c 85       	ldd	r18, Y+12	; 0x0c
    21a6:	3d 85       	ldd	r19, Y+13	; 0x0d
    21a8:	b9 01       	movw	r22, r18
    21aa:	0e 94 df 22 	call	0x45be	; 0x45be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    21ae:	8a 81       	ldd	r24, Y+2	; 0x02
    21b0:	9b 81       	ldd	r25, Y+3	; 0x03
    21b2:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    21b6:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    21ba:	88 23       	and	r24, r24
    21bc:	09 f0       	breq	.+2      	; 0x21c0 <xQueueReceive+0x112>
    21be:	8c cf       	rjmp	.-232    	; 0x20d8 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    21c0:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    21c4:	89 cf       	rjmp	.-238    	; 0x20d8 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    21c6:	8a 81       	ldd	r24, Y+2	; 0x02
    21c8:	9b 81       	ldd	r25, Y+3	; 0x03
    21ca:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    21ce:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    21d2:	82 cf       	rjmp	.-252    	; 0x20d8 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    21d4:	8a 81       	ldd	r24, Y+2	; 0x02
    21d6:	9b 81       	ldd	r25, Y+3	; 0x03
    21d8:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21dc:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    21e0:	8a 81       	ldd	r24, Y+2	; 0x02
    21e2:	9b 81       	ldd	r25, Y+3	; 0x03
    21e4:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    21e8:	88 23       	and	r24, r24
    21ea:	09 f4       	brne	.+2      	; 0x21ee <xQueueReceive+0x140>
    21ec:	75 cf       	rjmp	.-278    	; 0x20d8 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    21ee:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    21f0:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    21f2:	2e 96       	adiw	r28, 0x0e	; 14
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	cd bf       	out	0x3d, r28	; 61
    21fe:	cf 91       	pop	r28
    2200:	df 91       	pop	r29
    2202:	08 95       	ret

00002204 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2204:	df 93       	push	r29
    2206:	cf 93       	push	r28
    2208:	cd b7       	in	r28, 0x3d	; 61
    220a:	de b7       	in	r29, 0x3e	; 62
    220c:	2c 97       	sbiw	r28, 0x0c	; 12
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	de bf       	out	0x3e, r29	; 62
    2214:	0f be       	out	0x3f, r0	; 63
    2216:	cd bf       	out	0x3d, r28	; 61
    2218:	99 87       	std	Y+9, r25	; 0x09
    221a:	88 87       	std	Y+8, r24	; 0x08
    221c:	7b 87       	std	Y+11, r23	; 0x0b
    221e:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2220:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2222:	88 85       	ldd	r24, Y+8	; 0x08
    2224:	99 85       	ldd	r25, Y+9	; 0x09
    2226:	9b 83       	std	Y+3, r25	; 0x03
    2228:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    222a:	0f b6       	in	r0, 0x3f	; 63
    222c:	f8 94       	cli
    222e:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2230:	ea 81       	ldd	r30, Y+2	; 0x02
    2232:	fb 81       	ldd	r31, Y+3	; 0x03
    2234:	82 8d       	ldd	r24, Z+26	; 0x1a
    2236:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2238:	89 81       	ldd	r24, Y+1	; 0x01
    223a:	88 23       	and	r24, r24
    223c:	c1 f0       	breq	.+48     	; 0x226e <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	81 50       	subi	r24, 0x01	; 1
    2242:	ea 81       	ldd	r30, Y+2	; 0x02
    2244:	fb 81       	ldd	r31, Y+3	; 0x03
    2246:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2248:	ea 81       	ldd	r30, Y+2	; 0x02
    224a:	fb 81       	ldd	r31, Y+3	; 0x03
    224c:	80 85       	ldd	r24, Z+8	; 0x08
    224e:	88 23       	and	r24, r24
    2250:	49 f0       	breq	.+18     	; 0x2264 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2252:	8a 81       	ldd	r24, Y+2	; 0x02
    2254:	9b 81       	ldd	r25, Y+3	; 0x03
    2256:	08 96       	adiw	r24, 0x08	; 8
    2258:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    225c:	88 23       	and	r24, r24
    225e:	11 f0       	breq	.+4      	; 0x2264 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2260:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2264:	0f 90       	pop	r0
    2266:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	8c 87       	std	Y+12, r24	; 0x0c
    226c:	63 c0       	rjmp	.+198    	; 0x2334 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    226e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2270:	9b 85       	ldd	r25, Y+11	; 0x0b
    2272:	00 97       	sbiw	r24, 0x00	; 0
    2274:	21 f4       	brne	.+8      	; 0x227e <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2276:	0f 90       	pop	r0
    2278:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    227a:	1c 86       	std	Y+12, r1	; 0x0c
    227c:	5b c0       	rjmp	.+182    	; 0x2334 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    227e:	8c 81       	ldd	r24, Y+4	; 0x04
    2280:	88 23       	and	r24, r24
    2282:	31 f4       	brne	.+12     	; 0x2290 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2284:	ce 01       	movw	r24, r28
    2286:	05 96       	adiw	r24, 0x05	; 5
    2288:	0e 94 17 24 	call	0x482e	; 0x482e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    228c:	81 e0       	ldi	r24, 0x01	; 1
    228e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2290:	0f 90       	pop	r0
    2292:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2294:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	f8 94       	cli
    229c:	0f 92       	push	r0
    229e:	ea 81       	ldd	r30, Y+2	; 0x02
    22a0:	fb 81       	ldd	r31, Y+3	; 0x03
    22a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    22a4:	8f 3f       	cpi	r24, 0xFF	; 255
    22a6:	19 f4       	brne	.+6      	; 0x22ae <xQueueSemaphoreTake+0xaa>
    22a8:	ea 81       	ldd	r30, Y+2	; 0x02
    22aa:	fb 81       	ldd	r31, Y+3	; 0x03
    22ac:	15 8e       	std	Z+29, r1	; 0x1d
    22ae:	ea 81       	ldd	r30, Y+2	; 0x02
    22b0:	fb 81       	ldd	r31, Y+3	; 0x03
    22b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22b4:	8f 3f       	cpi	r24, 0xFF	; 255
    22b6:	19 f4       	brne	.+6      	; 0x22be <xQueueSemaphoreTake+0xba>
    22b8:	ea 81       	ldd	r30, Y+2	; 0x02
    22ba:	fb 81       	ldd	r31, Y+3	; 0x03
    22bc:	16 8e       	std	Z+30, r1	; 0x1e
    22be:	0f 90       	pop	r0
    22c0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    22c2:	ce 01       	movw	r24, r28
    22c4:	05 96       	adiw	r24, 0x05	; 5
    22c6:	9e 01       	movw	r18, r28
    22c8:	26 5f       	subi	r18, 0xF6	; 246
    22ca:	3f 4f       	sbci	r19, 0xFF	; 255
    22cc:	b9 01       	movw	r22, r18
    22ce:	0e 94 30 24 	call	0x4860	; 0x4860 <xTaskCheckForTimeOut>
    22d2:	88 23       	and	r24, r24
    22d4:	09 f5       	brne	.+66     	; 0x2318 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22d6:	8a 81       	ldd	r24, Y+2	; 0x02
    22d8:	9b 81       	ldd	r25, Y+3	; 0x03
    22da:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    22de:	88 23       	and	r24, r24
    22e0:	a1 f0       	breq	.+40     	; 0x230a <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22e2:	8a 81       	ldd	r24, Y+2	; 0x02
    22e4:	9b 81       	ldd	r25, Y+3	; 0x03
    22e6:	41 96       	adiw	r24, 0x11	; 17
    22e8:	2a 85       	ldd	r18, Y+10	; 0x0a
    22ea:	3b 85       	ldd	r19, Y+11	; 0x0b
    22ec:	b9 01       	movw	r22, r18
    22ee:	0e 94 df 22 	call	0x45be	; 0x45be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22f2:	8a 81       	ldd	r24, Y+2	; 0x02
    22f4:	9b 81       	ldd	r25, Y+3	; 0x03
    22f6:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    22fa:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    22fe:	88 23       	and	r24, r24
    2300:	09 f0       	breq	.+2      	; 0x2304 <xQueueSemaphoreTake+0x100>
    2302:	93 cf       	rjmp	.-218    	; 0x222a <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2304:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    2308:	90 cf       	rjmp	.-224    	; 0x222a <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    230a:	8a 81       	ldd	r24, Y+2	; 0x02
    230c:	9b 81       	ldd	r25, Y+3	; 0x03
    230e:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2312:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    2316:	89 cf       	rjmp	.-238    	; 0x222a <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2318:	8a 81       	ldd	r24, Y+2	; 0x02
    231a:	9b 81       	ldd	r25, Y+3	; 0x03
    231c:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2320:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2324:	8a 81       	ldd	r24, Y+2	; 0x02
    2326:	9b 81       	ldd	r25, Y+3	; 0x03
    2328:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    232c:	88 23       	and	r24, r24
    232e:	09 f4       	brne	.+2      	; 0x2332 <xQueueSemaphoreTake+0x12e>
    2330:	7c cf       	rjmp	.-264    	; 0x222a <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2332:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2334:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2336:	2c 96       	adiw	r28, 0x0c	; 12
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	de bf       	out	0x3e, r29	; 62
    233e:	0f be       	out	0x3f, r0	; 63
    2340:	cd bf       	out	0x3d, r28	; 61
    2342:	cf 91       	pop	r28
    2344:	df 91       	pop	r29
    2346:	08 95       	ret

00002348 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2348:	df 93       	push	r29
    234a:	cf 93       	push	r28
    234c:	cd b7       	in	r28, 0x3d	; 61
    234e:	de b7       	in	r29, 0x3e	; 62
    2350:	60 97       	sbiw	r28, 0x10	; 16
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	de bf       	out	0x3e, r29	; 62
    2358:	0f be       	out	0x3f, r0	; 63
    235a:	cd bf       	out	0x3d, r28	; 61
    235c:	9b 87       	std	Y+11, r25	; 0x0b
    235e:	8a 87       	std	Y+10, r24	; 0x0a
    2360:	7d 87       	std	Y+13, r23	; 0x0d
    2362:	6c 87       	std	Y+12, r22	; 0x0c
    2364:	5f 87       	std	Y+15, r21	; 0x0f
    2366:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2368:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    236a:	8a 85       	ldd	r24, Y+10	; 0x0a
    236c:	9b 85       	ldd	r25, Y+11	; 0x0b
    236e:	9b 83       	std	Y+3, r25	; 0x03
    2370:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2372:	0f b6       	in	r0, 0x3f	; 63
    2374:	f8 94       	cli
    2376:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2378:	ea 81       	ldd	r30, Y+2	; 0x02
    237a:	fb 81       	ldd	r31, Y+3	; 0x03
    237c:	82 8d       	ldd	r24, Z+26	; 0x1a
    237e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2380:	89 81       	ldd	r24, Y+1	; 0x01
    2382:	88 23       	and	r24, r24
    2384:	31 f1       	breq	.+76     	; 0x23d2 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2386:	ea 81       	ldd	r30, Y+2	; 0x02
    2388:	fb 81       	ldd	r31, Y+3	; 0x03
    238a:	86 81       	ldd	r24, Z+6	; 0x06
    238c:	97 81       	ldd	r25, Z+7	; 0x07
    238e:	9d 83       	std	Y+5, r25	; 0x05
    2390:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2392:	8a 81       	ldd	r24, Y+2	; 0x02
    2394:	9b 81       	ldd	r25, Y+3	; 0x03
    2396:	2c 85       	ldd	r18, Y+12	; 0x0c
    2398:	3d 85       	ldd	r19, Y+13	; 0x0d
    239a:	b9 01       	movw	r22, r18
    239c:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    23a0:	ea 81       	ldd	r30, Y+2	; 0x02
    23a2:	fb 81       	ldd	r31, Y+3	; 0x03
    23a4:	8c 81       	ldd	r24, Y+4	; 0x04
    23a6:	9d 81       	ldd	r25, Y+5	; 0x05
    23a8:	97 83       	std	Z+7, r25	; 0x07
    23aa:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23ac:	ea 81       	ldd	r30, Y+2	; 0x02
    23ae:	fb 81       	ldd	r31, Y+3	; 0x03
    23b0:	81 89       	ldd	r24, Z+17	; 0x11
    23b2:	88 23       	and	r24, r24
    23b4:	49 f0       	breq	.+18     	; 0x23c8 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23b6:	8a 81       	ldd	r24, Y+2	; 0x02
    23b8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ba:	41 96       	adiw	r24, 0x11	; 17
    23bc:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    23c0:	88 23       	and	r24, r24
    23c2:	11 f0       	breq	.+4      	; 0x23c8 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    23c4:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    23c8:	0f 90       	pop	r0
    23ca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	88 8b       	std	Y+16, r24	; 0x10
    23d0:	63 c0       	rjmp	.+198    	; 0x2498 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    23d4:	9f 85       	ldd	r25, Y+15	; 0x0f
    23d6:	00 97       	sbiw	r24, 0x00	; 0
    23d8:	21 f4       	brne	.+8      	; 0x23e2 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23de:	18 8a       	std	Y+16, r1	; 0x10
    23e0:	5b c0       	rjmp	.+182    	; 0x2498 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    23e2:	8e 81       	ldd	r24, Y+6	; 0x06
    23e4:	88 23       	and	r24, r24
    23e6:	31 f4       	brne	.+12     	; 0x23f4 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    23e8:	ce 01       	movw	r24, r28
    23ea:	07 96       	adiw	r24, 0x07	; 7
    23ec:	0e 94 17 24 	call	0x482e	; 0x482e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    23f0:	81 e0       	ldi	r24, 0x01	; 1
    23f2:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    23f4:	0f 90       	pop	r0
    23f6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23f8:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23fc:	0f b6       	in	r0, 0x3f	; 63
    23fe:	f8 94       	cli
    2400:	0f 92       	push	r0
    2402:	ea 81       	ldd	r30, Y+2	; 0x02
    2404:	fb 81       	ldd	r31, Y+3	; 0x03
    2406:	85 8d       	ldd	r24, Z+29	; 0x1d
    2408:	8f 3f       	cpi	r24, 0xFF	; 255
    240a:	19 f4       	brne	.+6      	; 0x2412 <xQueuePeek+0xca>
    240c:	ea 81       	ldd	r30, Y+2	; 0x02
    240e:	fb 81       	ldd	r31, Y+3	; 0x03
    2410:	15 8e       	std	Z+29, r1	; 0x1d
    2412:	ea 81       	ldd	r30, Y+2	; 0x02
    2414:	fb 81       	ldd	r31, Y+3	; 0x03
    2416:	86 8d       	ldd	r24, Z+30	; 0x1e
    2418:	8f 3f       	cpi	r24, 0xFF	; 255
    241a:	19 f4       	brne	.+6      	; 0x2422 <xQueuePeek+0xda>
    241c:	ea 81       	ldd	r30, Y+2	; 0x02
    241e:	fb 81       	ldd	r31, Y+3	; 0x03
    2420:	16 8e       	std	Z+30, r1	; 0x1e
    2422:	0f 90       	pop	r0
    2424:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2426:	ce 01       	movw	r24, r28
    2428:	07 96       	adiw	r24, 0x07	; 7
    242a:	9e 01       	movw	r18, r28
    242c:	22 5f       	subi	r18, 0xF2	; 242
    242e:	3f 4f       	sbci	r19, 0xFF	; 255
    2430:	b9 01       	movw	r22, r18
    2432:	0e 94 30 24 	call	0x4860	; 0x4860 <xTaskCheckForTimeOut>
    2436:	88 23       	and	r24, r24
    2438:	09 f5       	brne	.+66     	; 0x247c <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    243a:	8a 81       	ldd	r24, Y+2	; 0x02
    243c:	9b 81       	ldd	r25, Y+3	; 0x03
    243e:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    2442:	88 23       	and	r24, r24
    2444:	a1 f0       	breq	.+40     	; 0x246e <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2446:	8a 81       	ldd	r24, Y+2	; 0x02
    2448:	9b 81       	ldd	r25, Y+3	; 0x03
    244a:	41 96       	adiw	r24, 0x11	; 17
    244c:	2e 85       	ldd	r18, Y+14	; 0x0e
    244e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2450:	b9 01       	movw	r22, r18
    2452:	0e 94 df 22 	call	0x45be	; 0x45be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2456:	8a 81       	ldd	r24, Y+2	; 0x02
    2458:	9b 81       	ldd	r25, Y+3	; 0x03
    245a:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    245e:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    2462:	88 23       	and	r24, r24
    2464:	09 f0       	breq	.+2      	; 0x2468 <xQueuePeek+0x120>
    2466:	85 cf       	rjmp	.-246    	; 0x2372 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2468:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    246c:	82 cf       	rjmp	.-252    	; 0x2372 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    246e:	8a 81       	ldd	r24, Y+2	; 0x02
    2470:	9b 81       	ldd	r25, Y+3	; 0x03
    2472:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2476:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    247a:	7b cf       	rjmp	.-266    	; 0x2372 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    247c:	8a 81       	ldd	r24, Y+2	; 0x02
    247e:	9b 81       	ldd	r25, Y+3	; 0x03
    2480:	0e 94 41 14 	call	0x2882	; 0x2882 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2484:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2488:	8a 81       	ldd	r24, Y+2	; 0x02
    248a:	9b 81       	ldd	r25, Y+3	; 0x03
    248c:	0e 94 94 14 	call	0x2928	; 0x2928 <prvIsQueueEmpty>
    2490:	88 23       	and	r24, r24
    2492:	09 f4       	brne	.+2      	; 0x2496 <xQueuePeek+0x14e>
    2494:	6e cf       	rjmp	.-292    	; 0x2372 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2496:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2498:	88 89       	ldd	r24, Y+16	; 0x10
}
    249a:	60 96       	adiw	r28, 0x10	; 16
    249c:	0f b6       	in	r0, 0x3f	; 63
    249e:	f8 94       	cli
    24a0:	de bf       	out	0x3e, r29	; 62
    24a2:	0f be       	out	0x3f, r0	; 63
    24a4:	cd bf       	out	0x3d, r28	; 61
    24a6:	cf 91       	pop	r28
    24a8:	df 91       	pop	r29
    24aa:	08 95       	ret

000024ac <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    24ac:	df 93       	push	r29
    24ae:	cf 93       	push	r28
    24b0:	cd b7       	in	r28, 0x3d	; 61
    24b2:	de b7       	in	r29, 0x3e	; 62
    24b4:	2c 97       	sbiw	r28, 0x0c	; 12
    24b6:	0f b6       	in	r0, 0x3f	; 63
    24b8:	f8 94       	cli
    24ba:	de bf       	out	0x3e, r29	; 62
    24bc:	0f be       	out	0x3f, r0	; 63
    24be:	cd bf       	out	0x3d, r28	; 61
    24c0:	98 87       	std	Y+8, r25	; 0x08
    24c2:	8f 83       	std	Y+7, r24	; 0x07
    24c4:	7a 87       	std	Y+10, r23	; 0x0a
    24c6:	69 87       	std	Y+9, r22	; 0x09
    24c8:	5c 87       	std	Y+12, r21	; 0x0c
    24ca:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    24cc:	8f 81       	ldd	r24, Y+7	; 0x07
    24ce:	98 85       	ldd	r25, Y+8	; 0x08
    24d0:	9c 83       	std	Y+4, r25	; 0x04
    24d2:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    24d4:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    24d6:	eb 81       	ldd	r30, Y+3	; 0x03
    24d8:	fc 81       	ldd	r31, Y+4	; 0x04
    24da:	82 8d       	ldd	r24, Z+26	; 0x1a
    24dc:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    24de:	8a 81       	ldd	r24, Y+2	; 0x02
    24e0:	88 23       	and	r24, r24
    24e2:	81 f1       	breq	.+96     	; 0x2544 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    24e4:	eb 81       	ldd	r30, Y+3	; 0x03
    24e6:	fc 81       	ldd	r31, Y+4	; 0x04
    24e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    24ea:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    24ec:	8b 81       	ldd	r24, Y+3	; 0x03
    24ee:	9c 81       	ldd	r25, Y+4	; 0x04
    24f0:	29 85       	ldd	r18, Y+9	; 0x09
    24f2:	3a 85       	ldd	r19, Y+10	; 0x0a
    24f4:	b9 01       	movw	r22, r18
    24f6:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    24fa:	8a 81       	ldd	r24, Y+2	; 0x02
    24fc:	81 50       	subi	r24, 0x01	; 1
    24fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2500:	fc 81       	ldd	r31, Y+4	; 0x04
    2502:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2504:	89 81       	ldd	r24, Y+1	; 0x01
    2506:	8f 3f       	cpi	r24, 0xFF	; 255
    2508:	a9 f4       	brne	.+42     	; 0x2534 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    250a:	eb 81       	ldd	r30, Y+3	; 0x03
    250c:	fc 81       	ldd	r31, Y+4	; 0x04
    250e:	80 85       	ldd	r24, Z+8	; 0x08
    2510:	88 23       	and	r24, r24
    2512:	a9 f0       	breq	.+42     	; 0x253e <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2514:	8b 81       	ldd	r24, Y+3	; 0x03
    2516:	9c 81       	ldd	r25, Y+4	; 0x04
    2518:	08 96       	adiw	r24, 0x08	; 8
    251a:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    251e:	88 23       	and	r24, r24
    2520:	71 f0       	breq	.+28     	; 0x253e <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2522:	8b 85       	ldd	r24, Y+11	; 0x0b
    2524:	9c 85       	ldd	r25, Y+12	; 0x0c
    2526:	00 97       	sbiw	r24, 0x00	; 0
    2528:	51 f0       	breq	.+20     	; 0x253e <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    252a:	eb 85       	ldd	r30, Y+11	; 0x0b
    252c:	fc 85       	ldd	r31, Y+12	; 0x0c
    252e:	81 e0       	ldi	r24, 0x01	; 1
    2530:	80 83       	st	Z, r24
    2532:	05 c0       	rjmp	.+10     	; 0x253e <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2534:	89 81       	ldd	r24, Y+1	; 0x01
    2536:	8f 5f       	subi	r24, 0xFF	; 255
    2538:	eb 81       	ldd	r30, Y+3	; 0x03
    253a:	fc 81       	ldd	r31, Y+4	; 0x04
    253c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	8e 83       	std	Y+6, r24	; 0x06
    2542:	01 c0       	rjmp	.+2      	; 0x2546 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2544:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2546:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2548:	2c 96       	adiw	r28, 0x0c	; 12
    254a:	0f b6       	in	r0, 0x3f	; 63
    254c:	f8 94       	cli
    254e:	de bf       	out	0x3e, r29	; 62
    2550:	0f be       	out	0x3f, r0	; 63
    2552:	cd bf       	out	0x3d, r28	; 61
    2554:	cf 91       	pop	r28
    2556:	df 91       	pop	r29
    2558:	08 95       	ret

0000255a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    255a:	df 93       	push	r29
    255c:	cf 93       	push	r28
    255e:	cd b7       	in	r28, 0x3d	; 61
    2560:	de b7       	in	r29, 0x3e	; 62
    2562:	2a 97       	sbiw	r28, 0x0a	; 10
    2564:	0f b6       	in	r0, 0x3f	; 63
    2566:	f8 94       	cli
    2568:	de bf       	out	0x3e, r29	; 62
    256a:	0f be       	out	0x3f, r0	; 63
    256c:	cd bf       	out	0x3d, r28	; 61
    256e:	98 87       	std	Y+8, r25	; 0x08
    2570:	8f 83       	std	Y+7, r24	; 0x07
    2572:	7a 87       	std	Y+10, r23	; 0x0a
    2574:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2576:	8f 81       	ldd	r24, Y+7	; 0x07
    2578:	98 85       	ldd	r25, Y+8	; 0x08
    257a:	9a 83       	std	Y+2, r25	; 0x02
    257c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    257e:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2580:	e9 81       	ldd	r30, Y+1	; 0x01
    2582:	fa 81       	ldd	r31, Y+2	; 0x02
    2584:	82 8d       	ldd	r24, Z+26	; 0x1a
    2586:	88 23       	and	r24, r24
    2588:	b1 f0       	breq	.+44     	; 0x25b6 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    258a:	e9 81       	ldd	r30, Y+1	; 0x01
    258c:	fa 81       	ldd	r31, Y+2	; 0x02
    258e:	86 81       	ldd	r24, Z+6	; 0x06
    2590:	97 81       	ldd	r25, Z+7	; 0x07
    2592:	9c 83       	std	Y+4, r25	; 0x04
    2594:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	29 85       	ldd	r18, Y+9	; 0x09
    259c:	3a 85       	ldd	r19, Y+10	; 0x0a
    259e:	b9 01       	movw	r22, r18
    25a0:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    25a4:	e9 81       	ldd	r30, Y+1	; 0x01
    25a6:	fa 81       	ldd	r31, Y+2	; 0x02
    25a8:	8b 81       	ldd	r24, Y+3	; 0x03
    25aa:	9c 81       	ldd	r25, Y+4	; 0x04
    25ac:	97 83       	std	Z+7, r25	; 0x07
    25ae:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    25b0:	81 e0       	ldi	r24, 0x01	; 1
    25b2:	8e 83       	std	Y+6, r24	; 0x06
    25b4:	01 c0       	rjmp	.+2      	; 0x25b8 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    25b6:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    25b8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    25ba:	2a 96       	adiw	r28, 0x0a	; 10
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	de bf       	out	0x3e, r29	; 62
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	cf 91       	pop	r28
    25c8:	df 91       	pop	r29
    25ca:	08 95       	ret

000025cc <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    25cc:	df 93       	push	r29
    25ce:	cf 93       	push	r28
    25d0:	00 d0       	rcall	.+0      	; 0x25d2 <uxQueueMessagesWaiting+0x6>
    25d2:	0f 92       	push	r0
    25d4:	cd b7       	in	r28, 0x3d	; 61
    25d6:	de b7       	in	r29, 0x3e	; 62
    25d8:	9b 83       	std	Y+3, r25	; 0x03
    25da:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    25dc:	0f b6       	in	r0, 0x3f	; 63
    25de:	f8 94       	cli
    25e0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    25e2:	ea 81       	ldd	r30, Y+2	; 0x02
    25e4:	fb 81       	ldd	r31, Y+3	; 0x03
    25e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    25e8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    25ea:	0f 90       	pop	r0
    25ec:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    25ee:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    25f0:	0f 90       	pop	r0
    25f2:	0f 90       	pop	r0
    25f4:	0f 90       	pop	r0
    25f6:	cf 91       	pop	r28
    25f8:	df 91       	pop	r29
    25fa:	08 95       	ret

000025fc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    25fc:	df 93       	push	r29
    25fe:	cf 93       	push	r28
    2600:	00 d0       	rcall	.+0      	; 0x2602 <uxQueueSpacesAvailable+0x6>
    2602:	00 d0       	rcall	.+0      	; 0x2604 <uxQueueSpacesAvailable+0x8>
    2604:	0f 92       	push	r0
    2606:	cd b7       	in	r28, 0x3d	; 61
    2608:	de b7       	in	r29, 0x3e	; 62
    260a:	9d 83       	std	Y+5, r25	; 0x05
    260c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    260e:	8c 81       	ldd	r24, Y+4	; 0x04
    2610:	9d 81       	ldd	r25, Y+5	; 0x05
    2612:	9a 83       	std	Y+2, r25	; 0x02
    2614:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    261c:	e9 81       	ldd	r30, Y+1	; 0x01
    261e:	fa 81       	ldd	r31, Y+2	; 0x02
    2620:	93 8d       	ldd	r25, Z+27	; 0x1b
    2622:	e9 81       	ldd	r30, Y+1	; 0x01
    2624:	fa 81       	ldd	r31, Y+2	; 0x02
    2626:	82 8d       	ldd	r24, Z+26	; 0x1a
    2628:	29 2f       	mov	r18, r25
    262a:	28 1b       	sub	r18, r24
    262c:	82 2f       	mov	r24, r18
    262e:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2630:	0f 90       	pop	r0
    2632:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2634:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2636:	0f 90       	pop	r0
    2638:	0f 90       	pop	r0
    263a:	0f 90       	pop	r0
    263c:	0f 90       	pop	r0
    263e:	0f 90       	pop	r0
    2640:	cf 91       	pop	r28
    2642:	df 91       	pop	r29
    2644:	08 95       	ret

00002646 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2646:	df 93       	push	r29
    2648:	cf 93       	push	r28
    264a:	00 d0       	rcall	.+0      	; 0x264c <uxQueueMessagesWaitingFromISR+0x6>
    264c:	00 d0       	rcall	.+0      	; 0x264e <uxQueueMessagesWaitingFromISR+0x8>
    264e:	0f 92       	push	r0
    2650:	cd b7       	in	r28, 0x3d	; 61
    2652:	de b7       	in	r29, 0x3e	; 62
    2654:	9d 83       	std	Y+5, r25	; 0x05
    2656:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2658:	8c 81       	ldd	r24, Y+4	; 0x04
    265a:	9d 81       	ldd	r25, Y+5	; 0x05
    265c:	9a 83       	std	Y+2, r25	; 0x02
    265e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2660:	e9 81       	ldd	r30, Y+1	; 0x01
    2662:	fa 81       	ldd	r31, Y+2	; 0x02
    2664:	82 8d       	ldd	r24, Z+26	; 0x1a
    2666:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2668:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    266a:	0f 90       	pop	r0
    266c:	0f 90       	pop	r0
    266e:	0f 90       	pop	r0
    2670:	0f 90       	pop	r0
    2672:	0f 90       	pop	r0
    2674:	cf 91       	pop	r28
    2676:	df 91       	pop	r29
    2678:	08 95       	ret

0000267a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    267a:	df 93       	push	r29
    267c:	cf 93       	push	r28
    267e:	00 d0       	rcall	.+0      	; 0x2680 <vQueueDelete+0x6>
    2680:	00 d0       	rcall	.+0      	; 0x2682 <vQueueDelete+0x8>
    2682:	cd b7       	in	r28, 0x3d	; 61
    2684:	de b7       	in	r29, 0x3e	; 62
    2686:	9c 83       	std	Y+4, r25	; 0x04
    2688:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    268a:	8b 81       	ldd	r24, Y+3	; 0x03
    268c:	9c 81       	ldd	r25, Y+4	; 0x04
    268e:	9a 83       	std	Y+2, r25	; 0x02
    2690:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2692:	89 81       	ldd	r24, Y+1	; 0x01
    2694:	9a 81       	ldd	r25, Y+2	; 0x02
    2696:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    269a:	0f 90       	pop	r0
    269c:	0f 90       	pop	r0
    269e:	0f 90       	pop	r0
    26a0:	0f 90       	pop	r0
    26a2:	cf 91       	pop	r28
    26a4:	df 91       	pop	r29
    26a6:	08 95       	ret

000026a8 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    26a8:	df 93       	push	r29
    26aa:	cf 93       	push	r28
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	27 97       	sbiw	r28, 0x07	; 7
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	9c 83       	std	Y+4, r25	; 0x04
    26be:	8b 83       	std	Y+3, r24	; 0x03
    26c0:	7e 83       	std	Y+6, r23	; 0x06
    26c2:	6d 83       	std	Y+5, r22	; 0x05
    26c4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    26c6:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    26c8:	eb 81       	ldd	r30, Y+3	; 0x03
    26ca:	fc 81       	ldd	r31, Y+4	; 0x04
    26cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ce:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    26d0:	eb 81       	ldd	r30, Y+3	; 0x03
    26d2:	fc 81       	ldd	r31, Y+4	; 0x04
    26d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    26d6:	88 23       	and	r24, r24
    26d8:	09 f4       	brne	.+2      	; 0x26dc <prvCopyDataToQueue+0x34>
    26da:	7d c0       	rjmp	.+250    	; 0x27d6 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    26dc:	8f 81       	ldd	r24, Y+7	; 0x07
    26de:	88 23       	and	r24, r24
    26e0:	99 f5       	brne	.+102    	; 0x2748 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    26e2:	eb 81       	ldd	r30, Y+3	; 0x03
    26e4:	fc 81       	ldd	r31, Y+4	; 0x04
    26e6:	62 81       	ldd	r22, Z+2	; 0x02
    26e8:	73 81       	ldd	r23, Z+3	; 0x03
    26ea:	eb 81       	ldd	r30, Y+3	; 0x03
    26ec:	fc 81       	ldd	r31, Y+4	; 0x04
    26ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    26f0:	48 2f       	mov	r20, r24
    26f2:	50 e0       	ldi	r21, 0x00	; 0
    26f4:	2d 81       	ldd	r18, Y+5	; 0x05
    26f6:	3e 81       	ldd	r19, Y+6	; 0x06
    26f8:	cb 01       	movw	r24, r22
    26fa:	b9 01       	movw	r22, r18
    26fc:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2700:	eb 81       	ldd	r30, Y+3	; 0x03
    2702:	fc 81       	ldd	r31, Y+4	; 0x04
    2704:	22 81       	ldd	r18, Z+2	; 0x02
    2706:	33 81       	ldd	r19, Z+3	; 0x03
    2708:	eb 81       	ldd	r30, Y+3	; 0x03
    270a:	fc 81       	ldd	r31, Y+4	; 0x04
    270c:	84 8d       	ldd	r24, Z+28	; 0x1c
    270e:	88 2f       	mov	r24, r24
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	82 0f       	add	r24, r18
    2714:	93 1f       	adc	r25, r19
    2716:	eb 81       	ldd	r30, Y+3	; 0x03
    2718:	fc 81       	ldd	r31, Y+4	; 0x04
    271a:	93 83       	std	Z+3, r25	; 0x03
    271c:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    271e:	eb 81       	ldd	r30, Y+3	; 0x03
    2720:	fc 81       	ldd	r31, Y+4	; 0x04
    2722:	22 81       	ldd	r18, Z+2	; 0x02
    2724:	33 81       	ldd	r19, Z+3	; 0x03
    2726:	eb 81       	ldd	r30, Y+3	; 0x03
    2728:	fc 81       	ldd	r31, Y+4	; 0x04
    272a:	84 81       	ldd	r24, Z+4	; 0x04
    272c:	95 81       	ldd	r25, Z+5	; 0x05
    272e:	28 17       	cp	r18, r24
    2730:	39 07       	cpc	r19, r25
    2732:	08 f4       	brcc	.+2      	; 0x2736 <prvCopyDataToQueue+0x8e>
    2734:	50 c0       	rjmp	.+160    	; 0x27d6 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2736:	eb 81       	ldd	r30, Y+3	; 0x03
    2738:	fc 81       	ldd	r31, Y+4	; 0x04
    273a:	80 81       	ld	r24, Z
    273c:	91 81       	ldd	r25, Z+1	; 0x01
    273e:	eb 81       	ldd	r30, Y+3	; 0x03
    2740:	fc 81       	ldd	r31, Y+4	; 0x04
    2742:	93 83       	std	Z+3, r25	; 0x03
    2744:	82 83       	std	Z+2, r24	; 0x02
    2746:	47 c0       	rjmp	.+142    	; 0x27d6 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2748:	eb 81       	ldd	r30, Y+3	; 0x03
    274a:	fc 81       	ldd	r31, Y+4	; 0x04
    274c:	66 81       	ldd	r22, Z+6	; 0x06
    274e:	77 81       	ldd	r23, Z+7	; 0x07
    2750:	eb 81       	ldd	r30, Y+3	; 0x03
    2752:	fc 81       	ldd	r31, Y+4	; 0x04
    2754:	84 8d       	ldd	r24, Z+28	; 0x1c
    2756:	48 2f       	mov	r20, r24
    2758:	50 e0       	ldi	r21, 0x00	; 0
    275a:	2d 81       	ldd	r18, Y+5	; 0x05
    275c:	3e 81       	ldd	r19, Y+6	; 0x06
    275e:	cb 01       	movw	r24, r22
    2760:	b9 01       	movw	r22, r18
    2762:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2766:	eb 81       	ldd	r30, Y+3	; 0x03
    2768:	fc 81       	ldd	r31, Y+4	; 0x04
    276a:	26 81       	ldd	r18, Z+6	; 0x06
    276c:	37 81       	ldd	r19, Z+7	; 0x07
    276e:	eb 81       	ldd	r30, Y+3	; 0x03
    2770:	fc 81       	ldd	r31, Y+4	; 0x04
    2772:	84 8d       	ldd	r24, Z+28	; 0x1c
    2774:	88 2f       	mov	r24, r24
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	90 95       	com	r25
    277a:	81 95       	neg	r24
    277c:	9f 4f       	sbci	r25, 0xFF	; 255
    277e:	82 0f       	add	r24, r18
    2780:	93 1f       	adc	r25, r19
    2782:	eb 81       	ldd	r30, Y+3	; 0x03
    2784:	fc 81       	ldd	r31, Y+4	; 0x04
    2786:	97 83       	std	Z+7, r25	; 0x07
    2788:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    278a:	eb 81       	ldd	r30, Y+3	; 0x03
    278c:	fc 81       	ldd	r31, Y+4	; 0x04
    278e:	26 81       	ldd	r18, Z+6	; 0x06
    2790:	37 81       	ldd	r19, Z+7	; 0x07
    2792:	eb 81       	ldd	r30, Y+3	; 0x03
    2794:	fc 81       	ldd	r31, Y+4	; 0x04
    2796:	80 81       	ld	r24, Z
    2798:	91 81       	ldd	r25, Z+1	; 0x01
    279a:	28 17       	cp	r18, r24
    279c:	39 07       	cpc	r19, r25
    279e:	90 f4       	brcc	.+36     	; 0x27c4 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    27a0:	eb 81       	ldd	r30, Y+3	; 0x03
    27a2:	fc 81       	ldd	r31, Y+4	; 0x04
    27a4:	24 81       	ldd	r18, Z+4	; 0x04
    27a6:	35 81       	ldd	r19, Z+5	; 0x05
    27a8:	eb 81       	ldd	r30, Y+3	; 0x03
    27aa:	fc 81       	ldd	r31, Y+4	; 0x04
    27ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    27ae:	88 2f       	mov	r24, r24
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	90 95       	com	r25
    27b4:	81 95       	neg	r24
    27b6:	9f 4f       	sbci	r25, 0xFF	; 255
    27b8:	82 0f       	add	r24, r18
    27ba:	93 1f       	adc	r25, r19
    27bc:	eb 81       	ldd	r30, Y+3	; 0x03
    27be:	fc 81       	ldd	r31, Y+4	; 0x04
    27c0:	97 83       	std	Z+7, r25	; 0x07
    27c2:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    27c4:	8f 81       	ldd	r24, Y+7	; 0x07
    27c6:	82 30       	cpi	r24, 0x02	; 2
    27c8:	31 f4       	brne	.+12     	; 0x27d6 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    27ca:	89 81       	ldd	r24, Y+1	; 0x01
    27cc:	88 23       	and	r24, r24
    27ce:	19 f0       	breq	.+6      	; 0x27d6 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    27d0:	89 81       	ldd	r24, Y+1	; 0x01
    27d2:	81 50       	subi	r24, 0x01	; 1
    27d4:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    27d6:	89 81       	ldd	r24, Y+1	; 0x01
    27d8:	8f 5f       	subi	r24, 0xFF	; 255
    27da:	eb 81       	ldd	r30, Y+3	; 0x03
    27dc:	fc 81       	ldd	r31, Y+4	; 0x04
    27de:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    27e0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    27e2:	27 96       	adiw	r28, 0x07	; 7
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	de bf       	out	0x3e, r29	; 62
    27ea:	0f be       	out	0x3f, r0	; 63
    27ec:	cd bf       	out	0x3d, r28	; 61
    27ee:	cf 91       	pop	r28
    27f0:	df 91       	pop	r29
    27f2:	08 95       	ret

000027f4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    27f4:	df 93       	push	r29
    27f6:	cf 93       	push	r28
    27f8:	00 d0       	rcall	.+0      	; 0x27fa <prvCopyDataFromQueue+0x6>
    27fa:	00 d0       	rcall	.+0      	; 0x27fc <prvCopyDataFromQueue+0x8>
    27fc:	cd b7       	in	r28, 0x3d	; 61
    27fe:	de b7       	in	r29, 0x3e	; 62
    2800:	9a 83       	std	Y+2, r25	; 0x02
    2802:	89 83       	std	Y+1, r24	; 0x01
    2804:	7c 83       	std	Y+4, r23	; 0x04
    2806:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2808:	e9 81       	ldd	r30, Y+1	; 0x01
    280a:	fa 81       	ldd	r31, Y+2	; 0x02
    280c:	84 8d       	ldd	r24, Z+28	; 0x1c
    280e:	88 23       	and	r24, r24
    2810:	89 f1       	breq	.+98     	; 0x2874 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2812:	e9 81       	ldd	r30, Y+1	; 0x01
    2814:	fa 81       	ldd	r31, Y+2	; 0x02
    2816:	26 81       	ldd	r18, Z+6	; 0x06
    2818:	37 81       	ldd	r19, Z+7	; 0x07
    281a:	e9 81       	ldd	r30, Y+1	; 0x01
    281c:	fa 81       	ldd	r31, Y+2	; 0x02
    281e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2820:	88 2f       	mov	r24, r24
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	82 0f       	add	r24, r18
    2826:	93 1f       	adc	r25, r19
    2828:	e9 81       	ldd	r30, Y+1	; 0x01
    282a:	fa 81       	ldd	r31, Y+2	; 0x02
    282c:	97 83       	std	Z+7, r25	; 0x07
    282e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2830:	e9 81       	ldd	r30, Y+1	; 0x01
    2832:	fa 81       	ldd	r31, Y+2	; 0x02
    2834:	26 81       	ldd	r18, Z+6	; 0x06
    2836:	37 81       	ldd	r19, Z+7	; 0x07
    2838:	e9 81       	ldd	r30, Y+1	; 0x01
    283a:	fa 81       	ldd	r31, Y+2	; 0x02
    283c:	84 81       	ldd	r24, Z+4	; 0x04
    283e:	95 81       	ldd	r25, Z+5	; 0x05
    2840:	28 17       	cp	r18, r24
    2842:	39 07       	cpc	r19, r25
    2844:	40 f0       	brcs	.+16     	; 0x2856 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2846:	e9 81       	ldd	r30, Y+1	; 0x01
    2848:	fa 81       	ldd	r31, Y+2	; 0x02
    284a:	80 81       	ld	r24, Z
    284c:	91 81       	ldd	r25, Z+1	; 0x01
    284e:	e9 81       	ldd	r30, Y+1	; 0x01
    2850:	fa 81       	ldd	r31, Y+2	; 0x02
    2852:	97 83       	std	Z+7, r25	; 0x07
    2854:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2856:	e9 81       	ldd	r30, Y+1	; 0x01
    2858:	fa 81       	ldd	r31, Y+2	; 0x02
    285a:	46 81       	ldd	r20, Z+6	; 0x06
    285c:	57 81       	ldd	r21, Z+7	; 0x07
    285e:	e9 81       	ldd	r30, Y+1	; 0x01
    2860:	fa 81       	ldd	r31, Y+2	; 0x02
    2862:	84 8d       	ldd	r24, Z+28	; 0x1c
    2864:	28 2f       	mov	r18, r24
    2866:	30 e0       	ldi	r19, 0x00	; 0
    2868:	8b 81       	ldd	r24, Y+3	; 0x03
    286a:	9c 81       	ldd	r25, Y+4	; 0x04
    286c:	ba 01       	movw	r22, r20
    286e:	a9 01       	movw	r20, r18
    2870:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>
	}
}
    2874:	0f 90       	pop	r0
    2876:	0f 90       	pop	r0
    2878:	0f 90       	pop	r0
    287a:	0f 90       	pop	r0
    287c:	cf 91       	pop	r28
    287e:	df 91       	pop	r29
    2880:	08 95       	ret

00002882 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2882:	df 93       	push	r29
    2884:	cf 93       	push	r28
    2886:	00 d0       	rcall	.+0      	; 0x2888 <prvUnlockQueue+0x6>
    2888:	00 d0       	rcall	.+0      	; 0x288a <prvUnlockQueue+0x8>
    288a:	cd b7       	in	r28, 0x3d	; 61
    288c:	de b7       	in	r29, 0x3e	; 62
    288e:	9c 83       	std	Y+4, r25	; 0x04
    2890:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2898:	eb 81       	ldd	r30, Y+3	; 0x03
    289a:	fc 81       	ldd	r31, Y+4	; 0x04
    289c:	86 8d       	ldd	r24, Z+30	; 0x1e
    289e:	8a 83       	std	Y+2, r24	; 0x02
    28a0:	11 c0       	rjmp	.+34     	; 0x28c4 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28a2:	eb 81       	ldd	r30, Y+3	; 0x03
    28a4:	fc 81       	ldd	r31, Y+4	; 0x04
    28a6:	81 89       	ldd	r24, Z+17	; 0x11
    28a8:	88 23       	and	r24, r24
    28aa:	79 f0       	breq	.+30     	; 0x28ca <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28ac:	8b 81       	ldd	r24, Y+3	; 0x03
    28ae:	9c 81       	ldd	r25, Y+4	; 0x04
    28b0:	41 96       	adiw	r24, 0x11	; 17
    28b2:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    28b6:	88 23       	and	r24, r24
    28b8:	11 f0       	breq	.+4      	; 0x28be <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    28ba:	0e 94 9d 24 	call	0x493a	; 0x493a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    28be:	8a 81       	ldd	r24, Y+2	; 0x02
    28c0:	81 50       	subi	r24, 0x01	; 1
    28c2:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    28c4:	8a 81       	ldd	r24, Y+2	; 0x02
    28c6:	18 16       	cp	r1, r24
    28c8:	64 f3       	brlt	.-40     	; 0x28a2 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    28ca:	eb 81       	ldd	r30, Y+3	; 0x03
    28cc:	fc 81       	ldd	r31, Y+4	; 0x04
    28ce:	8f ef       	ldi	r24, 0xFF	; 255
    28d0:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    28d2:	0f 90       	pop	r0
    28d4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    28d6:	0f b6       	in	r0, 0x3f	; 63
    28d8:	f8 94       	cli
    28da:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    28dc:	eb 81       	ldd	r30, Y+3	; 0x03
    28de:	fc 81       	ldd	r31, Y+4	; 0x04
    28e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    28e2:	89 83       	std	Y+1, r24	; 0x01
    28e4:	11 c0       	rjmp	.+34     	; 0x2908 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28e6:	eb 81       	ldd	r30, Y+3	; 0x03
    28e8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ea:	80 85       	ldd	r24, Z+8	; 0x08
    28ec:	88 23       	and	r24, r24
    28ee:	79 f0       	breq	.+30     	; 0x290e <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28f0:	8b 81       	ldd	r24, Y+3	; 0x03
    28f2:	9c 81       	ldd	r25, Y+4	; 0x04
    28f4:	08 96       	adiw	r24, 0x08	; 8
    28f6:	0e 94 31 23 	call	0x4662	; 0x4662 <xTaskRemoveFromEventList>
    28fa:	88 23       	and	r24, r24
    28fc:	11 f0       	breq	.+4      	; 0x2902 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    28fe:	0e 94 9d 24 	call	0x493a	; 0x493a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2902:	89 81       	ldd	r24, Y+1	; 0x01
    2904:	81 50       	subi	r24, 0x01	; 1
    2906:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	18 16       	cp	r1, r24
    290c:	64 f3       	brlt	.-40     	; 0x28e6 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    290e:	eb 81       	ldd	r30, Y+3	; 0x03
    2910:	fc 81       	ldd	r31, Y+4	; 0x04
    2912:	8f ef       	ldi	r24, 0xFF	; 255
    2914:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2916:	0f 90       	pop	r0
    2918:	0f be       	out	0x3f, r0	; 63
}
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2928:	df 93       	push	r29
    292a:	cf 93       	push	r28
    292c:	00 d0       	rcall	.+0      	; 0x292e <prvIsQueueEmpty+0x6>
    292e:	0f 92       	push	r0
    2930:	cd b7       	in	r28, 0x3d	; 61
    2932:	de b7       	in	r29, 0x3e	; 62
    2934:	9b 83       	std	Y+3, r25	; 0x03
    2936:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2938:	0f b6       	in	r0, 0x3f	; 63
    293a:	f8 94       	cli
    293c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    293e:	ea 81       	ldd	r30, Y+2	; 0x02
    2940:	fb 81       	ldd	r31, Y+3	; 0x03
    2942:	82 8d       	ldd	r24, Z+26	; 0x1a
    2944:	88 23       	and	r24, r24
    2946:	19 f4       	brne	.+6      	; 0x294e <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	89 83       	std	Y+1, r24	; 0x01
    294c:	01 c0       	rjmp	.+2      	; 0x2950 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    294e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2950:	0f 90       	pop	r0
    2952:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2954:	89 81       	ldd	r24, Y+1	; 0x01
}
    2956:	0f 90       	pop	r0
    2958:	0f 90       	pop	r0
    295a:	0f 90       	pop	r0
    295c:	cf 91       	pop	r28
    295e:	df 91       	pop	r29
    2960:	08 95       	ret

00002962 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <xQueueIsQueueEmptyFromISR+0x6>
    2968:	00 d0       	rcall	.+0      	; 0x296a <xQueueIsQueueEmptyFromISR+0x8>
    296a:	0f 92       	push	r0
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
    2970:	9d 83       	std	Y+5, r25	; 0x05
    2972:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2974:	8c 81       	ldd	r24, Y+4	; 0x04
    2976:	9d 81       	ldd	r25, Y+5	; 0x05
    2978:	9a 83       	std	Y+2, r25	; 0x02
    297a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    297c:	e9 81       	ldd	r30, Y+1	; 0x01
    297e:	fa 81       	ldd	r31, Y+2	; 0x02
    2980:	82 8d       	ldd	r24, Z+26	; 0x1a
    2982:	88 23       	and	r24, r24
    2984:	19 f4       	brne	.+6      	; 0x298c <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2986:	81 e0       	ldi	r24, 0x01	; 1
    2988:	8b 83       	std	Y+3, r24	; 0x03
    298a:	01 c0       	rjmp	.+2      	; 0x298e <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    298c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    298e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2990:	0f 90       	pop	r0
    2992:	0f 90       	pop	r0
    2994:	0f 90       	pop	r0
    2996:	0f 90       	pop	r0
    2998:	0f 90       	pop	r0
    299a:	cf 91       	pop	r28
    299c:	df 91       	pop	r29
    299e:	08 95       	ret

000029a0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    29a0:	df 93       	push	r29
    29a2:	cf 93       	push	r28
    29a4:	00 d0       	rcall	.+0      	; 0x29a6 <prvIsQueueFull+0x6>
    29a6:	0f 92       	push	r0
    29a8:	cd b7       	in	r28, 0x3d	; 61
    29aa:	de b7       	in	r29, 0x3e	; 62
    29ac:	9b 83       	std	Y+3, r25	; 0x03
    29ae:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    29b6:	ea 81       	ldd	r30, Y+2	; 0x02
    29b8:	fb 81       	ldd	r31, Y+3	; 0x03
    29ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    29bc:	ea 81       	ldd	r30, Y+2	; 0x02
    29be:	fb 81       	ldd	r31, Y+3	; 0x03
    29c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    29c2:	98 17       	cp	r25, r24
    29c4:	19 f4       	brne	.+6      	; 0x29cc <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    29c6:	81 e0       	ldi	r24, 0x01	; 1
    29c8:	89 83       	std	Y+1, r24	; 0x01
    29ca:	01 c0       	rjmp	.+2      	; 0x29ce <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    29cc:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    29ce:	0f 90       	pop	r0
    29d0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    29d2:	89 81       	ldd	r24, Y+1	; 0x01
}
    29d4:	0f 90       	pop	r0
    29d6:	0f 90       	pop	r0
    29d8:	0f 90       	pop	r0
    29da:	cf 91       	pop	r28
    29dc:	df 91       	pop	r29
    29de:	08 95       	ret

000029e0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    29e0:	df 93       	push	r29
    29e2:	cf 93       	push	r28
    29e4:	00 d0       	rcall	.+0      	; 0x29e6 <xQueueIsQueueFullFromISR+0x6>
    29e6:	00 d0       	rcall	.+0      	; 0x29e8 <xQueueIsQueueFullFromISR+0x8>
    29e8:	0f 92       	push	r0
    29ea:	cd b7       	in	r28, 0x3d	; 61
    29ec:	de b7       	in	r29, 0x3e	; 62
    29ee:	9d 83       	std	Y+5, r25	; 0x05
    29f0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    29f2:	8c 81       	ldd	r24, Y+4	; 0x04
    29f4:	9d 81       	ldd	r25, Y+5	; 0x05
    29f6:	9a 83       	std	Y+2, r25	; 0x02
    29f8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    29fa:	e9 81       	ldd	r30, Y+1	; 0x01
    29fc:	fa 81       	ldd	r31, Y+2	; 0x02
    29fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a00:	e9 81       	ldd	r30, Y+1	; 0x01
    2a02:	fa 81       	ldd	r31, Y+2	; 0x02
    2a04:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a06:	98 17       	cp	r25, r24
    2a08:	19 f4       	brne	.+6      	; 0x2a10 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2a0a:	81 e0       	ldi	r24, 0x01	; 1
    2a0c:	8b 83       	std	Y+3, r24	; 0x03
    2a0e:	01 c0       	rjmp	.+2      	; 0x2a12 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2a10:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a12:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a14:	0f 90       	pop	r0
    2a16:	0f 90       	pop	r0
    2a18:	0f 90       	pop	r0
    2a1a:	0f 90       	pop	r0
    2a1c:	0f 90       	pop	r0
    2a1e:	cf 91       	pop	r28
    2a20:	df 91       	pop	r29
    2a22:	08 95       	ret

00002a24 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2a24:	0f 93       	push	r16
    2a26:	df 93       	push	r29
    2a28:	cf 93       	push	r28
    2a2a:	cd b7       	in	r28, 0x3d	; 61
    2a2c:	de b7       	in	r29, 0x3e	; 62
    2a2e:	28 97       	sbiw	r28, 0x08	; 8
    2a30:	0f b6       	in	r0, 0x3f	; 63
    2a32:	f8 94       	cli
    2a34:	de bf       	out	0x3e, r29	; 62
    2a36:	0f be       	out	0x3f, r0	; 63
    2a38:	cd bf       	out	0x3d, r28	; 61
    2a3a:	9d 83       	std	Y+5, r25	; 0x05
    2a3c:	8c 83       	std	Y+4, r24	; 0x04
    2a3e:	7f 83       	std	Y+7, r23	; 0x07
    2a40:	6e 83       	std	Y+6, r22	; 0x06
    2a42:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2a44:	88 85       	ldd	r24, Y+8	; 0x08
    2a46:	81 30       	cpi	r24, 0x01	; 1
    2a48:	19 f4       	brne	.+6      	; 0x2a50 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	89 83       	std	Y+1, r24	; 0x01
    2a4e:	01 c0       	rjmp	.+2      	; 0x2a52 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2a50:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2a52:	8e 81       	ldd	r24, Y+6	; 0x06
    2a54:	9f 81       	ldd	r25, Y+7	; 0x07
    2a56:	00 97       	sbiw	r24, 0x00	; 0
    2a58:	21 f4       	brne	.+8      	; 0x2a62 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2a5a:	81 e0       	ldi	r24, 0x01	; 1
    2a5c:	90 e0       	ldi	r25, 0x00	; 0
    2a5e:	9f 83       	std	Y+7, r25	; 0x07
    2a60:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2a62:	8c 81       	ldd	r24, Y+4	; 0x04
    2a64:	9d 81       	ldd	r25, Y+5	; 0x05
    2a66:	01 96       	adiw	r24, 0x01	; 1
    2a68:	9d 83       	std	Y+5, r25	; 0x05
    2a6a:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2a6c:	8c 81       	ldd	r24, Y+4	; 0x04
    2a6e:	9d 81       	ldd	r25, Y+5	; 0x05
    2a70:	0f 96       	adiw	r24, 0x0f	; 15
    2a72:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    2a76:	9b 83       	std	Y+3, r25	; 0x03
    2a78:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a7e:	00 97       	sbiw	r24, 0x00	; 0
    2a80:	89 f0       	breq	.+34     	; 0x2aa4 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2a82:	6a 81       	ldd	r22, Y+2	; 0x02
    2a84:	7b 81       	ldd	r23, Y+3	; 0x03
    2a86:	8a 81       	ldd	r24, Y+2	; 0x02
    2a88:	9b 81       	ldd	r25, Y+3	; 0x03
    2a8a:	9c 01       	movw	r18, r24
    2a8c:	21 5f       	subi	r18, 0xF1	; 241
    2a8e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a90:	4c 81       	ldd	r20, Y+4	; 0x04
    2a92:	5d 81       	ldd	r21, Y+5	; 0x05
    2a94:	ee 81       	ldd	r30, Y+6	; 0x06
    2a96:	ff 81       	ldd	r31, Y+7	; 0x07
    2a98:	cb 01       	movw	r24, r22
    2a9a:	b9 01       	movw	r22, r18
    2a9c:	9f 01       	movw	r18, r30
    2a9e:	09 81       	ldd	r16, Y+1	; 0x01
    2aa0:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    2aa6:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2aa8:	28 96       	adiw	r28, 0x08	; 8
    2aaa:	0f b6       	in	r0, 0x3f	; 63
    2aac:	f8 94       	cli
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	0f be       	out	0x3f, r0	; 63
    2ab2:	cd bf       	out	0x3d, r28	; 61
    2ab4:	cf 91       	pop	r28
    2ab6:	df 91       	pop	r29
    2ab8:	0f 91       	pop	r16
    2aba:	08 95       	ret

00002abc <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2abc:	df 93       	push	r29
    2abe:	cf 93       	push	r28
    2ac0:	00 d0       	rcall	.+0      	; 0x2ac2 <vStreamBufferDelete+0x6>
    2ac2:	00 d0       	rcall	.+0      	; 0x2ac4 <vStreamBufferDelete+0x8>
    2ac4:	cd b7       	in	r28, 0x3d	; 61
    2ac6:	de b7       	in	r29, 0x3e	; 62
    2ac8:	9c 83       	std	Y+4, r25	; 0x04
    2aca:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2acc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ace:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad0:	9a 83       	std	Y+2, r25	; 0x02
    2ad2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2ad4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad8:	86 85       	ldd	r24, Z+14	; 0x0e
    2ada:	88 2f       	mov	r24, r24
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	82 70       	andi	r24, 0x02	; 2
    2ae0:	90 70       	andi	r25, 0x00	; 0
    2ae2:	00 97       	sbiw	r24, 0x00	; 0
    2ae4:	29 f4       	brne	.+10     	; 0x2af0 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2ae6:	89 81       	ldd	r24, Y+1	; 0x01
    2ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    2aea:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
    2aee:	08 c0       	rjmp	.+16     	; 0x2b00 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2af0:	89 81       	ldd	r24, Y+1	; 0x01
    2af2:	9a 81       	ldd	r25, Y+2	; 0x02
    2af4:	60 e0       	ldi	r22, 0x00	; 0
    2af6:	70 e0       	ldi	r23, 0x00	; 0
    2af8:	4f e0       	ldi	r20, 0x0F	; 15
    2afa:	50 e0       	ldi	r21, 0x00	; 0
    2afc:	0e 94 c8 29 	call	0x5390	; 0x5390 <memset>
	}
}
    2b00:	0f 90       	pop	r0
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
    2b08:	cf 91       	pop	r28
    2b0a:	df 91       	pop	r29
    2b0c:	08 95       	ret

00002b0e <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2b0e:	0f 93       	push	r16
    2b10:	df 93       	push	r29
    2b12:	cf 93       	push	r28
    2b14:	00 d0       	rcall	.+0      	; 0x2b16 <xStreamBufferReset+0x8>
    2b16:	00 d0       	rcall	.+0      	; 0x2b18 <xStreamBufferReset+0xa>
    2b18:	0f 92       	push	r0
    2b1a:	cd b7       	in	r28, 0x3d	; 61
    2b1c:	de b7       	in	r29, 0x3e	; 62
    2b1e:	9d 83       	std	Y+5, r25	; 0x05
    2b20:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b22:	8c 81       	ldd	r24, Y+4	; 0x04
    2b24:	9d 81       	ldd	r25, Y+5	; 0x05
    2b26:	9b 83       	std	Y+3, r25	; 0x03
    2b28:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2b2a:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2b2c:	0f b6       	in	r0, 0x3f	; 63
    2b2e:	f8 94       	cli
    2b30:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2b32:	ea 81       	ldd	r30, Y+2	; 0x02
    2b34:	fb 81       	ldd	r31, Y+3	; 0x03
    2b36:	80 85       	ldd	r24, Z+8	; 0x08
    2b38:	91 85       	ldd	r25, Z+9	; 0x09
    2b3a:	00 97       	sbiw	r24, 0x00	; 0
    2b3c:	f1 f4       	brne	.+60     	; 0x2b7a <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2b3e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b40:	fb 81       	ldd	r31, Y+3	; 0x03
    2b42:	82 85       	ldd	r24, Z+10	; 0x0a
    2b44:	93 85       	ldd	r25, Z+11	; 0x0b
    2b46:	00 97       	sbiw	r24, 0x00	; 0
    2b48:	c1 f4       	brne	.+48     	; 0x2b7a <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b4e:	24 85       	ldd	r18, Z+12	; 0x0c
    2b50:	35 85       	ldd	r19, Z+13	; 0x0d
    2b52:	ea 81       	ldd	r30, Y+2	; 0x02
    2b54:	fb 81       	ldd	r31, Y+3	; 0x03
    2b56:	44 81       	ldd	r20, Z+4	; 0x04
    2b58:	55 81       	ldd	r21, Z+5	; 0x05
    2b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5e:	a6 81       	ldd	r26, Z+6	; 0x06
    2b60:	b7 81       	ldd	r27, Z+7	; 0x07
    2b62:	ea 81       	ldd	r30, Y+2	; 0x02
    2b64:	fb 81       	ldd	r31, Y+3	; 0x03
    2b66:	e6 85       	ldd	r30, Z+14	; 0x0e
    2b68:	8a 81       	ldd	r24, Y+2	; 0x02
    2b6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b6c:	b9 01       	movw	r22, r18
    2b6e:	9d 01       	movw	r18, r26
    2b70:	0e 2f       	mov	r16, r30
    2b72:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2b76:	81 e0       	ldi	r24, 0x01	; 1
    2b78:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2b7a:	0f 90       	pop	r0
    2b7c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b80:	0f 90       	pop	r0
    2b82:	0f 90       	pop	r0
    2b84:	0f 90       	pop	r0
    2b86:	0f 90       	pop	r0
    2b88:	0f 90       	pop	r0
    2b8a:	cf 91       	pop	r28
    2b8c:	df 91       	pop	r29
    2b8e:	0f 91       	pop	r16
    2b90:	08 95       	ret

00002b92 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2b92:	df 93       	push	r29
    2b94:	cf 93       	push	r28
    2b96:	cd b7       	in	r28, 0x3d	; 61
    2b98:	de b7       	in	r29, 0x3e	; 62
    2b9a:	27 97       	sbiw	r28, 0x07	; 7
    2b9c:	0f b6       	in	r0, 0x3f	; 63
    2b9e:	f8 94       	cli
    2ba0:	de bf       	out	0x3e, r29	; 62
    2ba2:	0f be       	out	0x3f, r0	; 63
    2ba4:	cd bf       	out	0x3d, r28	; 61
    2ba6:	9d 83       	std	Y+5, r25	; 0x05
    2ba8:	8c 83       	std	Y+4, r24	; 0x04
    2baa:	7f 83       	std	Y+7, r23	; 0x07
    2bac:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bae:	8c 81       	ldd	r24, Y+4	; 0x04
    2bb0:	9d 81       	ldd	r25, Y+5	; 0x05
    2bb2:	9b 83       	std	Y+3, r25	; 0x03
    2bb4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2bb6:	8e 81       	ldd	r24, Y+6	; 0x06
    2bb8:	9f 81       	ldd	r25, Y+7	; 0x07
    2bba:	00 97       	sbiw	r24, 0x00	; 0
    2bbc:	21 f4       	brne	.+8      	; 0x2bc6 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2bbe:	81 e0       	ldi	r24, 0x01	; 1
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	9f 83       	std	Y+7, r25	; 0x07
    2bc4:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2bc6:	ea 81       	ldd	r30, Y+2	; 0x02
    2bc8:	fb 81       	ldd	r31, Y+3	; 0x03
    2bca:	24 81       	ldd	r18, Z+4	; 0x04
    2bcc:	35 81       	ldd	r19, Z+5	; 0x05
    2bce:	8e 81       	ldd	r24, Y+6	; 0x06
    2bd0:	9f 81       	ldd	r25, Y+7	; 0x07
    2bd2:	28 17       	cp	r18, r24
    2bd4:	39 07       	cpc	r19, r25
    2bd6:	48 f0       	brcs	.+18     	; 0x2bea <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2bd8:	ea 81       	ldd	r30, Y+2	; 0x02
    2bda:	fb 81       	ldd	r31, Y+3	; 0x03
    2bdc:	8e 81       	ldd	r24, Y+6	; 0x06
    2bde:	9f 81       	ldd	r25, Y+7	; 0x07
    2be0:	97 83       	std	Z+7, r25	; 0x07
    2be2:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2be4:	81 e0       	ldi	r24, 0x01	; 1
    2be6:	89 83       	std	Y+1, r24	; 0x01
    2be8:	01 c0       	rjmp	.+2      	; 0x2bec <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2bea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2bec:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bee:	27 96       	adiw	r28, 0x07	; 7
    2bf0:	0f b6       	in	r0, 0x3f	; 63
    2bf2:	f8 94       	cli
    2bf4:	de bf       	out	0x3e, r29	; 62
    2bf6:	0f be       	out	0x3f, r0	; 63
    2bf8:	cd bf       	out	0x3d, r28	; 61
    2bfa:	cf 91       	pop	r28
    2bfc:	df 91       	pop	r29
    2bfe:	08 95       	ret

00002c00 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2c00:	df 93       	push	r29
    2c02:	cf 93       	push	r28
    2c04:	00 d0       	rcall	.+0      	; 0x2c06 <xStreamBufferSpacesAvailable+0x6>
    2c06:	00 d0       	rcall	.+0      	; 0x2c08 <xStreamBufferSpacesAvailable+0x8>
    2c08:	00 d0       	rcall	.+0      	; 0x2c0a <xStreamBufferSpacesAvailable+0xa>
    2c0a:	cd b7       	in	r28, 0x3d	; 61
    2c0c:	de b7       	in	r29, 0x3e	; 62
    2c0e:	9e 83       	std	Y+6, r25	; 0x06
    2c10:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c12:	8d 81       	ldd	r24, Y+5	; 0x05
    2c14:	9e 81       	ldd	r25, Y+6	; 0x06
    2c16:	9c 83       	std	Y+4, r25	; 0x04
    2c18:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1e:	24 81       	ldd	r18, Z+4	; 0x04
    2c20:	35 81       	ldd	r19, Z+5	; 0x05
    2c22:	eb 81       	ldd	r30, Y+3	; 0x03
    2c24:	fc 81       	ldd	r31, Y+4	; 0x04
    2c26:	80 81       	ld	r24, Z
    2c28:	91 81       	ldd	r25, Z+1	; 0x01
    2c2a:	82 0f       	add	r24, r18
    2c2c:	93 1f       	adc	r25, r19
    2c2e:	9a 83       	std	Y+2, r25	; 0x02
    2c30:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2c32:	eb 81       	ldd	r30, Y+3	; 0x03
    2c34:	fc 81       	ldd	r31, Y+4	; 0x04
    2c36:	22 81       	ldd	r18, Z+2	; 0x02
    2c38:	33 81       	ldd	r19, Z+3	; 0x03
    2c3a:	89 81       	ldd	r24, Y+1	; 0x01
    2c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3e:	82 1b       	sub	r24, r18
    2c40:	93 0b       	sbc	r25, r19
    2c42:	9a 83       	std	Y+2, r25	; 0x02
    2c44:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2c46:	89 81       	ldd	r24, Y+1	; 0x01
    2c48:	9a 81       	ldd	r25, Y+2	; 0x02
    2c4a:	01 97       	sbiw	r24, 0x01	; 1
    2c4c:	9a 83       	std	Y+2, r25	; 0x02
    2c4e:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2c50:	eb 81       	ldd	r30, Y+3	; 0x03
    2c52:	fc 81       	ldd	r31, Y+4	; 0x04
    2c54:	24 81       	ldd	r18, Z+4	; 0x04
    2c56:	35 81       	ldd	r19, Z+5	; 0x05
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	82 17       	cp	r24, r18
    2c5e:	93 07       	cpc	r25, r19
    2c60:	50 f0       	brcs	.+20     	; 0x2c76 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2c62:	eb 81       	ldd	r30, Y+3	; 0x03
    2c64:	fc 81       	ldd	r31, Y+4	; 0x04
    2c66:	24 81       	ldd	r18, Z+4	; 0x04
    2c68:	35 81       	ldd	r19, Z+5	; 0x05
    2c6a:	89 81       	ldd	r24, Y+1	; 0x01
    2c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6e:	82 1b       	sub	r24, r18
    2c70:	93 0b       	sbc	r25, r19
    2c72:	9a 83       	std	Y+2, r25	; 0x02
    2c74:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2c76:	89 81       	ldd	r24, Y+1	; 0x01
    2c78:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2c7a:	26 96       	adiw	r28, 0x06	; 6
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	de bf       	out	0x3e, r29	; 62
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	cd bf       	out	0x3d, r28	; 61
    2c86:	cf 91       	pop	r28
    2c88:	df 91       	pop	r29
    2c8a:	08 95       	ret

00002c8c <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2c8c:	df 93       	push	r29
    2c8e:	cf 93       	push	r28
    2c90:	00 d0       	rcall	.+0      	; 0x2c92 <xStreamBufferBytesAvailable+0x6>
    2c92:	00 d0       	rcall	.+0      	; 0x2c94 <xStreamBufferBytesAvailable+0x8>
    2c94:	00 d0       	rcall	.+0      	; 0x2c96 <xStreamBufferBytesAvailable+0xa>
    2c96:	cd b7       	in	r28, 0x3d	; 61
    2c98:	de b7       	in	r29, 0x3e	; 62
    2c9a:	9e 83       	std	Y+6, r25	; 0x06
    2c9c:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c9e:	8d 81       	ldd	r24, Y+5	; 0x05
    2ca0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ca2:	9c 83       	std	Y+4, r25	; 0x04
    2ca4:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca8:	9c 81       	ldd	r25, Y+4	; 0x04
    2caa:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    2cae:	9a 83       	std	Y+2, r25	; 0x02
    2cb0:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2cb2:	89 81       	ldd	r24, Y+1	; 0x01
    2cb4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2cb6:	26 96       	adiw	r28, 0x06	; 6
    2cb8:	0f b6       	in	r0, 0x3f	; 63
    2cba:	f8 94       	cli
    2cbc:	de bf       	out	0x3e, r29	; 62
    2cbe:	0f be       	out	0x3f, r0	; 63
    2cc0:	cd bf       	out	0x3d, r28	; 61
    2cc2:	cf 91       	pop	r28
    2cc4:	df 91       	pop	r29
    2cc6:	08 95       	ret

00002cc8 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2cc8:	ef 92       	push	r14
    2cca:	ff 92       	push	r15
    2ccc:	0f 93       	push	r16
    2cce:	1f 93       	push	r17
    2cd0:	df 93       	push	r29
    2cd2:	cf 93       	push	r28
    2cd4:	cd b7       	in	r28, 0x3d	; 61
    2cd6:	de b7       	in	r29, 0x3e	; 62
    2cd8:	63 97       	sbiw	r28, 0x13	; 19
    2cda:	0f b6       	in	r0, 0x3f	; 63
    2cdc:	f8 94       	cli
    2cde:	de bf       	out	0x3e, r29	; 62
    2ce0:	0f be       	out	0x3f, r0	; 63
    2ce2:	cd bf       	out	0x3d, r28	; 61
    2ce4:	9d 87       	std	Y+13, r25	; 0x0d
    2ce6:	8c 87       	std	Y+12, r24	; 0x0c
    2ce8:	7f 87       	std	Y+15, r23	; 0x0f
    2cea:	6e 87       	std	Y+14, r22	; 0x0e
    2cec:	59 8b       	std	Y+17, r21	; 0x11
    2cee:	48 8b       	std	Y+16, r20	; 0x10
    2cf0:	3b 8b       	std	Y+19, r19	; 0x13
    2cf2:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2cf4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2cf6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2cf8:	98 87       	std	Y+8, r25	; 0x08
    2cfa:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2cfc:	1c 82       	std	Y+4, r1	; 0x04
    2cfe:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2d00:	88 89       	ldd	r24, Y+16	; 0x10
    2d02:	99 89       	ldd	r25, Y+17	; 0x11
    2d04:	9a 83       	std	Y+2, r25	; 0x02
    2d06:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2d08:	ef 81       	ldd	r30, Y+7	; 0x07
    2d0a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d0c:	86 85       	ldd	r24, Z+14	; 0x0e
    2d0e:	88 2f       	mov	r24, r24
    2d10:	90 e0       	ldi	r25, 0x00	; 0
    2d12:	81 70       	andi	r24, 0x01	; 1
    2d14:	90 70       	andi	r25, 0x00	; 0
    2d16:	88 23       	and	r24, r24
    2d18:	29 f0       	breq	.+10     	; 0x2d24 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2d1a:	89 81       	ldd	r24, Y+1	; 0x01
    2d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1e:	02 96       	adiw	r24, 0x02	; 2
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2d24:	8a 89       	ldd	r24, Y+18	; 0x12
    2d26:	9b 89       	ldd	r25, Y+19	; 0x13
    2d28:	00 97       	sbiw	r24, 0x00	; 0
    2d2a:	09 f4       	brne	.+2      	; 0x2d2e <xStreamBufferSend+0x66>
    2d2c:	40 c0       	rjmp	.+128    	; 0x2dae <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2d2e:	ce 01       	movw	r24, r28
    2d30:	09 96       	adiw	r24, 0x09	; 9
    2d32:	0e 94 f9 23 	call	0x47f2	; 0x47f2 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2d36:	0f b6       	in	r0, 0x3f	; 63
    2d38:	f8 94       	cli
    2d3a:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2d3c:	8f 81       	ldd	r24, Y+7	; 0x07
    2d3e:	98 85       	ldd	r25, Y+8	; 0x08
    2d40:	0e 94 00 16 	call	0x2c00	; 0x2c00 <xStreamBufferSpacesAvailable>
    2d44:	9c 83       	std	Y+4, r25	; 0x04
    2d46:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2d48:	2b 81       	ldd	r18, Y+3	; 0x03
    2d4a:	3c 81       	ldd	r19, Y+4	; 0x04
    2d4c:	89 81       	ldd	r24, Y+1	; 0x01
    2d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d50:	28 17       	cp	r18, r24
    2d52:	39 07       	cpc	r19, r25
    2d54:	50 f5       	brcc	.+84     	; 0x2daa <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2d56:	80 e0       	ldi	r24, 0x00	; 0
    2d58:	90 e0       	ldi	r25, 0x00	; 0
    2d5a:	0e 94 09 29 	call	0x5212	; 0x5212 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2d5e:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <xTaskGetCurrentTaskHandle>
    2d62:	ef 81       	ldd	r30, Y+7	; 0x07
    2d64:	f8 85       	ldd	r31, Y+8	; 0x08
    2d66:	93 87       	std	Z+11, r25	; 0x0b
    2d68:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2d6a:	0f 90       	pop	r0
    2d6c:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2d6e:	ea 89       	ldd	r30, Y+18	; 0x12
    2d70:	fb 89       	ldd	r31, Y+19	; 0x13
    2d72:	60 e0       	ldi	r22, 0x00	; 0
    2d74:	70 e0       	ldi	r23, 0x00	; 0
    2d76:	80 e0       	ldi	r24, 0x00	; 0
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	20 e0       	ldi	r18, 0x00	; 0
    2d7c:	30 e0       	ldi	r19, 0x00	; 0
    2d7e:	40 e0       	ldi	r20, 0x00	; 0
    2d80:	50 e0       	ldi	r21, 0x00	; 0
    2d82:	00 e0       	ldi	r16, 0x00	; 0
    2d84:	10 e0       	ldi	r17, 0x00	; 0
    2d86:	7f 01       	movw	r14, r30
    2d88:	0e 94 12 26 	call	0x4c24	; 0x4c24 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2d8c:	ef 81       	ldd	r30, Y+7	; 0x07
    2d8e:	f8 85       	ldd	r31, Y+8	; 0x08
    2d90:	13 86       	std	Z+11, r1	; 0x0b
    2d92:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2d94:	ce 01       	movw	r24, r28
    2d96:	09 96       	adiw	r24, 0x09	; 9
    2d98:	9e 01       	movw	r18, r28
    2d9a:	2e 5e       	subi	r18, 0xEE	; 238
    2d9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d9e:	b9 01       	movw	r22, r18
    2da0:	0e 94 30 24 	call	0x4860	; 0x4860 <xTaskCheckForTimeOut>
    2da4:	88 23       	and	r24, r24
    2da6:	39 f2       	breq	.-114    	; 0x2d36 <xStreamBufferSend+0x6e>
    2da8:	02 c0       	rjmp	.+4      	; 0x2dae <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2daa:	0f 90       	pop	r0
    2dac:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	9c 81       	ldd	r25, Y+4	; 0x04
    2db2:	00 97       	sbiw	r24, 0x00	; 0
    2db4:	31 f4       	brne	.+12     	; 0x2dc2 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2db6:	8f 81       	ldd	r24, Y+7	; 0x07
    2db8:	98 85       	ldd	r25, Y+8	; 0x08
    2dba:	0e 94 00 16 	call	0x2c00	; 0x2c00 <xStreamBufferSpacesAvailable>
    2dbe:	9c 83       	std	Y+4, r25	; 0x04
    2dc0:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    2dc4:	98 85       	ldd	r25, Y+8	; 0x08
    2dc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    2dc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    2dca:	48 89       	ldd	r20, Y+16	; 0x10
    2dcc:	59 89       	ldd	r21, Y+17	; 0x11
    2dce:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd2:	a9 81       	ldd	r26, Y+1	; 0x01
    2dd4:	ba 81       	ldd	r27, Y+2	; 0x02
    2dd6:	b9 01       	movw	r22, r18
    2dd8:	9f 01       	movw	r18, r30
    2dda:	8d 01       	movw	r16, r26
    2ddc:	0e 94 a9 17 	call	0x2f52	; 0x2f52 <prvWriteMessageToBuffer>
    2de0:	9e 83       	std	Y+6, r25	; 0x06
    2de2:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2de4:	8d 81       	ldd	r24, Y+5	; 0x05
    2de6:	9e 81       	ldd	r25, Y+6	; 0x06
    2de8:	00 97       	sbiw	r24, 0x00	; 0
    2dea:	39 f1       	breq	.+78     	; 0x2e3a <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2dec:	8f 81       	ldd	r24, Y+7	; 0x07
    2dee:	98 85       	ldd	r25, Y+8	; 0x08
    2df0:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    2df4:	9c 01       	movw	r18, r24
    2df6:	ef 81       	ldd	r30, Y+7	; 0x07
    2df8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dfa:	86 81       	ldd	r24, Z+6	; 0x06
    2dfc:	97 81       	ldd	r25, Z+7	; 0x07
    2dfe:	28 17       	cp	r18, r24
    2e00:	39 07       	cpc	r19, r25
    2e02:	d8 f0       	brcs	.+54     	; 0x2e3a <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2e04:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
    2e08:	ef 81       	ldd	r30, Y+7	; 0x07
    2e0a:	f8 85       	ldd	r31, Y+8	; 0x08
    2e0c:	80 85       	ldd	r24, Z+8	; 0x08
    2e0e:	91 85       	ldd	r25, Z+9	; 0x09
    2e10:	00 97       	sbiw	r24, 0x00	; 0
    2e12:	89 f0       	breq	.+34     	; 0x2e36 <xStreamBufferSend+0x16e>
    2e14:	ef 81       	ldd	r30, Y+7	; 0x07
    2e16:	f8 85       	ldd	r31, Y+8	; 0x08
    2e18:	80 85       	ldd	r24, Z+8	; 0x08
    2e1a:	91 85       	ldd	r25, Z+9	; 0x09
    2e1c:	40 e0       	ldi	r20, 0x00	; 0
    2e1e:	50 e0       	ldi	r21, 0x00	; 0
    2e20:	60 e0       	ldi	r22, 0x00	; 0
    2e22:	70 e0       	ldi	r23, 0x00	; 0
    2e24:	20 e0       	ldi	r18, 0x00	; 0
    2e26:	00 e0       	ldi	r16, 0x00	; 0
    2e28:	10 e0       	ldi	r17, 0x00	; 0
    2e2a:	0e 94 ae 26 	call	0x4d5c	; 0x4d5c <xTaskGenericNotify>
    2e2e:	ef 81       	ldd	r30, Y+7	; 0x07
    2e30:	f8 85       	ldd	r31, Y+8	; 0x08
    2e32:	11 86       	std	Z+9, r1	; 0x09
    2e34:	10 86       	std	Z+8, r1	; 0x08
    2e36:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e3c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2e3e:	63 96       	adiw	r28, 0x13	; 19
    2e40:	0f b6       	in	r0, 0x3f	; 63
    2e42:	f8 94       	cli
    2e44:	de bf       	out	0x3e, r29	; 62
    2e46:	0f be       	out	0x3f, r0	; 63
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	cf 91       	pop	r28
    2e4c:	df 91       	pop	r29
    2e4e:	1f 91       	pop	r17
    2e50:	0f 91       	pop	r16
    2e52:	ff 90       	pop	r15
    2e54:	ef 90       	pop	r14
    2e56:	08 95       	ret

00002e58 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e58:	ef 92       	push	r14
    2e5a:	ff 92       	push	r15
    2e5c:	0f 93       	push	r16
    2e5e:	1f 93       	push	r17
    2e60:	df 93       	push	r29
    2e62:	cf 93       	push	r28
    2e64:	cd b7       	in	r28, 0x3d	; 61
    2e66:	de b7       	in	r29, 0x3e	; 62
    2e68:	61 97       	sbiw	r28, 0x11	; 17
    2e6a:	0f b6       	in	r0, 0x3f	; 63
    2e6c:	f8 94       	cli
    2e6e:	de bf       	out	0x3e, r29	; 62
    2e70:	0f be       	out	0x3f, r0	; 63
    2e72:	cd bf       	out	0x3d, r28	; 61
    2e74:	9b 87       	std	Y+11, r25	; 0x0b
    2e76:	8a 87       	std	Y+10, r24	; 0x0a
    2e78:	7d 87       	std	Y+13, r23	; 0x0d
    2e7a:	6c 87       	std	Y+12, r22	; 0x0c
    2e7c:	5f 87       	std	Y+15, r21	; 0x0f
    2e7e:	4e 87       	std	Y+14, r20	; 0x0e
    2e80:	39 8b       	std	Y+17, r19	; 0x11
    2e82:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2e84:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e86:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e88:	99 87       	std	Y+9, r25	; 0x09
    2e8a:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2e8c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e8e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e90:	9b 83       	std	Y+3, r25	; 0x03
    2e92:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2e94:	e8 85       	ldd	r30, Y+8	; 0x08
    2e96:	f9 85       	ldd	r31, Y+9	; 0x09
    2e98:	86 85       	ldd	r24, Z+14	; 0x0e
    2e9a:	88 2f       	mov	r24, r24
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	81 70       	andi	r24, 0x01	; 1
    2ea0:	90 70       	andi	r25, 0x00	; 0
    2ea2:	88 23       	and	r24, r24
    2ea4:	29 f0       	breq	.+10     	; 0x2eb0 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eaa:	02 96       	adiw	r24, 0x02	; 2
    2eac:	9b 83       	std	Y+3, r25	; 0x03
    2eae:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2eb0:	88 85       	ldd	r24, Y+8	; 0x08
    2eb2:	99 85       	ldd	r25, Y+9	; 0x09
    2eb4:	0e 94 00 16 	call	0x2c00	; 0x2c00 <xStreamBufferSpacesAvailable>
    2eb8:	9d 83       	std	Y+5, r25	; 0x05
    2eba:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2ebc:	88 85       	ldd	r24, Y+8	; 0x08
    2ebe:	99 85       	ldd	r25, Y+9	; 0x09
    2ec0:	2c 85       	ldd	r18, Y+12	; 0x0c
    2ec2:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ec4:	4e 85       	ldd	r20, Y+14	; 0x0e
    2ec6:	5f 85       	ldd	r21, Y+15	; 0x0f
    2ec8:	ec 81       	ldd	r30, Y+4	; 0x04
    2eca:	fd 81       	ldd	r31, Y+5	; 0x05
    2ecc:	aa 81       	ldd	r26, Y+2	; 0x02
    2ece:	bb 81       	ldd	r27, Y+3	; 0x03
    2ed0:	b9 01       	movw	r22, r18
    2ed2:	9f 01       	movw	r18, r30
    2ed4:	8d 01       	movw	r16, r26
    2ed6:	0e 94 a9 17 	call	0x2f52	; 0x2f52 <prvWriteMessageToBuffer>
    2eda:	9f 83       	std	Y+7, r25	; 0x07
    2edc:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2ede:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee2:	00 97       	sbiw	r24, 0x00	; 0
    2ee4:	39 f1       	breq	.+78     	; 0x2f34 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2ee6:	88 85       	ldd	r24, Y+8	; 0x08
    2ee8:	99 85       	ldd	r25, Y+9	; 0x09
    2eea:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    2eee:	9c 01       	movw	r18, r24
    2ef0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ef2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ef4:	86 81       	ldd	r24, Z+6	; 0x06
    2ef6:	97 81       	ldd	r25, Z+7	; 0x07
    2ef8:	28 17       	cp	r18, r24
    2efa:	39 07       	cpc	r19, r25
    2efc:	d8 f0       	brcs	.+54     	; 0x2f34 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2efe:	19 82       	std	Y+1, r1	; 0x01
    2f00:	e8 85       	ldd	r30, Y+8	; 0x08
    2f02:	f9 85       	ldd	r31, Y+9	; 0x09
    2f04:	80 85       	ldd	r24, Z+8	; 0x08
    2f06:	91 85       	ldd	r25, Z+9	; 0x09
    2f08:	00 97       	sbiw	r24, 0x00	; 0
    2f0a:	a1 f0       	breq	.+40     	; 0x2f34 <xStreamBufferSendFromISR+0xdc>
    2f0c:	e8 85       	ldd	r30, Y+8	; 0x08
    2f0e:	f9 85       	ldd	r31, Y+9	; 0x09
    2f10:	80 85       	ldd	r24, Z+8	; 0x08
    2f12:	91 85       	ldd	r25, Z+9	; 0x09
    2f14:	e8 89       	ldd	r30, Y+16	; 0x10
    2f16:	f9 89       	ldd	r31, Y+17	; 0x11
    2f18:	40 e0       	ldi	r20, 0x00	; 0
    2f1a:	50 e0       	ldi	r21, 0x00	; 0
    2f1c:	60 e0       	ldi	r22, 0x00	; 0
    2f1e:	70 e0       	ldi	r23, 0x00	; 0
    2f20:	20 e0       	ldi	r18, 0x00	; 0
    2f22:	00 e0       	ldi	r16, 0x00	; 0
    2f24:	10 e0       	ldi	r17, 0x00	; 0
    2f26:	7f 01       	movw	r14, r30
    2f28:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <xTaskGenericNotifyFromISR>
    2f2c:	e8 85       	ldd	r30, Y+8	; 0x08
    2f2e:	f9 85       	ldd	r31, Y+9	; 0x09
    2f30:	11 86       	std	Z+9, r1	; 0x09
    2f32:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2f34:	8e 81       	ldd	r24, Y+6	; 0x06
    2f36:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2f38:	61 96       	adiw	r28, 0x11	; 17
    2f3a:	0f b6       	in	r0, 0x3f	; 63
    2f3c:	f8 94       	cli
    2f3e:	de bf       	out	0x3e, r29	; 62
    2f40:	0f be       	out	0x3f, r0	; 63
    2f42:	cd bf       	out	0x3d, r28	; 61
    2f44:	cf 91       	pop	r28
    2f46:	df 91       	pop	r29
    2f48:	1f 91       	pop	r17
    2f4a:	0f 91       	pop	r16
    2f4c:	ff 90       	pop	r15
    2f4e:	ef 90       	pop	r14
    2f50:	08 95       	ret

00002f52 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2f52:	0f 93       	push	r16
    2f54:	1f 93       	push	r17
    2f56:	df 93       	push	r29
    2f58:	cf 93       	push	r28
    2f5a:	cd b7       	in	r28, 0x3d	; 61
    2f5c:	de b7       	in	r29, 0x3e	; 62
    2f5e:	61 97       	sbiw	r28, 0x11	; 17
    2f60:	0f b6       	in	r0, 0x3f	; 63
    2f62:	f8 94       	cli
    2f64:	de bf       	out	0x3e, r29	; 62
    2f66:	0f be       	out	0x3f, r0	; 63
    2f68:	cd bf       	out	0x3d, r28	; 61
    2f6a:	9d 83       	std	Y+5, r25	; 0x05
    2f6c:	8c 83       	std	Y+4, r24	; 0x04
    2f6e:	7f 83       	std	Y+7, r23	; 0x07
    2f70:	6e 83       	std	Y+6, r22	; 0x06
    2f72:	59 87       	std	Y+9, r21	; 0x09
    2f74:	48 87       	std	Y+8, r20	; 0x08
    2f76:	3b 87       	std	Y+11, r19	; 0x0b
    2f78:	2a 87       	std	Y+10, r18	; 0x0a
    2f7a:	1d 87       	std	Y+13, r17	; 0x0d
    2f7c:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    2f7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f80:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f82:	00 97       	sbiw	r24, 0x00	; 0
    2f84:	11 f4       	brne	.+4      	; 0x2f8a <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2f86:	1b 82       	std	Y+3, r1	; 0x03
    2f88:	38 c0       	rjmp	.+112    	; 0x2ffa <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2f8a:	ec 81       	ldd	r30, Y+4	; 0x04
    2f8c:	fd 81       	ldd	r31, Y+5	; 0x05
    2f8e:	86 85       	ldd	r24, Z+14	; 0x0e
    2f90:	88 2f       	mov	r24, r24
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	81 70       	andi	r24, 0x01	; 1
    2f96:	90 70       	andi	r25, 0x00	; 0
    2f98:	00 97       	sbiw	r24, 0x00	; 0
    2f9a:	d1 f4       	brne	.+52     	; 0x2fd0 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    2f9c:	81 e0       	ldi	r24, 0x01	; 1
    2f9e:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2fa0:	28 85       	ldd	r18, Y+8	; 0x08
    2fa2:	39 85       	ldd	r19, Y+9	; 0x09
    2fa4:	39 8b       	std	Y+17, r19	; 0x11
    2fa6:	28 8b       	std	Y+16, r18	; 0x10
    2fa8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2faa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fac:	9f 87       	std	Y+15, r25	; 0x0f
    2fae:	8e 87       	std	Y+14, r24	; 0x0e
    2fb0:	2e 85       	ldd	r18, Y+14	; 0x0e
    2fb2:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fb4:	88 89       	ldd	r24, Y+16	; 0x10
    2fb6:	99 89       	ldd	r25, Y+17	; 0x11
    2fb8:	82 17       	cp	r24, r18
    2fba:	93 07       	cpc	r25, r19
    2fbc:	20 f4       	brcc	.+8      	; 0x2fc6 <prvWriteMessageToBuffer+0x74>
    2fbe:	28 89       	ldd	r18, Y+16	; 0x10
    2fc0:	39 89       	ldd	r19, Y+17	; 0x11
    2fc2:	3f 87       	std	Y+15, r19	; 0x0f
    2fc4:	2e 87       	std	Y+14, r18	; 0x0e
    2fc6:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fc8:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fca:	99 87       	std	Y+9, r25	; 0x09
    2fcc:	88 87       	std	Y+8, r24	; 0x08
    2fce:	15 c0       	rjmp	.+42     	; 0x2ffa <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    2fd0:	2a 85       	ldd	r18, Y+10	; 0x0a
    2fd2:	3b 85       	ldd	r19, Y+11	; 0x0b
    2fd4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2fd6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fd8:	28 17       	cp	r18, r24
    2fda:	39 07       	cpc	r19, r25
    2fdc:	68 f0       	brcs	.+26     	; 0x2ff8 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    2fde:	81 e0       	ldi	r24, 0x01	; 1
    2fe0:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    2fe2:	9e 01       	movw	r18, r28
    2fe4:	28 5f       	subi	r18, 0xF8	; 248
    2fe6:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe8:	8c 81       	ldd	r24, Y+4	; 0x04
    2fea:	9d 81       	ldd	r25, Y+5	; 0x05
    2fec:	b9 01       	movw	r22, r18
    2fee:	42 e0       	ldi	r20, 0x02	; 2
    2ff0:	50 e0       	ldi	r21, 0x00	; 0
    2ff2:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <prvWriteBytesToBuffer>
    2ff6:	01 c0       	rjmp	.+2      	; 0x2ffa <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2ff8:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    2ffc:	88 23       	and	r24, r24
    2ffe:	61 f0       	breq	.+24     	; 0x3018 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    3000:	2e 81       	ldd	r18, Y+6	; 0x06
    3002:	3f 81       	ldd	r19, Y+7	; 0x07
    3004:	48 85       	ldd	r20, Y+8	; 0x08
    3006:	59 85       	ldd	r21, Y+9	; 0x09
    3008:	8c 81       	ldd	r24, Y+4	; 0x04
    300a:	9d 81       	ldd	r25, Y+5	; 0x05
    300c:	b9 01       	movw	r22, r18
    300e:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <prvWriteBytesToBuffer>
    3012:	9a 83       	std	Y+2, r25	; 0x02
    3014:	89 83       	std	Y+1, r24	; 0x01
    3016:	02 c0       	rjmp	.+4      	; 0x301c <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3018:	1a 82       	std	Y+2, r1	; 0x02
    301a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3020:	61 96       	adiw	r28, 0x11	; 17
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	de bf       	out	0x3e, r29	; 62
    3028:	0f be       	out	0x3f, r0	; 63
    302a:	cd bf       	out	0x3d, r28	; 61
    302c:	cf 91       	pop	r28
    302e:	df 91       	pop	r29
    3030:	1f 91       	pop	r17
    3032:	0f 91       	pop	r16
    3034:	08 95       	ret

00003036 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3036:	ef 92       	push	r14
    3038:	ff 92       	push	r15
    303a:	0f 93       	push	r16
    303c:	1f 93       	push	r17
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	cd b7       	in	r28, 0x3d	; 61
    3044:	de b7       	in	r29, 0x3e	; 62
    3046:	60 97       	sbiw	r28, 0x10	; 16
    3048:	0f b6       	in	r0, 0x3f	; 63
    304a:	f8 94       	cli
    304c:	de bf       	out	0x3e, r29	; 62
    304e:	0f be       	out	0x3f, r0	; 63
    3050:	cd bf       	out	0x3d, r28	; 61
    3052:	9a 87       	std	Y+10, r25	; 0x0a
    3054:	89 87       	std	Y+9, r24	; 0x09
    3056:	7c 87       	std	Y+12, r23	; 0x0c
    3058:	6b 87       	std	Y+11, r22	; 0x0b
    305a:	5e 87       	std	Y+14, r21	; 0x0e
    305c:	4d 87       	std	Y+13, r20	; 0x0d
    305e:	38 8b       	std	Y+16, r19	; 0x10
    3060:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3062:	89 85       	ldd	r24, Y+9	; 0x09
    3064:	9a 85       	ldd	r25, Y+10	; 0x0a
    3066:	98 87       	std	Y+8, r25	; 0x08
    3068:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    306a:	1e 82       	std	Y+6, r1	; 0x06
    306c:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    306e:	ef 81       	ldd	r30, Y+7	; 0x07
    3070:	f8 85       	ldd	r31, Y+8	; 0x08
    3072:	86 85       	ldd	r24, Z+14	; 0x0e
    3074:	88 2f       	mov	r24, r24
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	81 70       	andi	r24, 0x01	; 1
    307a:	90 70       	andi	r25, 0x00	; 0
    307c:	88 23       	and	r24, r24
    307e:	29 f0       	breq	.+10     	; 0x308a <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3080:	82 e0       	ldi	r24, 0x02	; 2
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	9a 83       	std	Y+2, r25	; 0x02
    3086:	89 83       	std	Y+1, r24	; 0x01
    3088:	02 c0       	rjmp	.+4      	; 0x308e <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    308a:	1a 82       	std	Y+2, r1	; 0x02
    308c:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    308e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3090:	98 89       	ldd	r25, Y+16	; 0x10
    3092:	00 97       	sbiw	r24, 0x00	; 0
    3094:	09 f4       	brne	.+2      	; 0x3098 <xStreamBufferReceive+0x62>
    3096:	3d c0       	rjmp	.+122    	; 0x3112 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3098:	0f b6       	in	r0, 0x3f	; 63
    309a:	f8 94       	cli
    309c:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    309e:	8f 81       	ldd	r24, Y+7	; 0x07
    30a0:	98 85       	ldd	r25, Y+8	; 0x08
    30a2:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    30a6:	9c 83       	std	Y+4, r25	; 0x04
    30a8:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    30aa:	2b 81       	ldd	r18, Y+3	; 0x03
    30ac:	3c 81       	ldd	r19, Y+4	; 0x04
    30ae:	89 81       	ldd	r24, Y+1	; 0x01
    30b0:	9a 81       	ldd	r25, Y+2	; 0x02
    30b2:	82 17       	cp	r24, r18
    30b4:	93 07       	cpc	r25, r19
    30b6:	50 f0       	brcs	.+20     	; 0x30cc <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    30b8:	80 e0       	ldi	r24, 0x00	; 0
    30ba:	90 e0       	ldi	r25, 0x00	; 0
    30bc:	0e 94 09 29 	call	0x5212	; 0x5212 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    30c0:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <xTaskGetCurrentTaskHandle>
    30c4:	ef 81       	ldd	r30, Y+7	; 0x07
    30c6:	f8 85       	ldd	r31, Y+8	; 0x08
    30c8:	91 87       	std	Z+9, r25	; 0x09
    30ca:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    30cc:	0f 90       	pop	r0
    30ce:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    30d0:	2b 81       	ldd	r18, Y+3	; 0x03
    30d2:	3c 81       	ldd	r19, Y+4	; 0x04
    30d4:	89 81       	ldd	r24, Y+1	; 0x01
    30d6:	9a 81       	ldd	r25, Y+2	; 0x02
    30d8:	82 17       	cp	r24, r18
    30da:	93 07       	cpc	r25, r19
    30dc:	00 f1       	brcs	.+64     	; 0x311e <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    30de:	ef 85       	ldd	r30, Y+15	; 0x0f
    30e0:	f8 89       	ldd	r31, Y+16	; 0x10
    30e2:	60 e0       	ldi	r22, 0x00	; 0
    30e4:	70 e0       	ldi	r23, 0x00	; 0
    30e6:	80 e0       	ldi	r24, 0x00	; 0
    30e8:	90 e0       	ldi	r25, 0x00	; 0
    30ea:	20 e0       	ldi	r18, 0x00	; 0
    30ec:	30 e0       	ldi	r19, 0x00	; 0
    30ee:	40 e0       	ldi	r20, 0x00	; 0
    30f0:	50 e0       	ldi	r21, 0x00	; 0
    30f2:	00 e0       	ldi	r16, 0x00	; 0
    30f4:	10 e0       	ldi	r17, 0x00	; 0
    30f6:	7f 01       	movw	r14, r30
    30f8:	0e 94 12 26 	call	0x4c24	; 0x4c24 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    30fc:	ef 81       	ldd	r30, Y+7	; 0x07
    30fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3100:	11 86       	std	Z+9, r1	; 0x09
    3102:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3104:	8f 81       	ldd	r24, Y+7	; 0x07
    3106:	98 85       	ldd	r25, Y+8	; 0x08
    3108:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    310c:	9c 83       	std	Y+4, r25	; 0x04
    310e:	8b 83       	std	Y+3, r24	; 0x03
    3110:	06 c0       	rjmp	.+12     	; 0x311e <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3112:	8f 81       	ldd	r24, Y+7	; 0x07
    3114:	98 85       	ldd	r25, Y+8	; 0x08
    3116:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    311a:	9c 83       	std	Y+4, r25	; 0x04
    311c:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    311e:	2b 81       	ldd	r18, Y+3	; 0x03
    3120:	3c 81       	ldd	r19, Y+4	; 0x04
    3122:	89 81       	ldd	r24, Y+1	; 0x01
    3124:	9a 81       	ldd	r25, Y+2	; 0x02
    3126:	82 17       	cp	r24, r18
    3128:	93 07       	cpc	r25, r19
    312a:	80 f5       	brcc	.+96     	; 0x318c <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    312c:	8f 81       	ldd	r24, Y+7	; 0x07
    312e:	98 85       	ldd	r25, Y+8	; 0x08
    3130:	2b 85       	ldd	r18, Y+11	; 0x0b
    3132:	3c 85       	ldd	r19, Y+12	; 0x0c
    3134:	4d 85       	ldd	r20, Y+13	; 0x0d
    3136:	5e 85       	ldd	r21, Y+14	; 0x0e
    3138:	eb 81       	ldd	r30, Y+3	; 0x03
    313a:	fc 81       	ldd	r31, Y+4	; 0x04
    313c:	a9 81       	ldd	r26, Y+1	; 0x01
    313e:	ba 81       	ldd	r27, Y+2	; 0x02
    3140:	b9 01       	movw	r22, r18
    3142:	9f 01       	movw	r18, r30
    3144:	8d 01       	movw	r16, r26
    3146:	0e 94 9f 19 	call	0x333e	; 0x333e <prvReadMessageFromBuffer>
    314a:	9e 83       	std	Y+6, r25	; 0x06
    314c:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    314e:	8d 81       	ldd	r24, Y+5	; 0x05
    3150:	9e 81       	ldd	r25, Y+6	; 0x06
    3152:	00 97       	sbiw	r24, 0x00	; 0
    3154:	d9 f0       	breq	.+54     	; 0x318c <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3156:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
    315a:	ef 81       	ldd	r30, Y+7	; 0x07
    315c:	f8 85       	ldd	r31, Y+8	; 0x08
    315e:	82 85       	ldd	r24, Z+10	; 0x0a
    3160:	93 85       	ldd	r25, Z+11	; 0x0b
    3162:	00 97       	sbiw	r24, 0x00	; 0
    3164:	89 f0       	breq	.+34     	; 0x3188 <xStreamBufferReceive+0x152>
    3166:	ef 81       	ldd	r30, Y+7	; 0x07
    3168:	f8 85       	ldd	r31, Y+8	; 0x08
    316a:	82 85       	ldd	r24, Z+10	; 0x0a
    316c:	93 85       	ldd	r25, Z+11	; 0x0b
    316e:	40 e0       	ldi	r20, 0x00	; 0
    3170:	50 e0       	ldi	r21, 0x00	; 0
    3172:	60 e0       	ldi	r22, 0x00	; 0
    3174:	70 e0       	ldi	r23, 0x00	; 0
    3176:	20 e0       	ldi	r18, 0x00	; 0
    3178:	00 e0       	ldi	r16, 0x00	; 0
    317a:	10 e0       	ldi	r17, 0x00	; 0
    317c:	0e 94 ae 26 	call	0x4d5c	; 0x4d5c <xTaskGenericNotify>
    3180:	ef 81       	ldd	r30, Y+7	; 0x07
    3182:	f8 85       	ldd	r31, Y+8	; 0x08
    3184:	13 86       	std	Z+11, r1	; 0x0b
    3186:	12 86       	std	Z+10, r1	; 0x0a
    3188:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    318c:	8d 81       	ldd	r24, Y+5	; 0x05
    318e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3190:	60 96       	adiw	r28, 0x10	; 16
    3192:	0f b6       	in	r0, 0x3f	; 63
    3194:	f8 94       	cli
    3196:	de bf       	out	0x3e, r29	; 62
    3198:	0f be       	out	0x3f, r0	; 63
    319a:	cd bf       	out	0x3d, r28	; 61
    319c:	cf 91       	pop	r28
    319e:	df 91       	pop	r29
    31a0:	1f 91       	pop	r17
    31a2:	0f 91       	pop	r16
    31a4:	ff 90       	pop	r15
    31a6:	ef 90       	pop	r14
    31a8:	08 95       	ret

000031aa <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    31aa:	df 93       	push	r29
    31ac:	cf 93       	push	r28
    31ae:	cd b7       	in	r28, 0x3d	; 61
    31b0:	de b7       	in	r29, 0x3e	; 62
    31b2:	2c 97       	sbiw	r28, 0x0c	; 12
    31b4:	0f b6       	in	r0, 0x3f	; 63
    31b6:	f8 94       	cli
    31b8:	de bf       	out	0x3e, r29	; 62
    31ba:	0f be       	out	0x3f, r0	; 63
    31bc:	cd bf       	out	0x3d, r28	; 61
    31be:	9c 87       	std	Y+12, r25	; 0x0c
    31c0:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    31c4:	9c 85       	ldd	r25, Y+12	; 0x0c
    31c6:	98 87       	std	Y+8, r25	; 0x08
    31c8:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    31ca:	ef 81       	ldd	r30, Y+7	; 0x07
    31cc:	f8 85       	ldd	r31, Y+8	; 0x08
    31ce:	86 85       	ldd	r24, Z+14	; 0x0e
    31d0:	88 2f       	mov	r24, r24
    31d2:	90 e0       	ldi	r25, 0x00	; 0
    31d4:	81 70       	andi	r24, 0x01	; 1
    31d6:	90 70       	andi	r25, 0x00	; 0
    31d8:	88 23       	and	r24, r24
    31da:	61 f1       	breq	.+88     	; 0x3234 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31dc:	8f 81       	ldd	r24, Y+7	; 0x07
    31de:	98 85       	ldd	r25, Y+8	; 0x08
    31e0:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    31e4:	9c 83       	std	Y+4, r25	; 0x04
    31e6:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    31e8:	8b 81       	ldd	r24, Y+3	; 0x03
    31ea:	9c 81       	ldd	r25, Y+4	; 0x04
    31ec:	83 30       	cpi	r24, 0x03	; 3
    31ee:	91 05       	cpc	r25, r1
    31f0:	f0 f0       	brcs	.+60     	; 0x322e <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    31f2:	ef 81       	ldd	r30, Y+7	; 0x07
    31f4:	f8 85       	ldd	r31, Y+8	; 0x08
    31f6:	80 81       	ld	r24, Z
    31f8:	91 81       	ldd	r25, Z+1	; 0x01
    31fa:	9a 83       	std	Y+2, r25	; 0x02
    31fc:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    31fe:	9e 01       	movw	r18, r28
    3200:	27 5f       	subi	r18, 0xF7	; 247
    3202:	3f 4f       	sbci	r19, 0xFF	; 255
    3204:	8f 81       	ldd	r24, Y+7	; 0x07
    3206:	98 85       	ldd	r25, Y+8	; 0x08
    3208:	eb 81       	ldd	r30, Y+3	; 0x03
    320a:	fc 81       	ldd	r31, Y+4	; 0x04
    320c:	b9 01       	movw	r22, r18
    320e:	42 e0       	ldi	r20, 0x02	; 2
    3210:	50 e0       	ldi	r21, 0x00	; 0
    3212:	9f 01       	movw	r18, r30
    3214:	0e 94 83 1b 	call	0x3706	; 0x3706 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3218:	89 85       	ldd	r24, Y+9	; 0x09
    321a:	9a 85       	ldd	r25, Y+10	; 0x0a
    321c:	9e 83       	std	Y+6, r25	; 0x06
    321e:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3220:	ef 81       	ldd	r30, Y+7	; 0x07
    3222:	f8 85       	ldd	r31, Y+8	; 0x08
    3224:	89 81       	ldd	r24, Y+1	; 0x01
    3226:	9a 81       	ldd	r25, Y+2	; 0x02
    3228:	91 83       	std	Z+1, r25	; 0x01
    322a:	80 83       	st	Z, r24
    322c:	05 c0       	rjmp	.+10     	; 0x3238 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    322e:	1e 82       	std	Y+6, r1	; 0x06
    3230:	1d 82       	std	Y+5, r1	; 0x05
    3232:	02 c0       	rjmp	.+4      	; 0x3238 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3234:	1e 82       	std	Y+6, r1	; 0x06
    3236:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3238:	8d 81       	ldd	r24, Y+5	; 0x05
    323a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    323c:	2c 96       	adiw	r28, 0x0c	; 12
    323e:	0f b6       	in	r0, 0x3f	; 63
    3240:	f8 94       	cli
    3242:	de bf       	out	0x3e, r29	; 62
    3244:	0f be       	out	0x3f, r0	; 63
    3246:	cd bf       	out	0x3d, r28	; 61
    3248:	cf 91       	pop	r28
    324a:	df 91       	pop	r29
    324c:	08 95       	ret

0000324e <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    324e:	ef 92       	push	r14
    3250:	ff 92       	push	r15
    3252:	0f 93       	push	r16
    3254:	1f 93       	push	r17
    3256:	df 93       	push	r29
    3258:	cf 93       	push	r28
    325a:	cd b7       	in	r28, 0x3d	; 61
    325c:	de b7       	in	r29, 0x3e	; 62
    325e:	61 97       	sbiw	r28, 0x11	; 17
    3260:	0f b6       	in	r0, 0x3f	; 63
    3262:	f8 94       	cli
    3264:	de bf       	out	0x3e, r29	; 62
    3266:	0f be       	out	0x3f, r0	; 63
    3268:	cd bf       	out	0x3d, r28	; 61
    326a:	9b 87       	std	Y+11, r25	; 0x0b
    326c:	8a 87       	std	Y+10, r24	; 0x0a
    326e:	7d 87       	std	Y+13, r23	; 0x0d
    3270:	6c 87       	std	Y+12, r22	; 0x0c
    3272:	5f 87       	std	Y+15, r21	; 0x0f
    3274:	4e 87       	std	Y+14, r20	; 0x0e
    3276:	39 8b       	std	Y+17, r19	; 0x11
    3278:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    327a:	8a 85       	ldd	r24, Y+10	; 0x0a
    327c:	9b 85       	ldd	r25, Y+11	; 0x0b
    327e:	99 87       	std	Y+9, r25	; 0x09
    3280:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3282:	1f 82       	std	Y+7, r1	; 0x07
    3284:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3286:	e8 85       	ldd	r30, Y+8	; 0x08
    3288:	f9 85       	ldd	r31, Y+9	; 0x09
    328a:	86 85       	ldd	r24, Z+14	; 0x0e
    328c:	88 2f       	mov	r24, r24
    328e:	90 e0       	ldi	r25, 0x00	; 0
    3290:	81 70       	andi	r24, 0x01	; 1
    3292:	90 70       	andi	r25, 0x00	; 0
    3294:	88 23       	and	r24, r24
    3296:	29 f0       	breq	.+10     	; 0x32a2 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3298:	82 e0       	ldi	r24, 0x02	; 2
    329a:	90 e0       	ldi	r25, 0x00	; 0
    329c:	9b 83       	std	Y+3, r25	; 0x03
    329e:	8a 83       	std	Y+2, r24	; 0x02
    32a0:	02 c0       	rjmp	.+4      	; 0x32a6 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    32a2:	1b 82       	std	Y+3, r1	; 0x03
    32a4:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    32a6:	88 85       	ldd	r24, Y+8	; 0x08
    32a8:	99 85       	ldd	r25, Y+9	; 0x09
    32aa:	0e 94 30 1c 	call	0x3860	; 0x3860 <prvBytesInBuffer>
    32ae:	9d 83       	std	Y+5, r25	; 0x05
    32b0:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    32b2:	2c 81       	ldd	r18, Y+4	; 0x04
    32b4:	3d 81       	ldd	r19, Y+5	; 0x05
    32b6:	8a 81       	ldd	r24, Y+2	; 0x02
    32b8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ba:	82 17       	cp	r24, r18
    32bc:	93 07       	cpc	r25, r19
    32be:	80 f5       	brcc	.+96     	; 0x3320 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    32c0:	88 85       	ldd	r24, Y+8	; 0x08
    32c2:	99 85       	ldd	r25, Y+9	; 0x09
    32c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    32c6:	3d 85       	ldd	r19, Y+13	; 0x0d
    32c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    32ca:	5f 85       	ldd	r21, Y+15	; 0x0f
    32cc:	ec 81       	ldd	r30, Y+4	; 0x04
    32ce:	fd 81       	ldd	r31, Y+5	; 0x05
    32d0:	aa 81       	ldd	r26, Y+2	; 0x02
    32d2:	bb 81       	ldd	r27, Y+3	; 0x03
    32d4:	b9 01       	movw	r22, r18
    32d6:	9f 01       	movw	r18, r30
    32d8:	8d 01       	movw	r16, r26
    32da:	0e 94 9f 19 	call	0x333e	; 0x333e <prvReadMessageFromBuffer>
    32de:	9f 83       	std	Y+7, r25	; 0x07
    32e0:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    32e2:	8e 81       	ldd	r24, Y+6	; 0x06
    32e4:	9f 81       	ldd	r25, Y+7	; 0x07
    32e6:	00 97       	sbiw	r24, 0x00	; 0
    32e8:	d9 f0       	breq	.+54     	; 0x3320 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    32ea:	19 82       	std	Y+1, r1	; 0x01
    32ec:	e8 85       	ldd	r30, Y+8	; 0x08
    32ee:	f9 85       	ldd	r31, Y+9	; 0x09
    32f0:	82 85       	ldd	r24, Z+10	; 0x0a
    32f2:	93 85       	ldd	r25, Z+11	; 0x0b
    32f4:	00 97       	sbiw	r24, 0x00	; 0
    32f6:	a1 f0       	breq	.+40     	; 0x3320 <xStreamBufferReceiveFromISR+0xd2>
    32f8:	e8 85       	ldd	r30, Y+8	; 0x08
    32fa:	f9 85       	ldd	r31, Y+9	; 0x09
    32fc:	82 85       	ldd	r24, Z+10	; 0x0a
    32fe:	93 85       	ldd	r25, Z+11	; 0x0b
    3300:	e8 89       	ldd	r30, Y+16	; 0x10
    3302:	f9 89       	ldd	r31, Y+17	; 0x11
    3304:	40 e0       	ldi	r20, 0x00	; 0
    3306:	50 e0       	ldi	r21, 0x00	; 0
    3308:	60 e0       	ldi	r22, 0x00	; 0
    330a:	70 e0       	ldi	r23, 0x00	; 0
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	00 e0       	ldi	r16, 0x00	; 0
    3310:	10 e0       	ldi	r17, 0x00	; 0
    3312:	7f 01       	movw	r14, r30
    3314:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <xTaskGenericNotifyFromISR>
    3318:	e8 85       	ldd	r30, Y+8	; 0x08
    331a:	f9 85       	ldd	r31, Y+9	; 0x09
    331c:	13 86       	std	Z+11, r1	; 0x0b
    331e:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3320:	8e 81       	ldd	r24, Y+6	; 0x06
    3322:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3324:	61 96       	adiw	r28, 0x11	; 17
    3326:	0f b6       	in	r0, 0x3f	; 63
    3328:	f8 94       	cli
    332a:	de bf       	out	0x3e, r29	; 62
    332c:	0f be       	out	0x3f, r0	; 63
    332e:	cd bf       	out	0x3d, r28	; 61
    3330:	cf 91       	pop	r28
    3332:	df 91       	pop	r29
    3334:	1f 91       	pop	r17
    3336:	0f 91       	pop	r16
    3338:	ff 90       	pop	r15
    333a:	ef 90       	pop	r14
    333c:	08 95       	ret

0000333e <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    333e:	0f 93       	push	r16
    3340:	1f 93       	push	r17
    3342:	df 93       	push	r29
    3344:	cf 93       	push	r28
    3346:	cd b7       	in	r28, 0x3d	; 61
    3348:	de b7       	in	r29, 0x3e	; 62
    334a:	62 97       	sbiw	r28, 0x12	; 18
    334c:	0f b6       	in	r0, 0x3f	; 63
    334e:	f8 94       	cli
    3350:	de bf       	out	0x3e, r29	; 62
    3352:	0f be       	out	0x3f, r0	; 63
    3354:	cd bf       	out	0x3d, r28	; 61
    3356:	9a 87       	std	Y+10, r25	; 0x0a
    3358:	89 87       	std	Y+9, r24	; 0x09
    335a:	7c 87       	std	Y+12, r23	; 0x0c
    335c:	6b 87       	std	Y+11, r22	; 0x0b
    335e:	5e 87       	std	Y+14, r21	; 0x0e
    3360:	4d 87       	std	Y+13, r20	; 0x0d
    3362:	38 8b       	std	Y+16, r19	; 0x10
    3364:	2f 87       	std	Y+15, r18	; 0x0f
    3366:	1a 8b       	std	Y+18, r17	; 0x12
    3368:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    336a:	89 89       	ldd	r24, Y+17	; 0x11
    336c:	9a 89       	ldd	r25, Y+18	; 0x12
    336e:	00 97       	sbiw	r24, 0x00	; 0
    3370:	91 f1       	breq	.+100    	; 0x33d6 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3372:	e9 85       	ldd	r30, Y+9	; 0x09
    3374:	fa 85       	ldd	r31, Y+10	; 0x0a
    3376:	80 81       	ld	r24, Z
    3378:	91 81       	ldd	r25, Z+1	; 0x01
    337a:	9e 83       	std	Y+6, r25	; 0x06
    337c:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    337e:	ae 01       	movw	r20, r28
    3380:	49 5f       	subi	r20, 0xF9	; 249
    3382:	5f 4f       	sbci	r21, 0xFF	; 255
    3384:	89 85       	ldd	r24, Y+9	; 0x09
    3386:	9a 85       	ldd	r25, Y+10	; 0x0a
    3388:	29 89       	ldd	r18, Y+17	; 0x11
    338a:	3a 89       	ldd	r19, Y+18	; 0x12
    338c:	ef 85       	ldd	r30, Y+15	; 0x0f
    338e:	f8 89       	ldd	r31, Y+16	; 0x10
    3390:	ba 01       	movw	r22, r20
    3392:	a9 01       	movw	r20, r18
    3394:	9f 01       	movw	r18, r30
    3396:	0e 94 83 1b 	call	0x3706	; 0x3706 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    339a:	8f 81       	ldd	r24, Y+7	; 0x07
    339c:	98 85       	ldd	r25, Y+8	; 0x08
    339e:	9a 83       	std	Y+2, r25	; 0x02
    33a0:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    33a2:	2f 85       	ldd	r18, Y+15	; 0x0f
    33a4:	38 89       	ldd	r19, Y+16	; 0x10
    33a6:	89 89       	ldd	r24, Y+17	; 0x11
    33a8:	9a 89       	ldd	r25, Y+18	; 0x12
    33aa:	a9 01       	movw	r20, r18
    33ac:	48 1b       	sub	r20, r24
    33ae:	59 0b       	sbc	r21, r25
    33b0:	ca 01       	movw	r24, r20
    33b2:	98 8b       	std	Y+16, r25	; 0x10
    33b4:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    33b6:	29 81       	ldd	r18, Y+1	; 0x01
    33b8:	3a 81       	ldd	r19, Y+2	; 0x02
    33ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    33bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    33be:	82 17       	cp	r24, r18
    33c0:	93 07       	cpc	r25, r19
    33c2:	68 f4       	brcc	.+26     	; 0x33de <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    33c4:	e9 85       	ldd	r30, Y+9	; 0x09
    33c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    33c8:	8d 81       	ldd	r24, Y+5	; 0x05
    33ca:	9e 81       	ldd	r25, Y+6	; 0x06
    33cc:	91 83       	std	Z+1, r25	; 0x01
    33ce:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    33d0:	1a 82       	std	Y+2, r1	; 0x02
    33d2:	19 82       	std	Y+1, r1	; 0x01
    33d4:	04 c0       	rjmp	.+8      	; 0x33de <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    33d6:	8d 85       	ldd	r24, Y+13	; 0x0d
    33d8:	9e 85       	ldd	r25, Y+14	; 0x0e
    33da:	9a 83       	std	Y+2, r25	; 0x02
    33dc:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    33de:	4b 85       	ldd	r20, Y+11	; 0x0b
    33e0:	5c 85       	ldd	r21, Y+12	; 0x0c
    33e2:	89 85       	ldd	r24, Y+9	; 0x09
    33e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    33e6:	29 81       	ldd	r18, Y+1	; 0x01
    33e8:	3a 81       	ldd	r19, Y+2	; 0x02
    33ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    33ec:	f8 89       	ldd	r31, Y+16	; 0x10
    33ee:	ba 01       	movw	r22, r20
    33f0:	a9 01       	movw	r20, r18
    33f2:	9f 01       	movw	r18, r30
    33f4:	0e 94 83 1b 	call	0x3706	; 0x3706 <prvReadBytesFromBuffer>
    33f8:	9c 83       	std	Y+4, r25	; 0x04
    33fa:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    33fc:	8b 81       	ldd	r24, Y+3	; 0x03
    33fe:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3400:	62 96       	adiw	r28, 0x12	; 18
    3402:	0f b6       	in	r0, 0x3f	; 63
    3404:	f8 94       	cli
    3406:	de bf       	out	0x3e, r29	; 62
    3408:	0f be       	out	0x3f, r0	; 63
    340a:	cd bf       	out	0x3d, r28	; 61
    340c:	cf 91       	pop	r28
    340e:	df 91       	pop	r29
    3410:	1f 91       	pop	r17
    3412:	0f 91       	pop	r16
    3414:	08 95       	ret

00003416 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3416:	df 93       	push	r29
    3418:	cf 93       	push	r28
    341a:	cd b7       	in	r28, 0x3d	; 61
    341c:	de b7       	in	r29, 0x3e	; 62
    341e:	27 97       	sbiw	r28, 0x07	; 7
    3420:	0f b6       	in	r0, 0x3f	; 63
    3422:	f8 94       	cli
    3424:	de bf       	out	0x3e, r29	; 62
    3426:	0f be       	out	0x3f, r0	; 63
    3428:	cd bf       	out	0x3d, r28	; 61
    342a:	9f 83       	std	Y+7, r25	; 0x07
    342c:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    342e:	8e 81       	ldd	r24, Y+6	; 0x06
    3430:	9f 81       	ldd	r25, Y+7	; 0x07
    3432:	9d 83       	std	Y+5, r25	; 0x05
    3434:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3436:	ec 81       	ldd	r30, Y+4	; 0x04
    3438:	fd 81       	ldd	r31, Y+5	; 0x05
    343a:	80 81       	ld	r24, Z
    343c:	91 81       	ldd	r25, Z+1	; 0x01
    343e:	9a 83       	std	Y+2, r25	; 0x02
    3440:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    3442:	ec 81       	ldd	r30, Y+4	; 0x04
    3444:	fd 81       	ldd	r31, Y+5	; 0x05
    3446:	22 81       	ldd	r18, Z+2	; 0x02
    3448:	33 81       	ldd	r19, Z+3	; 0x03
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	28 17       	cp	r18, r24
    3450:	39 07       	cpc	r19, r25
    3452:	19 f4       	brne	.+6      	; 0x345a <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    3454:	81 e0       	ldi	r24, 0x01	; 1
    3456:	8b 83       	std	Y+3, r24	; 0x03
    3458:	01 c0       	rjmp	.+2      	; 0x345c <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    345a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    345c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    345e:	27 96       	adiw	r28, 0x07	; 7
    3460:	0f b6       	in	r0, 0x3f	; 63
    3462:	f8 94       	cli
    3464:	de bf       	out	0x3e, r29	; 62
    3466:	0f be       	out	0x3f, r0	; 63
    3468:	cd bf       	out	0x3d, r28	; 61
    346a:	cf 91       	pop	r28
    346c:	df 91       	pop	r29
    346e:	08 95       	ret

00003470 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3470:	df 93       	push	r29
    3472:	cf 93       	push	r28
    3474:	cd b7       	in	r28, 0x3d	; 61
    3476:	de b7       	in	r29, 0x3e	; 62
    3478:	27 97       	sbiw	r28, 0x07	; 7
    347a:	0f b6       	in	r0, 0x3f	; 63
    347c:	f8 94       	cli
    347e:	de bf       	out	0x3e, r29	; 62
    3480:	0f be       	out	0x3f, r0	; 63
    3482:	cd bf       	out	0x3d, r28	; 61
    3484:	9f 83       	std	Y+7, r25	; 0x07
    3486:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3488:	8e 81       	ldd	r24, Y+6	; 0x06
    348a:	9f 81       	ldd	r25, Y+7	; 0x07
    348c:	9a 83       	std	Y+2, r25	; 0x02
    348e:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3490:	e9 81       	ldd	r30, Y+1	; 0x01
    3492:	fa 81       	ldd	r31, Y+2	; 0x02
    3494:	86 85       	ldd	r24, Z+14	; 0x0e
    3496:	88 2f       	mov	r24, r24
    3498:	90 e0       	ldi	r25, 0x00	; 0
    349a:	81 70       	andi	r24, 0x01	; 1
    349c:	90 70       	andi	r25, 0x00	; 0
    349e:	88 23       	and	r24, r24
    34a0:	29 f0       	breq	.+10     	; 0x34ac <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    34a2:	82 e0       	ldi	r24, 0x02	; 2
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	9c 83       	std	Y+4, r25	; 0x04
    34a8:	8b 83       	std	Y+3, r24	; 0x03
    34aa:	02 c0       	rjmp	.+4      	; 0x34b0 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    34ac:	1c 82       	std	Y+4, r1	; 0x04
    34ae:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    34b0:	8e 81       	ldd	r24, Y+6	; 0x06
    34b2:	9f 81       	ldd	r25, Y+7	; 0x07
    34b4:	0e 94 00 16 	call	0x2c00	; 0x2c00 <xStreamBufferSpacesAvailable>
    34b8:	9c 01       	movw	r18, r24
    34ba:	8b 81       	ldd	r24, Y+3	; 0x03
    34bc:	9c 81       	ldd	r25, Y+4	; 0x04
    34be:	82 17       	cp	r24, r18
    34c0:	93 07       	cpc	r25, r19
    34c2:	18 f0       	brcs	.+6      	; 0x34ca <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    34c4:	81 e0       	ldi	r24, 0x01	; 1
    34c6:	8d 83       	std	Y+5, r24	; 0x05
    34c8:	01 c0       	rjmp	.+2      	; 0x34cc <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    34ca:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    34cc:	8d 81       	ldd	r24, Y+5	; 0x05
}
    34ce:	27 96       	adiw	r28, 0x07	; 7
    34d0:	0f b6       	in	r0, 0x3f	; 63
    34d2:	f8 94       	cli
    34d4:	de bf       	out	0x3e, r29	; 62
    34d6:	0f be       	out	0x3f, r0	; 63
    34d8:	cd bf       	out	0x3d, r28	; 61
    34da:	cf 91       	pop	r28
    34dc:	df 91       	pop	r29
    34de:	08 95       	ret

000034e0 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    34e0:	ef 92       	push	r14
    34e2:	ff 92       	push	r15
    34e4:	0f 93       	push	r16
    34e6:	1f 93       	push	r17
    34e8:	df 93       	push	r29
    34ea:	cf 93       	push	r28
    34ec:	cd b7       	in	r28, 0x3d	; 61
    34ee:	de b7       	in	r29, 0x3e	; 62
    34f0:	28 97       	sbiw	r28, 0x08	; 8
    34f2:	0f b6       	in	r0, 0x3f	; 63
    34f4:	f8 94       	cli
    34f6:	de bf       	out	0x3e, r29	; 62
    34f8:	0f be       	out	0x3f, r0	; 63
    34fa:	cd bf       	out	0x3d, r28	; 61
    34fc:	9e 83       	std	Y+6, r25	; 0x06
    34fe:	8d 83       	std	Y+5, r24	; 0x05
    3500:	78 87       	std	Y+8, r23	; 0x08
    3502:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3504:	8d 81       	ldd	r24, Y+5	; 0x05
    3506:	9e 81       	ldd	r25, Y+6	; 0x06
    3508:	9c 83       	std	Y+4, r25	; 0x04
    350a:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    350c:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    350e:	eb 81       	ldd	r30, Y+3	; 0x03
    3510:	fc 81       	ldd	r31, Y+4	; 0x04
    3512:	80 85       	ldd	r24, Z+8	; 0x08
    3514:	91 85       	ldd	r25, Z+9	; 0x09
    3516:	00 97       	sbiw	r24, 0x00	; 0
    3518:	b9 f0       	breq	.+46     	; 0x3548 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    351a:	eb 81       	ldd	r30, Y+3	; 0x03
    351c:	fc 81       	ldd	r31, Y+4	; 0x04
    351e:	80 85       	ldd	r24, Z+8	; 0x08
    3520:	91 85       	ldd	r25, Z+9	; 0x09
    3522:	ef 81       	ldd	r30, Y+7	; 0x07
    3524:	f8 85       	ldd	r31, Y+8	; 0x08
    3526:	40 e0       	ldi	r20, 0x00	; 0
    3528:	50 e0       	ldi	r21, 0x00	; 0
    352a:	60 e0       	ldi	r22, 0x00	; 0
    352c:	70 e0       	ldi	r23, 0x00	; 0
    352e:	20 e0       	ldi	r18, 0x00	; 0
    3530:	00 e0       	ldi	r16, 0x00	; 0
    3532:	10 e0       	ldi	r17, 0x00	; 0
    3534:	7f 01       	movw	r14, r30
    3536:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    353a:	eb 81       	ldd	r30, Y+3	; 0x03
    353c:	fc 81       	ldd	r31, Y+4	; 0x04
    353e:	11 86       	std	Z+9, r1	; 0x09
    3540:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	8a 83       	std	Y+2, r24	; 0x02
    3546:	01 c0       	rjmp	.+2      	; 0x354a <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3548:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    354a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    354c:	28 96       	adiw	r28, 0x08	; 8
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	de bf       	out	0x3e, r29	; 62
    3554:	0f be       	out	0x3f, r0	; 63
    3556:	cd bf       	out	0x3d, r28	; 61
    3558:	cf 91       	pop	r28
    355a:	df 91       	pop	r29
    355c:	1f 91       	pop	r17
    355e:	0f 91       	pop	r16
    3560:	ff 90       	pop	r15
    3562:	ef 90       	pop	r14
    3564:	08 95       	ret

00003566 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3566:	ef 92       	push	r14
    3568:	ff 92       	push	r15
    356a:	0f 93       	push	r16
    356c:	1f 93       	push	r17
    356e:	df 93       	push	r29
    3570:	cf 93       	push	r28
    3572:	cd b7       	in	r28, 0x3d	; 61
    3574:	de b7       	in	r29, 0x3e	; 62
    3576:	28 97       	sbiw	r28, 0x08	; 8
    3578:	0f b6       	in	r0, 0x3f	; 63
    357a:	f8 94       	cli
    357c:	de bf       	out	0x3e, r29	; 62
    357e:	0f be       	out	0x3f, r0	; 63
    3580:	cd bf       	out	0x3d, r28	; 61
    3582:	9e 83       	std	Y+6, r25	; 0x06
    3584:	8d 83       	std	Y+5, r24	; 0x05
    3586:	78 87       	std	Y+8, r23	; 0x08
    3588:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    358a:	8d 81       	ldd	r24, Y+5	; 0x05
    358c:	9e 81       	ldd	r25, Y+6	; 0x06
    358e:	9c 83       	std	Y+4, r25	; 0x04
    3590:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3592:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3594:	eb 81       	ldd	r30, Y+3	; 0x03
    3596:	fc 81       	ldd	r31, Y+4	; 0x04
    3598:	82 85       	ldd	r24, Z+10	; 0x0a
    359a:	93 85       	ldd	r25, Z+11	; 0x0b
    359c:	00 97       	sbiw	r24, 0x00	; 0
    359e:	b9 f0       	breq	.+46     	; 0x35ce <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    35a0:	eb 81       	ldd	r30, Y+3	; 0x03
    35a2:	fc 81       	ldd	r31, Y+4	; 0x04
    35a4:	82 85       	ldd	r24, Z+10	; 0x0a
    35a6:	93 85       	ldd	r25, Z+11	; 0x0b
    35a8:	ef 81       	ldd	r30, Y+7	; 0x07
    35aa:	f8 85       	ldd	r31, Y+8	; 0x08
    35ac:	40 e0       	ldi	r20, 0x00	; 0
    35ae:	50 e0       	ldi	r21, 0x00	; 0
    35b0:	60 e0       	ldi	r22, 0x00	; 0
    35b2:	70 e0       	ldi	r23, 0x00	; 0
    35b4:	20 e0       	ldi	r18, 0x00	; 0
    35b6:	00 e0       	ldi	r16, 0x00	; 0
    35b8:	10 e0       	ldi	r17, 0x00	; 0
    35ba:	7f 01       	movw	r14, r30
    35bc:	0e 94 8b 27 	call	0x4f16	; 0x4f16 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    35c0:	eb 81       	ldd	r30, Y+3	; 0x03
    35c2:	fc 81       	ldd	r31, Y+4	; 0x04
    35c4:	13 86       	std	Z+11, r1	; 0x0b
    35c6:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	8a 83       	std	Y+2, r24	; 0x02
    35cc:	01 c0       	rjmp	.+2      	; 0x35d0 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    35ce:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    35d2:	28 96       	adiw	r28, 0x08	; 8
    35d4:	0f b6       	in	r0, 0x3f	; 63
    35d6:	f8 94       	cli
    35d8:	de bf       	out	0x3e, r29	; 62
    35da:	0f be       	out	0x3f, r0	; 63
    35dc:	cd bf       	out	0x3d, r28	; 61
    35de:	cf 91       	pop	r28
    35e0:	df 91       	pop	r29
    35e2:	1f 91       	pop	r17
    35e4:	0f 91       	pop	r16
    35e6:	ff 90       	pop	r15
    35e8:	ef 90       	pop	r14
    35ea:	08 95       	ret

000035ec <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    35ec:	df 93       	push	r29
    35ee:	cf 93       	push	r28
    35f0:	cd b7       	in	r28, 0x3d	; 61
    35f2:	de b7       	in	r29, 0x3e	; 62
    35f4:	2e 97       	sbiw	r28, 0x0e	; 14
    35f6:	0f b6       	in	r0, 0x3f	; 63
    35f8:	f8 94       	cli
    35fa:	de bf       	out	0x3e, r29	; 62
    35fc:	0f be       	out	0x3f, r0	; 63
    35fe:	cd bf       	out	0x3d, r28	; 61
    3600:	9e 83       	std	Y+6, r25	; 0x06
    3602:	8d 83       	std	Y+5, r24	; 0x05
    3604:	78 87       	std	Y+8, r23	; 0x08
    3606:	6f 83       	std	Y+7, r22	; 0x07
    3608:	5a 87       	std	Y+10, r21	; 0x0a
    360a:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    360c:	ed 81       	ldd	r30, Y+5	; 0x05
    360e:	fe 81       	ldd	r31, Y+6	; 0x06
    3610:	82 81       	ldd	r24, Z+2	; 0x02
    3612:	93 81       	ldd	r25, Z+3	; 0x03
    3614:	9c 83       	std	Y+4, r25	; 0x04
    3616:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3618:	ed 81       	ldd	r30, Y+5	; 0x05
    361a:	fe 81       	ldd	r31, Y+6	; 0x06
    361c:	24 81       	ldd	r18, Z+4	; 0x04
    361e:	35 81       	ldd	r19, Z+5	; 0x05
    3620:	8b 81       	ldd	r24, Y+3	; 0x03
    3622:	9c 81       	ldd	r25, Y+4	; 0x04
    3624:	a9 01       	movw	r20, r18
    3626:	48 1b       	sub	r20, r24
    3628:	59 0b       	sbc	r21, r25
    362a:	ca 01       	movw	r24, r20
    362c:	29 85       	ldd	r18, Y+9	; 0x09
    362e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3630:	3e 87       	std	Y+14, r19	; 0x0e
    3632:	2d 87       	std	Y+13, r18	; 0x0d
    3634:	9c 87       	std	Y+12, r25	; 0x0c
    3636:	8b 87       	std	Y+11, r24	; 0x0b
    3638:	4b 85       	ldd	r20, Y+11	; 0x0b
    363a:	5c 85       	ldd	r21, Y+12	; 0x0c
    363c:	8d 85       	ldd	r24, Y+13	; 0x0d
    363e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3640:	84 17       	cp	r24, r20
    3642:	95 07       	cpc	r25, r21
    3644:	20 f4       	brcc	.+8      	; 0x364e <prvWriteBytesToBuffer+0x62>
    3646:	2d 85       	ldd	r18, Y+13	; 0x0d
    3648:	3e 85       	ldd	r19, Y+14	; 0x0e
    364a:	3c 87       	std	Y+12, r19	; 0x0c
    364c:	2b 87       	std	Y+11, r18	; 0x0b
    364e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3650:	5c 85       	ldd	r21, Y+12	; 0x0c
    3652:	5a 83       	std	Y+2, r21	; 0x02
    3654:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3656:	ed 81       	ldd	r30, Y+5	; 0x05
    3658:	fe 81       	ldd	r31, Y+6	; 0x06
    365a:	24 85       	ldd	r18, Z+12	; 0x0c
    365c:	35 85       	ldd	r19, Z+13	; 0x0d
    365e:	8b 81       	ldd	r24, Y+3	; 0x03
    3660:	9c 81       	ldd	r25, Y+4	; 0x04
    3662:	82 0f       	add	r24, r18
    3664:	93 1f       	adc	r25, r19
    3666:	2f 81       	ldd	r18, Y+7	; 0x07
    3668:	38 85       	ldd	r19, Y+8	; 0x08
    366a:	49 81       	ldd	r20, Y+1	; 0x01
    366c:	5a 81       	ldd	r21, Y+2	; 0x02
    366e:	b9 01       	movw	r22, r18
    3670:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3674:	29 85       	ldd	r18, Y+9	; 0x09
    3676:	3a 85       	ldd	r19, Y+10	; 0x0a
    3678:	89 81       	ldd	r24, Y+1	; 0x01
    367a:	9a 81       	ldd	r25, Y+2	; 0x02
    367c:	82 17       	cp	r24, r18
    367e:	93 07       	cpc	r25, r19
    3680:	b0 f4       	brcc	.+44     	; 0x36ae <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3682:	ed 81       	ldd	r30, Y+5	; 0x05
    3684:	fe 81       	ldd	r31, Y+6	; 0x06
    3686:	64 85       	ldd	r22, Z+12	; 0x0c
    3688:	75 85       	ldd	r23, Z+13	; 0x0d
    368a:	2f 81       	ldd	r18, Y+7	; 0x07
    368c:	38 85       	ldd	r19, Y+8	; 0x08
    368e:	89 81       	ldd	r24, Y+1	; 0x01
    3690:	9a 81       	ldd	r25, Y+2	; 0x02
    3692:	a9 01       	movw	r20, r18
    3694:	48 0f       	add	r20, r24
    3696:	59 1f       	adc	r21, r25
    3698:	29 85       	ldd	r18, Y+9	; 0x09
    369a:	3a 85       	ldd	r19, Y+10	; 0x0a
    369c:	89 81       	ldd	r24, Y+1	; 0x01
    369e:	9a 81       	ldd	r25, Y+2	; 0x02
    36a0:	28 1b       	sub	r18, r24
    36a2:	39 0b       	sbc	r19, r25
    36a4:	cb 01       	movw	r24, r22
    36a6:	ba 01       	movw	r22, r20
    36a8:	a9 01       	movw	r20, r18
    36aa:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    36ae:	2b 81       	ldd	r18, Y+3	; 0x03
    36b0:	3c 81       	ldd	r19, Y+4	; 0x04
    36b2:	89 85       	ldd	r24, Y+9	; 0x09
    36b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    36b6:	82 0f       	add	r24, r18
    36b8:	93 1f       	adc	r25, r19
    36ba:	9c 83       	std	Y+4, r25	; 0x04
    36bc:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    36be:	ed 81       	ldd	r30, Y+5	; 0x05
    36c0:	fe 81       	ldd	r31, Y+6	; 0x06
    36c2:	24 81       	ldd	r18, Z+4	; 0x04
    36c4:	35 81       	ldd	r19, Z+5	; 0x05
    36c6:	8b 81       	ldd	r24, Y+3	; 0x03
    36c8:	9c 81       	ldd	r25, Y+4	; 0x04
    36ca:	82 17       	cp	r24, r18
    36cc:	93 07       	cpc	r25, r19
    36ce:	50 f0       	brcs	.+20     	; 0x36e4 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    36d0:	ed 81       	ldd	r30, Y+5	; 0x05
    36d2:	fe 81       	ldd	r31, Y+6	; 0x06
    36d4:	24 81       	ldd	r18, Z+4	; 0x04
    36d6:	35 81       	ldd	r19, Z+5	; 0x05
    36d8:	8b 81       	ldd	r24, Y+3	; 0x03
    36da:	9c 81       	ldd	r25, Y+4	; 0x04
    36dc:	82 1b       	sub	r24, r18
    36de:	93 0b       	sbc	r25, r19
    36e0:	9c 83       	std	Y+4, r25	; 0x04
    36e2:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    36e4:	ed 81       	ldd	r30, Y+5	; 0x05
    36e6:	fe 81       	ldd	r31, Y+6	; 0x06
    36e8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ea:	9c 81       	ldd	r25, Y+4	; 0x04
    36ec:	93 83       	std	Z+3, r25	; 0x03
    36ee:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    36f0:	89 85       	ldd	r24, Y+9	; 0x09
    36f2:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    36f4:	2e 96       	adiw	r28, 0x0e	; 14
    36f6:	0f b6       	in	r0, 0x3f	; 63
    36f8:	f8 94       	cli
    36fa:	de bf       	out	0x3e, r29	; 62
    36fc:	0f be       	out	0x3f, r0	; 63
    36fe:	cd bf       	out	0x3d, r28	; 61
    3700:	cf 91       	pop	r28
    3702:	df 91       	pop	r29
    3704:	08 95       	ret

00003706 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3706:	df 93       	push	r29
    3708:	cf 93       	push	r28
    370a:	cd b7       	in	r28, 0x3d	; 61
    370c:	de b7       	in	r29, 0x3e	; 62
    370e:	66 97       	sbiw	r28, 0x16	; 22
    3710:	0f b6       	in	r0, 0x3f	; 63
    3712:	f8 94       	cli
    3714:	de bf       	out	0x3e, r29	; 62
    3716:	0f be       	out	0x3f, r0	; 63
    3718:	cd bf       	out	0x3d, r28	; 61
    371a:	98 87       	std	Y+8, r25	; 0x08
    371c:	8f 83       	std	Y+7, r24	; 0x07
    371e:	7a 87       	std	Y+10, r23	; 0x0a
    3720:	69 87       	std	Y+9, r22	; 0x09
    3722:	5c 87       	std	Y+12, r21	; 0x0c
    3724:	4b 87       	std	Y+11, r20	; 0x0b
    3726:	3e 87       	std	Y+14, r19	; 0x0e
    3728:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    372a:	2d 85       	ldd	r18, Y+13	; 0x0d
    372c:	3e 85       	ldd	r19, Y+14	; 0x0e
    372e:	3a 8b       	std	Y+18, r19	; 0x12
    3730:	29 8b       	std	Y+17, r18	; 0x11
    3732:	4b 85       	ldd	r20, Y+11	; 0x0b
    3734:	5c 85       	ldd	r21, Y+12	; 0x0c
    3736:	58 8b       	std	Y+16, r21	; 0x10
    3738:	4f 87       	std	Y+15, r20	; 0x0f
    373a:	8f 85       	ldd	r24, Y+15	; 0x0f
    373c:	98 89       	ldd	r25, Y+16	; 0x10
    373e:	29 89       	ldd	r18, Y+17	; 0x11
    3740:	3a 89       	ldd	r19, Y+18	; 0x12
    3742:	28 17       	cp	r18, r24
    3744:	39 07       	cpc	r19, r25
    3746:	20 f4       	brcc	.+8      	; 0x3750 <prvReadBytesFromBuffer+0x4a>
    3748:	49 89       	ldd	r20, Y+17	; 0x11
    374a:	5a 89       	ldd	r21, Y+18	; 0x12
    374c:	58 8b       	std	Y+16, r21	; 0x10
    374e:	4f 87       	std	Y+15, r20	; 0x0f
    3750:	8f 85       	ldd	r24, Y+15	; 0x0f
    3752:	98 89       	ldd	r25, Y+16	; 0x10
    3754:	9e 83       	std	Y+6, r25	; 0x06
    3756:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3758:	8d 81       	ldd	r24, Y+5	; 0x05
    375a:	9e 81       	ldd	r25, Y+6	; 0x06
    375c:	00 97       	sbiw	r24, 0x00	; 0
    375e:	09 f4       	brne	.+2      	; 0x3762 <prvReadBytesFromBuffer+0x5c>
    3760:	74 c0       	rjmp	.+232    	; 0x384a <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3762:	ef 81       	ldd	r30, Y+7	; 0x07
    3764:	f8 85       	ldd	r31, Y+8	; 0x08
    3766:	80 81       	ld	r24, Z
    3768:	91 81       	ldd	r25, Z+1	; 0x01
    376a:	9a 83       	std	Y+2, r25	; 0x02
    376c:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    376e:	ef 81       	ldd	r30, Y+7	; 0x07
    3770:	f8 85       	ldd	r31, Y+8	; 0x08
    3772:	24 81       	ldd	r18, Z+4	; 0x04
    3774:	35 81       	ldd	r19, Z+5	; 0x05
    3776:	89 81       	ldd	r24, Y+1	; 0x01
    3778:	9a 81       	ldd	r25, Y+2	; 0x02
    377a:	a9 01       	movw	r20, r18
    377c:	48 1b       	sub	r20, r24
    377e:	59 0b       	sbc	r21, r25
    3780:	ca 01       	movw	r24, r20
    3782:	2d 81       	ldd	r18, Y+5	; 0x05
    3784:	3e 81       	ldd	r19, Y+6	; 0x06
    3786:	3e 8b       	std	Y+22, r19	; 0x16
    3788:	2d 8b       	std	Y+21, r18	; 0x15
    378a:	9c 8b       	std	Y+20, r25	; 0x14
    378c:	8b 8b       	std	Y+19, r24	; 0x13
    378e:	4b 89       	ldd	r20, Y+19	; 0x13
    3790:	5c 89       	ldd	r21, Y+20	; 0x14
    3792:	8d 89       	ldd	r24, Y+21	; 0x15
    3794:	9e 89       	ldd	r25, Y+22	; 0x16
    3796:	84 17       	cp	r24, r20
    3798:	95 07       	cpc	r25, r21
    379a:	20 f4       	brcc	.+8      	; 0x37a4 <prvReadBytesFromBuffer+0x9e>
    379c:	2d 89       	ldd	r18, Y+21	; 0x15
    379e:	3e 89       	ldd	r19, Y+22	; 0x16
    37a0:	3c 8b       	std	Y+20, r19	; 0x14
    37a2:	2b 8b       	std	Y+19, r18	; 0x13
    37a4:	4b 89       	ldd	r20, Y+19	; 0x13
    37a6:	5c 89       	ldd	r21, Y+20	; 0x14
    37a8:	5c 83       	std	Y+4, r21	; 0x04
    37aa:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    37ac:	ef 81       	ldd	r30, Y+7	; 0x07
    37ae:	f8 85       	ldd	r31, Y+8	; 0x08
    37b0:	24 85       	ldd	r18, Z+12	; 0x0c
    37b2:	35 85       	ldd	r19, Z+13	; 0x0d
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
    37b6:	9a 81       	ldd	r25, Y+2	; 0x02
    37b8:	a9 01       	movw	r20, r18
    37ba:	48 0f       	add	r20, r24
    37bc:	59 1f       	adc	r21, r25
    37be:	89 85       	ldd	r24, Y+9	; 0x09
    37c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    37c2:	2b 81       	ldd	r18, Y+3	; 0x03
    37c4:	3c 81       	ldd	r19, Y+4	; 0x04
    37c6:	ba 01       	movw	r22, r20
    37c8:	a9 01       	movw	r20, r18
    37ca:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    37ce:	2d 81       	ldd	r18, Y+5	; 0x05
    37d0:	3e 81       	ldd	r19, Y+6	; 0x06
    37d2:	8b 81       	ldd	r24, Y+3	; 0x03
    37d4:	9c 81       	ldd	r25, Y+4	; 0x04
    37d6:	82 17       	cp	r24, r18
    37d8:	93 07       	cpc	r25, r19
    37da:	b0 f4       	brcc	.+44     	; 0x3808 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    37dc:	29 85       	ldd	r18, Y+9	; 0x09
    37de:	3a 85       	ldd	r19, Y+10	; 0x0a
    37e0:	8b 81       	ldd	r24, Y+3	; 0x03
    37e2:	9c 81       	ldd	r25, Y+4	; 0x04
    37e4:	b9 01       	movw	r22, r18
    37e6:	68 0f       	add	r22, r24
    37e8:	79 1f       	adc	r23, r25
    37ea:	ef 81       	ldd	r30, Y+7	; 0x07
    37ec:	f8 85       	ldd	r31, Y+8	; 0x08
    37ee:	44 85       	ldd	r20, Z+12	; 0x0c
    37f0:	55 85       	ldd	r21, Z+13	; 0x0d
    37f2:	2d 81       	ldd	r18, Y+5	; 0x05
    37f4:	3e 81       	ldd	r19, Y+6	; 0x06
    37f6:	8b 81       	ldd	r24, Y+3	; 0x03
    37f8:	9c 81       	ldd	r25, Y+4	; 0x04
    37fa:	28 1b       	sub	r18, r24
    37fc:	39 0b       	sbc	r19, r25
    37fe:	cb 01       	movw	r24, r22
    3800:	ba 01       	movw	r22, r20
    3802:	a9 01       	movw	r20, r18
    3804:	0e 94 bf 29 	call	0x537e	; 0x537e <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3808:	29 81       	ldd	r18, Y+1	; 0x01
    380a:	3a 81       	ldd	r19, Y+2	; 0x02
    380c:	8d 81       	ldd	r24, Y+5	; 0x05
    380e:	9e 81       	ldd	r25, Y+6	; 0x06
    3810:	82 0f       	add	r24, r18
    3812:	93 1f       	adc	r25, r19
    3814:	9a 83       	std	Y+2, r25	; 0x02
    3816:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3818:	ef 81       	ldd	r30, Y+7	; 0x07
    381a:	f8 85       	ldd	r31, Y+8	; 0x08
    381c:	24 81       	ldd	r18, Z+4	; 0x04
    381e:	35 81       	ldd	r19, Z+5	; 0x05
    3820:	89 81       	ldd	r24, Y+1	; 0x01
    3822:	9a 81       	ldd	r25, Y+2	; 0x02
    3824:	82 17       	cp	r24, r18
    3826:	93 07       	cpc	r25, r19
    3828:	50 f0       	brcs	.+20     	; 0x383e <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    382a:	ef 81       	ldd	r30, Y+7	; 0x07
    382c:	f8 85       	ldd	r31, Y+8	; 0x08
    382e:	24 81       	ldd	r18, Z+4	; 0x04
    3830:	35 81       	ldd	r19, Z+5	; 0x05
    3832:	89 81       	ldd	r24, Y+1	; 0x01
    3834:	9a 81       	ldd	r25, Y+2	; 0x02
    3836:	82 1b       	sub	r24, r18
    3838:	93 0b       	sbc	r25, r19
    383a:	9a 83       	std	Y+2, r25	; 0x02
    383c:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    383e:	ef 81       	ldd	r30, Y+7	; 0x07
    3840:	f8 85       	ldd	r31, Y+8	; 0x08
    3842:	89 81       	ldd	r24, Y+1	; 0x01
    3844:	9a 81       	ldd	r25, Y+2	; 0x02
    3846:	91 83       	std	Z+1, r25	; 0x01
    3848:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    384a:	8d 81       	ldd	r24, Y+5	; 0x05
    384c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    384e:	66 96       	adiw	r28, 0x16	; 22
    3850:	0f b6       	in	r0, 0x3f	; 63
    3852:	f8 94       	cli
    3854:	de bf       	out	0x3e, r29	; 62
    3856:	0f be       	out	0x3f, r0	; 63
    3858:	cd bf       	out	0x3d, r28	; 61
    385a:	cf 91       	pop	r28
    385c:	df 91       	pop	r29
    385e:	08 95       	ret

00003860 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3860:	df 93       	push	r29
    3862:	cf 93       	push	r28
    3864:	00 d0       	rcall	.+0      	; 0x3866 <prvBytesInBuffer+0x6>
    3866:	00 d0       	rcall	.+0      	; 0x3868 <prvBytesInBuffer+0x8>
    3868:	cd b7       	in	r28, 0x3d	; 61
    386a:	de b7       	in	r29, 0x3e	; 62
    386c:	9c 83       	std	Y+4, r25	; 0x04
    386e:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3870:	eb 81       	ldd	r30, Y+3	; 0x03
    3872:	fc 81       	ldd	r31, Y+4	; 0x04
    3874:	24 81       	ldd	r18, Z+4	; 0x04
    3876:	35 81       	ldd	r19, Z+5	; 0x05
    3878:	eb 81       	ldd	r30, Y+3	; 0x03
    387a:	fc 81       	ldd	r31, Y+4	; 0x04
    387c:	82 81       	ldd	r24, Z+2	; 0x02
    387e:	93 81       	ldd	r25, Z+3	; 0x03
    3880:	82 0f       	add	r24, r18
    3882:	93 1f       	adc	r25, r19
    3884:	9a 83       	std	Y+2, r25	; 0x02
    3886:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3888:	eb 81       	ldd	r30, Y+3	; 0x03
    388a:	fc 81       	ldd	r31, Y+4	; 0x04
    388c:	20 81       	ld	r18, Z
    388e:	31 81       	ldd	r19, Z+1	; 0x01
    3890:	89 81       	ldd	r24, Y+1	; 0x01
    3892:	9a 81       	ldd	r25, Y+2	; 0x02
    3894:	82 1b       	sub	r24, r18
    3896:	93 0b       	sbc	r25, r19
    3898:	9a 83       	std	Y+2, r25	; 0x02
    389a:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    389c:	eb 81       	ldd	r30, Y+3	; 0x03
    389e:	fc 81       	ldd	r31, Y+4	; 0x04
    38a0:	24 81       	ldd	r18, Z+4	; 0x04
    38a2:	35 81       	ldd	r19, Z+5	; 0x05
    38a4:	89 81       	ldd	r24, Y+1	; 0x01
    38a6:	9a 81       	ldd	r25, Y+2	; 0x02
    38a8:	82 17       	cp	r24, r18
    38aa:	93 07       	cpc	r25, r19
    38ac:	50 f0       	brcs	.+20     	; 0x38c2 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    38ae:	eb 81       	ldd	r30, Y+3	; 0x03
    38b0:	fc 81       	ldd	r31, Y+4	; 0x04
    38b2:	24 81       	ldd	r18, Z+4	; 0x04
    38b4:	35 81       	ldd	r19, Z+5	; 0x05
    38b6:	89 81       	ldd	r24, Y+1	; 0x01
    38b8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ba:	82 1b       	sub	r24, r18
    38bc:	93 0b       	sbc	r25, r19
    38be:	9a 83       	std	Y+2, r25	; 0x02
    38c0:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    38c2:	89 81       	ldd	r24, Y+1	; 0x01
    38c4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38c6:	0f 90       	pop	r0
    38c8:	0f 90       	pop	r0
    38ca:	0f 90       	pop	r0
    38cc:	0f 90       	pop	r0
    38ce:	cf 91       	pop	r28
    38d0:	df 91       	pop	r29
    38d2:	08 95       	ret

000038d4 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    38d4:	0f 93       	push	r16
    38d6:	df 93       	push	r29
    38d8:	cf 93       	push	r28
    38da:	cd b7       	in	r28, 0x3d	; 61
    38dc:	de b7       	in	r29, 0x3e	; 62
    38de:	29 97       	sbiw	r28, 0x09	; 9
    38e0:	0f b6       	in	r0, 0x3f	; 63
    38e2:	f8 94       	cli
    38e4:	de bf       	out	0x3e, r29	; 62
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	cd bf       	out	0x3d, r28	; 61
    38ea:	9a 83       	std	Y+2, r25	; 0x02
    38ec:	89 83       	std	Y+1, r24	; 0x01
    38ee:	7c 83       	std	Y+4, r23	; 0x04
    38f0:	6b 83       	std	Y+3, r22	; 0x03
    38f2:	5e 83       	std	Y+6, r21	; 0x06
    38f4:	4d 83       	std	Y+5, r20	; 0x05
    38f6:	38 87       	std	Y+8, r19	; 0x08
    38f8:	2f 83       	std	Y+7, r18	; 0x07
    38fa:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    38fc:	89 81       	ldd	r24, Y+1	; 0x01
    38fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3900:	60 e0       	ldi	r22, 0x00	; 0
    3902:	70 e0       	ldi	r23, 0x00	; 0
    3904:	4f e0       	ldi	r20, 0x0F	; 15
    3906:	50 e0       	ldi	r21, 0x00	; 0
    3908:	0e 94 c8 29 	call	0x5390	; 0x5390 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    390c:	e9 81       	ldd	r30, Y+1	; 0x01
    390e:	fa 81       	ldd	r31, Y+2	; 0x02
    3910:	8b 81       	ldd	r24, Y+3	; 0x03
    3912:	9c 81       	ldd	r25, Y+4	; 0x04
    3914:	95 87       	std	Z+13, r25	; 0x0d
    3916:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3918:	e9 81       	ldd	r30, Y+1	; 0x01
    391a:	fa 81       	ldd	r31, Y+2	; 0x02
    391c:	8d 81       	ldd	r24, Y+5	; 0x05
    391e:	9e 81       	ldd	r25, Y+6	; 0x06
    3920:	95 83       	std	Z+5, r25	; 0x05
    3922:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3924:	e9 81       	ldd	r30, Y+1	; 0x01
    3926:	fa 81       	ldd	r31, Y+2	; 0x02
    3928:	8f 81       	ldd	r24, Y+7	; 0x07
    392a:	98 85       	ldd	r25, Y+8	; 0x08
    392c:	97 83       	std	Z+7, r25	; 0x07
    392e:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3930:	e9 81       	ldd	r30, Y+1	; 0x01
    3932:	fa 81       	ldd	r31, Y+2	; 0x02
    3934:	89 85       	ldd	r24, Y+9	; 0x09
    3936:	86 87       	std	Z+14, r24	; 0x0e
}
    3938:	29 96       	adiw	r28, 0x09	; 9
    393a:	0f b6       	in	r0, 0x3f	; 63
    393c:	f8 94       	cli
    393e:	de bf       	out	0x3e, r29	; 62
    3940:	0f be       	out	0x3f, r0	; 63
    3942:	cd bf       	out	0x3d, r28	; 61
    3944:	cf 91       	pop	r28
    3946:	df 91       	pop	r29
    3948:	0f 91       	pop	r16
    394a:	08 95       	ret

0000394c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    394c:	8f 92       	push	r8
    394e:	9f 92       	push	r9
    3950:	af 92       	push	r10
    3952:	bf 92       	push	r11
    3954:	cf 92       	push	r12
    3956:	df 92       	push	r13
    3958:	ef 92       	push	r14
    395a:	ff 92       	push	r15
    395c:	0f 93       	push	r16
    395e:	1f 93       	push	r17
    3960:	df 93       	push	r29
    3962:	cf 93       	push	r28
    3964:	cd b7       	in	r28, 0x3d	; 61
    3966:	de b7       	in	r29, 0x3e	; 62
    3968:	60 97       	sbiw	r28, 0x10	; 16
    396a:	0f b6       	in	r0, 0x3f	; 63
    396c:	f8 94       	cli
    396e:	de bf       	out	0x3e, r29	; 62
    3970:	0f be       	out	0x3f, r0	; 63
    3972:	cd bf       	out	0x3d, r28	; 61
    3974:	9f 83       	std	Y+7, r25	; 0x07
    3976:	8e 83       	std	Y+6, r24	; 0x06
    3978:	79 87       	std	Y+9, r23	; 0x09
    397a:	68 87       	std	Y+8, r22	; 0x08
    397c:	5b 87       	std	Y+11, r21	; 0x0b
    397e:	4a 87       	std	Y+10, r20	; 0x0a
    3980:	3d 87       	std	Y+13, r19	; 0x0d
    3982:	2c 87       	std	Y+12, r18	; 0x0c
    3984:	0e 87       	std	Y+14, r16	; 0x0e
    3986:	f8 8a       	std	Y+16, r15	; 0x10
    3988:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    398a:	8a 85       	ldd	r24, Y+10	; 0x0a
    398c:	9b 85       	ldd	r25, Y+11	; 0x0b
    398e:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    3992:	9a 83       	std	Y+2, r25	; 0x02
    3994:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3996:	89 81       	ldd	r24, Y+1	; 0x01
    3998:	9a 81       	ldd	r25, Y+2	; 0x02
    399a:	00 97       	sbiw	r24, 0x00	; 0
    399c:	b1 f0       	breq	.+44     	; 0x39ca <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    399e:	86 e2       	ldi	r24, 0x26	; 38
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    39a6:	9d 83       	std	Y+5, r25	; 0x05
    39a8:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    39aa:	8c 81       	ldd	r24, Y+4	; 0x04
    39ac:	9d 81       	ldd	r25, Y+5	; 0x05
    39ae:	00 97       	sbiw	r24, 0x00	; 0
    39b0:	39 f0       	breq	.+14     	; 0x39c0 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    39b2:	ec 81       	ldd	r30, Y+4	; 0x04
    39b4:	fd 81       	ldd	r31, Y+5	; 0x05
    39b6:	89 81       	ldd	r24, Y+1	; 0x01
    39b8:	9a 81       	ldd	r25, Y+2	; 0x02
    39ba:	90 8f       	std	Z+24, r25	; 0x18
    39bc:	87 8b       	std	Z+23, r24	; 0x17
    39be:	07 c0       	rjmp	.+14     	; 0x39ce <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    39c0:	89 81       	ldd	r24, Y+1	; 0x01
    39c2:	9a 81       	ldd	r25, Y+2	; 0x02
    39c4:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
    39c8:	02 c0       	rjmp	.+4      	; 0x39ce <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    39ca:	1d 82       	std	Y+5, r1	; 0x05
    39cc:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    39ce:	8c 81       	ldd	r24, Y+4	; 0x04
    39d0:	9d 81       	ldd	r25, Y+5	; 0x05
    39d2:	00 97       	sbiw	r24, 0x00	; 0
    39d4:	e9 f0       	breq	.+58     	; 0x3a10 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    39d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    39d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    39da:	9c 01       	movw	r18, r24
    39dc:	40 e0       	ldi	r20, 0x00	; 0
    39de:	50 e0       	ldi	r21, 0x00	; 0
    39e0:	8e 81       	ldd	r24, Y+6	; 0x06
    39e2:	9f 81       	ldd	r25, Y+7	; 0x07
    39e4:	68 85       	ldd	r22, Y+8	; 0x08
    39e6:	79 85       	ldd	r23, Y+9	; 0x09
    39e8:	ec 85       	ldd	r30, Y+12	; 0x0c
    39ea:	fd 85       	ldd	r31, Y+13	; 0x0d
    39ec:	af 85       	ldd	r26, Y+15	; 0x0f
    39ee:	b8 89       	ldd	r27, Y+16	; 0x10
    39f0:	ac 80       	ldd	r10, Y+4	; 0x04
    39f2:	bd 80       	ldd	r11, Y+5	; 0x05
    39f4:	8f 01       	movw	r16, r30
    39f6:	ee 84       	ldd	r14, Y+14	; 0x0e
    39f8:	6d 01       	movw	r12, r26
    39fa:	88 24       	eor	r8, r8
    39fc:	99 24       	eor	r9, r9
    39fe:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3a02:	8c 81       	ldd	r24, Y+4	; 0x04
    3a04:	9d 81       	ldd	r25, Y+5	; 0x05
    3a06:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3a0a:	81 e0       	ldi	r24, 0x01	; 1
    3a0c:	8b 83       	std	Y+3, r24	; 0x03
    3a0e:	02 c0       	rjmp	.+4      	; 0x3a14 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3a10:	8f ef       	ldi	r24, 0xFF	; 255
    3a12:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3a14:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3a16:	60 96       	adiw	r28, 0x10	; 16
    3a18:	0f b6       	in	r0, 0x3f	; 63
    3a1a:	f8 94       	cli
    3a1c:	de bf       	out	0x3e, r29	; 62
    3a1e:	0f be       	out	0x3f, r0	; 63
    3a20:	cd bf       	out	0x3d, r28	; 61
    3a22:	cf 91       	pop	r28
    3a24:	df 91       	pop	r29
    3a26:	1f 91       	pop	r17
    3a28:	0f 91       	pop	r16
    3a2a:	ff 90       	pop	r15
    3a2c:	ef 90       	pop	r14
    3a2e:	df 90       	pop	r13
    3a30:	cf 90       	pop	r12
    3a32:	bf 90       	pop	r11
    3a34:	af 90       	pop	r10
    3a36:	9f 90       	pop	r9
    3a38:	8f 90       	pop	r8
    3a3a:	08 95       	ret

00003a3c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3a3c:	8f 92       	push	r8
    3a3e:	9f 92       	push	r9
    3a40:	af 92       	push	r10
    3a42:	bf 92       	push	r11
    3a44:	cf 92       	push	r12
    3a46:	df 92       	push	r13
    3a48:	ef 92       	push	r14
    3a4a:	0f 93       	push	r16
    3a4c:	1f 93       	push	r17
    3a4e:	df 93       	push	r29
    3a50:	cf 93       	push	r28
    3a52:	cd b7       	in	r28, 0x3d	; 61
    3a54:	de b7       	in	r29, 0x3e	; 62
    3a56:	64 97       	sbiw	r28, 0x14	; 20
    3a58:	0f b6       	in	r0, 0x3f	; 63
    3a5a:	f8 94       	cli
    3a5c:	de bf       	out	0x3e, r29	; 62
    3a5e:	0f be       	out	0x3f, r0	; 63
    3a60:	cd bf       	out	0x3d, r28	; 61
    3a62:	9d 83       	std	Y+5, r25	; 0x05
    3a64:	8c 83       	std	Y+4, r24	; 0x04
    3a66:	7f 83       	std	Y+7, r23	; 0x07
    3a68:	6e 83       	std	Y+6, r22	; 0x06
    3a6a:	28 87       	std	Y+8, r18	; 0x08
    3a6c:	39 87       	std	Y+9, r19	; 0x09
    3a6e:	4a 87       	std	Y+10, r20	; 0x0a
    3a70:	5b 87       	std	Y+11, r21	; 0x0b
    3a72:	1d 87       	std	Y+13, r17	; 0x0d
    3a74:	0c 87       	std	Y+12, r16	; 0x0c
    3a76:	ee 86       	std	Y+14, r14	; 0x0e
    3a78:	d8 8a       	std	Y+16, r13	; 0x10
    3a7a:	cf 86       	std	Y+15, r12	; 0x0f
    3a7c:	ba 8a       	std	Y+18, r11	; 0x12
    3a7e:	a9 8a       	std	Y+17, r10	; 0x11
    3a80:	9c 8a       	std	Y+20, r9	; 0x14
    3a82:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3a84:	e9 89       	ldd	r30, Y+17	; 0x11
    3a86:	fa 89       	ldd	r31, Y+18	; 0x12
    3a88:	27 89       	ldd	r18, Z+23	; 0x17
    3a8a:	30 8d       	ldd	r19, Z+24	; 0x18
    3a8c:	88 85       	ldd	r24, Y+8	; 0x08
    3a8e:	99 85       	ldd	r25, Y+9	; 0x09
    3a90:	01 97       	sbiw	r24, 0x01	; 1
    3a92:	82 0f       	add	r24, r18
    3a94:	93 1f       	adc	r25, r19
    3a96:	9b 83       	std	Y+3, r25	; 0x03
    3a98:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3a9a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a9c:	9f 81       	ldd	r25, Y+7	; 0x07
    3a9e:	00 97       	sbiw	r24, 0x00	; 0
    3aa0:	51 f1       	breq	.+84     	; 0x3af6 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3aa2:	19 82       	std	Y+1, r1	; 0x01
    3aa4:	21 c0       	rjmp	.+66     	; 0x3ae8 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
    3aa8:	48 2f       	mov	r20, r24
    3aaa:	50 e0       	ldi	r21, 0x00	; 0
    3aac:	89 81       	ldd	r24, Y+1	; 0x01
    3aae:	28 2f       	mov	r18, r24
    3ab0:	30 e0       	ldi	r19, 0x00	; 0
    3ab2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	e2 0f       	add	r30, r18
    3aba:	f3 1f       	adc	r31, r19
    3abc:	20 81       	ld	r18, Z
    3abe:	89 89       	ldd	r24, Y+17	; 0x11
    3ac0:	9a 89       	ldd	r25, Y+18	; 0x12
    3ac2:	84 0f       	add	r24, r20
    3ac4:	95 1f       	adc	r25, r21
    3ac6:	fc 01       	movw	r30, r24
    3ac8:	79 96       	adiw	r30, 0x19	; 25
    3aca:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3acc:	89 81       	ldd	r24, Y+1	; 0x01
    3ace:	28 2f       	mov	r18, r24
    3ad0:	30 e0       	ldi	r19, 0x00	; 0
    3ad2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ad4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ad6:	fc 01       	movw	r30, r24
    3ad8:	e2 0f       	add	r30, r18
    3ada:	f3 1f       	adc	r31, r19
    3adc:	80 81       	ld	r24, Z
    3ade:	88 23       	and	r24, r24
    3ae0:	31 f0       	breq	.+12     	; 0x3aee <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3ae2:	89 81       	ldd	r24, Y+1	; 0x01
    3ae4:	8f 5f       	subi	r24, 0xFF	; 255
    3ae6:	89 83       	std	Y+1, r24	; 0x01
    3ae8:	89 81       	ldd	r24, Y+1	; 0x01
    3aea:	88 30       	cpi	r24, 0x08	; 8
    3aec:	e0 f2       	brcs	.-72     	; 0x3aa6 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3aee:	e9 89       	ldd	r30, Y+17	; 0x11
    3af0:	fa 89       	ldd	r31, Y+18	; 0x12
    3af2:	10 a2       	std	Z+32, r1	; 0x20
    3af4:	03 c0       	rjmp	.+6      	; 0x3afc <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3af6:	e9 89       	ldd	r30, Y+17	; 0x11
    3af8:	fa 89       	ldd	r31, Y+18	; 0x12
    3afa:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3afc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3afe:	85 30       	cpi	r24, 0x05	; 5
    3b00:	10 f0       	brcs	.+4      	; 0x3b06 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3b02:	84 e0       	ldi	r24, 0x04	; 4
    3b04:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3b06:	e9 89       	ldd	r30, Y+17	; 0x11
    3b08:	fa 89       	ldd	r31, Y+18	; 0x12
    3b0a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b0c:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3b0e:	89 89       	ldd	r24, Y+17	; 0x11
    3b10:	9a 89       	ldd	r25, Y+18	; 0x12
    3b12:	02 96       	adiw	r24, 0x02	; 2
    3b14:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3b18:	89 89       	ldd	r24, Y+17	; 0x11
    3b1a:	9a 89       	ldd	r25, Y+18	; 0x12
    3b1c:	0c 96       	adiw	r24, 0x0c	; 12
    3b1e:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3b22:	e9 89       	ldd	r30, Y+17	; 0x11
    3b24:	fa 89       	ldd	r31, Y+18	; 0x12
    3b26:	89 89       	ldd	r24, Y+17	; 0x11
    3b28:	9a 89       	ldd	r25, Y+18	; 0x12
    3b2a:	91 87       	std	Z+9, r25	; 0x09
    3b2c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b30:	28 2f       	mov	r18, r24
    3b32:	30 e0       	ldi	r19, 0x00	; 0
    3b34:	85 e0       	ldi	r24, 0x05	; 5
    3b36:	90 e0       	ldi	r25, 0x00	; 0
    3b38:	82 1b       	sub	r24, r18
    3b3a:	93 0b       	sbc	r25, r19
    3b3c:	e9 89       	ldd	r30, Y+17	; 0x11
    3b3e:	fa 89       	ldd	r31, Y+18	; 0x12
    3b40:	95 87       	std	Z+13, r25	; 0x0d
    3b42:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3b44:	e9 89       	ldd	r30, Y+17	; 0x11
    3b46:	fa 89       	ldd	r31, Y+18	; 0x12
    3b48:	89 89       	ldd	r24, Y+17	; 0x11
    3b4a:	9a 89       	ldd	r25, Y+18	; 0x12
    3b4c:	93 8b       	std	Z+19, r25	; 0x13
    3b4e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3b50:	e9 89       	ldd	r30, Y+17	; 0x11
    3b52:	fa 89       	ldd	r31, Y+18	; 0x12
    3b54:	11 a2       	std	Z+33, r1	; 0x21
    3b56:	12 a2       	std	Z+34, r1	; 0x22
    3b58:	13 a2       	std	Z+35, r1	; 0x23
    3b5a:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3b5c:	e9 89       	ldd	r30, Y+17	; 0x11
    3b5e:	fa 89       	ldd	r31, Y+18	; 0x12
    3b60:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3b62:	8a 81       	ldd	r24, Y+2	; 0x02
    3b64:	9b 81       	ldd	r25, Y+3	; 0x03
    3b66:	2c 81       	ldd	r18, Y+4	; 0x04
    3b68:	3d 81       	ldd	r19, Y+5	; 0x05
    3b6a:	4c 85       	ldd	r20, Y+12	; 0x0c
    3b6c:	5d 85       	ldd	r21, Y+13	; 0x0d
    3b6e:	b9 01       	movw	r22, r18
    3b70:	0e 94 1c 0b 	call	0x1638	; 0x1638 <pxPortInitialiseStack>
    3b74:	e9 89       	ldd	r30, Y+17	; 0x11
    3b76:	fa 89       	ldd	r31, Y+18	; 0x12
    3b78:	91 83       	std	Z+1, r25	; 0x01
    3b7a:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3b7c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b7e:	98 89       	ldd	r25, Y+16	; 0x10
    3b80:	00 97       	sbiw	r24, 0x00	; 0
    3b82:	31 f0       	breq	.+12     	; 0x3b90 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3b84:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b86:	f8 89       	ldd	r31, Y+16	; 0x10
    3b88:	89 89       	ldd	r24, Y+17	; 0x11
    3b8a:	9a 89       	ldd	r25, Y+18	; 0x12
    3b8c:	91 83       	std	Z+1, r25	; 0x01
    3b8e:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3b90:	64 96       	adiw	r28, 0x14	; 20
    3b92:	0f b6       	in	r0, 0x3f	; 63
    3b94:	f8 94       	cli
    3b96:	de bf       	out	0x3e, r29	; 62
    3b98:	0f be       	out	0x3f, r0	; 63
    3b9a:	cd bf       	out	0x3d, r28	; 61
    3b9c:	cf 91       	pop	r28
    3b9e:	df 91       	pop	r29
    3ba0:	1f 91       	pop	r17
    3ba2:	0f 91       	pop	r16
    3ba4:	ef 90       	pop	r14
    3ba6:	df 90       	pop	r13
    3ba8:	cf 90       	pop	r12
    3baa:	bf 90       	pop	r11
    3bac:	af 90       	pop	r10
    3bae:	9f 90       	pop	r9
    3bb0:	8f 90       	pop	r8
    3bb2:	08 95       	ret

00003bb4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3bb4:	df 93       	push	r29
    3bb6:	cf 93       	push	r28
    3bb8:	00 d0       	rcall	.+0      	; 0x3bba <prvAddNewTaskToReadyList+0x6>
    3bba:	cd b7       	in	r28, 0x3d	; 61
    3bbc:	de b7       	in	r29, 0x3e	; 62
    3bbe:	9a 83       	std	Y+2, r25	; 0x02
    3bc0:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3bc2:	0f b6       	in	r0, 0x3f	; 63
    3bc4:	f8 94       	cli
    3bc6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3bc8:	80 91 ab 06 	lds	r24, 0x06AB
    3bcc:	8f 5f       	subi	r24, 0xFF	; 255
    3bce:	80 93 ab 06 	sts	0x06AB, r24
		if( pxCurrentTCB == NULL )
    3bd2:	80 91 a8 06 	lds	r24, 0x06A8
    3bd6:	90 91 a9 06 	lds	r25, 0x06A9
    3bda:	00 97       	sbiw	r24, 0x00	; 0
    3bdc:	69 f4       	brne	.+26     	; 0x3bf8 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3bde:	89 81       	ldd	r24, Y+1	; 0x01
    3be0:	9a 81       	ldd	r25, Y+2	; 0x02
    3be2:	90 93 a9 06 	sts	0x06A9, r25
    3be6:	80 93 a8 06 	sts	0x06A8, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3bea:	80 91 ab 06 	lds	r24, 0x06AB
    3bee:	81 30       	cpi	r24, 0x01	; 1
    3bf0:	b9 f4       	brne	.+46     	; 0x3c20 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3bf2:	0e 94 b1 24 	call	0x4962	; 0x4962 <prvInitialiseTaskLists>
    3bf6:	14 c0       	rjmp	.+40     	; 0x3c20 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3bf8:	80 91 af 06 	lds	r24, 0x06AF
    3bfc:	88 23       	and	r24, r24
    3bfe:	81 f4       	brne	.+32     	; 0x3c20 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3c00:	e0 91 a8 06 	lds	r30, 0x06A8
    3c04:	f0 91 a9 06 	lds	r31, 0x06A9
    3c08:	96 89       	ldd	r25, Z+22	; 0x16
    3c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c0e:	86 89       	ldd	r24, Z+22	; 0x16
    3c10:	89 17       	cp	r24, r25
    3c12:	30 f0       	brcs	.+12     	; 0x3c20 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	90 93 a9 06 	sts	0x06A9, r25
    3c1c:	80 93 a8 06 	sts	0x06A8, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3c20:	80 91 b3 06 	lds	r24, 0x06B3
    3c24:	8f 5f       	subi	r24, 0xFF	; 255
    3c26:	80 93 b3 06 	sts	0x06B3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c2e:	96 89       	ldd	r25, Z+22	; 0x16
    3c30:	80 91 ae 06 	lds	r24, 0x06AE
    3c34:	89 17       	cp	r24, r25
    3c36:	28 f4       	brcc	.+10     	; 0x3c42 <prvAddNewTaskToReadyList+0x8e>
    3c38:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3c:	86 89       	ldd	r24, Z+22	; 0x16
    3c3e:	80 93 ae 06 	sts	0x06AE, r24
    3c42:	e9 81       	ldd	r30, Y+1	; 0x01
    3c44:	fa 81       	ldd	r31, Y+2	; 0x02
    3c46:	86 89       	ldd	r24, Z+22	; 0x16
    3c48:	28 2f       	mov	r18, r24
    3c4a:	30 e0       	ldi	r19, 0x00	; 0
    3c4c:	c9 01       	movw	r24, r18
    3c4e:	88 0f       	add	r24, r24
    3c50:	99 1f       	adc	r25, r25
    3c52:	88 0f       	add	r24, r24
    3c54:	99 1f       	adc	r25, r25
    3c56:	88 0f       	add	r24, r24
    3c58:	99 1f       	adc	r25, r25
    3c5a:	82 0f       	add	r24, r18
    3c5c:	93 1f       	adc	r25, r19
    3c5e:	ac 01       	movw	r20, r24
    3c60:	47 54       	subi	r20, 0x47	; 71
    3c62:	59 4f       	sbci	r21, 0xF9	; 249
    3c64:	89 81       	ldd	r24, Y+1	; 0x01
    3c66:	9a 81       	ldd	r25, Y+2	; 0x02
    3c68:	9c 01       	movw	r18, r24
    3c6a:	2e 5f       	subi	r18, 0xFE	; 254
    3c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c6e:	ca 01       	movw	r24, r20
    3c70:	b9 01       	movw	r22, r18
    3c72:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3c76:	0f 90       	pop	r0
    3c78:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3c7a:	80 91 af 06 	lds	r24, 0x06AF
    3c7e:	88 23       	and	r24, r24
    3c80:	61 f0       	breq	.+24     	; 0x3c9a <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3c82:	e0 91 a8 06 	lds	r30, 0x06A8
    3c86:	f0 91 a9 06 	lds	r31, 0x06A9
    3c8a:	96 89       	ldd	r25, Z+22	; 0x16
    3c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c90:	86 89       	ldd	r24, Z+22	; 0x16
    3c92:	98 17       	cp	r25, r24
    3c94:	10 f4       	brcc	.+4      	; 0x3c9a <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3c96:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3c9a:	0f 90       	pop	r0
    3c9c:	0f 90       	pop	r0
    3c9e:	cf 91       	pop	r28
    3ca0:	df 91       	pop	r29
    3ca2:	08 95       	ret

00003ca4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3ca4:	df 93       	push	r29
    3ca6:	cf 93       	push	r28
    3ca8:	00 d0       	rcall	.+0      	; 0x3caa <vTaskDelete+0x6>
    3caa:	00 d0       	rcall	.+0      	; 0x3cac <vTaskDelete+0x8>
    3cac:	00 d0       	rcall	.+0      	; 0x3cae <vTaskDelete+0xa>
    3cae:	cd b7       	in	r28, 0x3d	; 61
    3cb0:	de b7       	in	r29, 0x3e	; 62
    3cb2:	9c 83       	std	Y+4, r25	; 0x04
    3cb4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3cb6:	0f b6       	in	r0, 0x3f	; 63
    3cb8:	f8 94       	cli
    3cba:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc0:	00 97       	sbiw	r24, 0x00	; 0
    3cc2:	39 f4       	brne	.+14     	; 0x3cd2 <vTaskDelete+0x2e>
    3cc4:	80 91 a8 06 	lds	r24, 0x06A8
    3cc8:	90 91 a9 06 	lds	r25, 0x06A9
    3ccc:	9e 83       	std	Y+6, r25	; 0x06
    3cce:	8d 83       	std	Y+5, r24	; 0x05
    3cd0:	04 c0       	rjmp	.+8      	; 0x3cda <vTaskDelete+0x36>
    3cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3cd6:	9e 83       	std	Y+6, r25	; 0x06
    3cd8:	8d 83       	std	Y+5, r24	; 0x05
    3cda:	8d 81       	ldd	r24, Y+5	; 0x05
    3cdc:	9e 81       	ldd	r25, Y+6	; 0x06
    3cde:	9a 83       	std	Y+2, r25	; 0x02
    3ce0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3ce2:	89 81       	ldd	r24, Y+1	; 0x01
    3ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce6:	02 96       	adiw	r24, 0x02	; 2
    3ce8:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3cec:	e9 81       	ldd	r30, Y+1	; 0x01
    3cee:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf0:	84 89       	ldd	r24, Z+20	; 0x14
    3cf2:	95 89       	ldd	r25, Z+21	; 0x15
    3cf4:	00 97       	sbiw	r24, 0x00	; 0
    3cf6:	29 f0       	breq	.+10     	; 0x3d02 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3cf8:	89 81       	ldd	r24, Y+1	; 0x01
    3cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3cfc:	0c 96       	adiw	r24, 0x0c	; 12
    3cfe:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3d02:	80 91 b3 06 	lds	r24, 0x06B3
    3d06:	8f 5f       	subi	r24, 0xFF	; 255
    3d08:	80 93 b3 06 	sts	0x06B3, r24

			if( pxTCB == pxCurrentTCB )
    3d0c:	20 91 a8 06 	lds	r18, 0x06A8
    3d10:	30 91 a9 06 	lds	r19, 0x06A9
    3d14:	89 81       	ldd	r24, Y+1	; 0x01
    3d16:	9a 81       	ldd	r25, Y+2	; 0x02
    3d18:	82 17       	cp	r24, r18
    3d1a:	93 07       	cpc	r25, r19
    3d1c:	81 f4       	brne	.+32     	; 0x3d3e <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3d1e:	89 81       	ldd	r24, Y+1	; 0x01
    3d20:	9a 81       	ldd	r25, Y+2	; 0x02
    3d22:	9c 01       	movw	r18, r24
    3d24:	2e 5f       	subi	r18, 0xFE	; 254
    3d26:	3f 4f       	sbci	r19, 0xFF	; 255
    3d28:	85 e0       	ldi	r24, 0x05	; 5
    3d2a:	97 e0       	ldi	r25, 0x07	; 7
    3d2c:	b9 01       	movw	r22, r18
    3d2e:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3d32:	80 91 aa 06 	lds	r24, 0x06AA
    3d36:	8f 5f       	subi	r24, 0xFF	; 255
    3d38:	80 93 aa 06 	sts	0x06AA, r24
    3d3c:	0b c0       	rjmp	.+22     	; 0x3d54 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3d3e:	80 91 ab 06 	lds	r24, 0x06AB
    3d42:	81 50       	subi	r24, 0x01	; 1
    3d44:	80 93 ab 06 	sts	0x06AB, r24
				prvDeleteTCB( pxTCB );
    3d48:	89 81       	ldd	r24, Y+1	; 0x01
    3d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4c:	0e 94 21 25 	call	0x4a42	; 0x4a42 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3d50:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3d54:	0f 90       	pop	r0
    3d56:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3d58:	80 91 af 06 	lds	r24, 0x06AF
    3d5c:	88 23       	and	r24, r24
    3d5e:	59 f0       	breq	.+22     	; 0x3d76 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3d60:	20 91 a8 06 	lds	r18, 0x06A8
    3d64:	30 91 a9 06 	lds	r19, 0x06A9
    3d68:	89 81       	ldd	r24, Y+1	; 0x01
    3d6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d6c:	82 17       	cp	r24, r18
    3d6e:	93 07       	cpc	r25, r19
    3d70:	11 f4       	brne	.+4      	; 0x3d76 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3d72:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3d76:	26 96       	adiw	r28, 0x06	; 6
    3d78:	0f b6       	in	r0, 0x3f	; 63
    3d7a:	f8 94       	cli
    3d7c:	de bf       	out	0x3e, r29	; 62
    3d7e:	0f be       	out	0x3f, r0	; 63
    3d80:	cd bf       	out	0x3d, r28	; 61
    3d82:	cf 91       	pop	r28
    3d84:	df 91       	pop	r29
    3d86:	08 95       	ret

00003d88 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3d88:	df 93       	push	r29
    3d8a:	cf 93       	push	r28
    3d8c:	00 d0       	rcall	.+0      	; 0x3d8e <vTaskDelay+0x6>
    3d8e:	0f 92       	push	r0
    3d90:	cd b7       	in	r28, 0x3d	; 61
    3d92:	de b7       	in	r29, 0x3e	; 62
    3d94:	9b 83       	std	Y+3, r25	; 0x03
    3d96:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3d98:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d9e:	00 97       	sbiw	r24, 0x00	; 0
    3da0:	51 f0       	breq	.+20     	; 0x3db6 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3da2:	0e 94 91 20 	call	0x4122	; 0x4122 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3da6:	8a 81       	ldd	r24, Y+2	; 0x02
    3da8:	9b 81       	ldd	r25, Y+3	; 0x03
    3daa:	60 e0       	ldi	r22, 0x00	; 0
    3dac:	0e 94 43 29 	call	0x5286	; 0x5286 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3db0:	0e 94 9d 20 	call	0x413a	; 0x413a <xTaskResumeAll>
    3db4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3db6:	89 81       	ldd	r24, Y+1	; 0x01
    3db8:	88 23       	and	r24, r24
    3dba:	11 f4       	brne	.+4      	; 0x3dc0 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3dbc:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3dc0:	0f 90       	pop	r0
    3dc2:	0f 90       	pop	r0
    3dc4:	0f 90       	pop	r0
    3dc6:	cf 91       	pop	r28
    3dc8:	df 91       	pop	r29
    3dca:	08 95       	ret

00003dcc <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3dcc:	df 93       	push	r29
    3dce:	cf 93       	push	r28
    3dd0:	00 d0       	rcall	.+0      	; 0x3dd2 <vTaskSuspend+0x6>
    3dd2:	00 d0       	rcall	.+0      	; 0x3dd4 <vTaskSuspend+0x8>
    3dd4:	00 d0       	rcall	.+0      	; 0x3dd6 <vTaskSuspend+0xa>
    3dd6:	cd b7       	in	r28, 0x3d	; 61
    3dd8:	de b7       	in	r29, 0x3e	; 62
    3dda:	9c 83       	std	Y+4, r25	; 0x04
    3ddc:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3dde:	0f b6       	in	r0, 0x3f	; 63
    3de0:	f8 94       	cli
    3de2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3de4:	8b 81       	ldd	r24, Y+3	; 0x03
    3de6:	9c 81       	ldd	r25, Y+4	; 0x04
    3de8:	00 97       	sbiw	r24, 0x00	; 0
    3dea:	39 f4       	brne	.+14     	; 0x3dfa <vTaskSuspend+0x2e>
    3dec:	80 91 a8 06 	lds	r24, 0x06A8
    3df0:	90 91 a9 06 	lds	r25, 0x06A9
    3df4:	9e 83       	std	Y+6, r25	; 0x06
    3df6:	8d 83       	std	Y+5, r24	; 0x05
    3df8:	04 c0       	rjmp	.+8      	; 0x3e02 <vTaskSuspend+0x36>
    3dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3dfe:	9e 83       	std	Y+6, r25	; 0x06
    3e00:	8d 83       	std	Y+5, r24	; 0x05
    3e02:	8d 81       	ldd	r24, Y+5	; 0x05
    3e04:	9e 81       	ldd	r25, Y+6	; 0x06
    3e06:	9a 83       	std	Y+2, r25	; 0x02
    3e08:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
    3e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e0e:	02 96       	adiw	r24, 0x02	; 2
    3e10:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3e14:	e9 81       	ldd	r30, Y+1	; 0x01
    3e16:	fa 81       	ldd	r31, Y+2	; 0x02
    3e18:	84 89       	ldd	r24, Z+20	; 0x14
    3e1a:	95 89       	ldd	r25, Z+21	; 0x15
    3e1c:	00 97       	sbiw	r24, 0x00	; 0
    3e1e:	29 f0       	breq	.+10     	; 0x3e2a <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3e20:	89 81       	ldd	r24, Y+1	; 0x01
    3e22:	9a 81       	ldd	r25, Y+2	; 0x02
    3e24:	0c 96       	adiw	r24, 0x0c	; 12
    3e26:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3e2a:	89 81       	ldd	r24, Y+1	; 0x01
    3e2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2e:	9c 01       	movw	r18, r24
    3e30:	2e 5f       	subi	r18, 0xFE	; 254
    3e32:	3f 4f       	sbci	r19, 0xFF	; 255
    3e34:	8e e0       	ldi	r24, 0x0E	; 14
    3e36:	97 e0       	ldi	r25, 0x07	; 7
    3e38:	b9 01       	movw	r22, r18
    3e3a:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e40:	fa 81       	ldd	r31, Y+2	; 0x02
    3e42:	85 a1       	ldd	r24, Z+37	; 0x25
    3e44:	81 30       	cpi	r24, 0x01	; 1
    3e46:	19 f4       	brne	.+6      	; 0x3e4e <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3e48:	e9 81       	ldd	r30, Y+1	; 0x01
    3e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e4c:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3e4e:	0f 90       	pop	r0
    3e50:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3e52:	80 91 af 06 	lds	r24, 0x06AF
    3e56:	88 23       	and	r24, r24
    3e58:	39 f0       	breq	.+14     	; 0x3e68 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3e5a:	0f b6       	in	r0, 0x3f	; 63
    3e5c:	f8 94       	cli
    3e5e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3e60:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3e64:	0f 90       	pop	r0
    3e66:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3e68:	20 91 a8 06 	lds	r18, 0x06A8
    3e6c:	30 91 a9 06 	lds	r19, 0x06A9
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	82 17       	cp	r24, r18
    3e76:	93 07       	cpc	r25, r19
    3e78:	a1 f4       	brne	.+40     	; 0x3ea2 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3e7a:	80 91 af 06 	lds	r24, 0x06AF
    3e7e:	88 23       	and	r24, r24
    3e80:	19 f0       	breq	.+6      	; 0x3e88 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e82:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
    3e86:	0d c0       	rjmp	.+26     	; 0x3ea2 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3e88:	90 91 0e 07 	lds	r25, 0x070E
    3e8c:	80 91 ab 06 	lds	r24, 0x06AB
    3e90:	98 17       	cp	r25, r24
    3e92:	29 f4       	brne	.+10     	; 0x3e9e <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3e94:	10 92 a9 06 	sts	0x06A9, r1
    3e98:	10 92 a8 06 	sts	0x06A8, r1
    3e9c:	02 c0       	rjmp	.+4      	; 0x3ea2 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3e9e:	0e 94 72 22 	call	0x44e4	; 0x44e4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3ea2:	26 96       	adiw	r28, 0x06	; 6
    3ea4:	0f b6       	in	r0, 0x3f	; 63
    3ea6:	f8 94       	cli
    3ea8:	de bf       	out	0x3e, r29	; 62
    3eaa:	0f be       	out	0x3f, r0	; 63
    3eac:	cd bf       	out	0x3d, r28	; 61
    3eae:	cf 91       	pop	r28
    3eb0:	df 91       	pop	r29
    3eb2:	08 95       	ret

00003eb4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3eb4:	df 93       	push	r29
    3eb6:	cf 93       	push	r28
    3eb8:	00 d0       	rcall	.+0      	; 0x3eba <prvTaskIsTaskSuspended+0x6>
    3eba:	00 d0       	rcall	.+0      	; 0x3ebc <prvTaskIsTaskSuspended+0x8>
    3ebc:	0f 92       	push	r0
    3ebe:	cd b7       	in	r28, 0x3d	; 61
    3ec0:	de b7       	in	r29, 0x3e	; 62
    3ec2:	9d 83       	std	Y+5, r25	; 0x05
    3ec4:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3ec6:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3ec8:	8c 81       	ldd	r24, Y+4	; 0x04
    3eca:	9d 81       	ldd	r25, Y+5	; 0x05
    3ecc:	9a 83       	std	Y+2, r25	; 0x02
    3ece:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed4:	82 85       	ldd	r24, Z+10	; 0x0a
    3ed6:	93 85       	ldd	r25, Z+11	; 0x0b
    3ed8:	27 e0       	ldi	r18, 0x07	; 7
    3eda:	8e 30       	cpi	r24, 0x0E	; 14
    3edc:	92 07       	cpc	r25, r18
    3ede:	81 f4       	brne	.+32     	; 0x3f00 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee4:	84 89       	ldd	r24, Z+20	; 0x14
    3ee6:	95 89       	ldd	r25, Z+21	; 0x15
    3ee8:	26 e0       	ldi	r18, 0x06	; 6
    3eea:	8c 3f       	cpi	r24, 0xFC	; 252
    3eec:	92 07       	cpc	r25, r18
    3eee:	41 f0       	breq	.+16     	; 0x3f00 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3ef0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef4:	84 89       	ldd	r24, Z+20	; 0x14
    3ef6:	95 89       	ldd	r25, Z+21	; 0x15
    3ef8:	00 97       	sbiw	r24, 0x00	; 0
    3efa:	11 f4       	brne	.+4      	; 0x3f00 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3efc:	81 e0       	ldi	r24, 0x01	; 1
    3efe:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3f00:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3f02:	0f 90       	pop	r0
    3f04:	0f 90       	pop	r0
    3f06:	0f 90       	pop	r0
    3f08:	0f 90       	pop	r0
    3f0a:	0f 90       	pop	r0
    3f0c:	cf 91       	pop	r28
    3f0e:	df 91       	pop	r29
    3f10:	08 95       	ret

00003f12 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3f12:	df 93       	push	r29
    3f14:	cf 93       	push	r28
    3f16:	00 d0       	rcall	.+0      	; 0x3f18 <vTaskResume+0x6>
    3f18:	00 d0       	rcall	.+0      	; 0x3f1a <vTaskResume+0x8>
    3f1a:	cd b7       	in	r28, 0x3d	; 61
    3f1c:	de b7       	in	r29, 0x3e	; 62
    3f1e:	9c 83       	std	Y+4, r25	; 0x04
    3f20:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3f22:	8b 81       	ldd	r24, Y+3	; 0x03
    3f24:	9c 81       	ldd	r25, Y+4	; 0x04
    3f26:	9a 83       	std	Y+2, r25	; 0x02
    3f28:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3f2a:	20 91 a8 06 	lds	r18, 0x06A8
    3f2e:	30 91 a9 06 	lds	r19, 0x06A9
    3f32:	89 81       	ldd	r24, Y+1	; 0x01
    3f34:	9a 81       	ldd	r25, Y+2	; 0x02
    3f36:	82 17       	cp	r24, r18
    3f38:	93 07       	cpc	r25, r19
    3f3a:	09 f4       	brne	.+2      	; 0x3f3e <vTaskResume+0x2c>
    3f3c:	47 c0       	rjmp	.+142    	; 0x3fcc <vTaskResume+0xba>
    3f3e:	89 81       	ldd	r24, Y+1	; 0x01
    3f40:	9a 81       	ldd	r25, Y+2	; 0x02
    3f42:	00 97       	sbiw	r24, 0x00	; 0
    3f44:	09 f4       	brne	.+2      	; 0x3f48 <vTaskResume+0x36>
    3f46:	42 c0       	rjmp	.+132    	; 0x3fcc <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3f48:	0f b6       	in	r0, 0x3f	; 63
    3f4a:	f8 94       	cli
    3f4c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3f4e:	89 81       	ldd	r24, Y+1	; 0x01
    3f50:	9a 81       	ldd	r25, Y+2	; 0x02
    3f52:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <prvTaskIsTaskSuspended>
    3f56:	88 23       	and	r24, r24
    3f58:	b9 f1       	breq	.+110    	; 0x3fc8 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3f5a:	89 81       	ldd	r24, Y+1	; 0x01
    3f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5e:	02 96       	adiw	r24, 0x02	; 2
    3f60:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3f64:	e9 81       	ldd	r30, Y+1	; 0x01
    3f66:	fa 81       	ldd	r31, Y+2	; 0x02
    3f68:	96 89       	ldd	r25, Z+22	; 0x16
    3f6a:	80 91 ae 06 	lds	r24, 0x06AE
    3f6e:	89 17       	cp	r24, r25
    3f70:	28 f4       	brcc	.+10     	; 0x3f7c <vTaskResume+0x6a>
    3f72:	e9 81       	ldd	r30, Y+1	; 0x01
    3f74:	fa 81       	ldd	r31, Y+2	; 0x02
    3f76:	86 89       	ldd	r24, Z+22	; 0x16
    3f78:	80 93 ae 06 	sts	0x06AE, r24
    3f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f80:	86 89       	ldd	r24, Z+22	; 0x16
    3f82:	28 2f       	mov	r18, r24
    3f84:	30 e0       	ldi	r19, 0x00	; 0
    3f86:	c9 01       	movw	r24, r18
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	88 0f       	add	r24, r24
    3f8e:	99 1f       	adc	r25, r25
    3f90:	88 0f       	add	r24, r24
    3f92:	99 1f       	adc	r25, r25
    3f94:	82 0f       	add	r24, r18
    3f96:	93 1f       	adc	r25, r19
    3f98:	ac 01       	movw	r20, r24
    3f9a:	47 54       	subi	r20, 0x47	; 71
    3f9c:	59 4f       	sbci	r21, 0xF9	; 249
    3f9e:	89 81       	ldd	r24, Y+1	; 0x01
    3fa0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fa2:	9c 01       	movw	r18, r24
    3fa4:	2e 5f       	subi	r18, 0xFE	; 254
    3fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa8:	ca 01       	movw	r24, r20
    3faa:	b9 01       	movw	r22, r18
    3fac:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	96 89       	ldd	r25, Z+22	; 0x16
    3fb6:	e0 91 a8 06 	lds	r30, 0x06A8
    3fba:	f0 91 a9 06 	lds	r31, 0x06A9
    3fbe:	86 89       	ldd	r24, Z+22	; 0x16
    3fc0:	98 17       	cp	r25, r24
    3fc2:	10 f0       	brcs	.+4      	; 0x3fc8 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3fc4:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3fc8:	0f 90       	pop	r0
    3fca:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3fcc:	0f 90       	pop	r0
    3fce:	0f 90       	pop	r0
    3fd0:	0f 90       	pop	r0
    3fd2:	0f 90       	pop	r0
    3fd4:	cf 91       	pop	r28
    3fd6:	df 91       	pop	r29
    3fd8:	08 95       	ret

00003fda <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3fda:	df 93       	push	r29
    3fdc:	cf 93       	push	r28
    3fde:	00 d0       	rcall	.+0      	; 0x3fe0 <xTaskResumeFromISR+0x6>
    3fe0:	00 d0       	rcall	.+0      	; 0x3fe2 <xTaskResumeFromISR+0x8>
    3fe2:	00 d0       	rcall	.+0      	; 0x3fe4 <xTaskResumeFromISR+0xa>
    3fe4:	cd b7       	in	r28, 0x3d	; 61
    3fe6:	de b7       	in	r29, 0x3e	; 62
    3fe8:	9e 83       	std	Y+6, r25	; 0x06
    3fea:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3fec:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    3fee:	8d 81       	ldd	r24, Y+5	; 0x05
    3ff0:	9e 81       	ldd	r25, Y+6	; 0x06
    3ff2:	9b 83       	std	Y+3, r25	; 0x03
    3ff4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ff6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    3ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    3ffc:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <prvTaskIsTaskSuspended>
    4000:	88 23       	and	r24, r24
    4002:	09 f4       	brne	.+2      	; 0x4006 <xTaskResumeFromISR+0x2c>
    4004:	46 c0       	rjmp	.+140    	; 0x4092 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4006:	80 91 b8 06 	lds	r24, 0x06B8
    400a:	88 23       	and	r24, r24
    400c:	c1 f5       	brne	.+112    	; 0x407e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    400e:	ea 81       	ldd	r30, Y+2	; 0x02
    4010:	fb 81       	ldd	r31, Y+3	; 0x03
    4012:	96 89       	ldd	r25, Z+22	; 0x16
    4014:	e0 91 a8 06 	lds	r30, 0x06A8
    4018:	f0 91 a9 06 	lds	r31, 0x06A9
    401c:	86 89       	ldd	r24, Z+22	; 0x16
    401e:	98 17       	cp	r25, r24
    4020:	10 f0       	brcs	.+4      	; 0x4026 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    4022:	81 e0       	ldi	r24, 0x01	; 1
    4024:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4026:	8a 81       	ldd	r24, Y+2	; 0x02
    4028:	9b 81       	ldd	r25, Y+3	; 0x03
    402a:	02 96       	adiw	r24, 0x02	; 2
    402c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4030:	ea 81       	ldd	r30, Y+2	; 0x02
    4032:	fb 81       	ldd	r31, Y+3	; 0x03
    4034:	96 89       	ldd	r25, Z+22	; 0x16
    4036:	80 91 ae 06 	lds	r24, 0x06AE
    403a:	89 17       	cp	r24, r25
    403c:	28 f4       	brcc	.+10     	; 0x4048 <xTaskResumeFromISR+0x6e>
    403e:	ea 81       	ldd	r30, Y+2	; 0x02
    4040:	fb 81       	ldd	r31, Y+3	; 0x03
    4042:	86 89       	ldd	r24, Z+22	; 0x16
    4044:	80 93 ae 06 	sts	0x06AE, r24
    4048:	ea 81       	ldd	r30, Y+2	; 0x02
    404a:	fb 81       	ldd	r31, Y+3	; 0x03
    404c:	86 89       	ldd	r24, Z+22	; 0x16
    404e:	28 2f       	mov	r18, r24
    4050:	30 e0       	ldi	r19, 0x00	; 0
    4052:	c9 01       	movw	r24, r18
    4054:	88 0f       	add	r24, r24
    4056:	99 1f       	adc	r25, r25
    4058:	88 0f       	add	r24, r24
    405a:	99 1f       	adc	r25, r25
    405c:	88 0f       	add	r24, r24
    405e:	99 1f       	adc	r25, r25
    4060:	82 0f       	add	r24, r18
    4062:	93 1f       	adc	r25, r19
    4064:	ac 01       	movw	r20, r24
    4066:	47 54       	subi	r20, 0x47	; 71
    4068:	59 4f       	sbci	r21, 0xF9	; 249
    406a:	8a 81       	ldd	r24, Y+2	; 0x02
    406c:	9b 81       	ldd	r25, Y+3	; 0x03
    406e:	9c 01       	movw	r18, r24
    4070:	2e 5f       	subi	r18, 0xFE	; 254
    4072:	3f 4f       	sbci	r19, 0xFF	; 255
    4074:	ca 01       	movw	r24, r20
    4076:	b9 01       	movw	r22, r18
    4078:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    407c:	0a c0       	rjmp	.+20     	; 0x4092 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    407e:	8a 81       	ldd	r24, Y+2	; 0x02
    4080:	9b 81       	ldd	r25, Y+3	; 0x03
    4082:	9c 01       	movw	r18, r24
    4084:	24 5f       	subi	r18, 0xF4	; 244
    4086:	3f 4f       	sbci	r19, 0xFF	; 255
    4088:	8c ef       	ldi	r24, 0xFC	; 252
    408a:	96 e0       	ldi	r25, 0x06	; 6
    408c:	b9 01       	movw	r22, r18
    408e:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4092:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4094:	26 96       	adiw	r28, 0x06	; 6
    4096:	0f b6       	in	r0, 0x3f	; 63
    4098:	f8 94       	cli
    409a:	de bf       	out	0x3e, r29	; 62
    409c:	0f be       	out	0x3f, r0	; 63
    409e:	cd bf       	out	0x3d, r28	; 61
    40a0:	cf 91       	pop	r28
    40a2:	df 91       	pop	r29
    40a4:	08 95       	ret

000040a6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    40a6:	ef 92       	push	r14
    40a8:	ff 92       	push	r15
    40aa:	0f 93       	push	r16
    40ac:	df 93       	push	r29
    40ae:	cf 93       	push	r28
    40b0:	0f 92       	push	r0
    40b2:	cd b7       	in	r28, 0x3d	; 61
    40b4:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    40b6:	87 ea       	ldi	r24, 0xA7	; 167
    40b8:	94 e2       	ldi	r25, 0x24	; 36
    40ba:	2a eb       	ldi	r18, 0xBA	; 186
    40bc:	30 e0       	ldi	r19, 0x00	; 0
    40be:	e6 eb       	ldi	r30, 0xB6	; 182
    40c0:	f6 e0       	ldi	r31, 0x06	; 6
    40c2:	b9 01       	movw	r22, r18
    40c4:	46 e9       	ldi	r20, 0x96	; 150
    40c6:	50 e0       	ldi	r21, 0x00	; 0
    40c8:	20 e0       	ldi	r18, 0x00	; 0
    40ca:	30 e0       	ldi	r19, 0x00	; 0
    40cc:	00 e0       	ldi	r16, 0x00	; 0
    40ce:	7f 01       	movw	r14, r30
    40d0:	0e 94 a6 1c 	call	0x394c	; 0x394c <xTaskCreate>
    40d4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    40d6:	89 81       	ldd	r24, Y+1	; 0x01
    40d8:	81 30       	cpi	r24, 0x01	; 1
    40da:	81 f4       	brne	.+32     	; 0x40fc <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    40dc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    40de:	8f ef       	ldi	r24, 0xFF	; 255
    40e0:	9f ef       	ldi	r25, 0xFF	; 255
    40e2:	90 93 b5 06 	sts	0x06B5, r25
    40e6:	80 93 b4 06 	sts	0x06B4, r24
		xSchedulerRunning = pdTRUE;
    40ea:	81 e0       	ldi	r24, 0x01	; 1
    40ec:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    40f0:	10 92 ad 06 	sts	0x06AD, r1
    40f4:	10 92 ac 06 	sts	0x06AC, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    40f8:	0e 94 9f 0c 	call	0x193e	; 0x193e <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    40fc:	0f 90       	pop	r0
    40fe:	cf 91       	pop	r28
    4100:	df 91       	pop	r29
    4102:	0f 91       	pop	r16
    4104:	ff 90       	pop	r15
    4106:	ef 90       	pop	r14
    4108:	08 95       	ret

0000410a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    410a:	df 93       	push	r29
    410c:	cf 93       	push	r28
    410e:	cd b7       	in	r28, 0x3d	; 61
    4110:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4112:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4114:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    4118:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <vPortEndScheduler>
}
    411c:	cf 91       	pop	r28
    411e:	df 91       	pop	r29
    4120:	08 95       	ret

00004122 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4122:	df 93       	push	r29
    4124:	cf 93       	push	r28
    4126:	cd b7       	in	r28, 0x3d	; 61
    4128:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    412a:	80 91 b8 06 	lds	r24, 0x06B8
    412e:	8f 5f       	subi	r24, 0xFF	; 255
    4130:	80 93 b8 06 	sts	0x06B8, r24
}
    4134:	cf 91       	pop	r28
    4136:	df 91       	pop	r29
    4138:	08 95       	ret

0000413a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    413a:	df 93       	push	r29
    413c:	cf 93       	push	r28
    413e:	00 d0       	rcall	.+0      	; 0x4140 <xTaskResumeAll+0x6>
    4140:	00 d0       	rcall	.+0      	; 0x4142 <xTaskResumeAll+0x8>
    4142:	cd b7       	in	r28, 0x3d	; 61
    4144:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4146:	1c 82       	std	Y+4, r1	; 0x04
    4148:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    414a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    414c:	0f b6       	in	r0, 0x3f	; 63
    414e:	f8 94       	cli
    4150:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4152:	80 91 b8 06 	lds	r24, 0x06B8
    4156:	81 50       	subi	r24, 0x01	; 1
    4158:	80 93 b8 06 	sts	0x06B8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    415c:	80 91 b8 06 	lds	r24, 0x06B8
    4160:	88 23       	and	r24, r24
    4162:	09 f0       	breq	.+2      	; 0x4166 <xTaskResumeAll+0x2c>
    4164:	73 c0       	rjmp	.+230    	; 0x424c <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4166:	80 91 ab 06 	lds	r24, 0x06AB
    416a:	88 23       	and	r24, r24
    416c:	09 f4       	brne	.+2      	; 0x4170 <xTaskResumeAll+0x36>
    416e:	6e c0       	rjmp	.+220    	; 0x424c <xTaskResumeAll+0x112>
    4170:	45 c0       	rjmp	.+138    	; 0x41fc <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4172:	e0 91 01 07 	lds	r30, 0x0701
    4176:	f0 91 02 07 	lds	r31, 0x0702
    417a:	86 81       	ldd	r24, Z+6	; 0x06
    417c:	97 81       	ldd	r25, Z+7	; 0x07
    417e:	9c 83       	std	Y+4, r25	; 0x04
    4180:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4182:	8b 81       	ldd	r24, Y+3	; 0x03
    4184:	9c 81       	ldd	r25, Y+4	; 0x04
    4186:	0c 96       	adiw	r24, 0x0c	; 12
    4188:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    418c:	8b 81       	ldd	r24, Y+3	; 0x03
    418e:	9c 81       	ldd	r25, Y+4	; 0x04
    4190:	02 96       	adiw	r24, 0x02	; 2
    4192:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4196:	eb 81       	ldd	r30, Y+3	; 0x03
    4198:	fc 81       	ldd	r31, Y+4	; 0x04
    419a:	96 89       	ldd	r25, Z+22	; 0x16
    419c:	80 91 ae 06 	lds	r24, 0x06AE
    41a0:	89 17       	cp	r24, r25
    41a2:	28 f4       	brcc	.+10     	; 0x41ae <xTaskResumeAll+0x74>
    41a4:	eb 81       	ldd	r30, Y+3	; 0x03
    41a6:	fc 81       	ldd	r31, Y+4	; 0x04
    41a8:	86 89       	ldd	r24, Z+22	; 0x16
    41aa:	80 93 ae 06 	sts	0x06AE, r24
    41ae:	eb 81       	ldd	r30, Y+3	; 0x03
    41b0:	fc 81       	ldd	r31, Y+4	; 0x04
    41b2:	86 89       	ldd	r24, Z+22	; 0x16
    41b4:	28 2f       	mov	r18, r24
    41b6:	30 e0       	ldi	r19, 0x00	; 0
    41b8:	c9 01       	movw	r24, r18
    41ba:	88 0f       	add	r24, r24
    41bc:	99 1f       	adc	r25, r25
    41be:	88 0f       	add	r24, r24
    41c0:	99 1f       	adc	r25, r25
    41c2:	88 0f       	add	r24, r24
    41c4:	99 1f       	adc	r25, r25
    41c6:	82 0f       	add	r24, r18
    41c8:	93 1f       	adc	r25, r19
    41ca:	ac 01       	movw	r20, r24
    41cc:	47 54       	subi	r20, 0x47	; 71
    41ce:	59 4f       	sbci	r21, 0xF9	; 249
    41d0:	8b 81       	ldd	r24, Y+3	; 0x03
    41d2:	9c 81       	ldd	r25, Y+4	; 0x04
    41d4:	9c 01       	movw	r18, r24
    41d6:	2e 5f       	subi	r18, 0xFE	; 254
    41d8:	3f 4f       	sbci	r19, 0xFF	; 255
    41da:	ca 01       	movw	r24, r20
    41dc:	b9 01       	movw	r22, r18
    41de:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    41e2:	eb 81       	ldd	r30, Y+3	; 0x03
    41e4:	fc 81       	ldd	r31, Y+4	; 0x04
    41e6:	96 89       	ldd	r25, Z+22	; 0x16
    41e8:	e0 91 a8 06 	lds	r30, 0x06A8
    41ec:	f0 91 a9 06 	lds	r31, 0x06A9
    41f0:	86 89       	ldd	r24, Z+22	; 0x16
    41f2:	98 17       	cp	r25, r24
    41f4:	18 f0       	brcs	.+6      	; 0x41fc <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    41f6:	81 e0       	ldi	r24, 0x01	; 1
    41f8:	80 93 b1 06 	sts	0x06B1, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    41fc:	80 91 fc 06 	lds	r24, 0x06FC
    4200:	88 23       	and	r24, r24
    4202:	09 f0       	breq	.+2      	; 0x4206 <xTaskResumeAll+0xcc>
    4204:	b6 cf       	rjmp	.-148    	; 0x4172 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4206:	8b 81       	ldd	r24, Y+3	; 0x03
    4208:	9c 81       	ldd	r25, Y+4	; 0x04
    420a:	00 97       	sbiw	r24, 0x00	; 0
    420c:	11 f0       	breq	.+4      	; 0x4212 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    420e:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    4212:	80 91 b0 06 	lds	r24, 0x06B0
    4216:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4218:	89 81       	ldd	r24, Y+1	; 0x01
    421a:	88 23       	and	r24, r24
    421c:	79 f0       	breq	.+30     	; 0x423c <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    421e:	0e 94 8d 21 	call	0x431a	; 0x431a <xTaskIncrementTick>
    4222:	88 23       	and	r24, r24
    4224:	19 f0       	breq	.+6      	; 0x422c <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4226:	81 e0       	ldi	r24, 0x01	; 1
    4228:	80 93 b1 06 	sts	0x06B1, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    422c:	89 81       	ldd	r24, Y+1	; 0x01
    422e:	81 50       	subi	r24, 0x01	; 1
    4230:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4232:	89 81       	ldd	r24, Y+1	; 0x01
    4234:	88 23       	and	r24, r24
    4236:	99 f7       	brne	.-26     	; 0x421e <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4238:	10 92 b0 06 	sts	0x06B0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    423c:	80 91 b1 06 	lds	r24, 0x06B1
    4240:	88 23       	and	r24, r24
    4242:	21 f0       	breq	.+8      	; 0x424c <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4244:	81 e0       	ldi	r24, 0x01	; 1
    4246:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4248:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    424c:	0f 90       	pop	r0
    424e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4250:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4252:	0f 90       	pop	r0
    4254:	0f 90       	pop	r0
    4256:	0f 90       	pop	r0
    4258:	0f 90       	pop	r0
    425a:	cf 91       	pop	r28
    425c:	df 91       	pop	r29
    425e:	08 95       	ret

00004260 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4260:	df 93       	push	r29
    4262:	cf 93       	push	r28
    4264:	00 d0       	rcall	.+0      	; 0x4266 <xTaskGetTickCount+0x6>
    4266:	cd b7       	in	r28, 0x3d	; 61
    4268:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    426a:	0f b6       	in	r0, 0x3f	; 63
    426c:	f8 94       	cli
    426e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4270:	80 91 ac 06 	lds	r24, 0x06AC
    4274:	90 91 ad 06 	lds	r25, 0x06AD
    4278:	9a 83       	std	Y+2, r25	; 0x02
    427a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    427c:	0f 90       	pop	r0
    427e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4280:	89 81       	ldd	r24, Y+1	; 0x01
    4282:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4284:	0f 90       	pop	r0
    4286:	0f 90       	pop	r0
    4288:	cf 91       	pop	r28
    428a:	df 91       	pop	r29
    428c:	08 95       	ret

0000428e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    428e:	df 93       	push	r29
    4290:	cf 93       	push	r28
    4292:	00 d0       	rcall	.+0      	; 0x4294 <xTaskGetTickCountFromISR+0x6>
    4294:	0f 92       	push	r0
    4296:	cd b7       	in	r28, 0x3d	; 61
    4298:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    429a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    429c:	80 91 ac 06 	lds	r24, 0x06AC
    42a0:	90 91 ad 06 	lds	r25, 0x06AD
    42a4:	9b 83       	std	Y+3, r25	; 0x03
    42a6:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    42a8:	8a 81       	ldd	r24, Y+2	; 0x02
    42aa:	9b 81       	ldd	r25, Y+3	; 0x03
}
    42ac:	0f 90       	pop	r0
    42ae:	0f 90       	pop	r0
    42b0:	0f 90       	pop	r0
    42b2:	cf 91       	pop	r28
    42b4:	df 91       	pop	r29
    42b6:	08 95       	ret

000042b8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    42b8:	df 93       	push	r29
    42ba:	cf 93       	push	r28
    42bc:	cd b7       	in	r28, 0x3d	; 61
    42be:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    42c0:	80 91 ab 06 	lds	r24, 0x06AB
}
    42c4:	cf 91       	pop	r28
    42c6:	df 91       	pop	r29
    42c8:	08 95       	ret

000042ca <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    42ca:	df 93       	push	r29
    42cc:	cf 93       	push	r28
    42ce:	00 d0       	rcall	.+0      	; 0x42d0 <pcTaskGetName+0x6>
    42d0:	00 d0       	rcall	.+0      	; 0x42d2 <pcTaskGetName+0x8>
    42d2:	00 d0       	rcall	.+0      	; 0x42d4 <pcTaskGetName+0xa>
    42d4:	cd b7       	in	r28, 0x3d	; 61
    42d6:	de b7       	in	r29, 0x3e	; 62
    42d8:	9c 83       	std	Y+4, r25	; 0x04
    42da:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    42dc:	8b 81       	ldd	r24, Y+3	; 0x03
    42de:	9c 81       	ldd	r25, Y+4	; 0x04
    42e0:	00 97       	sbiw	r24, 0x00	; 0
    42e2:	39 f4       	brne	.+14     	; 0x42f2 <pcTaskGetName+0x28>
    42e4:	80 91 a8 06 	lds	r24, 0x06A8
    42e8:	90 91 a9 06 	lds	r25, 0x06A9
    42ec:	9e 83       	std	Y+6, r25	; 0x06
    42ee:	8d 83       	std	Y+5, r24	; 0x05
    42f0:	04 c0       	rjmp	.+8      	; 0x42fa <pcTaskGetName+0x30>
    42f2:	8b 81       	ldd	r24, Y+3	; 0x03
    42f4:	9c 81       	ldd	r25, Y+4	; 0x04
    42f6:	9e 83       	std	Y+6, r25	; 0x06
    42f8:	8d 83       	std	Y+5, r24	; 0x05
    42fa:	8d 81       	ldd	r24, Y+5	; 0x05
    42fc:	9e 81       	ldd	r25, Y+6	; 0x06
    42fe:	9a 83       	std	Y+2, r25	; 0x02
    4300:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    4302:	89 81       	ldd	r24, Y+1	; 0x01
    4304:	9a 81       	ldd	r25, Y+2	; 0x02
    4306:	49 96       	adiw	r24, 0x19	; 25
}
    4308:	26 96       	adiw	r28, 0x06	; 6
    430a:	0f b6       	in	r0, 0x3f	; 63
    430c:	f8 94       	cli
    430e:	de bf       	out	0x3e, r29	; 62
    4310:	0f be       	out	0x3f, r0	; 63
    4312:	cd bf       	out	0x3d, r28	; 61
    4314:	cf 91       	pop	r28
    4316:	df 91       	pop	r29
    4318:	08 95       	ret

0000431a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    431a:	df 93       	push	r29
    431c:	cf 93       	push	r28
    431e:	cd b7       	in	r28, 0x3d	; 61
    4320:	de b7       	in	r29, 0x3e	; 62
    4322:	29 97       	sbiw	r28, 0x09	; 9
    4324:	0f b6       	in	r0, 0x3f	; 63
    4326:	f8 94       	cli
    4328:	de bf       	out	0x3e, r29	; 62
    432a:	0f be       	out	0x3f, r0	; 63
    432c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    432e:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4330:	80 91 b8 06 	lds	r24, 0x06B8
    4334:	88 23       	and	r24, r24
    4336:	09 f0       	breq	.+2      	; 0x433a <xTaskIncrementTick+0x20>
    4338:	c0 c0       	rjmp	.+384    	; 0x44ba <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    433a:	80 91 ac 06 	lds	r24, 0x06AC
    433e:	90 91 ad 06 	lds	r25, 0x06AD
    4342:	01 96       	adiw	r24, 0x01	; 1
    4344:	9c 83       	std	Y+4, r25	; 0x04
    4346:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4348:	8b 81       	ldd	r24, Y+3	; 0x03
    434a:	9c 81       	ldd	r25, Y+4	; 0x04
    434c:	90 93 ad 06 	sts	0x06AD, r25
    4350:	80 93 ac 06 	sts	0x06AC, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4354:	8b 81       	ldd	r24, Y+3	; 0x03
    4356:	9c 81       	ldd	r25, Y+4	; 0x04
    4358:	00 97       	sbiw	r24, 0x00	; 0
    435a:	d9 f4       	brne	.+54     	; 0x4392 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    435c:	80 91 f8 06 	lds	r24, 0x06F8
    4360:	90 91 f9 06 	lds	r25, 0x06F9
    4364:	9a 83       	std	Y+2, r25	; 0x02
    4366:	89 83       	std	Y+1, r24	; 0x01
    4368:	80 91 fa 06 	lds	r24, 0x06FA
    436c:	90 91 fb 06 	lds	r25, 0x06FB
    4370:	90 93 f9 06 	sts	0x06F9, r25
    4374:	80 93 f8 06 	sts	0x06F8, r24
    4378:	89 81       	ldd	r24, Y+1	; 0x01
    437a:	9a 81       	ldd	r25, Y+2	; 0x02
    437c:	90 93 fb 06 	sts	0x06FB, r25
    4380:	80 93 fa 06 	sts	0x06FA, r24
    4384:	80 91 b2 06 	lds	r24, 0x06B2
    4388:	8f 5f       	subi	r24, 0xFF	; 255
    438a:	80 93 b2 06 	sts	0x06B2, r24
    438e:	0e 94 37 25 	call	0x4a6e	; 0x4a6e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4392:	20 91 b4 06 	lds	r18, 0x06B4
    4396:	30 91 b5 06 	lds	r19, 0x06B5
    439a:	8b 81       	ldd	r24, Y+3	; 0x03
    439c:	9c 81       	ldd	r25, Y+4	; 0x04
    439e:	82 17       	cp	r24, r18
    43a0:	93 07       	cpc	r25, r19
    43a2:	08 f4       	brcc	.+2      	; 0x43a6 <xTaskIncrementTick+0x8c>
    43a4:	71 c0       	rjmp	.+226    	; 0x4488 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    43a6:	e0 91 f8 06 	lds	r30, 0x06F8
    43aa:	f0 91 f9 06 	lds	r31, 0x06F9
    43ae:	80 81       	ld	r24, Z
    43b0:	88 23       	and	r24, r24
    43b2:	39 f4       	brne	.+14     	; 0x43c2 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43b4:	8f ef       	ldi	r24, 0xFF	; 255
    43b6:	9f ef       	ldi	r25, 0xFF	; 255
    43b8:	90 93 b5 06 	sts	0x06B5, r25
    43bc:	80 93 b4 06 	sts	0x06B4, r24
    43c0:	63 c0       	rjmp	.+198    	; 0x4488 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    43c2:	e0 91 f8 06 	lds	r30, 0x06F8
    43c6:	f0 91 f9 06 	lds	r31, 0x06F9
    43ca:	05 80       	ldd	r0, Z+5	; 0x05
    43cc:	f6 81       	ldd	r31, Z+6	; 0x06
    43ce:	e0 2d       	mov	r30, r0
    43d0:	86 81       	ldd	r24, Z+6	; 0x06
    43d2:	97 81       	ldd	r25, Z+7	; 0x07
    43d4:	99 87       	std	Y+9, r25	; 0x09
    43d6:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    43d8:	e8 85       	ldd	r30, Y+8	; 0x08
    43da:	f9 85       	ldd	r31, Y+9	; 0x09
    43dc:	82 81       	ldd	r24, Z+2	; 0x02
    43de:	93 81       	ldd	r25, Z+3	; 0x03
    43e0:	9f 83       	std	Y+7, r25	; 0x07
    43e2:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    43e4:	2b 81       	ldd	r18, Y+3	; 0x03
    43e6:	3c 81       	ldd	r19, Y+4	; 0x04
    43e8:	8e 81       	ldd	r24, Y+6	; 0x06
    43ea:	9f 81       	ldd	r25, Y+7	; 0x07
    43ec:	28 17       	cp	r18, r24
    43ee:	39 07       	cpc	r19, r25
    43f0:	38 f4       	brcc	.+14     	; 0x4400 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    43f2:	8e 81       	ldd	r24, Y+6	; 0x06
    43f4:	9f 81       	ldd	r25, Y+7	; 0x07
    43f6:	90 93 b5 06 	sts	0x06B5, r25
    43fa:	80 93 b4 06 	sts	0x06B4, r24
    43fe:	44 c0       	rjmp	.+136    	; 0x4488 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4400:	88 85       	ldd	r24, Y+8	; 0x08
    4402:	99 85       	ldd	r25, Y+9	; 0x09
    4404:	02 96       	adiw	r24, 0x02	; 2
    4406:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    440a:	e8 85       	ldd	r30, Y+8	; 0x08
    440c:	f9 85       	ldd	r31, Y+9	; 0x09
    440e:	84 89       	ldd	r24, Z+20	; 0x14
    4410:	95 89       	ldd	r25, Z+21	; 0x15
    4412:	00 97       	sbiw	r24, 0x00	; 0
    4414:	29 f0       	breq	.+10     	; 0x4420 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4416:	88 85       	ldd	r24, Y+8	; 0x08
    4418:	99 85       	ldd	r25, Y+9	; 0x09
    441a:	0c 96       	adiw	r24, 0x0c	; 12
    441c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4420:	e8 85       	ldd	r30, Y+8	; 0x08
    4422:	f9 85       	ldd	r31, Y+9	; 0x09
    4424:	96 89       	ldd	r25, Z+22	; 0x16
    4426:	80 91 ae 06 	lds	r24, 0x06AE
    442a:	89 17       	cp	r24, r25
    442c:	28 f4       	brcc	.+10     	; 0x4438 <xTaskIncrementTick+0x11e>
    442e:	e8 85       	ldd	r30, Y+8	; 0x08
    4430:	f9 85       	ldd	r31, Y+9	; 0x09
    4432:	86 89       	ldd	r24, Z+22	; 0x16
    4434:	80 93 ae 06 	sts	0x06AE, r24
    4438:	e8 85       	ldd	r30, Y+8	; 0x08
    443a:	f9 85       	ldd	r31, Y+9	; 0x09
    443c:	86 89       	ldd	r24, Z+22	; 0x16
    443e:	28 2f       	mov	r18, r24
    4440:	30 e0       	ldi	r19, 0x00	; 0
    4442:	c9 01       	movw	r24, r18
    4444:	88 0f       	add	r24, r24
    4446:	99 1f       	adc	r25, r25
    4448:	88 0f       	add	r24, r24
    444a:	99 1f       	adc	r25, r25
    444c:	88 0f       	add	r24, r24
    444e:	99 1f       	adc	r25, r25
    4450:	82 0f       	add	r24, r18
    4452:	93 1f       	adc	r25, r19
    4454:	ac 01       	movw	r20, r24
    4456:	47 54       	subi	r20, 0x47	; 71
    4458:	59 4f       	sbci	r21, 0xF9	; 249
    445a:	88 85       	ldd	r24, Y+8	; 0x08
    445c:	99 85       	ldd	r25, Y+9	; 0x09
    445e:	9c 01       	movw	r18, r24
    4460:	2e 5f       	subi	r18, 0xFE	; 254
    4462:	3f 4f       	sbci	r19, 0xFF	; 255
    4464:	ca 01       	movw	r24, r20
    4466:	b9 01       	movw	r22, r18
    4468:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    446c:	e8 85       	ldd	r30, Y+8	; 0x08
    446e:	f9 85       	ldd	r31, Y+9	; 0x09
    4470:	96 89       	ldd	r25, Z+22	; 0x16
    4472:	e0 91 a8 06 	lds	r30, 0x06A8
    4476:	f0 91 a9 06 	lds	r31, 0x06A9
    447a:	86 89       	ldd	r24, Z+22	; 0x16
    447c:	98 17       	cp	r25, r24
    447e:	08 f4       	brcc	.+2      	; 0x4482 <xTaskIncrementTick+0x168>
    4480:	92 cf       	rjmp	.-220    	; 0x43a6 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4482:	81 e0       	ldi	r24, 0x01	; 1
    4484:	8d 83       	std	Y+5, r24	; 0x05
    4486:	8f cf       	rjmp	.-226    	; 0x43a6 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4488:	e0 91 a8 06 	lds	r30, 0x06A8
    448c:	f0 91 a9 06 	lds	r31, 0x06A9
    4490:	86 89       	ldd	r24, Z+22	; 0x16
    4492:	28 2f       	mov	r18, r24
    4494:	30 e0       	ldi	r19, 0x00	; 0
    4496:	c9 01       	movw	r24, r18
    4498:	88 0f       	add	r24, r24
    449a:	99 1f       	adc	r25, r25
    449c:	88 0f       	add	r24, r24
    449e:	99 1f       	adc	r25, r25
    44a0:	88 0f       	add	r24, r24
    44a2:	99 1f       	adc	r25, r25
    44a4:	82 0f       	add	r24, r18
    44a6:	93 1f       	adc	r25, r19
    44a8:	fc 01       	movw	r30, r24
    44aa:	e7 54       	subi	r30, 0x47	; 71
    44ac:	f9 4f       	sbci	r31, 0xF9	; 249
    44ae:	80 81       	ld	r24, Z
    44b0:	82 30       	cpi	r24, 0x02	; 2
    44b2:	40 f0       	brcs	.+16     	; 0x44c4 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    44b4:	81 e0       	ldi	r24, 0x01	; 1
    44b6:	8d 83       	std	Y+5, r24	; 0x05
    44b8:	05 c0       	rjmp	.+10     	; 0x44c4 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    44ba:	80 91 b0 06 	lds	r24, 0x06B0
    44be:	8f 5f       	subi	r24, 0xFF	; 255
    44c0:	80 93 b0 06 	sts	0x06B0, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    44c4:	80 91 b1 06 	lds	r24, 0x06B1
    44c8:	88 23       	and	r24, r24
    44ca:	11 f0       	breq	.+4      	; 0x44d0 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    44cc:	81 e0       	ldi	r24, 0x01	; 1
    44ce:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    44d0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    44d2:	29 96       	adiw	r28, 0x09	; 9
    44d4:	0f b6       	in	r0, 0x3f	; 63
    44d6:	f8 94       	cli
    44d8:	de bf       	out	0x3e, r29	; 62
    44da:	0f be       	out	0x3f, r0	; 63
    44dc:	cd bf       	out	0x3d, r28	; 61
    44de:	cf 91       	pop	r28
    44e0:	df 91       	pop	r29
    44e2:	08 95       	ret

000044e4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    44e4:	df 93       	push	r29
    44e6:	cf 93       	push	r28
    44e8:	00 d0       	rcall	.+0      	; 0x44ea <vTaskSwitchContext+0x6>
    44ea:	0f 92       	push	r0
    44ec:	cd b7       	in	r28, 0x3d	; 61
    44ee:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    44f0:	80 91 b8 06 	lds	r24, 0x06B8
    44f4:	88 23       	and	r24, r24
    44f6:	21 f0       	breq	.+8      	; 0x4500 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    44f8:	81 e0       	ldi	r24, 0x01	; 1
    44fa:	80 93 b1 06 	sts	0x06B1, r24
    44fe:	59 c0       	rjmp	.+178    	; 0x45b2 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    4500:	10 92 b1 06 	sts	0x06B1, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4504:	80 91 ae 06 	lds	r24, 0x06AE
    4508:	8b 83       	std	Y+3, r24	; 0x03
    450a:	03 c0       	rjmp	.+6      	; 0x4512 <vTaskSwitchContext+0x2e>
    450c:	8b 81       	ldd	r24, Y+3	; 0x03
    450e:	81 50       	subi	r24, 0x01	; 1
    4510:	8b 83       	std	Y+3, r24	; 0x03
    4512:	8b 81       	ldd	r24, Y+3	; 0x03
    4514:	28 2f       	mov	r18, r24
    4516:	30 e0       	ldi	r19, 0x00	; 0
    4518:	c9 01       	movw	r24, r18
    451a:	88 0f       	add	r24, r24
    451c:	99 1f       	adc	r25, r25
    451e:	88 0f       	add	r24, r24
    4520:	99 1f       	adc	r25, r25
    4522:	88 0f       	add	r24, r24
    4524:	99 1f       	adc	r25, r25
    4526:	82 0f       	add	r24, r18
    4528:	93 1f       	adc	r25, r19
    452a:	fc 01       	movw	r30, r24
    452c:	e7 54       	subi	r30, 0x47	; 71
    452e:	f9 4f       	sbci	r31, 0xF9	; 249
    4530:	80 81       	ld	r24, Z
    4532:	88 23       	and	r24, r24
    4534:	59 f3       	breq	.-42     	; 0x450c <vTaskSwitchContext+0x28>
    4536:	8b 81       	ldd	r24, Y+3	; 0x03
    4538:	28 2f       	mov	r18, r24
    453a:	30 e0       	ldi	r19, 0x00	; 0
    453c:	c9 01       	movw	r24, r18
    453e:	88 0f       	add	r24, r24
    4540:	99 1f       	adc	r25, r25
    4542:	88 0f       	add	r24, r24
    4544:	99 1f       	adc	r25, r25
    4546:	88 0f       	add	r24, r24
    4548:	99 1f       	adc	r25, r25
    454a:	82 0f       	add	r24, r18
    454c:	93 1f       	adc	r25, r19
    454e:	87 54       	subi	r24, 0x47	; 71
    4550:	99 4f       	sbci	r25, 0xF9	; 249
    4552:	9a 83       	std	Y+2, r25	; 0x02
    4554:	89 83       	std	Y+1, r24	; 0x01
    4556:	e9 81       	ldd	r30, Y+1	; 0x01
    4558:	fa 81       	ldd	r31, Y+2	; 0x02
    455a:	01 80       	ldd	r0, Z+1	; 0x01
    455c:	f2 81       	ldd	r31, Z+2	; 0x02
    455e:	e0 2d       	mov	r30, r0
    4560:	82 81       	ldd	r24, Z+2	; 0x02
    4562:	93 81       	ldd	r25, Z+3	; 0x03
    4564:	e9 81       	ldd	r30, Y+1	; 0x01
    4566:	fa 81       	ldd	r31, Y+2	; 0x02
    4568:	92 83       	std	Z+2, r25	; 0x02
    456a:	81 83       	std	Z+1, r24	; 0x01
    456c:	e9 81       	ldd	r30, Y+1	; 0x01
    456e:	fa 81       	ldd	r31, Y+2	; 0x02
    4570:	21 81       	ldd	r18, Z+1	; 0x01
    4572:	32 81       	ldd	r19, Z+2	; 0x02
    4574:	89 81       	ldd	r24, Y+1	; 0x01
    4576:	9a 81       	ldd	r25, Y+2	; 0x02
    4578:	03 96       	adiw	r24, 0x03	; 3
    457a:	28 17       	cp	r18, r24
    457c:	39 07       	cpc	r19, r25
    457e:	59 f4       	brne	.+22     	; 0x4596 <vTaskSwitchContext+0xb2>
    4580:	e9 81       	ldd	r30, Y+1	; 0x01
    4582:	fa 81       	ldd	r31, Y+2	; 0x02
    4584:	01 80       	ldd	r0, Z+1	; 0x01
    4586:	f2 81       	ldd	r31, Z+2	; 0x02
    4588:	e0 2d       	mov	r30, r0
    458a:	82 81       	ldd	r24, Z+2	; 0x02
    458c:	93 81       	ldd	r25, Z+3	; 0x03
    458e:	e9 81       	ldd	r30, Y+1	; 0x01
    4590:	fa 81       	ldd	r31, Y+2	; 0x02
    4592:	92 83       	std	Z+2, r25	; 0x02
    4594:	81 83       	std	Z+1, r24	; 0x01
    4596:	e9 81       	ldd	r30, Y+1	; 0x01
    4598:	fa 81       	ldd	r31, Y+2	; 0x02
    459a:	01 80       	ldd	r0, Z+1	; 0x01
    459c:	f2 81       	ldd	r31, Z+2	; 0x02
    459e:	e0 2d       	mov	r30, r0
    45a0:	86 81       	ldd	r24, Z+6	; 0x06
    45a2:	97 81       	ldd	r25, Z+7	; 0x07
    45a4:	90 93 a9 06 	sts	0x06A9, r25
    45a8:	80 93 a8 06 	sts	0x06A8, r24
    45ac:	8b 81       	ldd	r24, Y+3	; 0x03
    45ae:	80 93 ae 06 	sts	0x06AE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    45b2:	0f 90       	pop	r0
    45b4:	0f 90       	pop	r0
    45b6:	0f 90       	pop	r0
    45b8:	cf 91       	pop	r28
    45ba:	df 91       	pop	r29
    45bc:	08 95       	ret

000045be <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    45be:	df 93       	push	r29
    45c0:	cf 93       	push	r28
    45c2:	00 d0       	rcall	.+0      	; 0x45c4 <vTaskPlaceOnEventList+0x6>
    45c4:	00 d0       	rcall	.+0      	; 0x45c6 <vTaskPlaceOnEventList+0x8>
    45c6:	cd b7       	in	r28, 0x3d	; 61
    45c8:	de b7       	in	r29, 0x3e	; 62
    45ca:	9a 83       	std	Y+2, r25	; 0x02
    45cc:	89 83       	std	Y+1, r24	; 0x01
    45ce:	7c 83       	std	Y+4, r23	; 0x04
    45d0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45d2:	80 91 a8 06 	lds	r24, 0x06A8
    45d6:	90 91 a9 06 	lds	r25, 0x06A9
    45da:	9c 01       	movw	r18, r24
    45dc:	24 5f       	subi	r18, 0xF4	; 244
    45de:	3f 4f       	sbci	r19, 0xFF	; 255
    45e0:	89 81       	ldd	r24, Y+1	; 0x01
    45e2:	9a 81       	ldd	r25, Y+2	; 0x02
    45e4:	b9 01       	movw	r22, r18
    45e6:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45ea:	8b 81       	ldd	r24, Y+3	; 0x03
    45ec:	9c 81       	ldd	r25, Y+4	; 0x04
    45ee:	61 e0       	ldi	r22, 0x01	; 1
    45f0:	0e 94 43 29 	call	0x5286	; 0x5286 <prvAddCurrentTaskToDelayedList>
}
    45f4:	0f 90       	pop	r0
    45f6:	0f 90       	pop	r0
    45f8:	0f 90       	pop	r0
    45fa:	0f 90       	pop	r0
    45fc:	cf 91       	pop	r28
    45fe:	df 91       	pop	r29
    4600:	08 95       	ret

00004602 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4602:	df 93       	push	r29
    4604:	cf 93       	push	r28
    4606:	00 d0       	rcall	.+0      	; 0x4608 <vTaskPlaceOnUnorderedEventList+0x6>
    4608:	00 d0       	rcall	.+0      	; 0x460a <vTaskPlaceOnUnorderedEventList+0x8>
    460a:	00 d0       	rcall	.+0      	; 0x460c <vTaskPlaceOnUnorderedEventList+0xa>
    460c:	cd b7       	in	r28, 0x3d	; 61
    460e:	de b7       	in	r29, 0x3e	; 62
    4610:	9a 83       	std	Y+2, r25	; 0x02
    4612:	89 83       	std	Y+1, r24	; 0x01
    4614:	7c 83       	std	Y+4, r23	; 0x04
    4616:	6b 83       	std	Y+3, r22	; 0x03
    4618:	5e 83       	std	Y+6, r21	; 0x06
    461a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    461c:	e0 91 a8 06 	lds	r30, 0x06A8
    4620:	f0 91 a9 06 	lds	r31, 0x06A9
    4624:	8b 81       	ldd	r24, Y+3	; 0x03
    4626:	9c 81       	ldd	r25, Y+4	; 0x04
    4628:	90 68       	ori	r25, 0x80	; 128
    462a:	95 87       	std	Z+13, r25	; 0x0d
    462c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    462e:	80 91 a8 06 	lds	r24, 0x06A8
    4632:	90 91 a9 06 	lds	r25, 0x06A9
    4636:	9c 01       	movw	r18, r24
    4638:	24 5f       	subi	r18, 0xF4	; 244
    463a:	3f 4f       	sbci	r19, 0xFF	; 255
    463c:	89 81       	ldd	r24, Y+1	; 0x01
    463e:	9a 81       	ldd	r25, Y+2	; 0x02
    4640:	b9 01       	movw	r22, r18
    4642:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4646:	8d 81       	ldd	r24, Y+5	; 0x05
    4648:	9e 81       	ldd	r25, Y+6	; 0x06
    464a:	61 e0       	ldi	r22, 0x01	; 1
    464c:	0e 94 43 29 	call	0x5286	; 0x5286 <prvAddCurrentTaskToDelayedList>
}
    4650:	26 96       	adiw	r28, 0x06	; 6
    4652:	0f b6       	in	r0, 0x3f	; 63
    4654:	f8 94       	cli
    4656:	de bf       	out	0x3e, r29	; 62
    4658:	0f be       	out	0x3f, r0	; 63
    465a:	cd bf       	out	0x3d, r28	; 61
    465c:	cf 91       	pop	r28
    465e:	df 91       	pop	r29
    4660:	08 95       	ret

00004662 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4662:	df 93       	push	r29
    4664:	cf 93       	push	r28
    4666:	00 d0       	rcall	.+0      	; 0x4668 <xTaskRemoveFromEventList+0x6>
    4668:	00 d0       	rcall	.+0      	; 0x466a <xTaskRemoveFromEventList+0x8>
    466a:	0f 92       	push	r0
    466c:	cd b7       	in	r28, 0x3d	; 61
    466e:	de b7       	in	r29, 0x3e	; 62
    4670:	9d 83       	std	Y+5, r25	; 0x05
    4672:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4674:	ec 81       	ldd	r30, Y+4	; 0x04
    4676:	fd 81       	ldd	r31, Y+5	; 0x05
    4678:	05 80       	ldd	r0, Z+5	; 0x05
    467a:	f6 81       	ldd	r31, Z+6	; 0x06
    467c:	e0 2d       	mov	r30, r0
    467e:	86 81       	ldd	r24, Z+6	; 0x06
    4680:	97 81       	ldd	r25, Z+7	; 0x07
    4682:	9b 83       	std	Y+3, r25	; 0x03
    4684:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4686:	8a 81       	ldd	r24, Y+2	; 0x02
    4688:	9b 81       	ldd	r25, Y+3	; 0x03
    468a:	0c 96       	adiw	r24, 0x0c	; 12
    468c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4690:	80 91 b8 06 	lds	r24, 0x06B8
    4694:	88 23       	and	r24, r24
    4696:	61 f5       	brne	.+88     	; 0x46f0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4698:	8a 81       	ldd	r24, Y+2	; 0x02
    469a:	9b 81       	ldd	r25, Y+3	; 0x03
    469c:	02 96       	adiw	r24, 0x02	; 2
    469e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    46a2:	ea 81       	ldd	r30, Y+2	; 0x02
    46a4:	fb 81       	ldd	r31, Y+3	; 0x03
    46a6:	96 89       	ldd	r25, Z+22	; 0x16
    46a8:	80 91 ae 06 	lds	r24, 0x06AE
    46ac:	89 17       	cp	r24, r25
    46ae:	28 f4       	brcc	.+10     	; 0x46ba <xTaskRemoveFromEventList+0x58>
    46b0:	ea 81       	ldd	r30, Y+2	; 0x02
    46b2:	fb 81       	ldd	r31, Y+3	; 0x03
    46b4:	86 89       	ldd	r24, Z+22	; 0x16
    46b6:	80 93 ae 06 	sts	0x06AE, r24
    46ba:	ea 81       	ldd	r30, Y+2	; 0x02
    46bc:	fb 81       	ldd	r31, Y+3	; 0x03
    46be:	86 89       	ldd	r24, Z+22	; 0x16
    46c0:	28 2f       	mov	r18, r24
    46c2:	30 e0       	ldi	r19, 0x00	; 0
    46c4:	c9 01       	movw	r24, r18
    46c6:	88 0f       	add	r24, r24
    46c8:	99 1f       	adc	r25, r25
    46ca:	88 0f       	add	r24, r24
    46cc:	99 1f       	adc	r25, r25
    46ce:	88 0f       	add	r24, r24
    46d0:	99 1f       	adc	r25, r25
    46d2:	82 0f       	add	r24, r18
    46d4:	93 1f       	adc	r25, r19
    46d6:	ac 01       	movw	r20, r24
    46d8:	47 54       	subi	r20, 0x47	; 71
    46da:	59 4f       	sbci	r21, 0xF9	; 249
    46dc:	8a 81       	ldd	r24, Y+2	; 0x02
    46de:	9b 81       	ldd	r25, Y+3	; 0x03
    46e0:	9c 01       	movw	r18, r24
    46e2:	2e 5f       	subi	r18, 0xFE	; 254
    46e4:	3f 4f       	sbci	r19, 0xFF	; 255
    46e6:	ca 01       	movw	r24, r20
    46e8:	b9 01       	movw	r22, r18
    46ea:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    46ee:	0a c0       	rjmp	.+20     	; 0x4704 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    46f0:	8a 81       	ldd	r24, Y+2	; 0x02
    46f2:	9b 81       	ldd	r25, Y+3	; 0x03
    46f4:	9c 01       	movw	r18, r24
    46f6:	24 5f       	subi	r18, 0xF4	; 244
    46f8:	3f 4f       	sbci	r19, 0xFF	; 255
    46fa:	8c ef       	ldi	r24, 0xFC	; 252
    46fc:	96 e0       	ldi	r25, 0x06	; 6
    46fe:	b9 01       	movw	r22, r18
    4700:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4704:	ea 81       	ldd	r30, Y+2	; 0x02
    4706:	fb 81       	ldd	r31, Y+3	; 0x03
    4708:	96 89       	ldd	r25, Z+22	; 0x16
    470a:	e0 91 a8 06 	lds	r30, 0x06A8
    470e:	f0 91 a9 06 	lds	r31, 0x06A9
    4712:	86 89       	ldd	r24, Z+22	; 0x16
    4714:	89 17       	cp	r24, r25
    4716:	30 f4       	brcc	.+12     	; 0x4724 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4718:	81 e0       	ldi	r24, 0x01	; 1
    471a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    471c:	81 e0       	ldi	r24, 0x01	; 1
    471e:	80 93 b1 06 	sts	0x06B1, r24
    4722:	01 c0       	rjmp	.+2      	; 0x4726 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4724:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4726:	89 81       	ldd	r24, Y+1	; 0x01
}
    4728:	0f 90       	pop	r0
    472a:	0f 90       	pop	r0
    472c:	0f 90       	pop	r0
    472e:	0f 90       	pop	r0
    4730:	0f 90       	pop	r0
    4732:	cf 91       	pop	r28
    4734:	df 91       	pop	r29
    4736:	08 95       	ret

00004738 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4738:	df 93       	push	r29
    473a:	cf 93       	push	r28
    473c:	00 d0       	rcall	.+0      	; 0x473e <vTaskRemoveFromUnorderedEventList+0x6>
    473e:	00 d0       	rcall	.+0      	; 0x4740 <vTaskRemoveFromUnorderedEventList+0x8>
    4740:	00 d0       	rcall	.+0      	; 0x4742 <vTaskRemoveFromUnorderedEventList+0xa>
    4742:	cd b7       	in	r28, 0x3d	; 61
    4744:	de b7       	in	r29, 0x3e	; 62
    4746:	9c 83       	std	Y+4, r25	; 0x04
    4748:	8b 83       	std	Y+3, r24	; 0x03
    474a:	7e 83       	std	Y+6, r23	; 0x06
    474c:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    474e:	8d 81       	ldd	r24, Y+5	; 0x05
    4750:	9e 81       	ldd	r25, Y+6	; 0x06
    4752:	90 68       	ori	r25, 0x80	; 128
    4754:	eb 81       	ldd	r30, Y+3	; 0x03
    4756:	fc 81       	ldd	r31, Y+4	; 0x04
    4758:	91 83       	std	Z+1, r25	; 0x01
    475a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    475c:	eb 81       	ldd	r30, Y+3	; 0x03
    475e:	fc 81       	ldd	r31, Y+4	; 0x04
    4760:	86 81       	ldd	r24, Z+6	; 0x06
    4762:	97 81       	ldd	r25, Z+7	; 0x07
    4764:	9a 83       	std	Y+2, r25	; 0x02
    4766:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4768:	8b 81       	ldd	r24, Y+3	; 0x03
    476a:	9c 81       	ldd	r25, Y+4	; 0x04
    476c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4770:	89 81       	ldd	r24, Y+1	; 0x01
    4772:	9a 81       	ldd	r25, Y+2	; 0x02
    4774:	02 96       	adiw	r24, 0x02	; 2
    4776:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    477a:	e9 81       	ldd	r30, Y+1	; 0x01
    477c:	fa 81       	ldd	r31, Y+2	; 0x02
    477e:	96 89       	ldd	r25, Z+22	; 0x16
    4780:	80 91 ae 06 	lds	r24, 0x06AE
    4784:	89 17       	cp	r24, r25
    4786:	28 f4       	brcc	.+10     	; 0x4792 <vTaskRemoveFromUnorderedEventList+0x5a>
    4788:	e9 81       	ldd	r30, Y+1	; 0x01
    478a:	fa 81       	ldd	r31, Y+2	; 0x02
    478c:	86 89       	ldd	r24, Z+22	; 0x16
    478e:	80 93 ae 06 	sts	0x06AE, r24
    4792:	e9 81       	ldd	r30, Y+1	; 0x01
    4794:	fa 81       	ldd	r31, Y+2	; 0x02
    4796:	86 89       	ldd	r24, Z+22	; 0x16
    4798:	28 2f       	mov	r18, r24
    479a:	30 e0       	ldi	r19, 0x00	; 0
    479c:	c9 01       	movw	r24, r18
    479e:	88 0f       	add	r24, r24
    47a0:	99 1f       	adc	r25, r25
    47a2:	88 0f       	add	r24, r24
    47a4:	99 1f       	adc	r25, r25
    47a6:	88 0f       	add	r24, r24
    47a8:	99 1f       	adc	r25, r25
    47aa:	82 0f       	add	r24, r18
    47ac:	93 1f       	adc	r25, r19
    47ae:	ac 01       	movw	r20, r24
    47b0:	47 54       	subi	r20, 0x47	; 71
    47b2:	59 4f       	sbci	r21, 0xF9	; 249
    47b4:	89 81       	ldd	r24, Y+1	; 0x01
    47b6:	9a 81       	ldd	r25, Y+2	; 0x02
    47b8:	9c 01       	movw	r18, r24
    47ba:	2e 5f       	subi	r18, 0xFE	; 254
    47bc:	3f 4f       	sbci	r19, 0xFF	; 255
    47be:	ca 01       	movw	r24, r20
    47c0:	b9 01       	movw	r22, r18
    47c2:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47c6:	e9 81       	ldd	r30, Y+1	; 0x01
    47c8:	fa 81       	ldd	r31, Y+2	; 0x02
    47ca:	96 89       	ldd	r25, Z+22	; 0x16
    47cc:	e0 91 a8 06 	lds	r30, 0x06A8
    47d0:	f0 91 a9 06 	lds	r31, 0x06A9
    47d4:	86 89       	ldd	r24, Z+22	; 0x16
    47d6:	89 17       	cp	r24, r25
    47d8:	18 f4       	brcc	.+6      	; 0x47e0 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    47da:	81 e0       	ldi	r24, 0x01	; 1
    47dc:	80 93 b1 06 	sts	0x06B1, r24
	}
}
    47e0:	26 96       	adiw	r28, 0x06	; 6
    47e2:	0f b6       	in	r0, 0x3f	; 63
    47e4:	f8 94       	cli
    47e6:	de bf       	out	0x3e, r29	; 62
    47e8:	0f be       	out	0x3f, r0	; 63
    47ea:	cd bf       	out	0x3d, r28	; 61
    47ec:	cf 91       	pop	r28
    47ee:	df 91       	pop	r29
    47f0:	08 95       	ret

000047f2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    47f2:	df 93       	push	r29
    47f4:	cf 93       	push	r28
    47f6:	00 d0       	rcall	.+0      	; 0x47f8 <vTaskSetTimeOutState+0x6>
    47f8:	cd b7       	in	r28, 0x3d	; 61
    47fa:	de b7       	in	r29, 0x3e	; 62
    47fc:	9a 83       	std	Y+2, r25	; 0x02
    47fe:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4800:	0f b6       	in	r0, 0x3f	; 63
    4802:	f8 94       	cli
    4804:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4806:	80 91 b2 06 	lds	r24, 0x06B2
    480a:	e9 81       	ldd	r30, Y+1	; 0x01
    480c:	fa 81       	ldd	r31, Y+2	; 0x02
    480e:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4810:	80 91 ac 06 	lds	r24, 0x06AC
    4814:	90 91 ad 06 	lds	r25, 0x06AD
    4818:	e9 81       	ldd	r30, Y+1	; 0x01
    481a:	fa 81       	ldd	r31, Y+2	; 0x02
    481c:	92 83       	std	Z+2, r25	; 0x02
    481e:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4820:	0f 90       	pop	r0
    4822:	0f be       	out	0x3f, r0	; 63
}
    4824:	0f 90       	pop	r0
    4826:	0f 90       	pop	r0
    4828:	cf 91       	pop	r28
    482a:	df 91       	pop	r29
    482c:	08 95       	ret

0000482e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    482e:	df 93       	push	r29
    4830:	cf 93       	push	r28
    4832:	00 d0       	rcall	.+0      	; 0x4834 <vTaskInternalSetTimeOutState+0x6>
    4834:	cd b7       	in	r28, 0x3d	; 61
    4836:	de b7       	in	r29, 0x3e	; 62
    4838:	9a 83       	std	Y+2, r25	; 0x02
    483a:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    483c:	80 91 b2 06 	lds	r24, 0x06B2
    4840:	e9 81       	ldd	r30, Y+1	; 0x01
    4842:	fa 81       	ldd	r31, Y+2	; 0x02
    4844:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4846:	80 91 ac 06 	lds	r24, 0x06AC
    484a:	90 91 ad 06 	lds	r25, 0x06AD
    484e:	e9 81       	ldd	r30, Y+1	; 0x01
    4850:	fa 81       	ldd	r31, Y+2	; 0x02
    4852:	92 83       	std	Z+2, r25	; 0x02
    4854:	81 83       	std	Z+1, r24	; 0x01
}
    4856:	0f 90       	pop	r0
    4858:	0f 90       	pop	r0
    485a:	cf 91       	pop	r28
    485c:	df 91       	pop	r29
    485e:	08 95       	ret

00004860 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4860:	df 93       	push	r29
    4862:	cf 93       	push	r28
    4864:	cd b7       	in	r28, 0x3d	; 61
    4866:	de b7       	in	r29, 0x3e	; 62
    4868:	29 97       	sbiw	r28, 0x09	; 9
    486a:	0f b6       	in	r0, 0x3f	; 63
    486c:	f8 94       	cli
    486e:	de bf       	out	0x3e, r29	; 62
    4870:	0f be       	out	0x3f, r0	; 63
    4872:	cd bf       	out	0x3d, r28	; 61
    4874:	9f 83       	std	Y+7, r25	; 0x07
    4876:	8e 83       	std	Y+6, r24	; 0x06
    4878:	79 87       	std	Y+9, r23	; 0x09
    487a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    487c:	0f b6       	in	r0, 0x3f	; 63
    487e:	f8 94       	cli
    4880:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4882:	80 91 ac 06 	lds	r24, 0x06AC
    4886:	90 91 ad 06 	lds	r25, 0x06AD
    488a:	9c 83       	std	Y+4, r25	; 0x04
    488c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    488e:	ee 81       	ldd	r30, Y+6	; 0x06
    4890:	ff 81       	ldd	r31, Y+7	; 0x07
    4892:	21 81       	ldd	r18, Z+1	; 0x01
    4894:	32 81       	ldd	r19, Z+2	; 0x02
    4896:	8b 81       	ldd	r24, Y+3	; 0x03
    4898:	9c 81       	ldd	r25, Y+4	; 0x04
    489a:	82 1b       	sub	r24, r18
    489c:	93 0b       	sbc	r25, r19
    489e:	9a 83       	std	Y+2, r25	; 0x02
    48a0:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    48a2:	e8 85       	ldd	r30, Y+8	; 0x08
    48a4:	f9 85       	ldd	r31, Y+9	; 0x09
    48a6:	80 81       	ld	r24, Z
    48a8:	91 81       	ldd	r25, Z+1	; 0x01
    48aa:	2f ef       	ldi	r18, 0xFF	; 255
    48ac:	8f 3f       	cpi	r24, 0xFF	; 255
    48ae:	92 07       	cpc	r25, r18
    48b0:	11 f4       	brne	.+4      	; 0x48b6 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    48b2:	1d 82       	std	Y+5, r1	; 0x05
    48b4:	36 c0       	rjmp	.+108    	; 0x4922 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    48b6:	ee 81       	ldd	r30, Y+6	; 0x06
    48b8:	ff 81       	ldd	r31, Y+7	; 0x07
    48ba:	90 81       	ld	r25, Z
    48bc:	80 91 b2 06 	lds	r24, 0x06B2
    48c0:	98 17       	cp	r25, r24
    48c2:	61 f0       	breq	.+24     	; 0x48dc <xTaskCheckForTimeOut+0x7c>
    48c4:	ee 81       	ldd	r30, Y+6	; 0x06
    48c6:	ff 81       	ldd	r31, Y+7	; 0x07
    48c8:	21 81       	ldd	r18, Z+1	; 0x01
    48ca:	32 81       	ldd	r19, Z+2	; 0x02
    48cc:	8b 81       	ldd	r24, Y+3	; 0x03
    48ce:	9c 81       	ldd	r25, Y+4	; 0x04
    48d0:	82 17       	cp	r24, r18
    48d2:	93 07       	cpc	r25, r19
    48d4:	18 f0       	brcs	.+6      	; 0x48dc <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    48d6:	81 e0       	ldi	r24, 0x01	; 1
    48d8:	8d 83       	std	Y+5, r24	; 0x05
    48da:	23 c0       	rjmp	.+70     	; 0x4922 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    48dc:	e8 85       	ldd	r30, Y+8	; 0x08
    48de:	f9 85       	ldd	r31, Y+9	; 0x09
    48e0:	20 81       	ld	r18, Z
    48e2:	31 81       	ldd	r19, Z+1	; 0x01
    48e4:	89 81       	ldd	r24, Y+1	; 0x01
    48e6:	9a 81       	ldd	r25, Y+2	; 0x02
    48e8:	82 17       	cp	r24, r18
    48ea:	93 07       	cpc	r25, r19
    48ec:	a0 f4       	brcc	.+40     	; 0x4916 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    48ee:	e8 85       	ldd	r30, Y+8	; 0x08
    48f0:	f9 85       	ldd	r31, Y+9	; 0x09
    48f2:	20 81       	ld	r18, Z
    48f4:	31 81       	ldd	r19, Z+1	; 0x01
    48f6:	89 81       	ldd	r24, Y+1	; 0x01
    48f8:	9a 81       	ldd	r25, Y+2	; 0x02
    48fa:	a9 01       	movw	r20, r18
    48fc:	48 1b       	sub	r20, r24
    48fe:	59 0b       	sbc	r21, r25
    4900:	ca 01       	movw	r24, r20
    4902:	e8 85       	ldd	r30, Y+8	; 0x08
    4904:	f9 85       	ldd	r31, Y+9	; 0x09
    4906:	91 83       	std	Z+1, r25	; 0x01
    4908:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    490a:	8e 81       	ldd	r24, Y+6	; 0x06
    490c:	9f 81       	ldd	r25, Y+7	; 0x07
    490e:	0e 94 17 24 	call	0x482e	; 0x482e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4912:	1d 82       	std	Y+5, r1	; 0x05
    4914:	06 c0       	rjmp	.+12     	; 0x4922 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4916:	e8 85       	ldd	r30, Y+8	; 0x08
    4918:	f9 85       	ldd	r31, Y+9	; 0x09
    491a:	11 82       	std	Z+1, r1	; 0x01
    491c:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    491e:	81 e0       	ldi	r24, 0x01	; 1
    4920:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4922:	0f 90       	pop	r0
    4924:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4926:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4928:	29 96       	adiw	r28, 0x09	; 9
    492a:	0f b6       	in	r0, 0x3f	; 63
    492c:	f8 94       	cli
    492e:	de bf       	out	0x3e, r29	; 62
    4930:	0f be       	out	0x3f, r0	; 63
    4932:	cd bf       	out	0x3d, r28	; 61
    4934:	cf 91       	pop	r28
    4936:	df 91       	pop	r29
    4938:	08 95       	ret

0000493a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    493a:	df 93       	push	r29
    493c:	cf 93       	push	r28
    493e:	cd b7       	in	r28, 0x3d	; 61
    4940:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4942:	81 e0       	ldi	r24, 0x01	; 1
    4944:	80 93 b1 06 	sts	0x06B1, r24
}
    4948:	cf 91       	pop	r28
    494a:	df 91       	pop	r29
    494c:	08 95       	ret

0000494e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    494e:	df 93       	push	r29
    4950:	cf 93       	push	r28
    4952:	00 d0       	rcall	.+0      	; 0x4954 <prvIdleTask+0x6>
    4954:	cd b7       	in	r28, 0x3d	; 61
    4956:	de b7       	in	r29, 0x3e	; 62
    4958:	9a 83       	std	Y+2, r25	; 0x02
    495a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    495c:	0e 94 f2 24 	call	0x49e4	; 0x49e4 <prvCheckTasksWaitingTermination>
    4960:	fd cf       	rjmp	.-6      	; 0x495c <prvIdleTask+0xe>

00004962 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4962:	df 93       	push	r29
    4964:	cf 93       	push	r28
    4966:	0f 92       	push	r0
    4968:	cd b7       	in	r28, 0x3d	; 61
    496a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    496c:	19 82       	std	Y+1, r1	; 0x01
    496e:	13 c0       	rjmp	.+38     	; 0x4996 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4970:	89 81       	ldd	r24, Y+1	; 0x01
    4972:	28 2f       	mov	r18, r24
    4974:	30 e0       	ldi	r19, 0x00	; 0
    4976:	c9 01       	movw	r24, r18
    4978:	88 0f       	add	r24, r24
    497a:	99 1f       	adc	r25, r25
    497c:	88 0f       	add	r24, r24
    497e:	99 1f       	adc	r25, r25
    4980:	88 0f       	add	r24, r24
    4982:	99 1f       	adc	r25, r25
    4984:	82 0f       	add	r24, r18
    4986:	93 1f       	adc	r25, r19
    4988:	87 54       	subi	r24, 0x47	; 71
    498a:	99 4f       	sbci	r25, 0xF9	; 249
    498c:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4990:	89 81       	ldd	r24, Y+1	; 0x01
    4992:	8f 5f       	subi	r24, 0xFF	; 255
    4994:	89 83       	std	Y+1, r24	; 0x01
    4996:	89 81       	ldd	r24, Y+1	; 0x01
    4998:	85 30       	cpi	r24, 0x05	; 5
    499a:	50 f3       	brcs	.-44     	; 0x4970 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    499c:	86 ee       	ldi	r24, 0xE6	; 230
    499e:	96 e0       	ldi	r25, 0x06	; 6
    49a0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    49a4:	8f ee       	ldi	r24, 0xEF	; 239
    49a6:	96 e0       	ldi	r25, 0x06	; 6
    49a8:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    49ac:	8c ef       	ldi	r24, 0xFC	; 252
    49ae:	96 e0       	ldi	r25, 0x06	; 6
    49b0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    49b4:	85 e0       	ldi	r24, 0x05	; 5
    49b6:	97 e0       	ldi	r25, 0x07	; 7
    49b8:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    49bc:	8e e0       	ldi	r24, 0x0E	; 14
    49be:	97 e0       	ldi	r25, 0x07	; 7
    49c0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    49c4:	86 ee       	ldi	r24, 0xE6	; 230
    49c6:	96 e0       	ldi	r25, 0x06	; 6
    49c8:	90 93 f9 06 	sts	0x06F9, r25
    49cc:	80 93 f8 06 	sts	0x06F8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    49d0:	8f ee       	ldi	r24, 0xEF	; 239
    49d2:	96 e0       	ldi	r25, 0x06	; 6
    49d4:	90 93 fb 06 	sts	0x06FB, r25
    49d8:	80 93 fa 06 	sts	0x06FA, r24
}
    49dc:	0f 90       	pop	r0
    49de:	cf 91       	pop	r28
    49e0:	df 91       	pop	r29
    49e2:	08 95       	ret

000049e4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    49e4:	df 93       	push	r29
    49e6:	cf 93       	push	r28
    49e8:	00 d0       	rcall	.+0      	; 0x49ea <prvCheckTasksWaitingTermination+0x6>
    49ea:	cd b7       	in	r28, 0x3d	; 61
    49ec:	de b7       	in	r29, 0x3e	; 62
    49ee:	20 c0       	rjmp	.+64     	; 0x4a30 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    49f0:	0f b6       	in	r0, 0x3f	; 63
    49f2:	f8 94       	cli
    49f4:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49f6:	e0 91 0a 07 	lds	r30, 0x070A
    49fa:	f0 91 0b 07 	lds	r31, 0x070B
    49fe:	86 81       	ldd	r24, Z+6	; 0x06
    4a00:	97 81       	ldd	r25, Z+7	; 0x07
    4a02:	9a 83       	std	Y+2, r25	; 0x02
    4a04:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4a06:	89 81       	ldd	r24, Y+1	; 0x01
    4a08:	9a 81       	ldd	r25, Y+2	; 0x02
    4a0a:	02 96       	adiw	r24, 0x02	; 2
    4a0c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4a10:	80 91 ab 06 	lds	r24, 0x06AB
    4a14:	81 50       	subi	r24, 0x01	; 1
    4a16:	80 93 ab 06 	sts	0x06AB, r24
				--uxDeletedTasksWaitingCleanUp;
    4a1a:	80 91 aa 06 	lds	r24, 0x06AA
    4a1e:	81 50       	subi	r24, 0x01	; 1
    4a20:	80 93 aa 06 	sts	0x06AA, r24
			}
			taskEXIT_CRITICAL();
    4a24:	0f 90       	pop	r0
    4a26:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4a28:	89 81       	ldd	r24, Y+1	; 0x01
    4a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a2c:	0e 94 21 25 	call	0x4a42	; 0x4a42 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4a30:	80 91 aa 06 	lds	r24, 0x06AA
    4a34:	88 23       	and	r24, r24
    4a36:	e1 f6       	brne	.-72     	; 0x49f0 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
    4a3c:	cf 91       	pop	r28
    4a3e:	df 91       	pop	r29
    4a40:	08 95       	ret

00004a42 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4a42:	df 93       	push	r29
    4a44:	cf 93       	push	r28
    4a46:	00 d0       	rcall	.+0      	; 0x4a48 <prvDeleteTCB+0x6>
    4a48:	cd b7       	in	r28, 0x3d	; 61
    4a4a:	de b7       	in	r29, 0x3e	; 62
    4a4c:	9a 83       	std	Y+2, r25	; 0x02
    4a4e:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4a50:	e9 81       	ldd	r30, Y+1	; 0x01
    4a52:	fa 81       	ldd	r31, Y+2	; 0x02
    4a54:	87 89       	ldd	r24, Z+23	; 0x17
    4a56:	90 8d       	ldd	r25, Z+24	; 0x18
    4a58:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
			vPortFree( pxTCB );
    4a5c:	89 81       	ldd	r24, Y+1	; 0x01
    4a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a60:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4a64:	0f 90       	pop	r0
    4a66:	0f 90       	pop	r0
    4a68:	cf 91       	pop	r28
    4a6a:	df 91       	pop	r29
    4a6c:	08 95       	ret

00004a6e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4a6e:	df 93       	push	r29
    4a70:	cf 93       	push	r28
    4a72:	00 d0       	rcall	.+0      	; 0x4a74 <prvResetNextTaskUnblockTime+0x6>
    4a74:	cd b7       	in	r28, 0x3d	; 61
    4a76:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4a78:	e0 91 f8 06 	lds	r30, 0x06F8
    4a7c:	f0 91 f9 06 	lds	r31, 0x06F9
    4a80:	80 81       	ld	r24, Z
    4a82:	88 23       	and	r24, r24
    4a84:	39 f4       	brne	.+14     	; 0x4a94 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4a86:	8f ef       	ldi	r24, 0xFF	; 255
    4a88:	9f ef       	ldi	r25, 0xFF	; 255
    4a8a:	90 93 b5 06 	sts	0x06B5, r25
    4a8e:	80 93 b4 06 	sts	0x06B4, r24
    4a92:	13 c0       	rjmp	.+38     	; 0x4aba <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a94:	e0 91 f8 06 	lds	r30, 0x06F8
    4a98:	f0 91 f9 06 	lds	r31, 0x06F9
    4a9c:	05 80       	ldd	r0, Z+5	; 0x05
    4a9e:	f6 81       	ldd	r31, Z+6	; 0x06
    4aa0:	e0 2d       	mov	r30, r0
    4aa2:	86 81       	ldd	r24, Z+6	; 0x06
    4aa4:	97 81       	ldd	r25, Z+7	; 0x07
    4aa6:	9a 83       	std	Y+2, r25	; 0x02
    4aa8:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4aaa:	e9 81       	ldd	r30, Y+1	; 0x01
    4aac:	fa 81       	ldd	r31, Y+2	; 0x02
    4aae:	82 81       	ldd	r24, Z+2	; 0x02
    4ab0:	93 81       	ldd	r25, Z+3	; 0x03
    4ab2:	90 93 b5 06 	sts	0x06B5, r25
    4ab6:	80 93 b4 06 	sts	0x06B4, r24
	}
}
    4aba:	0f 90       	pop	r0
    4abc:	0f 90       	pop	r0
    4abe:	cf 91       	pop	r28
    4ac0:	df 91       	pop	r29
    4ac2:	08 95       	ret

00004ac4 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4ac4:	df 93       	push	r29
    4ac6:	cf 93       	push	r28
    4ac8:	00 d0       	rcall	.+0      	; 0x4aca <xTaskGetCurrentTaskHandle+0x6>
    4aca:	cd b7       	in	r28, 0x3d	; 61
    4acc:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4ace:	80 91 a8 06 	lds	r24, 0x06A8
    4ad2:	90 91 a9 06 	lds	r25, 0x06A9
    4ad6:	9a 83       	std	Y+2, r25	; 0x02
    4ad8:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4ada:	89 81       	ldd	r24, Y+1	; 0x01
    4adc:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4ade:	0f 90       	pop	r0
    4ae0:	0f 90       	pop	r0
    4ae2:	cf 91       	pop	r28
    4ae4:	df 91       	pop	r29
    4ae6:	08 95       	ret

00004ae8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4ae8:	df 93       	push	r29
    4aea:	cf 93       	push	r28
    4aec:	00 d0       	rcall	.+0      	; 0x4aee <uxTaskResetEventItemValue+0x6>
    4aee:	cd b7       	in	r28, 0x3d	; 61
    4af0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4af2:	e0 91 a8 06 	lds	r30, 0x06A8
    4af6:	f0 91 a9 06 	lds	r31, 0x06A9
    4afa:	84 85       	ldd	r24, Z+12	; 0x0c
    4afc:	95 85       	ldd	r25, Z+13	; 0x0d
    4afe:	9a 83       	std	Y+2, r25	; 0x02
    4b00:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4b02:	a0 91 a8 06 	lds	r26, 0x06A8
    4b06:	b0 91 a9 06 	lds	r27, 0x06A9
    4b0a:	e0 91 a8 06 	lds	r30, 0x06A8
    4b0e:	f0 91 a9 06 	lds	r31, 0x06A9
    4b12:	86 89       	ldd	r24, Z+22	; 0x16
    4b14:	28 2f       	mov	r18, r24
    4b16:	30 e0       	ldi	r19, 0x00	; 0
    4b18:	85 e0       	ldi	r24, 0x05	; 5
    4b1a:	90 e0       	ldi	r25, 0x00	; 0
    4b1c:	82 1b       	sub	r24, r18
    4b1e:	93 0b       	sbc	r25, r19
    4b20:	1d 96       	adiw	r26, 0x0d	; 13
    4b22:	9c 93       	st	X, r25
    4b24:	8e 93       	st	-X, r24
    4b26:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4b28:	89 81       	ldd	r24, Y+1	; 0x01
    4b2a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b2c:	0f 90       	pop	r0
    4b2e:	0f 90       	pop	r0
    4b30:	cf 91       	pop	r28
    4b32:	df 91       	pop	r29
    4b34:	08 95       	ret

00004b36 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4b36:	df 93       	push	r29
    4b38:	cf 93       	push	r28
    4b3a:	cd b7       	in	r28, 0x3d	; 61
    4b3c:	de b7       	in	r29, 0x3e	; 62
    4b3e:	27 97       	sbiw	r28, 0x07	; 7
    4b40:	0f b6       	in	r0, 0x3f	; 63
    4b42:	f8 94       	cli
    4b44:	de bf       	out	0x3e, r29	; 62
    4b46:	0f be       	out	0x3f, r0	; 63
    4b48:	cd bf       	out	0x3d, r28	; 61
    4b4a:	8d 83       	std	Y+5, r24	; 0x05
    4b4c:	7f 83       	std	Y+7, r23	; 0x07
    4b4e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4b50:	0f b6       	in	r0, 0x3f	; 63
    4b52:	f8 94       	cli
    4b54:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4b56:	e0 91 a8 06 	lds	r30, 0x06A8
    4b5a:	f0 91 a9 06 	lds	r31, 0x06A9
    4b5e:	81 a1       	ldd	r24, Z+33	; 0x21
    4b60:	92 a1       	ldd	r25, Z+34	; 0x22
    4b62:	a3 a1       	ldd	r26, Z+35	; 0x23
    4b64:	b4 a1       	ldd	r27, Z+36	; 0x24
    4b66:	00 97       	sbiw	r24, 0x00	; 0
    4b68:	a1 05       	cpc	r26, r1
    4b6a:	b1 05       	cpc	r27, r1
    4b6c:	89 f4       	brne	.+34     	; 0x4b90 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4b6e:	e0 91 a8 06 	lds	r30, 0x06A8
    4b72:	f0 91 a9 06 	lds	r31, 0x06A9
    4b76:	81 e0       	ldi	r24, 0x01	; 1
    4b78:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    4b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    4b7e:	00 97       	sbiw	r24, 0x00	; 0
    4b80:	39 f0       	breq	.+14     	; 0x4b90 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b82:	8e 81       	ldd	r24, Y+6	; 0x06
    4b84:	9f 81       	ldd	r25, Y+7	; 0x07
    4b86:	61 e0       	ldi	r22, 0x01	; 1
    4b88:	0e 94 43 29 	call	0x5286	; 0x5286 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4b8c:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4b90:	0f 90       	pop	r0
    4b92:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4b94:	0f b6       	in	r0, 0x3f	; 63
    4b96:	f8 94       	cli
    4b98:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4b9a:	e0 91 a8 06 	lds	r30, 0x06A8
    4b9e:	f0 91 a9 06 	lds	r31, 0x06A9
    4ba2:	81 a1       	ldd	r24, Z+33	; 0x21
    4ba4:	92 a1       	ldd	r25, Z+34	; 0x22
    4ba6:	a3 a1       	ldd	r26, Z+35	; 0x23
    4ba8:	b4 a1       	ldd	r27, Z+36	; 0x24
    4baa:	89 83       	std	Y+1, r24	; 0x01
    4bac:	9a 83       	std	Y+2, r25	; 0x02
    4bae:	ab 83       	std	Y+3, r26	; 0x03
    4bb0:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4bb2:	89 81       	ldd	r24, Y+1	; 0x01
    4bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    4bb6:	ab 81       	ldd	r26, Y+3	; 0x03
    4bb8:	bc 81       	ldd	r27, Y+4	; 0x04
    4bba:	00 97       	sbiw	r24, 0x00	; 0
    4bbc:	a1 05       	cpc	r26, r1
    4bbe:	b1 05       	cpc	r27, r1
    4bc0:	d9 f0       	breq	.+54     	; 0x4bf8 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    4bc4:	88 23       	and	r24, r24
    4bc6:	49 f0       	breq	.+18     	; 0x4bda <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4bc8:	e0 91 a8 06 	lds	r30, 0x06A8
    4bcc:	f0 91 a9 06 	lds	r31, 0x06A9
    4bd0:	11 a2       	std	Z+33, r1	; 0x21
    4bd2:	12 a2       	std	Z+34, r1	; 0x22
    4bd4:	13 a2       	std	Z+35, r1	; 0x23
    4bd6:	14 a2       	std	Z+36, r1	; 0x24
    4bd8:	0f c0       	rjmp	.+30     	; 0x4bf8 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4bda:	e0 91 a8 06 	lds	r30, 0x06A8
    4bde:	f0 91 a9 06 	lds	r31, 0x06A9
    4be2:	89 81       	ldd	r24, Y+1	; 0x01
    4be4:	9a 81       	ldd	r25, Y+2	; 0x02
    4be6:	ab 81       	ldd	r26, Y+3	; 0x03
    4be8:	bc 81       	ldd	r27, Y+4	; 0x04
    4bea:	01 97       	sbiw	r24, 0x01	; 1
    4bec:	a1 09       	sbc	r26, r1
    4bee:	b1 09       	sbc	r27, r1
    4bf0:	81 a3       	std	Z+33, r24	; 0x21
    4bf2:	92 a3       	std	Z+34, r25	; 0x22
    4bf4:	a3 a3       	std	Z+35, r26	; 0x23
    4bf6:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4bf8:	e0 91 a8 06 	lds	r30, 0x06A8
    4bfc:	f0 91 a9 06 	lds	r31, 0x06A9
    4c00:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4c02:	0f 90       	pop	r0
    4c04:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4c06:	89 81       	ldd	r24, Y+1	; 0x01
    4c08:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0a:	ab 81       	ldd	r26, Y+3	; 0x03
    4c0c:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4c0e:	bc 01       	movw	r22, r24
    4c10:	cd 01       	movw	r24, r26
    4c12:	27 96       	adiw	r28, 0x07	; 7
    4c14:	0f b6       	in	r0, 0x3f	; 63
    4c16:	f8 94       	cli
    4c18:	de bf       	out	0x3e, r29	; 62
    4c1a:	0f be       	out	0x3f, r0	; 63
    4c1c:	cd bf       	out	0x3d, r28	; 61
    4c1e:	cf 91       	pop	r28
    4c20:	df 91       	pop	r29
    4c22:	08 95       	ret

00004c24 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4c24:	ef 92       	push	r14
    4c26:	ff 92       	push	r15
    4c28:	0f 93       	push	r16
    4c2a:	1f 93       	push	r17
    4c2c:	df 93       	push	r29
    4c2e:	cf 93       	push	r28
    4c30:	cd b7       	in	r28, 0x3d	; 61
    4c32:	de b7       	in	r29, 0x3e	; 62
    4c34:	2d 97       	sbiw	r28, 0x0d	; 13
    4c36:	0f b6       	in	r0, 0x3f	; 63
    4c38:	f8 94       	cli
    4c3a:	de bf       	out	0x3e, r29	; 62
    4c3c:	0f be       	out	0x3f, r0	; 63
    4c3e:	cd bf       	out	0x3d, r28	; 61
    4c40:	6a 83       	std	Y+2, r22	; 0x02
    4c42:	7b 83       	std	Y+3, r23	; 0x03
    4c44:	8c 83       	std	Y+4, r24	; 0x04
    4c46:	9d 83       	std	Y+5, r25	; 0x05
    4c48:	2e 83       	std	Y+6, r18	; 0x06
    4c4a:	3f 83       	std	Y+7, r19	; 0x07
    4c4c:	48 87       	std	Y+8, r20	; 0x08
    4c4e:	59 87       	std	Y+9, r21	; 0x09
    4c50:	1b 87       	std	Y+11, r17	; 0x0b
    4c52:	0a 87       	std	Y+10, r16	; 0x0a
    4c54:	fd 86       	std	Y+13, r15	; 0x0d
    4c56:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4c5e:	e0 91 a8 06 	lds	r30, 0x06A8
    4c62:	f0 91 a9 06 	lds	r31, 0x06A9
    4c66:	85 a1       	ldd	r24, Z+37	; 0x25
    4c68:	82 30       	cpi	r24, 0x02	; 2
    4c6a:	49 f1       	breq	.+82     	; 0x4cbe <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4c6c:	e0 91 a8 06 	lds	r30, 0x06A8
    4c70:	f0 91 a9 06 	lds	r31, 0x06A9
    4c74:	21 a1       	ldd	r18, Z+33	; 0x21
    4c76:	32 a1       	ldd	r19, Z+34	; 0x22
    4c78:	43 a1       	ldd	r20, Z+35	; 0x23
    4c7a:	54 a1       	ldd	r21, Z+36	; 0x24
    4c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c80:	ac 81       	ldd	r26, Y+4	; 0x04
    4c82:	bd 81       	ldd	r27, Y+5	; 0x05
    4c84:	80 95       	com	r24
    4c86:	90 95       	com	r25
    4c88:	a0 95       	com	r26
    4c8a:	b0 95       	com	r27
    4c8c:	82 23       	and	r24, r18
    4c8e:	93 23       	and	r25, r19
    4c90:	a4 23       	and	r26, r20
    4c92:	b5 23       	and	r27, r21
    4c94:	81 a3       	std	Z+33, r24	; 0x21
    4c96:	92 a3       	std	Z+34, r25	; 0x22
    4c98:	a3 a3       	std	Z+35, r26	; 0x23
    4c9a:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c9c:	e0 91 a8 06 	lds	r30, 0x06A8
    4ca0:	f0 91 a9 06 	lds	r31, 0x06A9
    4ca4:	81 e0       	ldi	r24, 0x01	; 1
    4ca6:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4ca8:	8c 85       	ldd	r24, Y+12	; 0x0c
    4caa:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cac:	00 97       	sbiw	r24, 0x00	; 0
    4cae:	39 f0       	breq	.+14     	; 0x4cbe <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4cb0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4cb2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cb4:	61 e0       	ldi	r22, 0x01	; 1
    4cb6:	0e 94 43 29 	call	0x5286	; 0x5286 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4cba:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4cbe:	0f 90       	pop	r0
    4cc0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4cc2:	0f b6       	in	r0, 0x3f	; 63
    4cc4:	f8 94       	cli
    4cc6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4cc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cca:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ccc:	00 97       	sbiw	r24, 0x00	; 0
    4cce:	71 f0       	breq	.+28     	; 0x4cec <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4cd0:	e0 91 a8 06 	lds	r30, 0x06A8
    4cd4:	f0 91 a9 06 	lds	r31, 0x06A9
    4cd8:	81 a1       	ldd	r24, Z+33	; 0x21
    4cda:	92 a1       	ldd	r25, Z+34	; 0x22
    4cdc:	a3 a1       	ldd	r26, Z+35	; 0x23
    4cde:	b4 a1       	ldd	r27, Z+36	; 0x24
    4ce0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ce2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ce4:	80 83       	st	Z, r24
    4ce6:	91 83       	std	Z+1, r25	; 0x01
    4ce8:	a2 83       	std	Z+2, r26	; 0x02
    4cea:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4cec:	e0 91 a8 06 	lds	r30, 0x06A8
    4cf0:	f0 91 a9 06 	lds	r31, 0x06A9
    4cf4:	85 a1       	ldd	r24, Z+37	; 0x25
    4cf6:	82 30       	cpi	r24, 0x02	; 2
    4cf8:	11 f0       	breq	.+4      	; 0x4cfe <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4cfa:	19 82       	std	Y+1, r1	; 0x01
    4cfc:	1a c0       	rjmp	.+52     	; 0x4d32 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4cfe:	e0 91 a8 06 	lds	r30, 0x06A8
    4d02:	f0 91 a9 06 	lds	r31, 0x06A9
    4d06:	21 a1       	ldd	r18, Z+33	; 0x21
    4d08:	32 a1       	ldd	r19, Z+34	; 0x22
    4d0a:	43 a1       	ldd	r20, Z+35	; 0x23
    4d0c:	54 a1       	ldd	r21, Z+36	; 0x24
    4d0e:	8e 81       	ldd	r24, Y+6	; 0x06
    4d10:	9f 81       	ldd	r25, Y+7	; 0x07
    4d12:	a8 85       	ldd	r26, Y+8	; 0x08
    4d14:	b9 85       	ldd	r27, Y+9	; 0x09
    4d16:	80 95       	com	r24
    4d18:	90 95       	com	r25
    4d1a:	a0 95       	com	r26
    4d1c:	b0 95       	com	r27
    4d1e:	82 23       	and	r24, r18
    4d20:	93 23       	and	r25, r19
    4d22:	a4 23       	and	r26, r20
    4d24:	b5 23       	and	r27, r21
    4d26:	81 a3       	std	Z+33, r24	; 0x21
    4d28:	92 a3       	std	Z+34, r25	; 0x22
    4d2a:	a3 a3       	std	Z+35, r26	; 0x23
    4d2c:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    4d2e:	81 e0       	ldi	r24, 0x01	; 1
    4d30:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4d32:	e0 91 a8 06 	lds	r30, 0x06A8
    4d36:	f0 91 a9 06 	lds	r31, 0x06A9
    4d3a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4d3c:	0f 90       	pop	r0
    4d3e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4d40:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4d42:	2d 96       	adiw	r28, 0x0d	; 13
    4d44:	0f b6       	in	r0, 0x3f	; 63
    4d46:	f8 94       	cli
    4d48:	de bf       	out	0x3e, r29	; 62
    4d4a:	0f be       	out	0x3f, r0	; 63
    4d4c:	cd bf       	out	0x3d, r28	; 61
    4d4e:	cf 91       	pop	r28
    4d50:	df 91       	pop	r29
    4d52:	1f 91       	pop	r17
    4d54:	0f 91       	pop	r16
    4d56:	ff 90       	pop	r15
    4d58:	ef 90       	pop	r14
    4d5a:	08 95       	ret

00004d5c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4d5c:	0f 93       	push	r16
    4d5e:	1f 93       	push	r17
    4d60:	df 93       	push	r29
    4d62:	cf 93       	push	r28
    4d64:	cd b7       	in	r28, 0x3d	; 61
    4d66:	de b7       	in	r29, 0x3e	; 62
    4d68:	2f 97       	sbiw	r28, 0x0f	; 15
    4d6a:	0f b6       	in	r0, 0x3f	; 63
    4d6c:	f8 94       	cli
    4d6e:	de bf       	out	0x3e, r29	; 62
    4d70:	0f be       	out	0x3f, r0	; 63
    4d72:	cd bf       	out	0x3d, r28	; 61
    4d74:	9e 83       	std	Y+6, r25	; 0x06
    4d76:	8d 83       	std	Y+5, r24	; 0x05
    4d78:	4f 83       	std	Y+7, r20	; 0x07
    4d7a:	58 87       	std	Y+8, r21	; 0x08
    4d7c:	69 87       	std	Y+9, r22	; 0x09
    4d7e:	7a 87       	std	Y+10, r23	; 0x0a
    4d80:	2b 87       	std	Y+11, r18	; 0x0b
    4d82:	1d 87       	std	Y+13, r17	; 0x0d
    4d84:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4d86:	81 e0       	ldi	r24, 0x01	; 1
    4d88:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d8e:	9c 83       	std	Y+4, r25	; 0x04
    4d90:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4d92:	0f b6       	in	r0, 0x3f	; 63
    4d94:	f8 94       	cli
    4d96:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4d98:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d9a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d9c:	00 97       	sbiw	r24, 0x00	; 0
    4d9e:	61 f0       	breq	.+24     	; 0x4db8 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4da0:	eb 81       	ldd	r30, Y+3	; 0x03
    4da2:	fc 81       	ldd	r31, Y+4	; 0x04
    4da4:	81 a1       	ldd	r24, Z+33	; 0x21
    4da6:	92 a1       	ldd	r25, Z+34	; 0x22
    4da8:	a3 a1       	ldd	r26, Z+35	; 0x23
    4daa:	b4 a1       	ldd	r27, Z+36	; 0x24
    4dac:	ec 85       	ldd	r30, Y+12	; 0x0c
    4dae:	fd 85       	ldd	r31, Y+13	; 0x0d
    4db0:	80 83       	st	Z, r24
    4db2:	91 83       	std	Z+1, r25	; 0x01
    4db4:	a2 83       	std	Z+2, r26	; 0x02
    4db6:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4db8:	eb 81       	ldd	r30, Y+3	; 0x03
    4dba:	fc 81       	ldd	r31, Y+4	; 0x04
    4dbc:	85 a1       	ldd	r24, Z+37	; 0x25
    4dbe:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4dc0:	eb 81       	ldd	r30, Y+3	; 0x03
    4dc2:	fc 81       	ldd	r31, Y+4	; 0x04
    4dc4:	82 e0       	ldi	r24, 0x02	; 2
    4dc6:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4dc8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4dca:	28 2f       	mov	r18, r24
    4dcc:	30 e0       	ldi	r19, 0x00	; 0
    4dce:	3f 87       	std	Y+15, r19	; 0x0f
    4dd0:	2e 87       	std	Y+14, r18	; 0x0e
    4dd2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dd4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4dd6:	82 30       	cpi	r24, 0x02	; 2
    4dd8:	91 05       	cpc	r25, r1
    4dda:	59 f1       	breq	.+86     	; 0x4e32 <xTaskGenericNotify+0xd6>
    4ddc:	2e 85       	ldd	r18, Y+14	; 0x0e
    4dde:	3f 85       	ldd	r19, Y+15	; 0x0f
    4de0:	23 30       	cpi	r18, 0x03	; 3
    4de2:	31 05       	cpc	r19, r1
    4de4:	34 f4       	brge	.+12     	; 0x4df2 <xTaskGenericNotify+0x96>
    4de6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4de8:	9f 85       	ldd	r25, Y+15	; 0x0f
    4dea:	81 30       	cpi	r24, 0x01	; 1
    4dec:	91 05       	cpc	r25, r1
    4dee:	61 f0       	breq	.+24     	; 0x4e08 <xTaskGenericNotify+0xac>
    4df0:	4a c0       	rjmp	.+148    	; 0x4e86 <xTaskGenericNotify+0x12a>
    4df2:	2e 85       	ldd	r18, Y+14	; 0x0e
    4df4:	3f 85       	ldd	r19, Y+15	; 0x0f
    4df6:	23 30       	cpi	r18, 0x03	; 3
    4df8:	31 05       	cpc	r19, r1
    4dfa:	59 f1       	breq	.+86     	; 0x4e52 <xTaskGenericNotify+0xf6>
    4dfc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dfe:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e00:	84 30       	cpi	r24, 0x04	; 4
    4e02:	91 05       	cpc	r25, r1
    4e04:	89 f1       	breq	.+98     	; 0x4e68 <xTaskGenericNotify+0x10c>
    4e06:	3f c0       	rjmp	.+126    	; 0x4e86 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4e08:	eb 81       	ldd	r30, Y+3	; 0x03
    4e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e0c:	21 a1       	ldd	r18, Z+33	; 0x21
    4e0e:	32 a1       	ldd	r19, Z+34	; 0x22
    4e10:	43 a1       	ldd	r20, Z+35	; 0x23
    4e12:	54 a1       	ldd	r21, Z+36	; 0x24
    4e14:	8f 81       	ldd	r24, Y+7	; 0x07
    4e16:	98 85       	ldd	r25, Y+8	; 0x08
    4e18:	a9 85       	ldd	r26, Y+9	; 0x09
    4e1a:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e1c:	82 2b       	or	r24, r18
    4e1e:	93 2b       	or	r25, r19
    4e20:	a4 2b       	or	r26, r20
    4e22:	b5 2b       	or	r27, r21
    4e24:	eb 81       	ldd	r30, Y+3	; 0x03
    4e26:	fc 81       	ldd	r31, Y+4	; 0x04
    4e28:	81 a3       	std	Z+33, r24	; 0x21
    4e2a:	92 a3       	std	Z+34, r25	; 0x22
    4e2c:	a3 a3       	std	Z+35, r26	; 0x23
    4e2e:	b4 a3       	std	Z+36, r27	; 0x24
    4e30:	2a c0       	rjmp	.+84     	; 0x4e86 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4e32:	eb 81       	ldd	r30, Y+3	; 0x03
    4e34:	fc 81       	ldd	r31, Y+4	; 0x04
    4e36:	81 a1       	ldd	r24, Z+33	; 0x21
    4e38:	92 a1       	ldd	r25, Z+34	; 0x22
    4e3a:	a3 a1       	ldd	r26, Z+35	; 0x23
    4e3c:	b4 a1       	ldd	r27, Z+36	; 0x24
    4e3e:	01 96       	adiw	r24, 0x01	; 1
    4e40:	a1 1d       	adc	r26, r1
    4e42:	b1 1d       	adc	r27, r1
    4e44:	eb 81       	ldd	r30, Y+3	; 0x03
    4e46:	fc 81       	ldd	r31, Y+4	; 0x04
    4e48:	81 a3       	std	Z+33, r24	; 0x21
    4e4a:	92 a3       	std	Z+34, r25	; 0x22
    4e4c:	a3 a3       	std	Z+35, r26	; 0x23
    4e4e:	b4 a3       	std	Z+36, r27	; 0x24
    4e50:	1a c0       	rjmp	.+52     	; 0x4e86 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4e52:	eb 81       	ldd	r30, Y+3	; 0x03
    4e54:	fc 81       	ldd	r31, Y+4	; 0x04
    4e56:	8f 81       	ldd	r24, Y+7	; 0x07
    4e58:	98 85       	ldd	r25, Y+8	; 0x08
    4e5a:	a9 85       	ldd	r26, Y+9	; 0x09
    4e5c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e5e:	81 a3       	std	Z+33, r24	; 0x21
    4e60:	92 a3       	std	Z+34, r25	; 0x22
    4e62:	a3 a3       	std	Z+35, r26	; 0x23
    4e64:	b4 a3       	std	Z+36, r27	; 0x24
    4e66:	0f c0       	rjmp	.+30     	; 0x4e86 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4e68:	89 81       	ldd	r24, Y+1	; 0x01
    4e6a:	82 30       	cpi	r24, 0x02	; 2
    4e6c:	59 f0       	breq	.+22     	; 0x4e84 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e70:	fc 81       	ldd	r31, Y+4	; 0x04
    4e72:	8f 81       	ldd	r24, Y+7	; 0x07
    4e74:	98 85       	ldd	r25, Y+8	; 0x08
    4e76:	a9 85       	ldd	r26, Y+9	; 0x09
    4e78:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e7a:	81 a3       	std	Z+33, r24	; 0x21
    4e7c:	92 a3       	std	Z+34, r25	; 0x22
    4e7e:	a3 a3       	std	Z+35, r26	; 0x23
    4e80:	b4 a3       	std	Z+36, r27	; 0x24
    4e82:	01 c0       	rjmp	.+2      	; 0x4e86 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4e84:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e86:	89 81       	ldd	r24, Y+1	; 0x01
    4e88:	81 30       	cpi	r24, 0x01	; 1
    4e8a:	b9 f5       	brne	.+110    	; 0x4efa <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    4e90:	02 96       	adiw	r24, 0x02	; 2
    4e92:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4e96:	eb 81       	ldd	r30, Y+3	; 0x03
    4e98:	fc 81       	ldd	r31, Y+4	; 0x04
    4e9a:	96 89       	ldd	r25, Z+22	; 0x16
    4e9c:	80 91 ae 06 	lds	r24, 0x06AE
    4ea0:	89 17       	cp	r24, r25
    4ea2:	28 f4       	brcc	.+10     	; 0x4eae <xTaskGenericNotify+0x152>
    4ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea8:	86 89       	ldd	r24, Z+22	; 0x16
    4eaa:	80 93 ae 06 	sts	0x06AE, r24
    4eae:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    4eb2:	86 89       	ldd	r24, Z+22	; 0x16
    4eb4:	28 2f       	mov	r18, r24
    4eb6:	30 e0       	ldi	r19, 0x00	; 0
    4eb8:	c9 01       	movw	r24, r18
    4eba:	88 0f       	add	r24, r24
    4ebc:	99 1f       	adc	r25, r25
    4ebe:	88 0f       	add	r24, r24
    4ec0:	99 1f       	adc	r25, r25
    4ec2:	88 0f       	add	r24, r24
    4ec4:	99 1f       	adc	r25, r25
    4ec6:	82 0f       	add	r24, r18
    4ec8:	93 1f       	adc	r25, r19
    4eca:	ac 01       	movw	r20, r24
    4ecc:	47 54       	subi	r20, 0x47	; 71
    4ece:	59 4f       	sbci	r21, 0xF9	; 249
    4ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    4ed4:	9c 01       	movw	r18, r24
    4ed6:	2e 5f       	subi	r18, 0xFE	; 254
    4ed8:	3f 4f       	sbci	r19, 0xFF	; 255
    4eda:	ca 01       	movw	r24, r20
    4edc:	b9 01       	movw	r22, r18
    4ede:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ee6:	96 89       	ldd	r25, Z+22	; 0x16
    4ee8:	e0 91 a8 06 	lds	r30, 0x06A8
    4eec:	f0 91 a9 06 	lds	r31, 0x06A9
    4ef0:	86 89       	ldd	r24, Z+22	; 0x16
    4ef2:	89 17       	cp	r24, r25
    4ef4:	10 f4       	brcc	.+4      	; 0x4efa <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4ef6:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4efa:	0f 90       	pop	r0
    4efc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4efe:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4f00:	2f 96       	adiw	r28, 0x0f	; 15
    4f02:	0f b6       	in	r0, 0x3f	; 63
    4f04:	f8 94       	cli
    4f06:	de bf       	out	0x3e, r29	; 62
    4f08:	0f be       	out	0x3f, r0	; 63
    4f0a:	cd bf       	out	0x3d, r28	; 61
    4f0c:	cf 91       	pop	r28
    4f0e:	df 91       	pop	r29
    4f10:	1f 91       	pop	r17
    4f12:	0f 91       	pop	r16
    4f14:	08 95       	ret

00004f16 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4f16:	ef 92       	push	r14
    4f18:	ff 92       	push	r15
    4f1a:	0f 93       	push	r16
    4f1c:	1f 93       	push	r17
    4f1e:	df 93       	push	r29
    4f20:	cf 93       	push	r28
    4f22:	cd b7       	in	r28, 0x3d	; 61
    4f24:	de b7       	in	r29, 0x3e	; 62
    4f26:	62 97       	sbiw	r28, 0x12	; 18
    4f28:	0f b6       	in	r0, 0x3f	; 63
    4f2a:	f8 94       	cli
    4f2c:	de bf       	out	0x3e, r29	; 62
    4f2e:	0f be       	out	0x3f, r0	; 63
    4f30:	cd bf       	out	0x3d, r28	; 61
    4f32:	9f 83       	std	Y+7, r25	; 0x07
    4f34:	8e 83       	std	Y+6, r24	; 0x06
    4f36:	48 87       	std	Y+8, r20	; 0x08
    4f38:	59 87       	std	Y+9, r21	; 0x09
    4f3a:	6a 87       	std	Y+10, r22	; 0x0a
    4f3c:	7b 87       	std	Y+11, r23	; 0x0b
    4f3e:	2c 87       	std	Y+12, r18	; 0x0c
    4f40:	1e 87       	std	Y+14, r17	; 0x0e
    4f42:	0d 87       	std	Y+13, r16	; 0x0d
    4f44:	f8 8a       	std	Y+16, r15	; 0x10
    4f46:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4f48:	81 e0       	ldi	r24, 0x01	; 1
    4f4a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4f4c:	8e 81       	ldd	r24, Y+6	; 0x06
    4f4e:	9f 81       	ldd	r25, Y+7	; 0x07
    4f50:	9d 83       	std	Y+5, r25	; 0x05
    4f52:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f54:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4f56:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f58:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f5a:	00 97       	sbiw	r24, 0x00	; 0
    4f5c:	61 f0       	breq	.+24     	; 0x4f76 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4f5e:	ec 81       	ldd	r30, Y+4	; 0x04
    4f60:	fd 81       	ldd	r31, Y+5	; 0x05
    4f62:	81 a1       	ldd	r24, Z+33	; 0x21
    4f64:	92 a1       	ldd	r25, Z+34	; 0x22
    4f66:	a3 a1       	ldd	r26, Z+35	; 0x23
    4f68:	b4 a1       	ldd	r27, Z+36	; 0x24
    4f6a:	ed 85       	ldd	r30, Y+13	; 0x0d
    4f6c:	fe 85       	ldd	r31, Y+14	; 0x0e
    4f6e:	80 83       	st	Z, r24
    4f70:	91 83       	std	Z+1, r25	; 0x01
    4f72:	a2 83       	std	Z+2, r26	; 0x02
    4f74:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4f76:	ec 81       	ldd	r30, Y+4	; 0x04
    4f78:	fd 81       	ldd	r31, Y+5	; 0x05
    4f7a:	85 a1       	ldd	r24, Z+37	; 0x25
    4f7c:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4f7e:	ec 81       	ldd	r30, Y+4	; 0x04
    4f80:	fd 81       	ldd	r31, Y+5	; 0x05
    4f82:	82 e0       	ldi	r24, 0x02	; 2
    4f84:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4f86:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f88:	28 2f       	mov	r18, r24
    4f8a:	30 e0       	ldi	r19, 0x00	; 0
    4f8c:	3a 8b       	std	Y+18, r19	; 0x12
    4f8e:	29 8b       	std	Y+17, r18	; 0x11
    4f90:	89 89       	ldd	r24, Y+17	; 0x11
    4f92:	9a 89       	ldd	r25, Y+18	; 0x12
    4f94:	82 30       	cpi	r24, 0x02	; 2
    4f96:	91 05       	cpc	r25, r1
    4f98:	59 f1       	breq	.+86     	; 0x4ff0 <xTaskGenericNotifyFromISR+0xda>
    4f9a:	29 89       	ldd	r18, Y+17	; 0x11
    4f9c:	3a 89       	ldd	r19, Y+18	; 0x12
    4f9e:	23 30       	cpi	r18, 0x03	; 3
    4fa0:	31 05       	cpc	r19, r1
    4fa2:	34 f4       	brge	.+12     	; 0x4fb0 <xTaskGenericNotifyFromISR+0x9a>
    4fa4:	89 89       	ldd	r24, Y+17	; 0x11
    4fa6:	9a 89       	ldd	r25, Y+18	; 0x12
    4fa8:	81 30       	cpi	r24, 0x01	; 1
    4faa:	91 05       	cpc	r25, r1
    4fac:	61 f0       	breq	.+24     	; 0x4fc6 <xTaskGenericNotifyFromISR+0xb0>
    4fae:	4a c0       	rjmp	.+148    	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
    4fb0:	29 89       	ldd	r18, Y+17	; 0x11
    4fb2:	3a 89       	ldd	r19, Y+18	; 0x12
    4fb4:	23 30       	cpi	r18, 0x03	; 3
    4fb6:	31 05       	cpc	r19, r1
    4fb8:	59 f1       	breq	.+86     	; 0x5010 <xTaskGenericNotifyFromISR+0xfa>
    4fba:	89 89       	ldd	r24, Y+17	; 0x11
    4fbc:	9a 89       	ldd	r25, Y+18	; 0x12
    4fbe:	84 30       	cpi	r24, 0x04	; 4
    4fc0:	91 05       	cpc	r25, r1
    4fc2:	89 f1       	breq	.+98     	; 0x5026 <xTaskGenericNotifyFromISR+0x110>
    4fc4:	3f c0       	rjmp	.+126    	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4fc6:	ec 81       	ldd	r30, Y+4	; 0x04
    4fc8:	fd 81       	ldd	r31, Y+5	; 0x05
    4fca:	21 a1       	ldd	r18, Z+33	; 0x21
    4fcc:	32 a1       	ldd	r19, Z+34	; 0x22
    4fce:	43 a1       	ldd	r20, Z+35	; 0x23
    4fd0:	54 a1       	ldd	r21, Z+36	; 0x24
    4fd2:	88 85       	ldd	r24, Y+8	; 0x08
    4fd4:	99 85       	ldd	r25, Y+9	; 0x09
    4fd6:	aa 85       	ldd	r26, Y+10	; 0x0a
    4fd8:	bb 85       	ldd	r27, Y+11	; 0x0b
    4fda:	82 2b       	or	r24, r18
    4fdc:	93 2b       	or	r25, r19
    4fde:	a4 2b       	or	r26, r20
    4fe0:	b5 2b       	or	r27, r21
    4fe2:	ec 81       	ldd	r30, Y+4	; 0x04
    4fe4:	fd 81       	ldd	r31, Y+5	; 0x05
    4fe6:	81 a3       	std	Z+33, r24	; 0x21
    4fe8:	92 a3       	std	Z+34, r25	; 0x22
    4fea:	a3 a3       	std	Z+35, r26	; 0x23
    4fec:	b4 a3       	std	Z+36, r27	; 0x24
    4fee:	2a c0       	rjmp	.+84     	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4ff0:	ec 81       	ldd	r30, Y+4	; 0x04
    4ff2:	fd 81       	ldd	r31, Y+5	; 0x05
    4ff4:	81 a1       	ldd	r24, Z+33	; 0x21
    4ff6:	92 a1       	ldd	r25, Z+34	; 0x22
    4ff8:	a3 a1       	ldd	r26, Z+35	; 0x23
    4ffa:	b4 a1       	ldd	r27, Z+36	; 0x24
    4ffc:	01 96       	adiw	r24, 0x01	; 1
    4ffe:	a1 1d       	adc	r26, r1
    5000:	b1 1d       	adc	r27, r1
    5002:	ec 81       	ldd	r30, Y+4	; 0x04
    5004:	fd 81       	ldd	r31, Y+5	; 0x05
    5006:	81 a3       	std	Z+33, r24	; 0x21
    5008:	92 a3       	std	Z+34, r25	; 0x22
    500a:	a3 a3       	std	Z+35, r26	; 0x23
    500c:	b4 a3       	std	Z+36, r27	; 0x24
    500e:	1a c0       	rjmp	.+52     	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5010:	ec 81       	ldd	r30, Y+4	; 0x04
    5012:	fd 81       	ldd	r31, Y+5	; 0x05
    5014:	88 85       	ldd	r24, Y+8	; 0x08
    5016:	99 85       	ldd	r25, Y+9	; 0x09
    5018:	aa 85       	ldd	r26, Y+10	; 0x0a
    501a:	bb 85       	ldd	r27, Y+11	; 0x0b
    501c:	81 a3       	std	Z+33, r24	; 0x21
    501e:	92 a3       	std	Z+34, r25	; 0x22
    5020:	a3 a3       	std	Z+35, r26	; 0x23
    5022:	b4 a3       	std	Z+36, r27	; 0x24
    5024:	0f c0       	rjmp	.+30     	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5026:	8b 81       	ldd	r24, Y+3	; 0x03
    5028:	82 30       	cpi	r24, 0x02	; 2
    502a:	59 f0       	breq	.+22     	; 0x5042 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    502c:	ec 81       	ldd	r30, Y+4	; 0x04
    502e:	fd 81       	ldd	r31, Y+5	; 0x05
    5030:	88 85       	ldd	r24, Y+8	; 0x08
    5032:	99 85       	ldd	r25, Y+9	; 0x09
    5034:	aa 85       	ldd	r26, Y+10	; 0x0a
    5036:	bb 85       	ldd	r27, Y+11	; 0x0b
    5038:	81 a3       	std	Z+33, r24	; 0x21
    503a:	92 a3       	std	Z+34, r25	; 0x22
    503c:	a3 a3       	std	Z+35, r26	; 0x23
    503e:	b4 a3       	std	Z+36, r27	; 0x24
    5040:	01 c0       	rjmp	.+2      	; 0x5044 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5042:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5044:	8b 81       	ldd	r24, Y+3	; 0x03
    5046:	81 30       	cpi	r24, 0x01	; 1
    5048:	09 f0       	breq	.+2      	; 0x504c <xTaskGenericNotifyFromISR+0x136>
    504a:	4f c0       	rjmp	.+158    	; 0x50ea <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    504c:	80 91 b8 06 	lds	r24, 0x06B8
    5050:	88 23       	and	r24, r24
    5052:	61 f5       	brne	.+88     	; 0x50ac <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5054:	8c 81       	ldd	r24, Y+4	; 0x04
    5056:	9d 81       	ldd	r25, Y+5	; 0x05
    5058:	02 96       	adiw	r24, 0x02	; 2
    505a:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    505e:	ec 81       	ldd	r30, Y+4	; 0x04
    5060:	fd 81       	ldd	r31, Y+5	; 0x05
    5062:	96 89       	ldd	r25, Z+22	; 0x16
    5064:	80 91 ae 06 	lds	r24, 0x06AE
    5068:	89 17       	cp	r24, r25
    506a:	28 f4       	brcc	.+10     	; 0x5076 <xTaskGenericNotifyFromISR+0x160>
    506c:	ec 81       	ldd	r30, Y+4	; 0x04
    506e:	fd 81       	ldd	r31, Y+5	; 0x05
    5070:	86 89       	ldd	r24, Z+22	; 0x16
    5072:	80 93 ae 06 	sts	0x06AE, r24
    5076:	ec 81       	ldd	r30, Y+4	; 0x04
    5078:	fd 81       	ldd	r31, Y+5	; 0x05
    507a:	86 89       	ldd	r24, Z+22	; 0x16
    507c:	28 2f       	mov	r18, r24
    507e:	30 e0       	ldi	r19, 0x00	; 0
    5080:	c9 01       	movw	r24, r18
    5082:	88 0f       	add	r24, r24
    5084:	99 1f       	adc	r25, r25
    5086:	88 0f       	add	r24, r24
    5088:	99 1f       	adc	r25, r25
    508a:	88 0f       	add	r24, r24
    508c:	99 1f       	adc	r25, r25
    508e:	82 0f       	add	r24, r18
    5090:	93 1f       	adc	r25, r19
    5092:	ac 01       	movw	r20, r24
    5094:	47 54       	subi	r20, 0x47	; 71
    5096:	59 4f       	sbci	r21, 0xF9	; 249
    5098:	8c 81       	ldd	r24, Y+4	; 0x04
    509a:	9d 81       	ldd	r25, Y+5	; 0x05
    509c:	9c 01       	movw	r18, r24
    509e:	2e 5f       	subi	r18, 0xFE	; 254
    50a0:	3f 4f       	sbci	r19, 0xFF	; 255
    50a2:	ca 01       	movw	r24, r20
    50a4:	b9 01       	movw	r22, r18
    50a6:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    50aa:	0a c0       	rjmp	.+20     	; 0x50c0 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    50ac:	8c 81       	ldd	r24, Y+4	; 0x04
    50ae:	9d 81       	ldd	r25, Y+5	; 0x05
    50b0:	9c 01       	movw	r18, r24
    50b2:	24 5f       	subi	r18, 0xF4	; 244
    50b4:	3f 4f       	sbci	r19, 0xFF	; 255
    50b6:	8c ef       	ldi	r24, 0xFC	; 252
    50b8:	96 e0       	ldi	r25, 0x06	; 6
    50ba:	b9 01       	movw	r22, r18
    50bc:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    50c0:	ec 81       	ldd	r30, Y+4	; 0x04
    50c2:	fd 81       	ldd	r31, Y+5	; 0x05
    50c4:	96 89       	ldd	r25, Z+22	; 0x16
    50c6:	e0 91 a8 06 	lds	r30, 0x06A8
    50ca:	f0 91 a9 06 	lds	r31, 0x06A9
    50ce:	86 89       	ldd	r24, Z+22	; 0x16
    50d0:	89 17       	cp	r24, r25
    50d2:	58 f4       	brcc	.+22     	; 0x50ea <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    50d4:	8f 85       	ldd	r24, Y+15	; 0x0f
    50d6:	98 89       	ldd	r25, Y+16	; 0x10
    50d8:	00 97       	sbiw	r24, 0x00	; 0
    50da:	21 f0       	breq	.+8      	; 0x50e4 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    50dc:	ef 85       	ldd	r30, Y+15	; 0x0f
    50de:	f8 89       	ldd	r31, Y+16	; 0x10
    50e0:	81 e0       	ldi	r24, 0x01	; 1
    50e2:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    50e4:	81 e0       	ldi	r24, 0x01	; 1
    50e6:	80 93 b1 06 	sts	0x06B1, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    50ea:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    50ec:	62 96       	adiw	r28, 0x12	; 18
    50ee:	0f b6       	in	r0, 0x3f	; 63
    50f0:	f8 94       	cli
    50f2:	de bf       	out	0x3e, r29	; 62
    50f4:	0f be       	out	0x3f, r0	; 63
    50f6:	cd bf       	out	0x3d, r28	; 61
    50f8:	cf 91       	pop	r28
    50fa:	df 91       	pop	r29
    50fc:	1f 91       	pop	r17
    50fe:	0f 91       	pop	r16
    5100:	ff 90       	pop	r15
    5102:	ef 90       	pop	r14
    5104:	08 95       	ret

00005106 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5106:	df 93       	push	r29
    5108:	cf 93       	push	r28
    510a:	cd b7       	in	r28, 0x3d	; 61
    510c:	de b7       	in	r29, 0x3e	; 62
    510e:	28 97       	sbiw	r28, 0x08	; 8
    5110:	0f b6       	in	r0, 0x3f	; 63
    5112:	f8 94       	cli
    5114:	de bf       	out	0x3e, r29	; 62
    5116:	0f be       	out	0x3f, r0	; 63
    5118:	cd bf       	out	0x3d, r28	; 61
    511a:	9e 83       	std	Y+6, r25	; 0x06
    511c:	8d 83       	std	Y+5, r24	; 0x05
    511e:	78 87       	std	Y+8, r23	; 0x08
    5120:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    5122:	8d 81       	ldd	r24, Y+5	; 0x05
    5124:	9e 81       	ldd	r25, Y+6	; 0x06
    5126:	9c 83       	std	Y+4, r25	; 0x04
    5128:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    512a:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    512c:	eb 81       	ldd	r30, Y+3	; 0x03
    512e:	fc 81       	ldd	r31, Y+4	; 0x04
    5130:	85 a1       	ldd	r24, Z+37	; 0x25
    5132:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5134:	eb 81       	ldd	r30, Y+3	; 0x03
    5136:	fc 81       	ldd	r31, Y+4	; 0x04
    5138:	82 e0       	ldi	r24, 0x02	; 2
    513a:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    513c:	eb 81       	ldd	r30, Y+3	; 0x03
    513e:	fc 81       	ldd	r31, Y+4	; 0x04
    5140:	81 a1       	ldd	r24, Z+33	; 0x21
    5142:	92 a1       	ldd	r25, Z+34	; 0x22
    5144:	a3 a1       	ldd	r26, Z+35	; 0x23
    5146:	b4 a1       	ldd	r27, Z+36	; 0x24
    5148:	01 96       	adiw	r24, 0x01	; 1
    514a:	a1 1d       	adc	r26, r1
    514c:	b1 1d       	adc	r27, r1
    514e:	eb 81       	ldd	r30, Y+3	; 0x03
    5150:	fc 81       	ldd	r31, Y+4	; 0x04
    5152:	81 a3       	std	Z+33, r24	; 0x21
    5154:	92 a3       	std	Z+34, r25	; 0x22
    5156:	a3 a3       	std	Z+35, r26	; 0x23
    5158:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    515a:	8a 81       	ldd	r24, Y+2	; 0x02
    515c:	81 30       	cpi	r24, 0x01	; 1
    515e:	09 f0       	breq	.+2      	; 0x5162 <vTaskNotifyGiveFromISR+0x5c>
    5160:	4f c0       	rjmp	.+158    	; 0x5200 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5162:	80 91 b8 06 	lds	r24, 0x06B8
    5166:	88 23       	and	r24, r24
    5168:	61 f5       	brne	.+88     	; 0x51c2 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    516a:	8b 81       	ldd	r24, Y+3	; 0x03
    516c:	9c 81       	ldd	r25, Y+4	; 0x04
    516e:	02 96       	adiw	r24, 0x02	; 2
    5170:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5174:	eb 81       	ldd	r30, Y+3	; 0x03
    5176:	fc 81       	ldd	r31, Y+4	; 0x04
    5178:	96 89       	ldd	r25, Z+22	; 0x16
    517a:	80 91 ae 06 	lds	r24, 0x06AE
    517e:	89 17       	cp	r24, r25
    5180:	28 f4       	brcc	.+10     	; 0x518c <vTaskNotifyGiveFromISR+0x86>
    5182:	eb 81       	ldd	r30, Y+3	; 0x03
    5184:	fc 81       	ldd	r31, Y+4	; 0x04
    5186:	86 89       	ldd	r24, Z+22	; 0x16
    5188:	80 93 ae 06 	sts	0x06AE, r24
    518c:	eb 81       	ldd	r30, Y+3	; 0x03
    518e:	fc 81       	ldd	r31, Y+4	; 0x04
    5190:	86 89       	ldd	r24, Z+22	; 0x16
    5192:	28 2f       	mov	r18, r24
    5194:	30 e0       	ldi	r19, 0x00	; 0
    5196:	c9 01       	movw	r24, r18
    5198:	88 0f       	add	r24, r24
    519a:	99 1f       	adc	r25, r25
    519c:	88 0f       	add	r24, r24
    519e:	99 1f       	adc	r25, r25
    51a0:	88 0f       	add	r24, r24
    51a2:	99 1f       	adc	r25, r25
    51a4:	82 0f       	add	r24, r18
    51a6:	93 1f       	adc	r25, r19
    51a8:	ac 01       	movw	r20, r24
    51aa:	47 54       	subi	r20, 0x47	; 71
    51ac:	59 4f       	sbci	r21, 0xF9	; 249
    51ae:	8b 81       	ldd	r24, Y+3	; 0x03
    51b0:	9c 81       	ldd	r25, Y+4	; 0x04
    51b2:	9c 01       	movw	r18, r24
    51b4:	2e 5f       	subi	r18, 0xFE	; 254
    51b6:	3f 4f       	sbci	r19, 0xFF	; 255
    51b8:	ca 01       	movw	r24, r20
    51ba:	b9 01       	movw	r22, r18
    51bc:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    51c0:	0a c0       	rjmp	.+20     	; 0x51d6 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    51c2:	8b 81       	ldd	r24, Y+3	; 0x03
    51c4:	9c 81       	ldd	r25, Y+4	; 0x04
    51c6:	9c 01       	movw	r18, r24
    51c8:	24 5f       	subi	r18, 0xF4	; 244
    51ca:	3f 4f       	sbci	r19, 0xFF	; 255
    51cc:	8c ef       	ldi	r24, 0xFC	; 252
    51ce:	96 e0       	ldi	r25, 0x06	; 6
    51d0:	b9 01       	movw	r22, r18
    51d2:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    51d6:	eb 81       	ldd	r30, Y+3	; 0x03
    51d8:	fc 81       	ldd	r31, Y+4	; 0x04
    51da:	96 89       	ldd	r25, Z+22	; 0x16
    51dc:	e0 91 a8 06 	lds	r30, 0x06A8
    51e0:	f0 91 a9 06 	lds	r31, 0x06A9
    51e4:	86 89       	ldd	r24, Z+22	; 0x16
    51e6:	89 17       	cp	r24, r25
    51e8:	58 f4       	brcc	.+22     	; 0x5200 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    51ea:	8f 81       	ldd	r24, Y+7	; 0x07
    51ec:	98 85       	ldd	r25, Y+8	; 0x08
    51ee:	00 97       	sbiw	r24, 0x00	; 0
    51f0:	21 f0       	breq	.+8      	; 0x51fa <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    51f2:	ef 81       	ldd	r30, Y+7	; 0x07
    51f4:	f8 85       	ldd	r31, Y+8	; 0x08
    51f6:	81 e0       	ldi	r24, 0x01	; 1
    51f8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    51fa:	81 e0       	ldi	r24, 0x01	; 1
    51fc:	80 93 b1 06 	sts	0x06B1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5200:	28 96       	adiw	r28, 0x08	; 8
    5202:	0f b6       	in	r0, 0x3f	; 63
    5204:	f8 94       	cli
    5206:	de bf       	out	0x3e, r29	; 62
    5208:	0f be       	out	0x3f, r0	; 63
    520a:	cd bf       	out	0x3d, r28	; 61
    520c:	cf 91       	pop	r28
    520e:	df 91       	pop	r29
    5210:	08 95       	ret

00005212 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5212:	df 93       	push	r29
    5214:	cf 93       	push	r28
    5216:	cd b7       	in	r28, 0x3d	; 61
    5218:	de b7       	in	r29, 0x3e	; 62
    521a:	27 97       	sbiw	r28, 0x07	; 7
    521c:	0f b6       	in	r0, 0x3f	; 63
    521e:	f8 94       	cli
    5220:	de bf       	out	0x3e, r29	; 62
    5222:	0f be       	out	0x3f, r0	; 63
    5224:	cd bf       	out	0x3d, r28	; 61
    5226:	9d 83       	std	Y+5, r25	; 0x05
    5228:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    522a:	8c 81       	ldd	r24, Y+4	; 0x04
    522c:	9d 81       	ldd	r25, Y+5	; 0x05
    522e:	00 97       	sbiw	r24, 0x00	; 0
    5230:	39 f4       	brne	.+14     	; 0x5240 <xTaskNotifyStateClear+0x2e>
    5232:	80 91 a8 06 	lds	r24, 0x06A8
    5236:	90 91 a9 06 	lds	r25, 0x06A9
    523a:	9f 83       	std	Y+7, r25	; 0x07
    523c:	8e 83       	std	Y+6, r24	; 0x06
    523e:	04 c0       	rjmp	.+8      	; 0x5248 <xTaskNotifyStateClear+0x36>
    5240:	8c 81       	ldd	r24, Y+4	; 0x04
    5242:	9d 81       	ldd	r25, Y+5	; 0x05
    5244:	9f 83       	std	Y+7, r25	; 0x07
    5246:	8e 83       	std	Y+6, r24	; 0x06
    5248:	8e 81       	ldd	r24, Y+6	; 0x06
    524a:	9f 81       	ldd	r25, Y+7	; 0x07
    524c:	9b 83       	std	Y+3, r25	; 0x03
    524e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5250:	0f b6       	in	r0, 0x3f	; 63
    5252:	f8 94       	cli
    5254:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5256:	ea 81       	ldd	r30, Y+2	; 0x02
    5258:	fb 81       	ldd	r31, Y+3	; 0x03
    525a:	85 a1       	ldd	r24, Z+37	; 0x25
    525c:	82 30       	cpi	r24, 0x02	; 2
    525e:	31 f4       	brne	.+12     	; 0x526c <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5260:	ea 81       	ldd	r30, Y+2	; 0x02
    5262:	fb 81       	ldd	r31, Y+3	; 0x03
    5264:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    5266:	81 e0       	ldi	r24, 0x01	; 1
    5268:	89 83       	std	Y+1, r24	; 0x01
    526a:	01 c0       	rjmp	.+2      	; 0x526e <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    526c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    526e:	0f 90       	pop	r0
    5270:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5272:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5274:	27 96       	adiw	r28, 0x07	; 7
    5276:	0f b6       	in	r0, 0x3f	; 63
    5278:	f8 94       	cli
    527a:	de bf       	out	0x3e, r29	; 62
    527c:	0f be       	out	0x3f, r0	; 63
    527e:	cd bf       	out	0x3d, r28	; 61
    5280:	cf 91       	pop	r28
    5282:	df 91       	pop	r29
    5284:	08 95       	ret

00005286 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5286:	df 93       	push	r29
    5288:	cf 93       	push	r28
    528a:	cd b7       	in	r28, 0x3d	; 61
    528c:	de b7       	in	r29, 0x3e	; 62
    528e:	27 97       	sbiw	r28, 0x07	; 7
    5290:	0f b6       	in	r0, 0x3f	; 63
    5292:	f8 94       	cli
    5294:	de bf       	out	0x3e, r29	; 62
    5296:	0f be       	out	0x3f, r0	; 63
    5298:	cd bf       	out	0x3d, r28	; 61
    529a:	9e 83       	std	Y+6, r25	; 0x06
    529c:	8d 83       	std	Y+5, r24	; 0x05
    529e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    52a0:	80 91 ac 06 	lds	r24, 0x06AC
    52a4:	90 91 ad 06 	lds	r25, 0x06AD
    52a8:	9a 83       	std	Y+2, r25	; 0x02
    52aa:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    52ac:	80 91 a8 06 	lds	r24, 0x06A8
    52b0:	90 91 a9 06 	lds	r25, 0x06A9
    52b4:	02 96       	adiw	r24, 0x02	; 2
    52b6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    52ba:	8d 81       	ldd	r24, Y+5	; 0x05
    52bc:	9e 81       	ldd	r25, Y+6	; 0x06
    52be:	2f ef       	ldi	r18, 0xFF	; 255
    52c0:	8f 3f       	cpi	r24, 0xFF	; 255
    52c2:	92 07       	cpc	r25, r18
    52c4:	81 f4       	brne	.+32     	; 0x52e6 <prvAddCurrentTaskToDelayedList+0x60>
    52c6:	8f 81       	ldd	r24, Y+7	; 0x07
    52c8:	88 23       	and	r24, r24
    52ca:	69 f0       	breq	.+26     	; 0x52e6 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    52cc:	80 91 a8 06 	lds	r24, 0x06A8
    52d0:	90 91 a9 06 	lds	r25, 0x06A9
    52d4:	9c 01       	movw	r18, r24
    52d6:	2e 5f       	subi	r18, 0xFE	; 254
    52d8:	3f 4f       	sbci	r19, 0xFF	; 255
    52da:	8e e0       	ldi	r24, 0x0E	; 14
    52dc:	97 e0       	ldi	r25, 0x07	; 7
    52de:	b9 01       	movw	r22, r18
    52e0:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    52e4:	43 c0       	rjmp	.+134    	; 0x536c <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    52e6:	29 81       	ldd	r18, Y+1	; 0x01
    52e8:	3a 81       	ldd	r19, Y+2	; 0x02
    52ea:	8d 81       	ldd	r24, Y+5	; 0x05
    52ec:	9e 81       	ldd	r25, Y+6	; 0x06
    52ee:	82 0f       	add	r24, r18
    52f0:	93 1f       	adc	r25, r19
    52f2:	9c 83       	std	Y+4, r25	; 0x04
    52f4:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    52f6:	e0 91 a8 06 	lds	r30, 0x06A8
    52fa:	f0 91 a9 06 	lds	r31, 0x06A9
    52fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5300:	9c 81       	ldd	r25, Y+4	; 0x04
    5302:	93 83       	std	Z+3, r25	; 0x03
    5304:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    5306:	2b 81       	ldd	r18, Y+3	; 0x03
    5308:	3c 81       	ldd	r19, Y+4	; 0x04
    530a:	89 81       	ldd	r24, Y+1	; 0x01
    530c:	9a 81       	ldd	r25, Y+2	; 0x02
    530e:	28 17       	cp	r18, r24
    5310:	39 07       	cpc	r19, r25
    5312:	70 f4       	brcc	.+28     	; 0x5330 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5314:	80 91 fa 06 	lds	r24, 0x06FA
    5318:	90 91 fb 06 	lds	r25, 0x06FB
    531c:	20 91 a8 06 	lds	r18, 0x06A8
    5320:	30 91 a9 06 	lds	r19, 0x06A9
    5324:	2e 5f       	subi	r18, 0xFE	; 254
    5326:	3f 4f       	sbci	r19, 0xFF	; 255
    5328:	b9 01       	movw	r22, r18
    532a:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>
    532e:	1e c0       	rjmp	.+60     	; 0x536c <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5330:	40 91 f8 06 	lds	r20, 0x06F8
    5334:	50 91 f9 06 	lds	r21, 0x06F9
    5338:	80 91 a8 06 	lds	r24, 0x06A8
    533c:	90 91 a9 06 	lds	r25, 0x06A9
    5340:	9c 01       	movw	r18, r24
    5342:	2e 5f       	subi	r18, 0xFE	; 254
    5344:	3f 4f       	sbci	r19, 0xFF	; 255
    5346:	ca 01       	movw	r24, r20
    5348:	b9 01       	movw	r22, r18
    534a:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    534e:	20 91 b4 06 	lds	r18, 0x06B4
    5352:	30 91 b5 06 	lds	r19, 0x06B5
    5356:	8b 81       	ldd	r24, Y+3	; 0x03
    5358:	9c 81       	ldd	r25, Y+4	; 0x04
    535a:	82 17       	cp	r24, r18
    535c:	93 07       	cpc	r25, r19
    535e:	30 f4       	brcc	.+12     	; 0x536c <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5360:	8b 81       	ldd	r24, Y+3	; 0x03
    5362:	9c 81       	ldd	r25, Y+4	; 0x04
    5364:	90 93 b5 06 	sts	0x06B5, r25
    5368:	80 93 b4 06 	sts	0x06B4, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    536c:	27 96       	adiw	r28, 0x07	; 7
    536e:	0f b6       	in	r0, 0x3f	; 63
    5370:	f8 94       	cli
    5372:	de bf       	out	0x3e, r29	; 62
    5374:	0f be       	out	0x3f, r0	; 63
    5376:	cd bf       	out	0x3d, r28	; 61
    5378:	cf 91       	pop	r28
    537a:	df 91       	pop	r29
    537c:	08 95       	ret

0000537e <memcpy>:
    537e:	fb 01       	movw	r30, r22
    5380:	dc 01       	movw	r26, r24
    5382:	02 c0       	rjmp	.+4      	; 0x5388 <memcpy+0xa>
    5384:	01 90       	ld	r0, Z+
    5386:	0d 92       	st	X+, r0
    5388:	41 50       	subi	r20, 0x01	; 1
    538a:	50 40       	sbci	r21, 0x00	; 0
    538c:	d8 f7       	brcc	.-10     	; 0x5384 <memcpy+0x6>
    538e:	08 95       	ret

00005390 <memset>:
    5390:	dc 01       	movw	r26, r24
    5392:	01 c0       	rjmp	.+2      	; 0x5396 <memset+0x6>
    5394:	6d 93       	st	X+, r22
    5396:	41 50       	subi	r20, 0x01	; 1
    5398:	50 40       	sbci	r21, 0x00	; 0
    539a:	e0 f7       	brcc	.-8      	; 0x5394 <memset+0x4>
    539c:	08 95       	ret

0000539e <_exit>:
    539e:	f8 94       	cli

000053a0 <__stop_program>:
    53a0:	ff cf       	rjmp	.-2      	; 0x53a0 <__stop_program>
